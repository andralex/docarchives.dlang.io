[
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/object.d",
		"name": "object",
		"members": [
			{
				"name": "Object",
				"line": 57,
				"comment": " All D class objects inherit from Object.\n",
				"members": [
					{
						"endchar": 5,
						"name": "toString",
						"line": 62,
						"comment": " Convert Object to a human readable string.\n",
						"deco": "FZAya",
						"endline": 65,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toHash",
						"line": 70,
						"comment": " Compute hash function for Object.\n",
						"deco": "FNbNeZm",
						"endline": 74,
						"originalType": "nothrow @trusted size_t()",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 85,
						"comment": " Compare with another Object obj.\n Returns:\n  $(TABLE\n  $(TR $(TD this &lt; obj) $(TD &lt; 0))\n  $(TR $(TD this == obj) $(TD 0))\n  $(TR $(TD this &gt; obj) $(TD &gt; 0))\n  )\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 92,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 97,
						"comment": " Returns !=0 if this object does have the same contents as obj.\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 100,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "factory",
						"line": 132,
						"comment": " Create instance of class specified by the fully qualified name\n classname.\n The class must either have no constructors or have\n a default constructor.\n Returns:\n   null if failed\n Example:\n ---\n module foo.bar;\n\n class C\n {\n     this() { x = 10; }\n     int x;\n }\n\n void main()\n {\n     auto c = cast(C)Object.factory(\"foo.bar.C\");\n     assert(c !is null && c.x == 10);\n }\n ---\n",
						"deco": "FAyaZC6Object",
						"parameters": [
							{
								"name": "classname",
								"deco": "Aya"
							}
						],
						"endline": 140,
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "opEquals",
				"line": 168,
				"comment": " Returns true if lhs and rhs are equal.\n",
				"deco": "FxC6ObjectxC6ObjectZb",
				"parameters": [
					{
						"name": "lhs",
						"deco": "xC6Object"
					},
					{
						"name": "rhs",
						"deco": "xC6Object"
					}
				],
				"endline": 172,
				"originalType": "(const Object lhs, const Object rhs)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"name": "Interface",
				"line": 186,
				"comment": " Information about an interface.\n When an object is accessed via an interface, an Interface* appears as the\n first entry in its vtbl.\n",
				"members": [
					{
						"offset": 0,
						"name": "classinfo",
						"line": 188,
						"comment": ".classinfo for this interface (not for containing class)\n",
						"deco": "C14TypeInfo_Class",
						"originalType": "TypeInfo_Class",
						"char": 22,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "offset",
						"line": 190,
						"comment": "offset to Interface 'this' from Object 'this'\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 17,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "OffsetTypeInfo",
				"line": 197,
				"comment": " Array of pairs giving the offset and type information for each\n member in an aggregate.\n",
				"members": [
					{
						"offset": 0,
						"name": "offset",
						"line": 199,
						"comment": "Offset of member from start of object\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 14,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "ti",
						"line": 200,
						"comment": "TypeInfo for this member\n",
						"deco": "C8TypeInfo",
						"originalType": "TypeInfo",
						"char": 14,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "TypeInfo",
				"line": 208,
				"comment": " Runtime type information about a type.\n Can be retrieved for any type using a\n $(GLINK2 expression,TypeidExpression, TypeidExpression).\n",
				"members": [
					{
						"endchar": 79,
						"name": "getHash",
						"line": 261,
						"comment": "Returns a hash of the instance of a type.\n",
						"deco": "xFNbNexPvZm",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 261,
						"originalType": "const nothrow @trusted size_t(in void* p)",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 68,
						"name": "equals",
						"line": 264,
						"comment": "Compares two instances for equality.\n",
						"deco": "xFxPvxPvZb",
						"parameters": [
							{
								"name": "p1",
								"deco": "xPv"
							},
							{
								"name": "p2",
								"deco": "xPv"
							}
						],
						"endline": 264,
						"originalType": "const bool(in void* p1, in void* p2)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 75,
						"name": "compare",
						"line": 267,
						"comment": "Compares two instances for &lt;, ==, or &gt;.\n",
						"deco": "xFxPvxPvZi",
						"parameters": [
							{
								"name": "p1",
								"deco": "xPv"
							},
							{
								"name": "p2",
								"deco": "xPv"
							}
						],
						"endline": 267,
						"originalType": "const int(in void* p1, in void* p2)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 73,
						"name": "tsize",
						"line": 270,
						"comment": "Returns size of the type.\n",
						"deco": "xFNaNbNdNiNfZm",
						"endline": 270,
						"originalType": "const pure nothrow @nogc @property @safe size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "swap",
						"line": 273,
						"comment": "Swaps two instances of the type.\n",
						"deco": "xFPvPvZv",
						"parameters": [
							{
								"name": "p1",
								"deco": "Pv"
							},
							{
								"name": "p2",
								"deco": "Pv"
							}
						],
						"endline": 282,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 78,
						"name": "next",
						"line": 286,
						"comment": "Get TypeInfo for 'next' type, as defined by what kind of type this is,\n\nnull if none.\n",
						"deco": "NgFNaNbNdNiZNgC8TypeInfo",
						"endline": 286,
						"char": 31,
						"kind": "function"
					},
					{
						"name": "initializer",
						"line": 290,
						"comment": "Return default initializer.  If the type should be initialized to all zeros,\n\nan array with a null ptr and a length equal to the type size will be returned.\n",
						"deco": "xFNaNbNiNfZAxv",
						"char": 28,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "init",
						"line": 293,
						"comment": "$(RED Scheduled for deprecation.) Please use `initializer` instead.\n",
						"char": 5,
						"kind": "alias"
					},
					{
						"endchar": 71,
						"name": "flags",
						"line": 301,
						"comment": "Get flags for type: 1 means GC should scan for pointers,\n\n2 means arg of this type is passed in XMM register\n",
						"deco": "xFNaNbNdNiNfZk",
						"endline": 301,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 58,
						"name": "offTi",
						"line": 304,
						"comment": "Get type information on the contents of the type; null if not available\n",
						"deco": "xFZAxS6object14OffsetTypeInfo",
						"endline": 304,
						"char": 29,
						"kind": "function"
					},
					{
						"endchar": 34,
						"name": "destroy",
						"line": 306,
						"comment": "Run the destructor on the object and all its sub-objects\n",
						"deco": "xFPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 306,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 35,
						"name": "postblit",
						"line": 308,
						"comment": "Run the postblit on the object and all its sub-objects\n",
						"deco": "xFPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 308,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 78,
						"name": "talign",
						"line": 312,
						"comment": "Return alignment of type\n",
						"deco": "xFNaNbNdNiNfZm",
						"endline": 312,
						"originalType": "const pure nothrow @nogc @property @safe size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "argTypes",
						"line": 317,
						"comment": " Return internal info on arguments fitting into 8byte.\n See X86-64 ABI 3.2.3\n",
						"deco": "FNbNfJC8TypeInfoJC8TypeInfoZi",
						"parameters": [
							{
								"name": "arg1",
								"storageClass": [
									"out"
								],
								"deco": "C8TypeInfo"
							},
							{
								"name": "arg2",
								"storageClass": [
									"out"
								],
								"deco": "C8TypeInfo"
							}
						],
						"endline": 321,
						"char": 26,
						"kind": "function"
					},
					{
						"endchar": 87,
						"name": "rtInfo",
						"line": 325,
						"comment": " Return info used by the garbage collector to do precise collection.\n",
						"deco": "xFNaNbNdNiNfZPyv",
						"endline": 325,
						"char": 32,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"offset": 16,
						"name": "m_init",
						"line": 940,
						"comment": " class static initializer\n (init.length gives size in bytes of class)\n",
						"deco": "Ag",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "name",
						"line": 943,
						"comment": "class name\n",
						"deco": "Aya",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "vtbl",
						"line": 944,
						"comment": "virtual function pointer table\n",
						"deco": "APv",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 64,
						"name": "interfaces",
						"line": 945,
						"comment": "interfaces this class implements\n",
						"deco": "AS6object9Interface",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 80,
						"name": "base",
						"line": 946,
						"comment": "base class\n",
						"deco": "C14TypeInfo_Class",
						"originalType": "TypeInfo_Class",
						"char": 22,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "find",
						"line": 973,
						"comment": " Search all modules for TypeInfo_Class corresponding to classname.\n Returns: null if not found\n",
						"deco": "FxAaZxC14TypeInfo_Class",
						"parameters": [
							{
								"name": "classname",
								"deco": "xAa"
							}
						],
						"endline": 988,
						"originalType": "const(TypeInfo_Class)(in char[] classname)",
						"char": 34,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "create",
						"line": 993,
						"comment": " Create instance of Object represented by 'this'.\n",
						"deco": "xFZC6Object",
						"endline": 1005,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "TypeInfo_Class",
				"line": 872,
				"comment": " Runtime type information about a class.\n Can be retrieved from an object instance by using the\n $(DDSUBLINK spec/property,classinfo, .classinfo) property.\n",
				"base": "object.TypeInfo",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Throwable",
				"line": 1614,
				"comment": "\n\n\n\n The base class of all thrown objects.\n\n All thrown objects must inherit from Throwable. Class $(D Exception), which\n derives from this class, represents the category of thrown objects that are\n safe to catch and handle. In principle, one should not catch Throwable\n objects that are not derived from $(D Exception), as they represent\n unrecoverable runtime errors. Certain runtime guarantees may fail to hold\n when these errors are thrown, making it unsafe to continue execution after\n catching them.\n",
				"members": [
					{
						"offset": 16,
						"name": "msg",
						"line": 1623,
						"comment": "A message describing the error.\n",
						"deco": "Aya",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "file",
						"line": 1629,
						"comment": " The _file name and line number of the D source code corresponding with\n where the error was thrown from.\n",
						"deco": "Aya",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "line",
						"line": 1630,
						"comment": "ditto\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 56,
						"name": "info",
						"line": 1637,
						"comment": " The stack trace of where the error happened. This is an opaque object\n that can either be converted to $(D string), or iterated over with $(D\n foreach) to extract the items in the stack trace (as strings).\n",
						"deco": "C6object9Throwable9TraceInfo",
						"originalType": "TraceInfo",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 64,
						"name": "next",
						"line": 1645,
						"comment": " A reference to the _next error in the list. This is used when a new\n $(D Throwable) is thrown from inside a $(D catch) block. The originally\n caught $(D Exception) will be chained to the new $(D Throwable) via this\n field.\n",
						"deco": "C6object9Throwable",
						"originalType": "Throwable",
						"char": 17,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1667,
						"comment": " Overrides $(D Object.toString) and returns the error message.\n Internally this forwards to the $(D toString) overload that\n takes a $(PARAM sink) delegate.\n",
						"deco": "FZAya",
						"endline": 1672,
						"char": 21,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1680,
						"comment": " The Throwable hierarchy uses a toString overload that takes a\n $(PARAM sink) delegate to avoid GC allocations, which cannot be\n performed in certain error situations.  Override this $(D\n toString) method to customize the error message.\n",
						"deco": "xFMDFxAaZvZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFxAaZv"
							}
						],
						"endline": 1711,
						"originalType": "const void(scope void delegate(in char[]) sink)",
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1732,
						"comment": " Creates a new instance of Exception. The next parameter is used\n internally and should always be $(D null) when passed by user code.\n This constructor does not automatically throw the newly-created\n Exception; the $(D throw) statement should be used for that purpose.\n",
						"deco": "FNaNbNiNfAyaAyamC6object9ThrowableZC9Exception",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 1735,
						"originalType": "pure nothrow @nogc @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 30,
						"kind": "constructor"
					}
				],
				"name": "Exception",
				"line": 1723,
				"comment": " The base class of all errors that are safe to catch and handle.\n\n In principle, only thrown objects derived from this class are safe to catch\n inside a $(D catch) block. Thrown objects not derived from Exception\n represent runtime errors that should not be caught, as certain runtime\n guarantees may not hold, making it unsafe to continue program execution.\n",
				"base": "object.Throwable",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1788,
						"comment": " Creates a new instance of Error. The next parameter is used\n internally and should always be $(D null) when passed by user code.\n This constructor does not automatically throw the newly-created\n Error; the $(D throw) statement should be used for that purpose.\n",
						"deco": "FNaNbNiNfAyaC6object9ThrowableZC6object5Error",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 1792,
						"originalType": "pure nothrow @nogc @safe (string msg, Throwable next = null)",
						"char": 30,
						"kind": "constructor"
					},
					{
						"offset": 72,
						"name": "bypassedException",
						"line": 1802,
						"comment": "The first $(D Exception) which was bypassed when this Error was thrown,\n\nor $(D null) if no $(D Exception)s were pending.\n",
						"deco": "C6object9Throwable",
						"originalType": "Throwable",
						"char": 17,
						"kind": "variable"
					}
				],
				"name": "Error",
				"line": 1780,
				"comment": " The base class of all unrecoverable runtime errors.\n\n This represents the category of $(D Throwable) objects that are $(B not)\n safe to catch and handle. In principle, one should not catch Error\n objects, as they represent unrecoverable runtime errors.\n Certain runtime guarantees may fail to hold when these errors are\n thrown, making it unsafe to continue execution after catching them.\n",
				"base": "object.Throwable",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "destroy",
						"line": 2693,
						"type": "void(T obj)",
						"parameters": [
							{
								"name": "obj",
								"type": "T"
							}
						],
						"endline": 2696,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "destroy",
				"line": 2693,
				"comment": "    Destroys the given object and puts it in an invalid state. It's used to\n    destroy an object so that any cleanup which its destructor or finalizer\n    does is done and so that it no longer references any other objects. It does\n    $(I not) initiate a GC cycle or free any GC memory.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "capacity",
						"line": 2928,
						"type": "pure nothrow @property size_t(T[] arr)",
						"parameters": [
							{
								"name": "arr",
								"type": "T[]"
							}
						],
						"endline": 2931,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "capacity",
				"line": 2928,
				"comment": " (Property) Get the current capacity of a slice. The capacity is the size\n that the slice can grow to before the underlying array must be\n reallocated or extended.\n\n If an append must reallocate a slice with no possibility of extension, then\n 0 is returned. This happens when the slice references a static array, or\n if another slice references elements past the end of the current slice.\n\n Note: The capacity of a slice may be impacted by operations on other slices.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2933_209)\n---\n//Static array slice: no capacity\nint[4] sarray = [1, 2, 3, 4];\nint[]  slice  = sarray[];\nassert(sarray.capacity == 0);\n//Appending to slice will reallocate to a new array\nslice ~= 5;\nassert(slice.capacity >= 5);\n\n//Dynamic array slices\nint[] a = [1, 2, 3, 4];\nint[] b = a[1 .. $];\nint[] c = a[1 .. $ - 1];\ndebug(SENTINEL) {} else // non-zero capacity very much depends on the array and GC implementation\n{\n    assert(a.capacity != 0);\n    assert(a.capacity == b.capacity + 1); //both a and b share the same tail\n}\nassert(c.capacity == 0);              //an append to c must relocate c.\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2933_209)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reserve",
						"line": 2963,
						"type": "pure nothrow @trusted size_t(ref T[] arr, size_t newcapacity)",
						"parameters": [
							{
								"name": "arr",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "newcapacity",
								"type": "size_t"
							}
						],
						"endline": 2966,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "reserve",
				"line": 2963,
				"comment": " Reserves capacity for a slice. The capacity is the size\n that the slice can grow to before the underlying array must be\n reallocated or extended.\n\n The return value is the new capacity of the array (which may be larger than\n the requested capacity).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2968_210)\n---\n//Static array slice: no capacity. Reserve relocates.\nint[4] sarray = [1, 2, 3, 4];\nint[]  slice  = sarray[];\nauto u = slice.reserve(8);\nassert(u >= 8);\nassert(sarray.ptr !is slice.ptr);\nassert(slice.capacity == u);\n\n//Dynamic array slices\nint[] a = [1, 2, 3, 4];\na.reserve(8); //prepare a for appending 4 more items\nauto p = a.ptr;\nu = a.capacity;\na ~= [5, 6, 7, 8];\nassert(p == a.ptr);      //a should not have been reallocated\nassert(u == a.capacity); //a should not have been extended\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2968_210)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeSafeAppend",
						"line": 3010,
						"type": "nothrow ref inout(T[])(auto ref inout(T[]) arr)",
						"parameters": [
							{
								"name": "arr",
								"type": "inout(T[])",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 3014,
						"char": 21,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "assumeSafeAppend",
				"line": 3010,
				"comment": " Assume that it is safe to append to this array. Appends made to this array\n after calling this function may append in place, even if the array was a\n slice of a larger array to begin with.\n\n Use this only when it is certain there are no elements in use beyond the\n array in the memory block.  If there are, those elements will be\n overwritten by appending to this array.\n\n Calling this function, and then using references to data located after the\n given array results in undefined behavior.\n\n Returns:\n   The input is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3016_212)\n---\nint[] a = [1, 2, 3, 4];\n\n// Without assumeSafeAppend. Appending relocates.\nint[] b = a [0 .. 3];\nb ~= 5;\nassert(a.ptr != b.ptr);\n\ndebug(SENTINEL) {} else\n{\n    // With assumeSafeAppend. Appending overwrites.\n    int[] c = a [0 .. 3];\n    c.assumeSafeAppend() ~= 5;\n    assert(a.ptr == c.ptr);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3016_212)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "_ArrayEq",
						"line": 3117,
						"type": "bool(T1[] a1, T2[] a2)",
						"parameters": [
							{
								"name": "a1",
								"type": "T1[]"
							},
							{
								"name": "a2",
								"type": "T2[]"
							}
						],
						"endline": 3127,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "_ArrayEq",
				"line": 3117,
				"comment": " Helper function used to see if two containers of different\n types have the same contents in the same sequence.\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "hashOf",
						"line": 3151,
						"type": "size_t(auto ref T arg, size_t seed = 0)",
						"parameters": [
							{
								"name": "arg",
								"type": "T",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "seed",
								"type": "size_t",
								"default": "0"
							}
						],
						"endline": 3155,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "hashOf",
				"line": 3151,
				"comment": "Calculates the hash value of $(D arg) with $(D seed) initial value.\nResult may be non-equals with `typeid(T).getHash(&arg)`\nThe $(D seed) value may be used for hash chaining:\n----\nstruct Test\n{\n    int a;\n    string b;\n    MyObject c;\n\n    size_t toHash() const @safe pure nothrow\n    {\n        size_t hash = a.hashOf();\n        hash = b.hashOf(hash);\n        size_t h1 = c.myMegaHash();\n        hash = h1.hashOf(hash); //Mix two hash values\n        return hash;\n    }\n}\n----\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RTInfo",
						"line": 3176,
						"init": "null",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "RTInfo",
				"line": 3174,
				"comment": " Create RTInfo for type T\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dup",
						"line": 3277,
						"type": "@property (T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]"
							}
						],
						"endline": 3289,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "dup",
				"line": 3277,
				"comment": "Provide the .dup array property.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!is(const(T) : T)",
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dup",
						"line": 3293,
						"type": "@property T[](const(T)[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "const(T)[]"
							}
						],
						"endline": 3301,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "dup",
				"line": 3293,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(const(T) : T)",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dup",
						"line": 3304,
						"type": "@property @trusted T[](const(T)[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "const(T)[]"
							}
						],
						"endline": 3308,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "dup",
				"line": 3304,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"deco": "v",
						"kind": "type"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "idup",
						"line": 3311,
						"type": "@property immutable(T)[](T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]"
							}
						],
						"endline": 3321,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "idup",
				"line": 3311,
				"comment": "Provide the .idup array property.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 26,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "idup",
						"line": 3324,
						"type": "@property immutable(T)[](const(T)[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "const(T)[]"
							}
						],
						"endline": 3327,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "idup",
				"line": 3324,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"deco": "v",
						"kind": "type"
					}
				],
				"char": 26,
				"kind": "template"
			}
		],
		"comment": " Forms the symbols available to all D programs. Includes Object, which is\n the root of the class object hierarchy.  This module is implicitly\n imported.\n Macros:\n      WIKI = Object\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Walter Bright, Sean Kelly\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/attribute.d",
		"name": "core.attribute",
		"members": [],
		"comment": " This module contains UDA's (User Defined Attributes) either used in\n the runtime or special UDA's recognized by compiler.\n\n Copyright: Copyright Jacob Carlborg 2015.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Jacob Carlborg\n Source:    $(DRUNTIMESRC core/_attribute.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/atomic.d",
		"name": "core.atomic",
		"members": [
			{
				"members": [
					{
						"endchar": 5,
						"name": "atomicOp",
						"line": 74,
						"type": "pure nothrow @nogc HeadUnshared!T(ref shared T val, V1 mod)",
						"parameters": [
							{
								"name": "val",
								"type": "T",
								"storageClass": [
									"shared",
									"ref"
								]
							},
							{
								"name": "mod",
								"type": "V1"
							}
						],
						"endline": 78,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "atomicOp",
				"line": 74,
				"comment": " Performs the binary operation 'op' on val using 'mod' as the modifier.\n\n Params:\n  val = The target variable.\n  mod = The modifier to apply.\n\n Returns:\n  The result of the operation.\n",
				"parameters": [
					{
						"name": "op",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "V1",
						"kind": "type"
					}
				],
				"constraint": "__traits(compiles, mixin(\"*cast(T*)&val\" ~ op ~ \"mod\"))",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "cas",
						"line": 94,
						"type": "pure nothrow @nogc bool(shared(T)* here, const V1 ifThis, V2 writeThis)",
						"parameters": [
							{
								"name": "here",
								"type": "shared(T)*"
							},
							{
								"name": "ifThis",
								"type": "V1",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "writeThis",
								"type": "V2"
							}
						],
						"char": 10,
						"kind": "function"
					}
				],
				"name": "cas",
				"line": 94,
				"comment": " Stores 'writeThis' to the memory referenced by 'here' if the value\n referenced by 'here' is equal to 'ifThis'.  This operation is both\n lock-free and atomic.\n\n Params:\n  here      = The address of the destination variable.\n  writeThis = The value to store.\n  ifThis    = The comparison value.\n\n Returns:\n  true if the store occurred, false if not.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "V1",
						"kind": "type"
					},
					{
						"name": "V2",
						"kind": "type"
					}
				],
				"constraint": "!is(T == class) && !is(T U : U*) && __traits(compiles, ()\n{\n*here = writeThis;\n}\n)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "cas",
						"line": 98,
						"type": "pure nothrow @nogc bool(shared(T)* here, const shared(V1) ifThis, shared(V2) writeThis)",
						"parameters": [
							{
								"name": "here",
								"type": "shared(T)*"
							},
							{
								"name": "ifThis",
								"type": "shared(V1)",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "writeThis",
								"type": "shared(V2)"
							}
						],
						"char": 10,
						"kind": "function"
					}
				],
				"name": "cas",
				"line": 98,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "V1",
						"kind": "type"
					},
					{
						"name": "V2",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) && __traits(compiles, ()\n{\n*here = writeThis;\n}\n)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "cas",
						"line": 102,
						"type": "pure nothrow @nogc bool(shared(T)* here, const shared(V1)* ifThis, shared(V2)* writeThis)",
						"parameters": [
							{
								"name": "here",
								"type": "shared(T)*"
							},
							{
								"name": "ifThis",
								"type": "shared(V1)*",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "writeThis",
								"type": "shared(V2)*"
							}
						],
						"char": 10,
						"kind": "function"
					}
				],
				"name": "cas",
				"line": 102,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "V1",
						"kind": "type"
					},
					{
						"name": "V2",
						"kind": "type"
					}
				],
				"constraint": "is(T U : U*) && __traits(compiles, ()\n{\n*here = writeThis;\n}\n)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "atomicLoad",
						"line": 117,
						"type": "pure nothrow @nogc HeadUnshared!T(ref const shared T val)",
						"parameters": [
							{
								"name": "val",
								"type": "T",
								"storageClass": [
									"const",
									"shared",
									"ref"
								]
							}
						],
						"endline": 120,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "atomicLoad",
				"line": 117,
				"comment": " Loads 'val' from memory and returns it.  The memory barrier specified\n by 'ms' is applied to the operation, which is fully sequenced by\n default.  Valid memory orders are MemoryOrder.raw, MemoryOrder.acq,\n and MemoryOrder.seq.\n\n Params:\n  val = The target variable.\n\n Returns:\n  The value of 'val'.\n",
				"parameters": [
					{
						"name": "ms",
						"defaultValue": "MemoryOrder.seq",
						"deco": "E4core6atomic11MemoryOrder",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "atomicStore",
						"line": 133,
						"type": "pure nothrow @nogc void(ref shared T val, V1 newval)",
						"parameters": [
							{
								"name": "val",
								"type": "T",
								"storageClass": [
									"shared",
									"ref"
								]
							},
							{
								"name": "newval",
								"type": "V1"
							}
						],
						"endline": 137,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "atomicStore",
				"line": 133,
				"comment": " Writes 'newval' into 'val'.  The memory barrier specified by 'ms' is\n applied to the operation, which is fully sequenced by default.\n Valid memory orders are MemoryOrder.raw, MemoryOrder.rel, and\n MemoryOrder.seq.\n\n Params:\n  val    = The target variable.\n  newval = The value to store.\n",
				"parameters": [
					{
						"name": "ms",
						"defaultValue": "MemoryOrder.seq",
						"deco": "E4core6atomic11MemoryOrder",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "V1",
						"kind": "type"
					}
				],
				"constraint": "__traits(compiles, ()\n{\nval = newval;\n}\n)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "raw",
						"line": 145,
						"value": "0",
						"comment": "Not sequenced.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "acq",
						"line": 146,
						"value": "1",
						"comment": "Hoist-load + hoist-store barrier.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "rel",
						"line": 147,
						"value": "2",
						"comment": "Sink-load + sink-store barrier.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "seq",
						"line": 148,
						"value": "3",
						"comment": "Fully sequenced (acquire + release).\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "MemoryOrder",
				"line": 143,
				"comment": " Specifies the memory ordering semantics of an atomic operation.\n",
				"baseDeco": "i",
				"char": 5,
				"kind": "enum"
			},
			{
				"name": "atomicFence",
				"line": 159,
				"comment": " Inserts a full load/store memory fence (on platforms that need it). This ensures\n that all loads and stores before a call to this function are executed before any\n loads and stores after the call.\n",
				"deco": "FNbNiZv",
				"char": 10,
				"kind": "function"
			}
		],
		"comment": " The atomic module provides basic support for lock-free\n concurrent programming.\n\n Copyright: Copyright Sean Kelly 2005 - 2010.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly, Alex Rønne Petersen\n Source:    $(DRUNTIMESRC core/_atomic.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/math.d",
		"name": "core.math",
		"members": [
			{
				"name": "cos",
				"line": 43,
				"comment": " Returns cosine of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH cos(x)) $(TH invalid?))\n      $(TR $(TD $(NAN))            $(TD $(NAN)) $(TD yes)     )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(NAN)) $(TD yes)     )\n      )\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "sin",
				"line": 58,
				"comment": " Returns sine of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)               $(TH sin(x))      $(TH invalid?))\n      $(TR $(TD $(NAN))          $(TD $(NAN))      $(TD yes))\n      $(TR $(TD $(PLUSMN)0.0)    $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMNINF))    $(TD $(NAN))      $(TD yes))\n      )\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "rndtol",
				"line": 66,
				"comment": " Returns x rounded to a long value using the current rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n",
				"deco": "FNaNbNiNfeZl",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "rndtonl",
				"line": 75,
				"comment": " Returns x rounded to a long value using the FE_TONEAREST rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n",
				"deco": "UNieZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"name": "sqrt",
				"line": 90,
				"comment": " Compute square root of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH sqrt(x))   $(TH invalid?))\n      $(TR $(TD -0.0)      $(TD -0.0)      $(TD no))\n      $(TR $(TD $(LT)0.0)  $(TD $(NAN))    $(TD yes))\n      $(TR $(TD +$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      )\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"char": 11,
				"kind": "function"
			},
			{
				"name": "sqrt",
				"line": 91,
				"comment": "ditto\n\n Compute square root of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH sqrt(x))   $(TH invalid?))\n      $(TR $(TD -0.0)      $(TD -0.0)      $(TD no))\n      $(TR $(TD $(LT)0.0)  $(TD $(NAN))    $(TD yes))\n      $(TR $(TD +$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      )\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"char": 12,
				"kind": "function"
			},
			{
				"name": "sqrt",
				"line": 92,
				"comment": "ditto\n\n Compute square root of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH sqrt(x))   $(TH invalid?))\n      $(TR $(TD -0.0)      $(TD -0.0)      $(TD no))\n      $(TR $(TD $(LT)0.0)  $(TD $(NAN))    $(TD yes))\n      $(TR $(TD +$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 10,
				"kind": "function"
			},
			{
				"name": "ldexp",
				"line": 100,
				"comment": " Compute n * 2$(SUPERSCRIPT exp)\n References: frexp\n",
				"deco": "FNaNbNiNfeiZe",
				"parameters": [
					{
						"name": "n",
						"deco": "e"
					},
					{
						"name": "exp",
						"deco": "i"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "fabs",
				"line": 127,
				"comment": " Returns |x|\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH fabs(x)))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) )\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "rint",
				"line": 137,
				"comment": " Rounds x to the nearest integer value, using the current rounding\n mode.\n If the return value is not equal to x, the FE_INEXACT\n exception is raised.\n $(B nearbyint) performs\n the same operation, but does not set the FE_INEXACT exception.\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "yl2x",
				"line": 144,
				"comment": " Building block functions, they\n translate to a single x87 instruction.\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			}
		],
		"comment": " Builtin mathematical intrinsics\n\n Source: $(DRUNTIMESRC core/_math.d)\n Macros:\n      TABLE_SV = <table border=\"1\" cellpadding=\"4\" cellspacing=\"0\">\n              <caption>Special Values</caption>\n              $0</table>\n\n      NAN = $(RED NAN)\n      SUP = <span style=\"vertical-align:super;font-size:smaller\">$0</span>\n      POWER = $1<sup>$2</sup>\n      PLUSMN = &plusmn;\n      INFIN = &infin;\n      PLUSMNINF = &plusmn;&infin;\n      LT = &lt;\n      GT = &gt;\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright),\n                        Don Clugston\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/simd.d",
		"name": "core.simd",
		"members": [
			{
				"members": [
					{
						"name": "Vector",
						"line": 36,
						"type": "__vector(T)",
						"char": 23,
						"kind": "alias"
					}
				],
				"name": "Vector",
				"line": 31,
				"comment": " Create a vector type.\n\n Parameters:\n      T = one of double[2], float[4], void[16], byte[16], ubyte[16],\n      short[8], ushort[8], int[4], uint[4], long[2], ulong[2].\n      For 256 bit vectors,\n      one of double[4], float[8], void[32], byte[32], ubyte[32],\n      short[16], ushort[16], int[8], uint[8], long[4], ulong[4]\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "void16",
				"line": 41,
				"comment": "\n",
				"deco": "NhG16v",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "double2",
				"line": 42,
				"comment": "\n",
				"deco": "NhG2d",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "float4",
				"line": 43,
				"comment": "\n",
				"deco": "NhG4f",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "byte16",
				"line": 44,
				"comment": "\n",
				"deco": "NhG16g",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "ubyte16",
				"line": 45,
				"comment": "\n",
				"deco": "NhG16h",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "short8",
				"line": 46,
				"comment": "\n",
				"deco": "NhG8s",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "ushort8",
				"line": 47,
				"comment": "\n",
				"deco": "NhG8t",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "int4",
				"line": 48,
				"comment": "\n",
				"deco": "NhG4i",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "uint4",
				"line": 49,
				"comment": "\n",
				"deco": "NhG4k",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "long2",
				"line": 50,
				"comment": "\n",
				"deco": "NhG2l",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "ulong2",
				"line": 51,
				"comment": "\n",
				"deco": "NhG2m",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "void32",
				"line": 53,
				"comment": "\n",
				"deco": "NhG32v",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "double4",
				"line": 54,
				"comment": "\n",
				"deco": "NhG4d",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "float8",
				"line": 55,
				"comment": "\n",
				"deco": "NhG8f",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "byte32",
				"line": 56,
				"comment": "\n",
				"deco": "NhG32g",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "ubyte32",
				"line": 57,
				"comment": "\n",
				"deco": "NhG32h",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "short16",
				"line": 58,
				"comment": "\n",
				"deco": "NhG16s",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "ushort16",
				"line": 59,
				"comment": "\n",
				"deco": "NhG16t",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "int8",
				"line": 60,
				"comment": "\n",
				"deco": "NhG8i",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "uint8",
				"line": 61,
				"comment": "\n",
				"deco": "NhG8k",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "long4",
				"line": 62,
				"comment": "\n",
				"deco": "NhG4l",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "ulong4",
				"line": 63,
				"comment": "\n",
				"deco": "NhG4m",
				"char": 63,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "XMM",
				"line": 73,
				"comment": " XMM opcodes that conform to the following:\n\n  opcode xmm1,xmm2/mem\n\n and do not have side effects (i.e. do not write to memory).\n",
				"baseDeco": "i",
				"char": 3,
				"kind": "enum"
			}
		],
		"comment": " Builtin SIMD intrinsics\n\n Source: $(DRUNTIMESRC core/_simd.d)\n\n Copyright: Copyright Digital Mars 2012.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright),\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/thread.d",
		"name": "core.thread",
		"members": [
			{
				"name": "getpid",
				"line": 55,
				"comment": " Returns the process ID of the calling process, which is guaranteed to be\n unique on the system. This call is always successful.\n\n Example:\n ---\n writefln(\"Current process id: %s\", getpid());\n ---\n",
				"char": 40,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "ThreadException",
				"line": 71,
				"comment": "\n\n\n\n Base class for thread exceptions.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "ThreadError",
				"line": 88,
				"comment": " Base class for thread errors to be used for function inside GC when allocations are unavailable.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Thread",
				"line": 534,
				"comment": "\n\n\n\n This class encapsulates all threading functionality for the D\n programming language.  As thread manipulation is a required facility\n for garbage collection, all user threads should derive from this\n class, and instances of this class should never be explicitly deleted.\n A new thread may be created using either derivation or composition, as\n in the following example.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1831_253)\n---\nclass DerivedThread : Thread\n{\n    this()\n    {\n        super(&run);\n    }\n\nprivate:\n    void run()\n    {\n        // Derived thread running.\n    }\n}\n\nvoid threadFunc()\n{\n    // Composed thread running.\n}\n\n// create and start instances of each type\nauto derived = new DerivedThread().start();\nauto composed = new Thread(&threadFunc).start();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1831_253)\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 552,
						"comment": "\n\n\n\n Initializes a thread object which is associated with a static\n D function.\n\n Params:\n  fn = The thread function.\n  sz = The stack size for this thread.\n\n In:\n  fn must not be null.\n",
						"deco": "FPFZvmZC4core6thread6Thread",
						"parameters": [
							{
								"name": "fn",
								"deco": "PFZv"
							},
							{
								"name": "sz",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 563,
						"originalType": "(void function() fn, size_t sz = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 577,
						"comment": " Initializes a thread object which is associated with a dynamic\n D function.\n\n Params:\n  dg = The thread function.\n  sz = The stack size for this thread.\n\n In:\n  dg must not be null.\n",
						"deco": "FDFZvmZC4core6thread6Thread",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFZv"
							},
							{
								"name": "sz",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 588,
						"originalType": "(void delegate() dg, size_t sz = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "~this",
						"line": 594,
						"comment": " Cleans up any remaining resources used by this object.\n",
						"deco": "FZv",
						"endline": 618,
						"char": 5,
						"kind": "destructor"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 638,
							"deco": "FNbZv",
							"endline": 638,
							"char": 5,
							"kind": "function"
						},
						"name": "start",
						"line": 636,
						"comment": "\n\n\n\n Starts the thread and invokes the function or delegate passed upon\n construction.\n\n In:\n  This routine may only be called once per thread instance.\n\n Throws:\n  ThreadException if the thread fails to start.\n",
						"deco": "FNbZC4core6thread6Thread",
						"endline": 728,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "join",
						"line": 746,
						"comment": " Waits for this thread to complete.  If the thread terminated as the\n result of an unhandled exception, this exception will be rethrown.\n\n Params:\n  rethrow = Rethrow any unhandled exception which may have caused this\n            thread to terminate.\n\n Throws:\n  ThreadException if the operation fails.\n  Any exception not handled by the joined thread.\n\n Returns:\n  Any exception not handled by this thread if rethrow = false, null\n  otherwise.\n",
						"deco": "FbZC6object9Throwable",
						"parameters": [
							{
								"name": "rethrow",
								"deco": "b",
								"default": "true"
							}
						],
						"endline": 776,
						"char": 21,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "id",
						"line": 794,
						"comment": "\n\n\n\n Gets the OS identifier for this thread.\n\n Returns:\n  If the thread hasn't been started yet, returns $(LREF ThreadID)$(D.init).\n  Otherwise, returns the result of $(D GetCurrentThreadId) on Windows,\n  and $(D pthread_self) on POSIX.\n\n  The value is unique for the current process.\n",
						"deco": "FNdZm",
						"endline": 800,
						"originalType": "@property ThreadID()",
						"char": 30,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "name",
						"line": 809,
						"comment": " Gets the user-readable label for this thread.\n\n Returns:\n  The name of this thread.\n",
						"deco": "FNdZAya",
						"endline": 815,
						"char": 28,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "name",
						"line": 824,
						"comment": " Sets the user-readable label for this thread.\n\n Params:\n  val = The new name of this thread.\n",
						"deco": "FNdAyaZv",
						"parameters": [
							{
								"name": "val",
								"deco": "Aya"
							}
						],
						"endline": 830,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "isDaemon",
						"line": 843,
						"comment": " Gets the daemon status for this thread.  While the runtime will wait for\n all normal threads to complete before tearing down the process, daemon\n threads are effectively ignored and thus will not prevent the process\n from terminating.  In effect, daemon threads will be terminated\n automatically by the OS when the process exits.\n\n Returns:\n  true if this is a daemon thread.\n",
						"deco": "FNdZb",
						"endline": 849,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "isDaemon",
						"line": 862,
						"comment": " Sets the daemon status for this thread.  While the runtime will wait for\n all normal threads to complete before tearing down the process, daemon\n threads are effectively ignored and thus will not prevent the process\n from terminating.  In effect, daemon threads will be terminated\n automatically by the OS when the process exits.\n\n Params:\n  val = The new daemon status for this thread.\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "val",
								"deco": "b"
							}
						],
						"endline": 868,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "isRunning",
						"line": 877,
						"comment": " Tests whether this thread is running.\n\n Returns:\n  true if the thread is running, false if not.\n",
						"deco": "FNbNdZb",
						"endline": 894,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"name": "PRIORITY_MIN",
						"line": 908,
						"comment": "\n\n\n\n The minimum scheduling priority that may be set for a thread.  On\n systems where multiple scheduling policies are defined, this value\n represents the minimum valid priority for the scheduling policy of\n the process.\n",
						"deco": "xi",
						"originalType": "int",
						"char": 25,
						"kind": "variable",
						"storageClass": [
							"const",
							"__gshared"
						]
					},
					{
						"name": "PRIORITY_MAX",
						"line": 917,
						"comment": " The maximum scheduling priority that may be set for a thread.  On\n systems where multiple scheduling policies are defined, this value\n represents the maximum valid priority for the scheduling policy of\n the process.\n",
						"deco": "xi",
						"originalType": "int",
						"char": 25,
						"kind": "variable",
						"storageClass": [
							"const",
							"__gshared"
						]
					},
					{
						"name": "PRIORITY_DEFAULT",
						"line": 926,
						"comment": " The default scheduling priority that is set for a thread.  On\n systems where multiple scheduling policies are defined, this value\n represents the default priority for the scheduling policy of\n the process.\n",
						"deco": "xi",
						"originalType": "int",
						"char": 25,
						"kind": "variable",
						"storageClass": [
							"const",
							"__gshared"
						]
					},
					{
						"endchar": 5,
						"name": "priority",
						"line": 938,
						"comment": " Gets the scheduling priority for the associated thread.\n\n Note: Getting the priority of a thread that already terminated\n might return the default priority.\n\n Returns:\n  The scheduling priority of this thread.\n",
						"deco": "FNdZi",
						"endline": 957,
						"char": 25,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 971,
							"deco": "FZv",
							"endline": 971,
							"char": 5,
							"kind": "function"
						},
						"name": "priority",
						"line": 969,
						"comment": " Sets the scheduling priority for the associated thread.\n\n Note: Setting the priority of a thread that already terminated\n might have no effect.\n\n Params:\n  val = The new scheduling priority of this thread.\n",
						"deco": "FNdiZv",
						"parameters": [
							{
								"name": "val",
								"deco": "i"
							}
						],
						"endline": 1041,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "sleep",
						"line": 1094,
						"comment": "\n\n\n\n Suspends the calling thread for at least the supplied period.  This may\n result in multiple OS calls if period is greater than the maximum sleep\n duration supported by the operating system.\n\n Params:\n  val = The minimum duration the calling thread should be suspended.\n\n In:\n  period must be non-negative.\n\n Example:\n ------------------------------------------------------------------------\n\n Thread.sleep( dur!(\"msecs\")( 50 ) );  // sleep for 50 milliseconds\n Thread.sleep( dur!(\"seconds\")( 5 ) ); // sleep for 5 seconds\n\n ------------------------------------------------------------------------\n",
						"deco": "FNbS4core4time8DurationZv",
						"parameters": [
							{
								"name": "val",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 1141,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "yield",
						"line": 1147,
						"comment": " Forces a context switch to occur away from the calling thread.\n",
						"deco": "FNbZv",
						"endline": 1153,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getThis",
						"line": 1168,
						"comment": "\n\n\n\n Provides a reference to the calling thread.\n\n Returns:\n  The thread object representing the calling thread.  The result of\n  deleting this object is undefined.  If the current thread is not\n  attached to the runtime, a null reference is returned.\n",
						"deco": "FNbZC4core6thread6Thread",
						"endline": 1174,
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getAll",
						"line": 1187,
						"comment": " Provides a list of all threads currently being tracked by the system.\n Note that threads in the returned array might no longer run (see\n $(D Thread.)$(LREF isRunning)).\n\n Returns:\n  An array containing references to all threads currently being\n  tracked by the system.  The result of deleting any contained\n  objects is undefined.\n",
						"deco": "FZAC4core6thread6Thread",
						"endline": 1194,
						"char": 21,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 1209,
						"comment": " Operates on all threads currently being tracked by the system.  The\n result of deleting any Thread object is undefined.\n Note that threads passed to the callback might no longer run (see\n $(D Thread.)$(LREF isRunning)).\n\n Params:\n  dg = The supplied code as a delegate.\n\n Returns:\n  Zero if all elemented are visited, nonzero if not.\n",
						"deco": "FMDFKC4core6thread6ThreadZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFKC4core6thread6ThreadZi"
							}
						],
						"endline": 1226,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 5,
				"name": "thread_setGCSignals",
				"line": 1901,
				"comment": " Instruct the thread module, when initialized, to use a different set of\n signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads.\n This function should be called at most once, prior to thread_init().\n This function is Posix-only.\n\n\n\n\n",
				"deco": "UiiZv",
				"parameters": [
					{
						"name": "suspendSignalNo",
						"deco": "i"
					},
					{
						"name": "resumeSignalNo",
						"deco": "i"
					}
				],
				"endline": 1903,
				"char": 21,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_init",
				"line": 1938,
				"comment": " Initializes the thread module.  This function must be called by the\n garbage collector on startup and before any other thread routines\n are called.\n",
				"deco": "UZv",
				"endline": 2005,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_term",
				"line": 2012,
				"comment": " Terminates the thread module. No other thread routine may be called\n afterwards.\n",
				"deco": "UZv",
				"endline": 2022,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_isMainThread",
				"line": 2028,
				"comment": "\n",
				"deco": "UZb",
				"endline": 2031,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_attachThis",
				"line": 2044,
				"comment": " Registers the calling thread for use with the D Runtime.  If this routine\n is called for a thread which is already registered, no action is performed.\n\n NOTE: This routine does not run thread-local static constructors when called.\n       If full functionality as a D thread is desired, the following function\n       must be called after thread_attachThis:\n\n       extern (C) void rt_moduleTlsCtor();\n",
				"deco": "UZC4core6thread6Thread",
				"endline": 2085,
				"char": 19,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_detachThis",
				"line": 2161,
				"comment": " Deregisters the calling thread from use with the runtime.  If this routine\n is called for a thread which is not registered, the result is undefined.\n\n NOTE: This routine does not run thread-local static destructors when called.\n       If full functionality as a D thread is desired, the following function\n       must be called after thread_detachThis, particularly if the thread is\n       being detached at some indeterminate time before program termination:\n\n       $(D extern(C) void rt_moduleTlsDtor();)\n",
				"deco": "UNbZv",
				"endline": 2165,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_detachByAddr",
				"line": 2179,
				"comment": " Deregisters the given thread from use with the runtime.  If this routine\n is called for a thread which is not registered, the result is undefined.\n\n NOTE: This routine does not run thread-local static destructors when called.\n       If full functionality as a D thread is desired, the following function\n       must be called by the detached thread, particularly if the thread is\n       being detached at some indeterminate time before program termination:\n\n       $(D extern(C) void rt_moduleTlsDtor();)\n",
				"deco": "UmZv",
				"parameters": [
					{
						"name": "addr",
						"deco": "m"
					}
				],
				"endline": 2183,
				"originalType": "extern (C) void(ThreadID addr)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_detachInstance",
				"line": 2187,
				"comment": "ditto\n",
				"deco": "UC4core6thread6ThreadZv",
				"parameters": [
					{
						"name": "t",
						"deco": "C4core6thread6Thread"
					}
				],
				"endline": 2190,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_findByAddr",
				"line": 2220,
				"comment": " Search the list of all threads for a thread with the given thread identifier.\n\n Params:\n  addr = The thread identifier to search for.\n Returns:\n  The thread object associated with the thread identifier, null if not found.\n",
				"deco": "FmZC4core6thread6Thread",
				"parameters": [
					{
						"name": "addr",
						"deco": "m"
					}
				],
				"endline": 2236,
				"originalType": "Thread(ThreadID addr)",
				"char": 15,
				"kind": "function",
				"storageClass": [
					"static"
				]
			},
			{
				"endchar": 1,
				"name": "thread_setThis",
				"line": 2249,
				"comment": " Sets the current thread to a specific reference. Only to be used\n when dealing with externally-created threads (in e.g. C code).\n The primary use of this function is when Thread.getThis() must\n return a sensible value in, for example, TLS destructors. In\n other words, don't touch this unless you know what you're doing.\n\n Params:\n  t = A reference to the current thread. May be null.\n",
				"deco": "UC4core6thread6ThreadZv",
				"parameters": [
					{
						"name": "t",
						"deco": "C4core6thread6Thread"
					}
				],
				"endline": 2252,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_joinAll",
				"line": 2260,
				"comment": " Joins all non-daemon threads that are currently running.  This is done by\n performing successive scans through the thread list until a scan consists\n of only daemon threads.\n",
				"deco": "UZv",
				"endline": 2294,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_suspendAll",
				"line": 2599,
				"comment": " Suspend all threads but the calling thread for \"stop the world\" garbage\n collection runs.  This function may be called multiple times, and must\n be followed by a matching number of calls to thread_resumeAll before\n processing is resumed.\n\n Throws:\n  ThreadError if the suspend operation fails for a running thread.\n",
				"deco": "UNbZv",
				"endline": 2673,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_resumeAll",
				"line": 2755,
				"comment": " Resume all threads but the calling thread for \"stop the world\" garbage\n collection runs.  This function must be called once for each preceding\n call to thread_suspendAll before the threads are actually resumed.\n\n In:\n  This routine must be preceded by a call to thread_suspendAll.\n\n Throws:\n  ThreadError if the resume operation fails for a running thread.\n",
				"deco": "UNbZv",
				"endline": 2782,
				"char": 17,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "stack",
						"line": 2789,
						"value": "0",
						"comment": "The stack and/or registers are being scanned.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tls",
						"line": 2790,
						"value": "1",
						"comment": "TLS data is being scanned.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "ScanType",
				"line": 2787,
				"comment": " Indicates the kind of scan being performed by $(D thread_scanAllType).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "ScanAllThreadsFn",
				"line": 2793,
				"comment": "The scanning function.\n",
				"deco": "DFNbPvPvZv",
				"char": 43,
				"kind": "alias"
			},
			{
				"name": "ScanAllThreadsTypeFn",
				"line": 2794,
				"comment": "ditto\n",
				"deco": "DFNbE4core6thread8ScanTypePvPvZv",
				"char": 53,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "thread_scanAllType",
				"line": 2806,
				"comment": " The main entry point for garbage collection.  The supplied delegate\n will be passed ranges representing both stack and register values.\n\n Params:\n  scan        = The scanner function.  It should scan from p1 through p2 - 1.\n\n In:\n  This routine must be preceded by a call to thread_suspendAll.\n",
				"deco": "UNbMDFNbE4core6thread8ScanTypePvPvZvZv",
				"parameters": [
					{
						"name": "scan",
						"storageClass": [
							"scope"
						],
						"deco": "DFNbE4core6thread8ScanTypePvPvZv"
					}
				],
				"endline": 2814,
				"originalType": "nothrow extern (C) void(scope ScanAllThreadsTypeFn scan)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_scanAll",
				"line": 2889,
				"comment": " The main entry point for garbage collection.  The supplied delegate\n will be passed ranges representing both stack and register values.\n\n Params:\n  scan        = The scanner function.  It should scan from p1 through p2 - 1.\n\n In:\n  This routine must be preceded by a call to thread_suspendAll.\n",
				"deco": "UNbMDFNbPvPvZvZv",
				"parameters": [
					{
						"name": "scan",
						"storageClass": [
							"scope"
						],
						"deco": "DFNbPvPvZv"
					}
				],
				"endline": 2892,
				"originalType": "nothrow extern (C) void(scope ScanAllThreadsFn scan)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_enterCriticalRegion",
				"line": 2916,
				"comment": " Signals that the code following this call is a critical region. Any code in\n this region must finish running before the calling thread can be suspended\n by a call to thread_suspendAll.\n\n This function is, in particular, meant to help maintain garbage collector\n invariants when a lock is not used.\n\n A critical region is exited with thread_exitCriticalRegion.\n\n $(RED Warning):\n Using critical regions is extremely error-prone. For instance, using locks\n inside a critical region can easily result in a deadlock when another thread\n holding the lock already got suspended.\n\n The term and concept of a 'critical region' comes from\n $(LINK2 https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925 Mono's SGen garbage collector).\n\n In:\n  The calling thread must be attached to the runtime.\n",
				"deco": "UZv",
				"endline": 2925,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_exitCriticalRegion",
				"line": 2935,
				"comment": " Signals that the calling thread is no longer in a critical region. Following\n a call to this function, the thread can once again be suspended.\n\n In:\n  The calling thread must be attached to the runtime.\n",
				"deco": "UZv",
				"endline": 2944,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_inCriticalRegion",
				"line": 2953,
				"comment": " Returns true if the current thread is in a critical region; otherwise, false.\n\n In:\n  The calling thread must be attached to the runtime.\n",
				"deco": "UZb",
				"endline": 2962,
				"char": 17,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 3080,
						"value": "0",
						"comment": "Address is not marked.\n",
						"char": 10,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 3081,
						"value": "1",
						"comment": "Address is marked.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "unknown",
						"line": 3082,
						"value": "2",
						"comment": "Address is not managed by the GC.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "IsMarked",
				"line": 3078,
				"comment": " Indicates whether an address has been marked by the GC.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "IsMarkedDg",
				"line": 3085,
				"comment": "The isMarked callback function.\n",
				"deco": "DFNbPvZi",
				"char": 42,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "thread_processGCMarks",
				"line": 3099,
				"comment": " This routine allows the runtime to process any special per-thread handling\n for the GC.  This is needed for taking into account any memory that is\n referenced by non-scanned pointers but is about to be freed.  That currently\n means the array append cache.\n\n Params:\n  isMarked = The function used to check if $(D addr) is marked.\n\n In:\n  This routine must be called just prior to resuming all threads.\n",
				"deco": "UNbMDFNbPvZiZv",
				"parameters": [
					{
						"name": "isMarked",
						"storageClass": [
							"scope"
						],
						"deco": "DFNbPvZi"
					}
				],
				"endline": 3109,
				"originalType": "nothrow extern (C) void(scope IsMarkedDg isMarked)",
				"char": 16,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_stackTop",
				"line": 3209,
				"comment": " Returns the stack top of the currently active stack within the calling\n thread.\n\n In:\n  The calling thread must be attached to the runtime.\n\n Returns:\n  The address of the stack top.\n",
				"deco": "UNbZPv",
				"endline": 3218,
				"char": 18,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_stackBottom",
				"line": 3231,
				"comment": " Returns the stack bottom of the currently active stack within the calling\n thread.\n\n In:\n  The calling thread must be attached to the runtime.\n\n Returns:\n  The address of the stack bottom.\n",
				"deco": "UNbZPv",
				"endline": 3239,
				"char": 18,
				"kind": "function"
			},
			{
				"name": "ThreadGroup",
				"line": 3250,
				"comment": "\n\n\n\n This class is intended to simplify certain common programming techniques.\n",
				"members": [
					{
						"endchar": 5,
						"name": "create",
						"line": 3262,
						"comment": " Creates and starts a new Thread object that executes fn and adds it to\n the list of tracked threads.\n\n Params:\n  fn = The thread function.\n\n Returns:\n  A reference to the newly created thread.\n",
						"deco": "FPFZvZC4core6thread6Thread",
						"parameters": [
							{
								"name": "fn",
								"deco": "PFZv"
							}
						],
						"endline": 3271,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "create",
						"line": 3284,
						"comment": " Creates and starts a new Thread object that executes dg and adds it to\n the list of tracked threads.\n\n Params:\n  dg = The thread function.\n\n Returns:\n  A reference to the newly created thread.\n",
						"deco": "FDFZvZC4core6thread6Thread",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFZv"
							}
						],
						"endline": 3293,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 3307,
							"deco": "FZv",
							"endline": 3307,
							"char": 5,
							"kind": "function"
						},
						"name": "add",
						"line": 3305,
						"comment": " Add t to the list of tracked threads if it is not already being tracked.\n\n Params:\n  t = The thread to add.\n\n In:\n  t must not be null.\n",
						"deco": "FC4core6thread6ThreadZv",
						"parameters": [
							{
								"name": "t",
								"deco": "C4core6thread6Thread"
							}
						],
						"endline": 3316,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 3331,
							"deco": "FZv",
							"endline": 3331,
							"char": 5,
							"kind": "function"
						},
						"name": "remove",
						"line": 3329,
						"comment": " Removes t from the list of tracked threads.  No operation will be\n performed if t is not currently being tracked by this object.\n\n Params:\n  t = The thread to remove.\n\n In:\n  t must not be null.\n",
						"deco": "FC4core6thread6ThreadZv",
						"parameters": [
							{
								"name": "t",
								"deco": "C4core6thread6Thread"
							}
						],
						"endline": 3340,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 3346,
						"comment": " Operates on all threads currently tracked by this object.\n",
						"deco": "FMDFKC4core6thread6ThreadZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFKC4core6thread6ThreadZi"
							}
						],
						"endline": 3362,
						"char": 15,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "joinAll",
						"line": 3376,
						"comment": " Iteratively joins all tracked threads.  This function will block add,\n remove, and opApply until it completes.\n\n Params:\n  rethrow = Rethrow any unhandled exception which may have caused the\n            current thread to terminate.\n\n Throws:\n  Any exception not handled by the joined threads.\n",
						"deco": "FbZv",
						"parameters": [
							{
								"name": "rethrow",
								"deco": "b",
								"default": "true"
							}
						],
						"endline": 3387,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Fiber",
				"line": 3926,
				"comment": "\n\n\n\n This class provides a cooperative concurrency mechanism integrated with the\n threading and garbage collection functionality.  Calling a fiber may be\n considered a blocking operation that returns when the fiber yields (via\n Fiber.yield()).  Execution occurs within the context of the calling thread\n so synchronization is not necessary to guarantee memory visibility so long\n as the same thread calls the fiber each time.  Please note that there is no\n requirement that a fiber be bound to one specific thread.  Rather, fibers\n may be freely passed between threads so long as they are not currently\n executing.  Like threads, a new fiber thread may be created using either\n derivation or composition, as in the following example.\n\n Warning:\n Status registers are not saved by the current implementations. This means\n floating point exception status bits (overflow, divide by 0), rounding mode\n and similar stuff is set per-thread, not per Fiber!\n\n Warning:\n On ARM FPU registers are not saved if druntime was compiled as ARM_SoftFloat.\n If such a build is used on a ARM_SoftFP system which actually has got a FPU\n and other libraries are using the FPU registers (other code is compiled\n as ARM_SoftFP) this can cause problems. Druntime must be compiled as\n ARM_SoftFP in this case.\n\n Example:\n ----------------------------------------------------------------------\n\n class DerivedFiber : Fiber\n {\n     this()\n     {\n         super( &run );\n     }\n\n private :\n     void run()\n     {\n         printf( \"Derived fiber running.\\n\" );\n     }\n }\n\n void fiberFunc()\n {\n     printf( \"Composed fiber running.\\n\" );\n     Fiber.yield();\n     printf( \"Composed fiber running.\\n\" );\n }\n\n // create instances of each type\n Fiber derived = new DerivedFiber();\n Fiber composed = new Fiber( &fiberFunc );\n\n // call both fibers once\n derived.call();\n composed.call();\n printf( \"Execution returned to calling context.\\n\" );\n composed.call();\n\n // since each fiber has run to completion, each should have state TERM\n assert( derived.state == Fiber.State.TERM );\n assert( composed.state == Fiber.State.TERM );\n\n ----------------------------------------------------------------------\n\n Authors: Based on a design by Mikola Lysenko.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3944,
						"comment": "\n\n\n\n Initializes a fiber object which is associated with a static\n D function.\n\n Params:\n  fn = The fiber function.\n  sz = The stack size for this fiber.\n\n In:\n  fn must not be null.\n",
						"deco": "FNbPFZvmZC4core6thread5Fiber",
						"parameters": [
							{
								"name": "fn",
								"deco": "PFZv"
							},
							{
								"name": "sz",
								"deco": "m",
								"default": "PAGESIZE * 4LU"
							}
						],
						"endline": 3953,
						"originalType": "nothrow (void function() fn, size_t sz = PAGESIZE * 4)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3967,
						"comment": " Initializes a fiber object which is associated with a dynamic\n D function.\n\n Params:\n  dg = The fiber function.\n  sz = The stack size for this fiber.\n\n In:\n  dg must not be null.\n",
						"deco": "FNbDFZvmZC4core6thread5Fiber",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFZv"
							},
							{
								"name": "sz",
								"deco": "m",
								"default": "PAGESIZE * 4LU"
							}
						],
						"endline": 3976,
						"originalType": "nothrow (void delegate() dg, size_t sz = PAGESIZE * 4)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "~this",
						"line": 3982,
						"comment": " Cleans up any remaining resources used by this object.\n",
						"deco": "FNbZv",
						"endline": 3997,
						"char": 5,
						"kind": "destructor"
					},
					{
						"endchar": 5,
						"name": "call",
						"line": 4024,
						"comment": "\n\n\n\n Transfers execution to this fiber object.  The calling context will be\n suspended until the fiber calls Fiber.yield() or until it terminates\n via an unhandled exception.\n\n Params:\n  rethrow = Rethrow any unhandled exception which may have caused this\n            fiber to terminate.\n\n In:\n  This fiber must be in state HOLD.\n\n Throws:\n  Any exception not handled by the joined thread.\n\n Returns:\n  Any exception not handled by this fiber if rethrow = false, null\n  otherwise.\n",
						"deco": "FE4core6thread5Fiber7RethrowZC6object9Throwable",
						"parameters": [
							{
								"name": "rethrow",
								"deco": "E4core6thread5Fiber7Rethrow",
								"default": "cast(Rethrow)true"
							}
						],
						"endline": 4027,
						"originalType": "Throwable(Rethrow rethrow = Rethrow.yes)",
						"char": 21,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "call",
								"line": 4030,
								"type": "Throwable()",
								"endline": 4043,
								"char": 21,
								"kind": "function",
								"storageClass": [
									"final"
								]
							}
						],
						"name": "call",
						"line": 4030,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "rethrow",
								"deco": "E4core6thread5Fiber7Rethrow",
								"kind": "value"
							}
						],
						"char": 21,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "call",
						"line": 4047,
						"comment": "ditto\n",
						"deco": "FbZC6object9Throwable",
						"parameters": [
							{
								"name": "rethrow",
								"deco": "b"
							}
						],
						"endline": 4050,
						"char": 21,
						"kind": "function",
						"storageClass": [
							"final",
							"deprecated"
						]
					},
					{
						"members": [],
						"name": "Rethrow",
						"line": 4085,
						"comment": "Flag to control rethrow behavior of $(D $(LREF call))\n",
						"baseDeco": "b",
						"char": 5,
						"kind": "enum"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 4100,
							"deco": "FNbZv",
							"endline": 4100,
							"char": 5,
							"kind": "function"
						},
						"name": "reset",
						"line": 4098,
						"comment": " Resets this fiber so that it may be re-used, optionally with a\n new function/delegate.  This routine should only be called for\n fibers that have terminated, as doing otherwise could result in\n scope-dependent functionality that is not executed.\n Stack-based classes, for example, may not be cleaned up\n properly if a fiber is reset before it has terminated.\n\n In:\n  This fiber must be in state TERM or HOLD.\n",
						"deco": "FNbZv",
						"endline": 4109,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "reset",
						"line": 4112,
						"comment": "ditto\n",
						"deco": "FNbPFZvZv",
						"parameters": [
							{
								"name": "fn",
								"deco": "PFZv"
							}
						],
						"endline": 4117,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "reset",
						"line": 4120,
						"comment": "ditto\n",
						"deco": "FNbDFZvZv",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFZv"
							}
						],
						"endline": 4125,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"members": [
							{
								"name": "HOLD",
								"line": 4141,
								"value": "0",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "EXEC",
								"line": 4142,
								"value": "1",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "TERM",
								"line": 4143,
								"value": "2",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "State",
						"line": 4139,
						"comment": "\n\n\n\n A fiber may occupy one of three states: HOLD, EXEC, and TERM.  The HOLD\n state applies to any fiber that is suspended and ready to be called.\n The EXEC state will be set for any fiber that is currently executing.\n And the TERM state is set when a fiber terminates.  Once a fiber\n terminates, it must be reset before it may be called again.\n",
						"baseDeco": "i",
						"char": 5,
						"kind": "enum"
					},
					{
						"endchar": 5,
						"name": "state",
						"line": 4153,
						"comment": " Gets the current state of this fiber.\n\n Returns:\n  The state of this fiber as an enumerated value.\n",
						"deco": "xFNbNdZE4core6thread5Fiber5State",
						"endline": 4156,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "yield",
						"line": 4167,
						"comment": "\n\n\n\n Forces a context switch to occur away from the calling fiber.\n",
						"deco": "FNbZv",
						"endline": 4179,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "yieldAndThrow",
						"line": 4192,
						"comment": " Forces a context switch to occur away from the calling fiber and then\n throws obj in the calling fiber.\n\n Params:\n  t = The object to throw.\n\n In:\n  t must not be null.\n",
						"deco": "FNbC6object9ThrowableZv",
						"parameters": [
							{
								"name": "t",
								"deco": "C6object9Throwable"
							}
						],
						"endline": 4210,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getThis",
						"line": 4226,
						"comment": "\n\n\n\n Provides a reference to the calling fiber or null if no fiber is\n currently active.\n\n Returns:\n  The fiber object representing the calling fiber or null if no fiber\n  is currently active within this thread. The result of deleting this object is undefined.\n",
						"deco": "FNbZC4core6thread5Fiber",
						"endline": 4229,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"name": "ThreadID",
				"line": 5351,
				"comment": " Represents the ID of a thread, as returned by $(D Thread.)$(LREF id).\n The exact type varies from platform to platform.\n",
				"deco": "m",
				"char": 5,
				"kind": "alias"
			}
		],
		"comment": " The thread module provides support for thread creation and management.\n\n Copyright: Copyright Sean Kelly 2005 - 2012.\n License: Distributed under the\n      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n    (See accompanying file LICENSE)\n Authors:   Sean Kelly, Walter Bright, Alex Rønne Petersen, Martin Nowak\n Source:    $(DRUNTIMESRC core/_thread.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/demangle.d",
		"name": "core.demangle",
		"members": [
			{
				"endchar": 1,
				"name": "demangle",
				"line": 1685,
				"comment": " Demangles D mangled names.  If it is not a D mangled name, it returns its\n argument name.\n\n Params:\n  buf = The string to demangle.\n  dst = An optional destination buffer.\n\n Returns:\n  The demangled name or the original string if the name is not a mangled D\n  name.\n",
				"deco": "FAxaAaZAa",
				"parameters": [
					{
						"name": "buf",
						"deco": "Axa"
					},
					{
						"name": "dst",
						"deco": "Aa",
						"default": "null"
					}
				],
				"endline": 1690,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "demangleType",
				"line": 1704,
				"comment": " Demangles a D mangled type.\n\n Params:\n  buf = The string to demangle.\n  dst = An optional destination buffer.\n\n Returns:\n  The demangled type name or the original string if the name is not a\n  mangled D type.\n",
				"deco": "FAxaAaZAa",
				"parameters": [
					{
						"name": "buf",
						"deco": "Axa"
					},
					{
						"name": "dst",
						"deco": "Aa",
						"default": "null"
					}
				],
				"endline": 1708,
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "mangle",
						"line": 1723,
						"type": "pure nothrow @safe char[](const(char)[] fqn, char[] dst = null)",
						"parameters": [
							{
								"name": "fqn",
								"type": "const(char)[]"
							},
							{
								"name": "dst",
								"type": "char[]",
								"default": "null"
							}
						],
						"endline": 1772,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "mangle",
				"line": 1723,
				"comment": " Mangles a D symbol.\n\n Params:\n  T = The type of the symbol.\n  fqn = The fully qualified name of the symbol.\n  dst = An optional destination buffer.\n\n Returns:\n  The mangled name for a symbols of type T and the given fully\n  qualified name.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1776_286)\n---\nassert(mangle!int(\"a.b\") == \"_D1a1bi\");\nassert(mangle!(char[])(\"test.foo\") == \"_D4test3fooAa\");\nassert(mangle!(int function(int))(\"a.b\") == \"_D1a1bPFiZi\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1776_286)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "mangleFunc",
						"line": 1809,
						"type": "pure nothrow @safe char[](const(char)[] fqn, char[] dst = null)",
						"parameters": [
							{
								"name": "fqn",
								"type": "const(char)[]"
							},
							{
								"name": "dst",
								"type": "char[]",
								"default": "null"
							}
						],
						"endline": 1829,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "mangleFunc",
				"line": 1809,
				"comment": " Mangles a D function.\n\n Params:\n  T = function pointer type.\n  fqn = The fully qualified name of the symbol.\n  dst = An optional destination buffer.\n\n Returns:\n  The mangled name for a function with function pointer type T and\n  the given fully qualified name.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1833_288)\n---\nassert(mangleFunc!(int function(int))(\"a.b\") == \"_D1a1bFiZi\");\nassert(mangleFunc!(int function(Object))(\"object.Object.opEquals\") == \"_D6object6Object8opEqualsFC6ObjectZi\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1833_288)\n",
				"parameters": [
					{
						"name": "T",
						"type": "FT*",
						"kind": "type"
					},
					{
						"name": "FT",
						"kind": "type"
					}
				],
				"constraint": "is(FT == function)",
				"char": 8,
				"kind": "template"
			},
			{
				"name": "cPrefix",
				"line": 1897,
				"comment": " C name mangling is done by adding a prefix on some platforms.\n",
				"deco": "Aya",
				"init": "\"\"",
				"char": 17,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			}
		],
		"comment": " The demangle module converts mangled D symbols to a representation similar\n to what would have existed in code.\n\n Copyright: Copyright Sean Kelly 2010 - 2014.\n License: Distributed under the\n      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n    (See accompanying file LICENSE)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/_demangle.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/runtime.d",
		"name": "core.runtime",
		"members": [
			{
				"name": "rt_loadLibrary",
				"line": 21,
				"comment": "C interface for Runtime.loadLibrary\n",
				"deco": "UxPaZPv",
				"parameters": [
					{
						"name": "name",
						"deco": "xPa"
					}
				],
				"originalType": "extern (C) void*(const char* name)",
				"char": 18,
				"kind": "function"
			},
			{
				"name": "rt_unloadLibrary",
				"line": 25,
				"comment": "C interface for Runtime.unloadLibrary, returns 1/0 instead of bool\n",
				"deco": "UPvZi",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pv"
					}
				],
				"char": 16,
				"kind": "function"
			},
			{
				"name": "rt_init",
				"line": 28,
				"comment": "C interface for Runtime.initialize, returns 1/0 instead of bool\n",
				"deco": "UZi",
				"char": 15,
				"kind": "function"
			},
			{
				"name": "rt_term",
				"line": 30,
				"comment": "C interface for Runtime.terminate, returns 1/0 instead of bool\n",
				"deco": "UZi",
				"char": 15,
				"kind": "function"
			},
			{
				"name": "CArgs",
				"line": 72,
				"comment": "\n\n\n\n Stores the unprocessed arguments supplied when the\n process was started.\n",
				"members": [
					{
						"offset": 0,
						"name": "argc",
						"line": 74,
						"comment": "The argument count.\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "argv",
						"line": 75,
						"comment": "The arguments as a C array of strings.\n",
						"deco": "PPa",
						"char": 12,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "Runtime",
				"line": 82,
				"comment": " This struct encapsulates all functionality related to the underlying runtime\n module for the calling context.\n",
				"members": [
					{
						"endchar": 5,
						"name": "initialize",
						"line": 94,
						"comment": " Initializes the runtime.  This call is to be used in instances where the\n standard program initialization process is not executed.  This is most\n often in shared libraries or in libraries linked to a C program.\n If the runtime was already successfully initialized this returns true.\n Each call to initialize must be paired by a call to $(LREF terminate).\n\n Returns:\n  true if initialization succeeded or false if initialization failed.\n",
						"deco": "FZb",
						"endline": 97,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "terminate",
						"line": 115,
						"comment": " Terminates the runtime.  This call is to be used in instances where the\n standard program termination process will not be not executed.  This is\n most often in shared libraries or in libraries linked to a C program.\n If the runtime was not successfully initialized the function returns false.\n\n Returns:\n  true if termination succeeded or false if termination failed.\n",
						"deco": "FZb",
						"endline": 118,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "args",
						"line": 133,
						"comment": " Returns the arguments supplied when the process was started.\n\n Returns:\n  The arguments supplied when this process was started.\n",
						"deco": "FNdZAAya",
						"endline": 136,
						"char": 31,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "cArgs",
						"line": 159,
						"comment": " Returns the unprocessed C arguments supplied when the process was started.\n Use this when you need to supply argc and argv to C libraries.\n\n Returns:\n  A $(LREF CArgs) struct with the arguments supplied when this process was started.\n\n Example:\n ---\n import core.runtime;\n\n // A C library function requiring char** arguments\n extern(C) void initLibFoo(int argc, char** argv);\n\n void main()\n {\n     auto args = Runtime.cArgs;\n     initLibFoo(args.argc, args.argv);\n }\n ---\n",
						"deco": "FNdNiZS4core7runtime5CArgs",
						"endline": 162,
						"char": 28,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "loadLibrary",
								"line": 175,
								"type": "void*(in char[] name)",
								"parameters": [
									{
										"name": "name",
										"type": "char[]",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 216,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "loadLibrary",
						"line": 175,
						"comment": " Locates a dynamic library with the supplied library name and dynamically\n loads it into the caller's address space.  If the library contains a D\n runtime it will be integrated with the current runtime.\n\n Params:\n  name = The name of the dynamic library to load.\n\n Returns:\n  A reference to the library or null on error.\n",
						"parameters": [],
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "unloadLibrary",
								"line": 227,
								"type": "bool(void* p)",
								"parameters": [
									{
										"name": "p",
										"type": "void*"
									}
								],
								"endline": 230,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "unloadLibrary",
						"line": 227,
						"comment": " Unloads the dynamic library referenced by p.  If this library contains a\n D runtime then any necessary finalization or cleanup of that runtime\n will be performed.\n\n Params:\n  p = A reference to the library to unload.\n",
						"parameters": [],
						"char": 17,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "traceHandler",
						"line": 244,
						"comment": " Overrides the default trace mechanism with a user-supplied version.  A\n trace represents the context from which an exception was thrown, and the\n trace handler will be called when this occurs.  The pointer supplied to\n this routine indicates the base address from which tracing should occur.\n If the supplied pointer is null then the trace routine should determine\n an appropriate calling context from which to begin the trace.\n\n Params:\n  h = The new trace handler.  Set to null to use the default handler.\n",
						"deco": "FNdPFPvZC6object9Throwable9TraceInfoZv",
						"parameters": [
							{
								"name": "h",
								"deco": "PFPvZC6object9Throwable9TraceInfo"
							}
						],
						"endline": 247,
						"originalType": "@property void(TraceHandler h)",
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "traceHandler",
						"line": 255,
						"comment": " Gets the current trace handler.\n\n Returns:\n  The current trace handler or null if none has been set.\n",
						"deco": "FNdZPFPvZC6object9Throwable9TraceInfo",
						"endline": 258,
						"originalType": "@property TraceHandler()",
						"char": 35,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "collectHandler",
						"line": 271,
						"comment": " Overrides the default collect hander with a user-supplied version.  This\n routine will be called for each resource object that is finalized in a\n non-deterministic manner--typically during a garbage collection cycle.\n If the supplied routine returns true then the object's dtor will called\n as normal, but if the routine returns false than the dtor will not be\n called.  The default behavior is for all object dtors to be called.\n\n Params:\n  h = The new collect handler.  Set to null to use the default handler.\n",
						"deco": "FNdPFC6ObjectZbZv",
						"parameters": [
							{
								"name": "h",
								"deco": "PFC6ObjectZb"
							}
						],
						"endline": 274,
						"originalType": "@property void(CollectHandler h)",
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "collectHandler",
						"line": 283,
						"comment": " Gets the current collect handler.\n\n Returns:\n  The current collect handler or null if none has been set.\n",
						"deco": "FNdZPFC6ObjectZb",
						"endline": 286,
						"originalType": "@property CollectHandler()",
						"char": 37,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "moduleUnitTester",
						"line": 298,
						"comment": " Overrides the default module unit tester with a user-supplied version.\n This routine will be called once on program initialization.  The return\n value of this routine indicates to the runtime whether the tests ran\n without error.\n\n Params:\n  h = The new unit tester.  Set to null to use the default unit tester.\n",
						"deco": "FNdPFZbZv",
						"parameters": [
							{
								"name": "h",
								"deco": "PFZb"
							}
						],
						"endline": 301,
						"originalType": "@property void(ModuleUnitTester h)",
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "moduleUnitTester",
						"line": 310,
						"comment": " Gets the current module unit tester.\n\n Returns:\n  The current module unit tester handler or null if none has been set.\n",
						"deco": "FNdZPFZb",
						"endline": 313,
						"originalType": "@property ModuleUnitTester()",
						"char": 39,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "dmd_coverSourcePath",
				"line": 332,
				"comment": " Set source file path for coverage reports.\n\n Params:\n  path = The new path name.\n Note:\n  This is a dmd specific setting.\n",
				"deco": "UAyaZv",
				"parameters": [
					{
						"name": "path",
						"deco": "Aya"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"name": "dmd_coverDestPath",
				"line": 342,
				"comment": " Set output path for coverage reports.\n\n Params:\n  path = The new path name.\n Note:\n  This is a dmd specific setting.\n",
				"deco": "UAyaZv",
				"parameters": [
					{
						"name": "path",
						"deco": "Aya"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"name": "dmd_coverSetMerge",
				"line": 352,
				"comment": " Enable merging of coverage reports with existing data.\n\n Params:\n  flag = enable/disable coverage merge mode\n Note:\n  This is a dmd specific setting.\n",
				"deco": "UbZv",
				"parameters": [
					{
						"name": "flag",
						"deco": "b"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"name": "trace_setlogfilename",
				"line": 363,
				"comment": " Set the output file name for profile reports (-profile switch).\n An empty name will set the output to stdout.\n\n Params:\n  name = file name\n Note:\n  This is a dmd specific setting.\n",
				"deco": "UAyaZv",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"name": "trace_setdeffilename",
				"line": 374,
				"comment": " Set the output file name for the optimized profile linker DEF file (-profile switch).\n An empty name will set the output to stdout.\n\n Params:\n  name = file name\n Note:\n  This is a dmd specific setting.\n",
				"deco": "UAyaZv",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"name": "profilegc_setlogfilename",
				"line": 385,
				"comment": " Set the output file name for memory profile reports (-profile=gc switch).\n An empty name will set the output to stdout.\n\n Params:\n  name = file name\n Note:\n  This is a dmd specific setting.\n",
				"deco": "UAyaZv",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "runModuleUnitTests",
				"line": 401,
				"comment": "\n\n\n\n This routine is called by the runtime to run module unit tests on startup.\n The user-supplied unit tester will be called if one has been supplied,\n otherwise all unit tests will be run in sequence.\n\n Returns:\n  true if execution should continue after testing is complete and false if\n  not.  Default behavior is to return true.\n",
				"deco": "UZb",
				"endline": 472,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "defaultTraceHandler",
				"line": 483,
				"comment": "\n\n\n\n\n",
				"deco": "FPvZC6object9Throwable9TraceInfo",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pv",
						"default": "null"
					}
				],
				"endline": 756,
				"originalType": "Throwable.TraceInfo(void* ptr = null)",
				"char": 21,
				"kind": "function"
			}
		],
		"comment": " The runtime module exposes information specific to the D runtime code.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/_runtime.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/checkedint.d",
		"name": "core.checkedint",
		"members": [
			{
				"endchar": 1,
				"name": "adds",
				"line": 50,
				"comment": " Add two signed integers, checking for overflow.\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the sum\n",
				"deco": "FNaNbNiNfiiKbZi",
				"parameters": [
					{
						"name": "x",
						"deco": "i"
					},
					{
						"name": "y",
						"deco": "i"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 56,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "adds",
				"line": 78,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfllKbZl",
				"parameters": [
					{
						"name": "x",
						"deco": "l"
					},
					{
						"name": "y",
						"deco": "l"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 85,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "addu",
				"line": 120,
				"comment": " Add two unsigned integers, checking for overflow (aka carry).\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the sum\n",
				"deco": "FNaNbNiNfkkKbZk",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					},
					{
						"name": "y",
						"deco": "k"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 126,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "addu",
				"line": 148,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfmmKbZm",
				"parameters": [
					{
						"name": "x",
						"deco": "m"
					},
					{
						"name": "y",
						"deco": "m"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 154,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "subs",
				"line": 189,
				"comment": " Subtract two signed integers, checking for overflow.\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the difference\n",
				"deco": "FNaNbNiNfiiKbZi",
				"parameters": [
					{
						"name": "x",
						"deco": "i"
					},
					{
						"name": "y",
						"deco": "i"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 195,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "subs",
				"line": 217,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfllKbZl",
				"parameters": [
					{
						"name": "x",
						"deco": "l"
					},
					{
						"name": "y",
						"deco": "l"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 224,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "subu",
				"line": 260,
				"comment": " Subtract two unsigned integers, checking for overflow (aka borrow).\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the difference\n",
				"deco": "FNaNbNiNfkkKbZk",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					},
					{
						"name": "y",
						"deco": "k"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 265,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "subu",
				"line": 288,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfmmKbZm",
				"parameters": [
					{
						"name": "x",
						"deco": "m"
					},
					{
						"name": "y",
						"deco": "m"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 293,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "negs",
				"line": 325,
				"comment": " Negate an integer.\n\n Params:\n      x = operand\n      overflow = set if x cannot be negated, is not affected otherwise\n Returns:\n      the negation of x\n",
				"deco": "FNaNbNiNfiKbZi",
				"parameters": [
					{
						"name": "x",
						"deco": "i"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 330,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "negs",
				"line": 349,
				"comment": "ditto\n",
				"deco": "FNaNbNiNflKbZl",
				"parameters": [
					{
						"name": "x",
						"deco": "l"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 354,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "muls",
				"line": 386,
				"comment": " Multiply two signed integers, checking for overflow.\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the product\n",
				"deco": "FNaNbNiNfiiKbZi",
				"parameters": [
					{
						"name": "x",
						"deco": "i"
					},
					{
						"name": "y",
						"deco": "i"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 392,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "muls",
				"line": 416,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfllKbZl",
				"parameters": [
					{
						"name": "x",
						"deco": "l"
					},
					{
						"name": "y",
						"deco": "l"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 423,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "mulu",
				"line": 463,
				"comment": " Multiply two unsigned integers, checking for overflow (aka carry).\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the product\n",
				"deco": "FNaNbNiNfkkKbZk",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					},
					{
						"name": "y",
						"deco": "k"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 469,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "mulu",
				"line": 493,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfmmKbZm",
				"parameters": [
					{
						"name": "x",
						"deco": "m"
					},
					{
						"name": "y",
						"deco": "m"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 499,
				"char": 7,
				"kind": "function"
			}
		],
		"comment": " This module implements integral arithmetic primitives that check\n for out-of-range results.\n\n Integral arithmetic operators operate on fixed width types.\n Results that are not representable in those fixed widths are silently\n truncated to fit.\n This module offers integral arithmetic primitives that produce the\n same results, but set an 'overflow' flag when such truncation occurs.\n The setting is sticky, meaning that numerous operations can be cascaded\n and then the flag need only be checked at the end.\n Whether the operation is signed or unsigned is indicated by an 's' or 'u'\n suffix, respectively. While this could be achieved without such suffixes by\n using overloading on the signedness of the types, the suffix makes it clear\n which is happening without needing to examine the types.\n\n While the generic versions of these functions are computationally expensive\n relative to the cost of the operation itself, compiler implementations are free\n to recognize them and generate equivalent and faster code.\n\n References: $(LINK2 http://blog.regehr.org/archives/1139, Fast Integer Overflow Checks)\n Copyright: Copyright (c) Walter Bright 2014.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Walter Bright\n Source:    $(DRUNTIMESRC core/_checkedint.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/bitop.d",
		"name": "core.bitop",
		"members": [
			{
				"name": "bsf",
				"line": 33,
				"comment": " Scans the bits in v starting with bit 0, looking\n for the first set bit.\n Returns:\n      The bit number of the first bit set.\n      The return value is undefined if v is zero.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL36_308)\n---\nassert(bsf(0x21) == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL36_308)\n",
				"deco": "FNaNbNiNfmZi",
				"parameters": [
					{
						"name": "v",
						"deco": "m"
					}
				],
				"originalType": "pure nothrow @nogc @safe int(size_t v)",
				"char": 5,
				"kind": "function"
			},
			{
				"name": "bsr",
				"line": 49,
				"comment": " Scans the bits in v from the most significant bit\n to the least significant bit, looking\n for the first set bit.\n Returns:\n      The bit number of the first bit set.\n      The return value is undefined if v is zero.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL52_309)\n---\nassert(bsr(0x21) == 5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL52_309)\n",
				"deco": "FNaNbNiNfmZi",
				"parameters": [
					{
						"name": "v",
						"deco": "m"
					}
				],
				"originalType": "pure nothrow @nogc @safe int(size_t v)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "bt",
				"line": 62,
				"comment": " Tests the bit.\n (No longer an intrisic - the compiler recognizes the patterns\n in the body.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL72_310)\n---\nsize_t[2] array;\n\narray[0] = 2;\narray[1] = 0x100;\n\nassert(bt(array.ptr, 1));\nassert(array[0] == 2);\nassert(array[1] == 0x100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL72_310)\n",
				"deco": "FNaNbNixPmmZi",
				"parameters": [
					{
						"name": "p",
						"deco": "xPm"
					},
					{
						"name": "bitnum",
						"deco": "m"
					}
				],
				"endline": 70,
				"originalType": "pure nothrow @nogc @system int(in size_t* p, size_t bitnum)",
				"char": 5,
				"kind": "function"
			},
			{
				"name": "btc",
				"line": 87,
				"comment": " Tests and complements the bit.\n",
				"deco": "FNaNbNiPmmZi",
				"parameters": [
					{
						"name": "p",
						"deco": "Pm"
					},
					{
						"name": "bitnum",
						"deco": "m"
					}
				],
				"originalType": "pure nothrow @nogc @system int(size_t* p, size_t bitnum)",
				"char": 5,
				"kind": "function"
			},
			{
				"name": "btr",
				"line": 93,
				"comment": " Tests and resets (sets to 0) the bit.\n",
				"deco": "FNaNbNiPmmZi",
				"parameters": [
					{
						"name": "p",
						"deco": "Pm"
					},
					{
						"name": "bitnum",
						"deco": "m"
					}
				],
				"originalType": "pure nothrow @nogc @system int(size_t* p, size_t bitnum)",
				"char": 5,
				"kind": "function"
			},
			{
				"name": "bts",
				"line": 109,
				"comment": " Tests and sets the bit.\n Params:\n p = a non-NULL pointer to an array of size_ts.\n bitnum = a bit number, starting with bit 0 of p[0],\n and progressing. It addresses bits like the expression:\n---\np[index / (size_t.sizeof*8)] & (1 << (index & ((size_t.sizeof*8) - 1)))\n---\n Returns:\n      A non-zero value if the bit was set, and a zero\n      if it was clear.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL112_311)\n---\nsize_t[2] array;\n\narray[0] = 2;\narray[1] = 0x100;\n\nassert(btc(array.ptr, 35) == 0);\nif (size_t.sizeof == 8)\n{\n    assert(array[0] == 0x8_0000_0002);\n    assert(array[1] == 0x100);\n}\nelse\n{\n    assert(array[0] == 2);\n    assert(array[1] == 0x108);\n}\n\nassert(btc(array.ptr, 35));\nassert(array[0] == 2);\nassert(array[1] == 0x100);\n\nassert(bts(array.ptr, 35) == 0);\nif (size_t.sizeof == 8)\n{\n    assert(array[0] == 0x8_0000_0002);\n    assert(array[1] == 0x100);\n}\nelse\n{\n    assert(array[0] == 2);\n    assert(array[1] == 0x108);\n}\n\nassert(btr(array.ptr, 35));\nassert(array[0] == 2);\nassert(array[1] == 0x100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL112_311)\n",
				"deco": "FNaNbNiPmmZi",
				"parameters": [
					{
						"name": "p",
						"deco": "Pm"
					},
					{
						"name": "bitnum",
						"deco": "m"
					}
				],
				"originalType": "pure nothrow @nogc @system int(size_t* p, size_t bitnum)",
				"char": 5,
				"kind": "function"
			},
			{
				"name": "bswap",
				"line": 157,
				"comment": " Swaps bytes in a 4 byte uint end-to-end, i.e. byte 0 becomes\n byte 3, byte 1 becomes byte 2, byte 2 becomes byte 1, byte 3\n becomes byte 0.\n",
				"deco": "FNaNbNiNfkZk",
				"parameters": [
					{
						"name": "v",
						"deco": "k"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "inp",
				"line": 164,
				"comment": " Reads I/O port at port_address.\n",
				"deco": "FNbNikZh",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					}
				],
				"char": 11,
				"kind": "function"
			},
			{
				"name": "inpw",
				"line": 170,
				"comment": " ditto\n",
				"deco": "FNbNikZt",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					}
				],
				"char": 12,
				"kind": "function"
			},
			{
				"name": "inpl",
				"line": 176,
				"comment": " ditto\n",
				"deco": "FNbNikZk",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					}
				],
				"char": 10,
				"kind": "function"
			},
			{
				"name": "outp",
				"line": 182,
				"comment": " Writes and returns value to I/O port at port_address.\n",
				"deco": "FNbNikhZh",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					},
					{
						"name": "value",
						"deco": "h"
					}
				],
				"char": 11,
				"kind": "function"
			},
			{
				"name": "outpw",
				"line": 188,
				"comment": " ditto\n",
				"deco": "FNbNiktZt",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					},
					{
						"name": "value",
						"deco": "t"
					}
				],
				"char": 12,
				"kind": "function"
			},
			{
				"name": "outpl",
				"line": 194,
				"comment": " ditto\n",
				"deco": "FNbNikkZk",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					},
					{
						"name": "value",
						"deco": "k"
					}
				],
				"char": 10,
				"kind": "function"
			},
			{
				"name": "_popcnt",
				"line": 204,
				"comment": " Calculates the number of set bits in a 32-bit integer\n using the X86 SSE4 POPCNT instruction.\n POPCNT is not available on all X86 CPUs.\n",
				"deco": "FNaNbNiNftZt",
				"parameters": [
					{
						"name": "x",
						"deco": "t"
					}
				],
				"char": 12,
				"kind": "function"
			},
			{
				"name": "_popcnt",
				"line": 206,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfkZi",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					}
				],
				"char": 9,
				"kind": "function"
			},
			{
				"name": "_popcnt",
				"line": 210,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfmZi",
				"parameters": [
					{
						"name": "x",
						"deco": "m"
					}
				],
				"char": 13,
				"kind": "function"
			},
			{
				"name": "volatileLoad",
				"line": 279,
				"comment": " Read/write value from/to the memory location indicated by ptr.\n\n These functions are recognized by the compiler, and calls to them are guaranteed\n to not be removed (as dead assignment elimination or presumed to have no effect)\n or reordered in the same thread.\n\n These reordering guarantees are only made with regards to other\n operations done through these functions; the compiler is free to reorder regular\n loads/stores with regards to loads/stores done through these functions.\n\n This is useful when dealing with memory-mapped I/O (MMIO) where a store can\n have an effect other than just writing a value, or where sequential loads\n with no intervening stores can retrieve\n different values from the same location due to external stores to the location.\n\n These functions will, when possible, do the load/store as a single operation. In\n general, this is possible when the size of the operation is less than or equal to\n $(D (void*).sizeof), although some targets may support larger operations. If the\n load/store cannot be done as a single operation, multiple smaller operations will be used.\n\n These are not to be conflated with atomic operations. They do not guarantee any\n atomicity. This may be provided by coincidence as a result of the instructions\n used on the target, but this should not be relied on for portable programs.\n Further, no memory fences are implied by these functions.\n They should not be used for communication between threads.\n They may be used to guarantee a write or read cycle occurs at a specified address.\n",
				"deco": "FNbNiNfPhZh",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Ph"
					}
				],
				"char": 8,
				"kind": "function"
			},
			{
				"name": "volatileLoad",
				"line": 280,
				"comment": "ditto\n",
				"deco": "FNbNiNfPtZt",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pt"
					}
				],
				"char": 8,
				"kind": "function"
			},
			{
				"name": "volatileLoad",
				"line": 281,
				"comment": "ditto\n",
				"deco": "FNbNiNfPkZk",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pk"
					}
				],
				"char": 8,
				"kind": "function"
			},
			{
				"name": "volatileLoad",
				"line": 282,
				"comment": "ditto\n",
				"deco": "FNbNiNfPmZm",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pm"
					}
				],
				"char": 8,
				"kind": "function"
			},
			{
				"name": "volatileStore",
				"line": 284,
				"comment": "ditto\n",
				"deco": "FNbNiNfPhhZv",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Ph"
					},
					{
						"name": "value",
						"deco": "h"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "volatileStore",
				"line": 285,
				"comment": "ditto\n",
				"deco": "FNbNiNfPttZv",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pt"
					},
					{
						"name": "value",
						"deco": "t"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "volatileStore",
				"line": 286,
				"comment": "ditto\n",
				"deco": "FNbNiNfPkkZv",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pk"
					},
					{
						"name": "value",
						"deco": "k"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "volatileStore",
				"line": 287,
				"comment": "ditto\n",
				"deco": "FNbNiNfPmmZv",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pm"
					},
					{
						"name": "value",
						"deco": "m"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "popcnt",
				"line": 307,
				"comment": "  Calculates the number of set bits in a 32-bit integer.\n",
				"deco": "FNaNbNiNfkZi",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					}
				],
				"endline": 336,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "bitswap",
				"line": 354,
				"comment": " Reverses the order of bits in a 32-bit integer.\n",
				"deco": "FNaNbNiNekZk",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					}
				],
				"endline": 408,
				"char": 15,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "bitswap",
				"line": 421,
				"comment": " Reverses the order of bits in a 64-bit integer.\n",
				"deco": "FNaNbNiNemZm",
				"parameters": [
					{
						"name": "x",
						"deco": "m"
					}
				],
				"endline": 478,
				"char": 7,
				"kind": "function"
			}
		],
		"comment": " This module contains a collection of bit-level operations.\n\n Copyright: Copyright Don Clugston 2005 - 2013.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Don Clugston, Sean Kelly, Walter Bright, Alex Rønne Petersen\n Source:    $(DRUNTIMESRC core/_bitop.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/time.d",
		"name": "core.time",
		"members": [
			{
				"members": [
					{
						"name": "normal",
						"line": 156,
						"value": "0",
						"comment": "        Use the normal clock.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bootTime",
						"line": 163,
						"value": "1",
						"comment": "        $(BLUE Linux-Only)\n\n        Uses $(D CLOCK_BOOTTIME).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "coarse",
						"line": 193,
						"value": "2",
						"comment": "        Use the coarse clock, not the normal one (e.g. on Linux, that would be\n        $(D CLOCK_REALTIME_COARSE) instead of $(D CLOCK_REALTIME) for\n        $(D clock_gettime) if a function is using the realtime clock). It's\n        generally faster to get the time with the coarse clock than the normal\n        clock, but it's less precise (e.g. 1 msec instead of 1 usec or 1 nsec).\n        Howeover, it $(I is) guaranteed to still have sub-second precision\n        (just not as high as with $(D ClockType.normal)).\n\n        On systems which do not support a coarser clock,\n        $(D MonoTimeImpl!(ClockType.coarse)) will internally use the same clock\n        as $(D Monotime) does, and $(D Clock.currTime!(ClockType.coarse)) will\n        use the same clock as $(D Clock.currTime). This is because the coarse\n        clock is doing the same thing as the normal clock (just at lower\n        precision), whereas some of the other clock types\n        (e.g. $(D ClockType.processCPUTime)) mean something fundamentally\n        different. So, treating those as $(D ClockType.normal) on systems where\n        they weren't natively supported would give misleading results.\n\n        Most programs should not use the coarse clock, exactly because it's\n        less precise, and most programs don't need to get the time often\n        enough to care, but for those rare programs that need to get the time\n        extremely frequently (e.g. hundreds of thousands of times a second) but\n        don't care about high precision, the coarse clock might be appropriate.\n\n        Currently, only Linux and FreeBSD support a coarser clock, and on other\n        platforms, it's treated as $(D ClockType.normal).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "precise",
						"line": 206,
						"value": "3",
						"comment": "        Uses a more precise clock than the normal one (which is already very\n        precise), but it takes longer to get the time. Similarly to\n        $(D ClockType.coarse), if it's used on a system that does not support a\n        more precise clock than the normal one, it's treated as equivalent to\n        $(D ClockType.normal).\n\n        Currently, only FreeBSD supports a more precise clock, where it uses\n        $(D CLOCK_MONOTONIC_PRECISE) for the monotonic time and\n        $(D CLOCK_REALTIME_PRECISE) for the wall clock time.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "processCPUTime",
						"line": 213,
						"value": "4",
						"comment": "        $(BLUE Linux,Solaris-Only)\n\n        Uses $(D CLOCK_PROCESS_CPUTIME_ID).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "raw",
						"line": 220,
						"value": "5",
						"comment": "        $(BLUE Linux-Only)\n\n        Uses $(D CLOCK_MONOTONIC_RAW).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "second",
						"line": 243,
						"value": "6",
						"comment": "        Uses a clock that has a precision of one second (contrast to the coarse\n        clock, which has sub-second precision like the normal clock does).\n\n        FreeBSD is the only system which specifically has a clock set up for\n        this (it has $(D CLOCK_SECOND) to use with $(D clock_gettime) which\n        takes advantage of an in-kernel cached value), but on other systems, the\n        fastest function available will be used, and the resulting $(D SysTime)\n        will be rounded down to the second if the clock that was used gave the\n        time at a more precise resolution. So, it's guaranteed that the time\n        will be given at a precision of one second and it's likely the case that\n        will be faster than $(D ClockType.normal), since there tend to be\n        several options on a system to get the time at low resolutions, and they\n        tend to be faster than getting the time at high resolutions.\n\n        So, the primary difference between $(D ClockType.coarse) and\n        $(D ClockType.second) is that $(D ClockType.coarse) sacrifices some\n        precision in order to get speed but is still fairly precise, whereas\n        $(D ClockType.second) tries to be as fast as possible at the expense of\n        all sub-second precision.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "threadCPUTime",
						"line": 250,
						"value": "7",
						"comment": "        $(BLUE Linux,Solaris-Only)\n\n        Uses $(D CLOCK_THREAD_CPUTIME_ID).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "uptime",
						"line": 257,
						"value": "8",
						"comment": "        $(BLUE FreeBSD-Only)\n\n        Uses $(D CLOCK_UPTIME).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "uptimeCoarse",
						"line": 264,
						"value": "9",
						"comment": "        $(BLUE FreeBSD-Only)\n\n        Uses $(D CLOCK_UPTIME_FAST).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "uptimePrecise",
						"line": 271,
						"value": "10",
						"comment": "        $(BLUE FreeBSD-Only)\n\n        Uses $(D CLOCK_UPTIME_PRECISE).\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "ClockType",
				"line": 151,
				"comment": "    What type of clock to use with $(LREF MonoTime) / $(LREF MonoTimeImpl) or\n    $(D std.datetime.Clock.currTime). They default to $(D ClockType.normal),\n    and most programs do not need to ever deal with the others.\n\n    The other $(D ClockType)s are provided so that other clocks provided by the\n    underlying C, system calls can be used with $(LREF MonoTimeImpl) or\n    $(D std.datetime.Clock.currTime) without having to use the C API directly.\n\n    In the case of the monotonic time, $(LREF MonoTimeImpl) is templatized on\n    $(D ClockType), whereas with $(D std.datetime.Clock.currTime), its a runtime\n    argument, since in the case of the monotonic time, the type of the clock\n    affects the resolution of a $(LREF MonoTimeImpl) object, whereas with\n    $(XREF datetime, SysTime), its resolution is always hecto-nanoseconds\n    regardless of the source of the time.\n\n    $(D ClockType.normal), $(D ClockType.coarse), and $(D ClockType.precise)\n    work with both $(D Clock.currTime) and $(LREF MonoTimeImpl).\n    $(D ClockType.second) only works with $(D Clock.currTime). The others only\n    work with $(LREF MonoTimeImpl).\n",
				"baseDeco": "i",
				"char": 19,
				"kind": "enum"
			},
			{
				"name": "Duration",
				"line": 439,
				"comment": "    Represents a duration of time of weeks or less (kept internally as hnsecs).\n    (e.g. 22 days or 700 seconds).\n\n    It is used when representing a duration of time - such as how long to\n    sleep with $(CXREF thread, Thread.sleep).\n\n    In std.datetime, it is also used as the result of various arithmetic\n    operations on time points.\n\n    Use the $(LREF dur) function or one of its non-generic aliases to create\n    $(D Duration)s.\n\n    It's not possible to create a Duration of months or years, because the\n    variable number of days in a month or year makes it impossible to convert\n    between months or years and smaller units without a specific date. So,\n    nothing uses $(D Duration)s when dealing with months or years. Rather,\n    functions specific to months and years are defined. For instance,\n    $(XREF datetime, Date) has $(D add!\"years\") and $(D add!\"months\") for adding\n    years and months rather than creating a Duration of years or months and\n    adding that to a $(XREF datetime, Date). But Duration is used when dealing\n    with weeks or smaller.\n\n    Examples:\n--------------------\nassert(dur!\"days\"(12) == dur!\"hnsecs\"(10_368_000_000_000L));\nassert(dur!\"hnsecs\"(27) == dur!\"hnsecs\"(27));\nassert(std.datetime.Date(2010, 9, 7) + dur!\"days\"(5) ==\n       std.datetime.Date(2010, 9, 12));\n\nassert(days(-12) == dur!\"hnsecs\"(-10_368_000_000_000L));\nassert(hnsecs(-27) == dur!\"hnsecs\"(-27));\nassert(std.datetime.Date(2010, 9, 7) - std.datetime.Date(2010, 10, 3) ==\n       days(-26));\n--------------------\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1862_352)\n---\nimport core.time;\n\n// using the dur template\nauto numDays = dur!\"days\"(12);\n\n// using the days function\nnumDays = days(12);\n\n// alternatively using UFCS syntax\nnumDays = 12.days;\n\nauto myTime = 100.msecs + 20_000.usecs + 30_000.hnsecs;\nassert(myTime == 123.msecs);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1862_352)\n",
				"members": [
					{
						"endchar": 74,
						"name": "zero",
						"line": 449,
						"comment": "        A $(D Duration) of $(D 0). It's shorter than doing something like\n        $(D dur!\"seconds\"(0)) and more explicit than $(D Duration.init).\n",
						"deco": "FNaNbNdNiNfZS4core4time8Duration",
						"endline": 449,
						"char": 45,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 80,
						"name": "max",
						"line": 454,
						"comment": "        Largest $(D Duration) possible.\n",
						"deco": "FNaNbNdNiNfZS4core4time8Duration",
						"endline": 454,
						"char": 45,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 80,
						"name": "min",
						"line": 459,
						"comment": "        Most negative $(D Duration) possible.\n",
						"deco": "FNaNbNdNiNfZS4core4time8Duration",
						"endline": 459,
						"char": 45,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 484,
						"comment": "        Compares this $(D Duration) with the given $(D Duration).\n\n        Returns:\n            $(TABLE\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
						"deco": "xFNaNbNiNfS4core4time8DurationZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 491,
						"char": 9,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 558,
								"type": "const nothrow @nogc Duration(D rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "D"
									}
								],
								"endline": 566,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 558,
						"comment": "        Adds, subtracts or calculates the modulo of two durations.\n\n        The legal types of arithmetic for $(D Duration) using this operator are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD +) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD -) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD %) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD +) $(TD TickDuration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD -) $(TD TickDuration) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            rhs = The duration to add to or subtract from this $(D Duration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\" || op == \"%\") && is(_Unqual!D == Duration) || (op == \"+\" || op == \"-\") && is(_Unqual!D == TickDuration)",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 643,
								"type": "const nothrow @nogc Duration(D lhs)",
								"parameters": [
									{
										"name": "lhs",
										"type": "D"
									}
								],
								"endline": 648,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinaryRight",
						"line": 643,
						"comment": "        Adds or subtracts two durations.\n\n        The legal types of arithmetic for $(D Duration) using this operator are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD +) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD TickDuration) $(TD -) $(TD Duration) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            lhs = The $(D TickDuration) to add to this $(D Duration) or to\n                  subtract this $(D Duration) from.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && is(_Unqual!D == TickDuration)",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 697,
								"type": "nothrow @nogc ref Duration(in D rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 706,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 697,
						"comment": "        Adds, subtracts or calculates the modulo of two durations as well as\n        assigning the result to this $(D Duration).\n\n        The legal types of arithmetic for $(D Duration) using this operator are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD +) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD -) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD %) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD +) $(TD TickDuration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD -) $(TD TickDuration) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            rhs = The duration to add to or subtract from this $(D Duration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\" || op == \"%\") && is(_Unqual!D == Duration) || (op == \"+\" || op == \"-\") && is(_Unqual!D == TickDuration)",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 807,
								"type": "const nothrow @nogc Duration(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 811,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 807,
						"comment": "        Multiplies or divides the duration by an integer value.\n\n        The legal types of arithmetic for $(D Duration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD *) $(TD long) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD /) $(TD long) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            value = The value to multiply this $(D Duration) by.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"*\" || op == \"/\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 868,
								"type": "nothrow @nogc ref Duration(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 873,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 868,
						"comment": "        Multiplies/Divides the duration by an integer value as well as\n        assigning the result to this $(D Duration).\n\n        The legal types of arithmetic for $(D Duration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD *) $(TD long) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD /) $(TD long) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            value = The value to multiply/divide this $(D Duration) by.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"*\" || op == \"/\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 949,
								"type": "const nothrow @nogc long(Duration rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Duration"
									}
								],
								"endline": 953,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 949,
						"comment": "        Divides two durations.\n\n        The legal types of arithmetic for $(D Duration) using this operator are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD /) $(TD Duration) $(TD -->) $(TD long))\n        )\n\n        Params:\n            rhs = The duration to divide this $(D Duration) by.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"/\"",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 988,
								"type": "const nothrow @nogc Duration(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 992,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinaryRight",
						"line": 988,
						"comment": "        Multiplies an integral value and a $(D Duration).\n\n        The legal types of arithmetic for $(D Duration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD long) $(TD *) $(TD Duration) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            value = The number of units to multiply this $(D Duration) by.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"*\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 1019,
								"type": "const nothrow @nogc Duration()",
								"endline": 1023,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 1019,
						"comment": "        Returns the negation of this $(D Duration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 1045,
								"type": "const nothrow @nogc TickDuration()",
								"endline": 1049,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 1045,
						"comment": "        Returns a $(LREF TickDuration) with the same number of hnsecs as this\n        $(D Duration).\n        Note that the conventional way to convert between $(D Duration) and\n        $(D TickDuration) is using $(XREF conv, to), e.g.:\n        $(D duration.to!TickDuration())\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(_Unqual!T == TickDuration)",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"members": [
									{
										"endchar": 9,
										"name": "split",
										"line": 1128,
										"type": "const nothrow @nogc void(out Args args)",
										"parameters": [
											{
												"name": "args",
												"type": "Args",
												"storageClass": [
													"out"
												]
											}
										],
										"endline": 1139,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "split",
								"line": 1128,
								"comment": " Ditto\n",
								"parameters": [
									{
										"name": "Args",
										"kind": "tuple"
									}
								],
								"constraint": "units.length != 0 && args.length == units.length && allAreMutableIntegralTypes!Args",
								"char": 14,
								"kind": "template"
							},
							{
								"endchar": 9,
								"name": "split",
								"line": 1142,
								"comment": " Ditto\n",
								"type": "const nothrow @nogc ()",
								"endline": 1184,
								"char": 14,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "split",
						"line": 1122,
						"comment": "        Splits out the Duration into the given units.\n\n        split takes the list of time units to split out as template arguments.\n        The time unit strings must be given in decreasing order. How it returns\n        the values for those units depends on the overload used.\n\n        The overload which accepts function arguments takes integral types in\n        the order that the time unit strings were given, and those integers are\n        passed by $(D ref). split assigns the values for the units to each\n        corresponding integer. Any integral type may be used, but no attempt is\n        made to prevent integer overflow, so don't use small integral types in\n        circumstances where the values for those units aren't likely to fit in\n        an integral type that small.\n\n        The overload with no arguments returns the values for the units in a\n        struct with members whose names are the same as the given time unit\n        strings. The members are all $(D long)s. This overload will also work\n        with no time strings being given, in which case $(I all) of the time\n        units from weeks through hnsecs will be provided (but no nsecs, since it\n        would always be $(D 0)).\n\n        For both overloads, the entire value of the Duration is split among the\n        units (rather than splitting the Duration across all units and then only\n        providing the values for the requested units), so if only one unit is\n        given, the result is equivalent to $(LREF total).\n\n        $(D \"nsecs\") is accepted by split, but $(D \"years\") and $(D \"months\")\n        are not.\n\n        For negative durations, all of the split values will be negative.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1223_332)\n---\n{\n    auto d = dur!\"days\"(12) + dur!\"minutes\"(7) + dur!\"usecs\"(501223);\n    long days;\n    int seconds;\n    short msecs;\n    d.split!(\"days\", \"seconds\", \"msecs\")(days, seconds, msecs);\n    assert(days == 12);\n    assert(seconds == 7 * 60);\n    assert(msecs == 501);\n\n    auto splitStruct = d.split!(\"days\", \"seconds\", \"msecs\")();\n    assert(splitStruct.days == 12);\n    assert(splitStruct.seconds == 7 * 60);\n    assert(splitStruct.msecs == 501);\n\n    auto fullSplitStruct = d.split();\n    assert(fullSplitStruct.weeks == 1);\n    assert(fullSplitStruct.days == 5);\n    assert(fullSplitStruct.hours == 0);\n    assert(fullSplitStruct.minutes == 7);\n    assert(fullSplitStruct.seconds == 0);\n    assert(fullSplitStruct.msecs == 501);\n    assert(fullSplitStruct.usecs == 223);\n    assert(fullSplitStruct.hnsecs == 0);\n\n    assert(d.split!\"minutes\"().minutes == d.total!\"minutes\");\n}\n\n{\n    auto d = dur!\"days\"(12);\n    assert(d.split!\"weeks\"().weeks == 1);\n    assert(d.split!\"days\"().days == 12);\n\n    assert(d.split().weeks == 1);\n    assert(d.split().days == 5);\n}\n\n{\n    auto d = dur!\"days\"(7) + dur!\"hnsecs\"(42);\n    assert(d.split!(\"seconds\", \"nsecs\")().nsecs == 4200);\n}\n\n{\n    auto d = dur!\"days\"(-7) + dur!\"hours\"(-9);\n    auto result = d.split!(\"days\", \"hours\")();\n    assert(result.days == -7);\n    assert(result.hours == -9);\n}\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1223_332)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1434_334)\n---\nassert(dur!\"weeks\"(12).get!\"weeks\" == 12);\nassert(dur!\"weeks\"(12).get!\"days\" == 0);\n\nassert(dur!\"days\"(13).get!\"weeks\" == 1);\nassert(dur!\"days\"(13).get!\"days\" == 6);\n\nassert(dur!\"hours\"(49).get!\"days\" == 2);\nassert(dur!\"hours\"(49).get!\"hours\" == 1);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1434_334)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1470_336)\n---\nassert(dur!\"weeks\"(12).weeks == 12);\nassert(dur!\"days\"(13).weeks == 1);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1470_336)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1494_338)\n---\nassert(dur!\"weeks\"(12).days == 0);\nassert(dur!\"days\"(13).days == 6);\nassert(dur!\"hours\"(49).days == 2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1494_338)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1520_340)\n---\nassert(dur!\"days\"(8).hours == 0);\nassert(dur!\"hours\"(49).hours == 1);\nassert(dur!\"minutes\"(121).hours == 2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1520_340)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1546_342)\n---\nassert(dur!\"hours\"(47).minutes == 0);\nassert(dur!\"minutes\"(127).minutes == 7);\nassert(dur!\"seconds\"(121).minutes == 2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1546_342)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1572_344)\n---\nassert(dur!\"minutes\"(47).seconds == 0);\nassert(dur!\"seconds\"(127).seconds == 7);\nassert(dur!\"msecs\"(1217).seconds == 1);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1572_344)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1605_346)\n---\nassert(dur!\"msecs\"(1000).fracSec == FracSec.from!\"msecs\"(0));\nassert(dur!\"msecs\"(1217).fracSec == FracSec.from!\"msecs\"(217));\nassert(dur!\"usecs\"(43).fracSec == FracSec.from!\"usecs\"(43));\nassert(dur!\"hnsecs\"(50_007).fracSec == FracSec.from!\"hnsecs\"(50_007));\nassert(dur!\"nsecs\"(62_127).fracSec == FracSec.from!\"nsecs\"(62_100));\n\nassert(dur!\"msecs\"(-1000).fracSec == FracSec.from!\"msecs\"(-0));\nassert(dur!\"msecs\"(-1217).fracSec == FracSec.from!\"msecs\"(-217));\nassert(dur!\"usecs\"(-43).fracSec == FracSec.from!\"usecs\"(-43));\nassert(dur!\"hnsecs\"(-50_007).fracSec == FracSec.from!\"hnsecs\"(-50_007));\nassert(dur!\"nsecs\"(-62_127).fracSec == FracSec.from!\"nsecs\"(-62_100));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1605_346)\n",
						"parameters": [
							{
								"name": "units",
								"kind": "tuple"
							}
						],
						"constraint": "allAreAcceptedUnits!(\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"msecs\", \"usecs\", \"hnsecs\", \"nsecs\")(units) && unitsAreInDescendingOrder(units)",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "total",
								"line": 1643,
								"type": "const nothrow @nogc @property long()",
								"endline": 1658,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "total",
						"line": 1643,
						"comment": "        Returns the total number of the given units in this $(D Duration).\n        So, unlike $(D split), it does not strip out the larger units.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1661_348)\n---\nassert(dur!\"weeks\"(12).total!\"weeks\" == 12);\nassert(dur!\"weeks\"(12).total!\"days\" == 84);\n\nassert(dur!\"days\"(13).total!\"weeks\" == 1);\nassert(dur!\"days\"(13).total!\"days\" == 13);\n\nassert(dur!\"hours\"(49).total!\"days\" == 2);\nassert(dur!\"hours\"(49).total!\"hours\" == 49);\n\nassert(dur!\"nsecs\"(2007).total!\"hnsecs\" == 20);\nassert(dur!\"nsecs\"(2007).total!\"nsecs\" == 2000);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1661_348)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"weeks\" || units == \"days\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\" || units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\" || units == \"nsecs\"",
						"char": 20,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1713,
						"comment": "        Converts this $(D Duration) to a $(D string).\n",
						"deco": "xFNaNbNfZAya",
						"endline": 1716,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isNegative",
						"line": 1771,
						"comment": "        Returns whether this $(D Duration) is negative.\n",
						"deco": "xFNaNbNdNiNfZb",
						"endline": 1774,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "to",
						"line": 1891,
						"type": "pure nothrow @nogc @safe T(D td)",
						"parameters": [
							{
								"name": "td",
								"type": "D"
							}
						],
						"endline": 1919,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "to",
				"line": 1891,
				"comment": "    Converts a $(D TickDuration) to the given units as either an integral\n    value or a floating point value.\n\n    Params:\n        units = The units to convert to. Accepts $(D \"seconds\") and smaller\n                only.\n        T     = The type to convert to (either an integral type or a\n                floating point type).\n\n        td    = The TickDuration to convert\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1922_353)\n---\nauto t = TickDuration.from!\"seconds\"(1000);\n\nlong tl = to!(\"seconds\",long)(t);\nassert(tl == 1000);\n\ndouble td = to!(\"seconds\",double)(t);\nassert(_abs(td - 1000) < 0.001);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1922_353)\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "D",
						"kind": "type"
					}
				],
				"constraint": "is(_Unqual!D == TickDuration) && (units == \"seconds\" || units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\" || units == \"nsecs\")",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dur",
						"line": 2024,
						"type": "pure nothrow @nogc @safe Duration(long length)",
						"parameters": [
							{
								"name": "length",
								"deco": "l"
							}
						],
						"endline": 2036,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "dur",
				"line": 2024,
				"comment": "    These allow you to construct a $(D Duration) from the given time units\n    with the given length.\n\n    You can either use the generic function $(D dur) and give it the units as\n    a $(D string) or use the named aliases.\n\n    The possible values for units are $(D \"weeks\"), $(D \"days\"), $(D \"hours\"),\n    $(D \"minutes\"), $(D \"seconds\"), $(D \"msecs\") (milliseconds), $(D \"usecs\"),\n    (microseconds), $(D \"hnsecs\") (hecto-nanoseconds, i.e. 100 ns), and\n    $(D \"nsecs\").\n\n    Params:\n        units  = The time units of the $(D Duration) (e.g. $(D \"days\")).\n        length = The number of units in the $(D Duration).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2049_355)\n---\n// Generic\nassert(dur!\"weeks\"(142).total!\"weeks\" == 142);\nassert(dur!\"days\"(142).total!\"days\" == 142);\nassert(dur!\"hours\"(142).total!\"hours\" == 142);\nassert(dur!\"minutes\"(142).total!\"minutes\" == 142);\nassert(dur!\"seconds\"(142).total!\"seconds\" == 142);\nassert(dur!\"msecs\"(142).total!\"msecs\" == 142);\nassert(dur!\"usecs\"(142).total!\"usecs\" == 142);\nassert(dur!\"hnsecs\"(142).total!\"hnsecs\" == 142);\nassert(dur!\"nsecs\"(142).total!\"nsecs\" == 100);\n\n// Non-generic\nassert(weeks(142).total!\"weeks\" == 142);\nassert(days(142).total!\"days\" == 142);\nassert(hours(142).total!\"hours\" == 142);\nassert(minutes(142).total!\"minutes\" == 142);\nassert(seconds(142).total!\"seconds\" == 142);\nassert(msecs(142).total!\"msecs\" == 142);\nassert(usecs(142).total!\"usecs\" == 142);\nassert(hnsecs(142).total!\"hnsecs\" == 142);\nassert(nsecs(142).total!\"nsecs\" == 100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2049_355)\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "units == \"weeks\" || units == \"days\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\" || units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\" || units == \"nsecs\"",
				"char": 10,
				"kind": "template"
			},
			{
				"name": "weeks",
				"line": 2038,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "days",
				"line": 2039,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "hours",
				"line": 2040,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "minutes",
				"line": 2041,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "seconds",
				"line": 2042,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "msecs",
				"line": 2043,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "usecs",
				"line": 2044,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "hnsecs",
				"line": 2045,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "nsecs",
				"line": 2046,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "MonoTime",
				"line": 2135,
				"comment": "    alias for $(D MonoTimeImpl) instantiated with $(D ClockType.normal). This is\n    what most programs should use. It's also what much of $(D MonoTimeImpl) uses\n    in its documentation (particularly in the examples), because that's what's\n    going to be used in most code.\n",
				"deco": "S4core4time42__T12MonoTimeImplVE4core4time9ClockTypei0Z12MonoTimeImpl",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "MonoTimeImpl",
						"line": 2184,
						"members": [
							{
								"endchar": 5,
								"name": "currTime",
								"line": 2245,
								"comment": "        The current time of the system's monotonic clock. This has no relation\n        to the wall clock time, as the wall clock time can be adjusted (e.g.\n        by NTP), whereas the monotonic clock always moves forward. The source\n        of the monotonic time is system-specific.\n\n        On Windows, $(D QueryPerformanceCounter) is used. On Mac OS X,\n        $(D mach_absolute_time) is used, while on other POSIX systems,\n        $(D clock_gettime) is used.\n\n        $(RED Warning): On some systems, the monotonic clock may stop counting\n                        when the computer goes to sleep or hibernates. So, the\n                        monotonic clock may indicate less time than has actually\n                        passed if that occurs. This is known to happen on\n                        Mac OS X. It has not been tested whether it occurs on\n                        either Windows or Linux.\n",
								"type": "nothrow @nogc @property @trusted MonoTimeImpl()",
								"endline": 2280,
								"char": 35,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"endchar": 51,
								"name": "zero",
								"line": 2289,
								"comment": "        A $(D MonoTime) of $(D 0) ticks. It's provided to be consistent with\n        $(D Duration.zero), and it's more explicit than $(D MonoTime.init).\n",
								"type": "MonoTimeImpl()",
								"endline": 2289,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 57,
								"name": "max",
								"line": 2294,
								"comment": "        Largest $(D MonoTime) possible.\n",
								"type": "MonoTimeImpl()",
								"endline": 2294,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 57,
								"name": "min",
								"line": 2299,
								"comment": "        Most negative $(D MonoTime) possible.\n",
								"type": "MonoTimeImpl()",
								"endline": 2299,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opCmp",
								"line": 2323,
								"comment": "        Compares this MonoTime with the given MonoTime.\n\n        Returns:\n            $(BOOKTABLE,\n                $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n                $(TR $(TD this == rhs) $(TD 0))\n                $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
								"type": "const pure nothrow @nogc int(MonoTimeImpl rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "MonoTimeImpl"
									}
								],
								"endline": 2328,
								"char": 9,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 2393,
										"type": "const pure nothrow @nogc Duration(MonoTimeImpl rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "MonoTimeImpl"
											}
										],
										"endline": 2398,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 2393,
								"comment": "        Subtracting two MonoTimes results in a $(LREF Duration) representing\n        the amount of time which elapsed between them.\n\n        The primary way that programs should time how long something takes is to\n        do\n--------------------\nMonoTime before = MonoTime.currTime;\n// do stuff\nMonoTime after = MonoTime.currTime;\n\n// How long it took.\nDuration timeElapsed = after - before;\n--------------------\n        or to use a wrapper (such as a stop watch type) which does that.\n\n        $(RED Warning):\n            Because $(LREF Duration) is in hnsecs, whereas MonoTime is in system\n            ticks, it's usually the case that this assertion will fail\n--------------------\nauto before = MonoTime.currTime;\n// do stuff\nauto after = MonoTime.currTime;\nauto timeElapsed = after - before;\nassert(before + timeElapsed == after).\n--------------------\n\n            This is generally fine, and by its very nature, converting from\n            system ticks to any type of seconds (hnsecs, nsecs, etc.) will\n            introduce rounding errors, but if code needs to avoid any of the\n            small rounding errors introduced by conversion, then it needs to use\n            MonoTime's $(D ticks) property and keep all calculations in ticks\n            rather than using $(LREF Duration).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"-\"",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 2431,
										"type": "const pure nothrow @nogc MonoTimeImpl(Duration rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Duration"
											}
										],
										"endline": 2436,
										"char": 18,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 2431,
								"comment": "        Adding or subtracting a $(LREF Duration) to/from a MonoTime results in\n        a MonoTime which is adjusted by that amount.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"+\" || op == \"-\"",
								"char": 18,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 2463,
										"type": "pure nothrow @nogc ref MonoTimeImpl(Duration rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Duration"
											}
										],
										"endline": 2469,
										"char": 22,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 2463,
								"comment": " Ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"+\" || op == \"-\"",
								"char": 22,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "ticks",
								"line": 2507,
								"comment": "        The number of ticks in the monotonic time.\n\n        Most programs should not use this directly, but it's exposed for those\n        few programs that need it.\n\n        The main reasons that a program might need to use ticks directly is if\n        the system clock has higher precision than hnsecs, and the program needs\n        that higher precision, or if the program needs to avoid the rounding\n        errors caused by converting to hnsecs.\n",
								"type": "const pure nothrow @nogc @property long()",
								"endline": 2510,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "ticksPerSecond",
								"line": 2526,
								"comment": "        The number of ticks that MonoTime has per second - i.e. the resolution\n        or frequency of the system's monotonic clock.\n\n        e.g. if the system clock had a resolution of microseconds, then\n        ticksPerSecond would be $(D 1_000_000).\n",
								"type": "pure nothrow @nogc @property long()",
								"endline": 2529,
								"char": 27,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 2538,
								"comment": "\n",
								"type": "const pure nothrow string()",
								"endline": 2545,
								"char": 12,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "MonoTimeImpl",
				"line": 2184,
				"comment": "    Represents a timestamp of the system's monotonic clock.\n\n    A monotonic clock is one which always goes forward and never moves\n    backwards, unlike the system's wall clock time (as represented by\n    $(XREF datetime, SysTime)). The system's wall clock time can be adjusted\n    by the user or by the system itself via services such as NTP, so it is\n    unreliable to use the wall clock time for timing. Timers which use the wall\n    clock time could easily end up never going off due to changes made to the\n    wall clock time or otherwise waiting for a different period of time than\n    that specified by the programmer. However, because the monotonic clock\n    always increases at a fixed rate and is not affected by adjustments to the\n    wall clock time, it is ideal for use with timers or anything which requires\n    high precision timing.\n\n    So, MonoTime should be used for anything involving timers and timing,\n    whereas $(XREF datetime, SysTime) should be used when the wall clock time\n    is required.\n\n    The monotonic clock has no relation to wall clock time. Rather, it holds\n    its time as the number of ticks of the clock which have occurred since the\n    clock started (typically when the system booted up). So, to determine how\n    much time has passed between two points in time, one monotonic time is\n    subtracted from the other to determine the number of ticks which occurred\n    between the two points of time, and those ticks are divided by the number of\n    ticks that occur every second (as represented by MonoTime.ticksPerSecond)\n    to get a meaningful duration of time. Normally, MonoTime does these\n    calculations for the programmer, but the $(D ticks) and $(D ticksPerSecond)\n    properties are provided for those who require direct access to the system\n    ticks. The normal way that MonoTime would be used is\n\n--------------------\n    MonoTime before = MonoTime.currTime;\n    // do stuff...\n    MonoTime after = MonoTime.currTime;\n    Duration timeElapsed = after - before;\n--------------------\n\n    $(LREF MonoTime) is an alias to $(D MonoTimeImpl!(ClockType.normal)) and is\n    what most programs should use for the monotonic clock, so that's what is\n    used in most of $(D MonoTimeImpl)'s documentation. But $(D MonoTimeImpl)\n    can be instantiated with other clock types for those rare programs that need\n    it.\n\n    See_Also:\n        $(LREF ClockType)\n",
				"parameters": [
					{
						"name": "clockType",
						"deco": "E4core4time9ClockType",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "convClockFreq",
				"line": 2733,
				"comment": "    Converts the given time from one clock frequency/resolution to another.\n\n    See_Also:\n        $(LREF ticksToNSecs)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2745_372)\n---\n// one tick is one second -> one tick is a hecto-nanosecond\nassert(convClockFreq(45, 1, 10_000_000) == 450_000_000);\n\n// one tick is one microsecond -> one tick is a millisecond\nassert(convClockFreq(9029, 1_000_000, 1_000) == 9);\n\n// one tick is 1/3_515_654 of a second -> 1/1_001_010 of a second\nassert(convClockFreq(912_319, 3_515_654, 1_001_010) == 259_764);\n\n// one tick is 1/MonoTime.ticksPerSecond -> one tick is a nanosecond\n// Equivalent to ticksToNSecs\nauto nsecs = convClockFreq(1982, MonoTime.ticksPerSecond, 1_000_000_000);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2745_372)\n",
				"deco": "FNaNbNiNflllZl",
				"parameters": [
					{
						"name": "ticks",
						"deco": "l"
					},
					{
						"name": "srcTicksPerSecond",
						"deco": "l"
					},
					{
						"name": "dstTicksPerSecond",
						"deco": "l"
					}
				],
				"endline": 2742,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "ticksToNSecs",
				"line": 2831,
				"comment": "    Convenience wrapper around $(LREF convClockFreq) which converts ticks at\n    a clock frequency of $(D MonoTime.ticksPerSecond) to nanoseconds.\n\n    It's primarily of use when $(D MonoTime.ticksPerSecond) is greater than\n    hecto-nanosecond resolution, and an application needs a higher precision\n    than hecto-nanoceconds.\n\n    See_Also:\n        $(LREF convClockFreq)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2837_374)\n---\nauto before = MonoTime.currTime;\n// do stuff\nauto after = MonoTime.currTime;\nauto diffInTicks = after.ticks - before.ticks;\nauto diffInNSecs = ticksToNSecs(diffInTicks);\nassert(diffInNSecs == convClockFreq(diffInTicks, MonoTime.ticksPerSecond, 1_000_000_000));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2837_374)\n",
				"deco": "FNaNbNiNflZl",
				"parameters": [
					{
						"name": "ticks",
						"deco": "l"
					}
				],
				"endline": 2834,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nsecsToTicks",
				"line": 2851,
				"comment": "    The reverse of $(LREF ticksToNSecs).\n",
				"deco": "FNaNbNiNflZl",
				"parameters": [
					{
						"name": "ticks",
						"deco": "l"
					}
				],
				"endline": 2854,
				"char": 6,
				"kind": "function"
			},
			{
				"name": "TickDuration",
				"line": 2881,
				"comment": "    $(RED Warning: TickDuration will be deprecated in the near future (once all\n          uses of it in Phobos have been deprecated). Please use\n          $(LREF MonoTime) for the cases where a monotonic timestamp is needed\n          and $(LREF Duration) when a duration is needed, rather than using\n          TickDuration. It has been decided that TickDuration is too confusing\n          (e.g. it conflates a monotonic timestamp and a duration in monotonic\n           clock ticks) and that having multiple duration types is too awkward\n          and confusing.)\n\n   Represents a duration of time in system clock ticks.\n\n   The system clock ticks are the ticks of the system clock at the highest\n   precision that the system provides.\n",
				"members": [
					{
						"name": "ticksPerSec",
						"line": 2891,
						"comment": "       The number of ticks that the system clock has in one second.\n\n       If $(D ticksPerSec) is $(D 0), then then $(D TickDuration) failed to\n       get the value of $(D ticksPerSec) on the current system, and\n       $(D TickDuration) is not going to work. That would be highly abnormal\n       though.\n",
						"deco": "yl",
						"originalType": "long",
						"char": 27,
						"kind": "variable",
						"storageClass": [
							"static",
							"immutable"
						]
					},
					{
						"name": "appOrigin",
						"line": 2898,
						"comment": "        The tick of the system clock (as a $(D TickDuration)) when the\n        application started.\n",
						"deco": "yS4core4time12TickDuration",
						"originalType": "TickDuration",
						"char": 35,
						"kind": "variable",
						"storageClass": [
							"static",
							"immutable"
						]
					},
					{
						"endchar": 51,
						"name": "zero",
						"line": 2908,
						"comment": "        It's the same as $(D TickDuration(0)), but it's provided to be\n        consistent with $(D Duration) and $(D FracSec), which provide $(D zero)\n        properties.\n",
						"deco": "FNaNbNdNiNfZS4core4time12TickDuration",
						"endline": 2908,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 57,
						"name": "max",
						"line": 2913,
						"comment": "        Largest $(D TickDuration) possible.\n",
						"deco": "FNaNbNdNiNfZS4core4time12TickDuration",
						"endline": 2913,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 57,
						"name": "min",
						"line": 2918,
						"comment": "        Most negative $(D TickDuration) possible.\n",
						"deco": "FNaNbNdNiNfZS4core4time12TickDuration",
						"endline": 2918,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"offset": 0,
						"name": "length",
						"line": 2985,
						"comment": "       The number of system ticks in this $(D TickDuration).\n\n       You can convert this $(D length) into the number of seconds by dividing\n       it by $(D ticksPerSec) (or using one the appropriate property function\n       to do it).\n",
						"deco": "l",
						"char": 10,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "seconds",
						"line": 2990,
						"comment": "        Returns the total number of seconds in this $(D TickDuration).\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 2993,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "msecs",
						"line": 3013,
						"comment": "        Returns the total number of milliseconds in this $(D TickDuration).\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 3016,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "usecs",
						"line": 3022,
						"comment": "        Returns the total number of microseconds in this $(D TickDuration).\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 3025,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hnsecs",
						"line": 3031,
						"comment": "        Returns the total number of hecto-nanoseconds in this $(D TickDuration).\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 3034,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "nsecs",
						"line": 3040,
						"comment": "        Returns the total number of nanoseconds in this $(D TickDuration).\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 3043,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "from",
								"line": 3054,
								"type": "pure nothrow @nogc @safe TickDuration(long length)",
								"parameters": [
									{
										"name": "length",
										"deco": "l"
									}
								],
								"endline": 3064,
								"char": 25,
								"kind": "function"
							}
						],
						"name": "from",
						"line": 3054,
						"comment": "        This allows you to construct a $(D TickDuration) from the given time\n        units with the given length.\n\n        Params:\n            units  = The time units of the $(D TickDuration) (e.g. $(D \"msecs\")).\n            length = The number of units in the $(D TickDuration).\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"seconds\" || units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\" || units == \"nsecs\"",
						"char": 25,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 3090,
								"type": "const pure nothrow @nogc @safe Duration()",
								"endline": 3094,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 3090,
						"comment": "        Returns a $(LREF Duration) with the same number of hnsecs as this\n        $(D TickDuration).\n        Note that the conventional way to convert between $(D TickDuration)\n        and $(D Duration) is using $(XREF conv, to), e.g.:\n        $(D tickDuration.to!Duration())\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(_Unqual!T == Duration)",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 3139,
								"type": "pure nothrow @nogc ref @safe TickDuration(TickDuration rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "TickDuration"
									}
								],
								"endline": 3144,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 3139,
						"comment": "        Adds or subtracts two $(D TickDuration)s as well as assigning the result\n        to this $(D TickDuration).\n\n        The legal types of arithmetic for $(D TickDuration) using this operator\n        are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD +=) $(TD TickDuration) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD -=) $(TD TickDuration) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            rhs = The $(D TickDuration) to add to or subtract from this\n                  $(D $(D TickDuration)).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 22,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 3185,
								"type": "const pure nothrow @nogc @safe TickDuration(TickDuration rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "TickDuration"
									}
								],
								"endline": 3189,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 3185,
						"comment": "        Adds or subtracts two $(D TickDuration)s.\n\n        The legal types of arithmetic for $(D TickDuration) using this operator\n        are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD +) $(TD TickDuration) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD -) $(TD TickDuration) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            rhs = The $(D TickDuration) to add to or subtract from this\n                  $(D TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 3206,
								"type": "const pure nothrow @nogc @safe TickDuration()",
								"endline": 3210,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 3206,
						"comment": "        Returns the negation of this $(D TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 18,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 3228,
						"comment": "       operator overloading \"<, >, <=, >=\"\n",
						"deco": "xFNaNbNiNfS4core4time12TickDurationZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "S4core4time12TickDuration"
							}
						],
						"endline": 3231,
						"char": 9,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 3284,
								"type": "pure nothrow @nogc @safe void(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 3289,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 3284,
						"comment": "        The legal types of arithmetic for $(D TickDuration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD *) $(TD long) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD *) $(TD floating point) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            value = The value to divide from this duration.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"*\" && (__traits(isIntegral, T) || __traits(isFloating, T))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 3332,
								"type": "pure @safe void(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 3340,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 3332,
						"comment": "        The legal types of arithmetic for $(D TickDuration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD /) $(TD long) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD /) $(TD floating point) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            value = The value to divide from this $(D TickDuration).\n\n        Throws:\n            $(D TimeException) if an attempt to divide by $(D 0) is made.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"/\" && (__traits(isIntegral, T) || __traits(isFloating, T))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 3382,
								"type": "const pure nothrow @nogc @safe TickDuration(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 3387,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 3382,
						"comment": "        The legal types of arithmetic for $(D TickDuration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD *) $(TD long) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD *) $(TD floating point) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            value = The value to divide from this $(D TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"*\" && (__traits(isIntegral, T) || __traits(isFloating, T))",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 3418,
								"type": "const pure @safe TickDuration(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 3426,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 3418,
						"comment": "        The legal types of arithmetic for $(D TickDuration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD /) $(TD long) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD /) $(TD floating point) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            value = The value to divide from this $(D TickDuration).\n\n        Throws:\n            $(D TimeException) if an attempt to divide by $(D 0) is made.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"/\" && (__traits(isIntegral, T) || __traits(isFloating, T))",
						"char": 18,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3448,
						"comment": "        Params:\n            ticks = The number of ticks in the TickDuration.\n",
						"deco": "FNaNbNcNiNflZS4core4time12TickDuration",
						"parameters": [
							{
								"name": "ticks",
								"deco": "l"
							}
						],
						"endline": 3451,
						"originalType": "pure nothrow @nogc ref @safe (long ticks)",
						"char": 30,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "currSystemTick",
						"line": 3485,
						"comment": "        The current system tick. The number of ticks per second varies from\n        system to system. $(D currSystemTick) uses a monotonic clock, so it's\n        intended for precision timing by comparing relative time values, not for\n        getting the current system time.\n\n        On Windows, $(D QueryPerformanceCounter) is used. On Mac OS X,\n        $(D mach_absolute_time) is used, while on other Posix systems,\n        $(D clock_gettime) is used. If $(D mach_absolute_time) or\n        $(D clock_gettime) is unavailable, then Posix systems use\n        $(D gettimeofday) (the decision is made when $(D TickDuration) is\n        compiled), which unfortunately, is not monotonic, but if\n        $(D mach_absolute_time) and $(D clock_gettime) aren't available, then\n        $(D gettimeofday) is the the best that there is.\n\n        $(RED Warning):\n            On some systems, the monotonic clock may stop counting when\n            the computer goes to sleep or hibernates. So, the monotonic\n            clock could be off if that occurs. This is known to happen\n            on Mac OS X. It has not been tested whether it occurs on\n            either Windows or on Linux.\n\n        Throws:\n            $(D TimeException) if it fails to get the time.\n",
						"deco": "FNbNdNiNeZS4core4time12TickDuration",
						"endline": 3531,
						"char": 35,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "convert",
						"line": 3552,
						"type": "pure nothrow @nogc @safe long(long value)",
						"parameters": [
							{
								"name": "value",
								"deco": "l"
							}
						],
						"endline": 3599,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "convert",
				"line": 3552,
				"comment": "    Generic way of converting between two time units. Conversions to smaller\n    units use truncating division. Years and months can be converted to each\n    other, small units can be converted to each other, but years and months\n    cannot be converted to or from smaller units (due to the varying number\n    of days in a month or year).\n\n    Params:\n        from  = The units of time to convert from.\n        to    = The units of time to convert to.\n        value = The value to convert.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3602_392)\n---\nassert(convert!(\"years\", \"months\")(1) == 12);\nassert(convert!(\"months\", \"years\")(12) == 1);\n\nassert(convert!(\"weeks\", \"days\")(1) == 7);\nassert(convert!(\"hours\", \"seconds\")(1) == 3600);\nassert(convert!(\"seconds\", \"days\")(1) == 0);\nassert(convert!(\"seconds\", \"days\")(86_400) == 1);\n\nassert(convert!(\"nsecs\", \"nsecs\")(1) == 1);\nassert(convert!(\"nsecs\", \"hnsecs\")(1) == 0);\nassert(convert!(\"hnsecs\", \"nsecs\")(1) == 100);\nassert(convert!(\"nsecs\", \"seconds\")(1) == 0);\nassert(convert!(\"seconds\", \"nsecs\")(1) == 1_000_000_000);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3602_392)\n",
				"parameters": [
					{
						"name": "from",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "to",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "(from == \"weeks\" || from == \"days\" || from == \"hours\" || from == \"minutes\" || from == \"seconds\" || from == \"msecs\" || from == \"usecs\" || from == \"hnsecs\" || from == \"nsecs\") && (to == \"weeks\" || to == \"days\" || to == \"hours\" || to == \"minutes\" || to == \"seconds\" || to == \"msecs\" || to == \"usecs\" || to == \"hnsecs\" || to == \"nsecs\") || (from == \"years\" || from == \"months\") && (to == \"years\" || to == \"months\")",
				"char": 6,
				"kind": "template"
			},
			{
				"name": "FracSec",
				"line": 3710,
				"comment": "    Represents fractional seconds.\n\n    This is the portion of the time which is smaller than a second and it cannot\n    hold values which would be greater than or equal to a second (or less than\n    or equal to a negative second).\n\n    It holds hnsecs internally, but you can create it using either milliseconds,\n    microseconds, or hnsecs. What it does is allow for a simple way to set or\n    adjust the fractional seconds portion of a $(D Duration) or a\n    $(XREF datetime, SysTime) without having to worry about whether you're\n    dealing with milliseconds, microseconds, or hnsecs.\n\n    $(D FracSec)'s functions which take time unit strings do accept\n    $(D \"nsecs\"), but because the resolution of $(D Duration) and\n    $(XREF datetime, SysTime) is hnsecs, you don't actually get precision higher\n    than hnsecs. $(D \"nsecs\") is accepted merely for convenience. Any values\n    given as nsecs will be converted to hnsecs using $(D convert) (which uses\n    truncating division when converting to smaller units).\n",
				"members": [
					{
						"endchar": 72,
						"name": "zero",
						"line": 3720,
						"comment": "        A $(D FracSec) of $(D 0). It's shorter than doing something like\n        $(D FracSec.from!\"msecs\"(0)) and more explicit than $(D FracSec.init).\n",
						"deco": "FNaNbNdNiNfZS4core4time7FracSec",
						"endline": 3720,
						"char": 44,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "from",
								"line": 3741,
								"type": "FracSec(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 3750,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "from",
						"line": 3741,
						"comment": "        Create a $(D FracSec) from the given units ($(D \"msecs\"), $(D \"usecs\"),\n        or $(D \"hnsecs\")).\n\n        Params:\n            units = The units to create a FracSec from.\n            value = The number of the given units passed the second.\n\n        Throws:\n            $(D TimeException) if the given value would result in a $(D FracSec)\n            greater than or equal to $(D 1) second or less than or equal to\n            $(D -1) seconds.\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\" || units == \"nsecs\"",
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 3792,
								"type": "const nothrow @nogc FracSec()",
								"endline": 3796,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 3792,
						"comment": "        Returns the negation of this $(D FracSec).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 13,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "msecs",
						"line": 3814,
						"comment": "        The value of this $(D FracSec) as milliseconds.\n",
						"deco": "xFNaNbNdNiNfZi",
						"endline": 3817,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "msecs",
						"line": 3846,
						"comment": "        The value of this $(D FracSec) as milliseconds.\n\n        Params:\n            milliseconds = The number of milliseconds passed the second.\n\n        Throws:\n            $(D TimeException) if the given value is not less than $(D 1) second\n            and greater than a $(D -1) seconds.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "milliseconds",
								"deco": "i"
							}
						],
						"endline": 3851,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "usecs",
						"line": 3886,
						"comment": "        The value of this $(D FracSec) as microseconds.\n",
						"deco": "xFNaNbNdNiNfZi",
						"endline": 3889,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "usecs",
						"line": 3918,
						"comment": "        The value of this $(D FracSec) as microseconds.\n\n        Params:\n            microseconds = The number of microseconds passed the second.\n\n        Throws:\n            $(D TimeException) if the given value is not less than $(D 1) second\n            and greater than a $(D -1) seconds.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "microseconds",
								"deco": "i"
							}
						],
						"endline": 3923,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hnsecs",
						"line": 3959,
						"comment": "        The value of this $(D FracSec) as hnsecs.\n",
						"deco": "xFNaNbNdNiNfZi",
						"endline": 3962,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hnsecs",
						"line": 3991,
						"comment": "        The value of this $(D FracSec) as hnsecs.\n\n        Params:\n            hnsecs = The number of hnsecs passed the second.\n\n        Throws:\n            $(D TimeException) if the given value is not less than $(D 1) second\n            and greater than a $(D -1) seconds.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "hnsecs",
								"deco": "i"
							}
						],
						"endline": 3995,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "nsecs",
						"line": 4035,
						"comment": "        The value of this $(D FracSec) as nsecs.\n\n        Note that this does not give you any greater precision\n        than getting the value of this $(D FracSec) as hnsecs.\n",
						"deco": "xFNaNbNdNiNfZi",
						"endline": 4038,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "nsecs",
						"line": 4070,
						"comment": "        The value of this $(D FracSec) as nsecs.\n\n        Note that this does not give you any greater precision\n        than setting the value of this $(D FracSec) as hnsecs.\n\n        Params:\n            nsecs = The number of nsecs passed the second.\n\n        Throws:\n            $(D TimeException) if the given value is not less than $(D 1) second\n            and greater than a $(D -1) seconds.\n",
						"deco": "FNaNdNflZv",
						"parameters": [
							{
								"name": "nsecs",
								"deco": "l"
							}
						],
						"endline": 4075,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 4129,
						"comment": "        Converts this $(D TickDuration) to a string.\n",
						"deco": "xFNaNbNfZAya",
						"endline": 4132,
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 4307,
						"comment": "        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC4core4time13TimeException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 4310,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 4319,
						"comment": "        Params:\n            msg  = The message for the exception.\n            next = The previous exception in the chain of exceptions.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n",
						"deco": "FNaNbNfAyaC6object9ThrowableAyamZC4core4time13TimeException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 4322,
						"originalType": "pure nothrow @safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "TimeException",
				"line": 4298,
				"comment": "    Exception type used by core.time.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "abs",
				"line": 4350,
				"comment": "    Returns the absolute value of a duration.\n",
				"deco": "FNaNbNiNfS4core4time8DurationZS4core4time8Duration",
				"parameters": [
					{
						"name": "duration",
						"deco": "S4core4time8Duration"
					}
				],
				"endline": 4353,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "abs",
				"line": 4356,
				"comment": " Ditto\n",
				"deco": "FNaNbNiNfS4core4time12TickDurationZS4core4time12TickDuration",
				"parameters": [
					{
						"name": "duration",
						"deco": "S4core4time12TickDuration"
					}
				],
				"endline": 4359,
				"char": 14,
				"kind": "function"
			}
		],
		"comment": "    Module containing core time functionality, such as $(LREF Duration) (which\n    represents a duration of time) or $(LREF MonoTime) (which represents a\n    timestamp of the system's monotonic clock).\n\n    Various functions take a string (or strings) to represent a unit of time\n    (e.g. $(D convert!(\"days\", \"hours\")(numDays))). The valid strings to use\n    with such functions are \"years\", \"months\", \"weeks\", \"days\", \"hours\",\n    \"minutes\", \"seconds\", \"msecs\" (milliseconds), \"usecs\" (microseconds),\n    \"hnsecs\" (hecto-nanoseconds - i.e. 100 ns) or some subset thereof. There\n    are a few functions that also allow \"nsecs\", but very little actually\n    has precision greater than hnsecs.\n\n    $(BOOKTABLE Cheat Sheet,\n    $(TR $(TH Symbol) $(TH Description))\n    $(LEADINGROW Types)\n    $(TR $(TDNW $(LREF Duration)) $(TD Represents a duration of time of weeks\n    or less (kept internally as hnsecs). (e.g. 22 days or 700 seconds).))\n    $(TR $(TDNW $(LREF TickDuration)) $(TD Represents a duration of time in\n    system clock ticks, using the highest precision that the system provides.))\n    $(TR $(TDNW $(LREF MonoTime)) $(TD Represents a monotonic timestamp in\n    system clock ticks, using the highest precision that the system provides.))\n    $(TR $(TDNW $(LREF FracSec)) $(TD Represents fractional seconds\n    (portions of time smaller than a second).))\n    $(LEADINGROW Functions)\n    $(TR $(TDNW $(LREF convert)) $(TD Generic way of converting between two time\n    units.))\n    $(TR $(TDNW $(LREF dur)) $(TD Allows constructing a $(LREF Duration) from\n    the given time units with the given length.))\n    $(TR $(TDNW $(LREF weeks)$(NBSP)$(LREF days)$(NBSP)$(LREF hours)$(BR)\n    $(LREF minutes)$(NBSP)$(LREF seconds)$(NBSP)$(LREF msecs)$(BR)\n    $(LREF usecs)$(NBSP)$(LREF hnsecs)$(NBSP)$(LREF nsecs))\n    $(TD Convenience aliases for $(LREF dur).))\n    $(TR $(TDNW $(LREF abs)) $(TD Returns the absolute value of a duration.))\n    )\n\n    $(BOOKTABLE Conversions,\n    $(TR $(TH )\n     $(TH From $(LREF Duration))\n     $(TH From $(LREF TickDuration))\n     $(TH From $(LREF FracSec))\n     $(TH From units)\n    )\n    $(TR $(TD $(B To $(LREF Duration)))\n     $(TD -)\n     $(TD $(D tickDuration.)$(SXREF conv, to)$(D !Duration()))\n     $(TD -)\n     $(TD $(D dur!\"msecs\"(5)) or $(D 5.msecs()))\n    )\n    $(TR $(TD $(B To $(LREF TickDuration)))\n     $(TD $(D duration.)$(SXREF conv, to)$(D !TickDuration()))\n     $(TD -)\n     $(TD -)\n     $(TD $(D TickDuration.from!\"msecs\"(msecs)))\n    )\n    $(TR $(TD $(B To $(LREF FracSec)))\n     $(TD $(D duration.fracSec))\n     $(TD -)\n     $(TD -)\n     $(TD $(D FracSec.from!\"msecs\"(msecs)))\n    )\n    $(TR $(TD $(B To units))\n     $(TD $(D duration.total!\"days\"))\n     $(TD $(D tickDuration.msecs))\n     $(TD $(D fracSec.msecs))\n     $(TD $(D convert!(\"days\", \"msecs\")(msecs)))\n    ))\n\n    Copyright: Copyright 2010 - 2012\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   Jonathan M Davis and Kato Shoichi\n    Source:    $(DRUNTIMESRC core/_time.d)\n    Macros:\n    NBSP=&nbsp;\n    SXREF=<a href=\"std_$1.html#$2\">$(D $2)</a>\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/exception.d",
		"name": "core.exception",
		"members": [
			{
				"members": [],
				"name": "RangeError",
				"line": 17,
				"comment": " Thrown on a range error.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "AssertError",
				"line": 48,
				"comment": " Thrown on an assert error.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "FinalizeError",
				"line": 121,
				"comment": " Thrown on finalize error.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "HiddenFuncError",
				"line": 190,
				"comment": " Thrown on hidden function error.\n $(RED Deprecated.\n   This feature is not longer part of the language.)\n",
				"base": "object.Error",
				"char": 12,
				"kind": "class"
			},
			{
				"members": [],
				"name": "OutOfMemoryError",
				"line": 214,
				"comment": " Thrown on an out of memory error.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "InvalidMemoryOperationError",
				"line": 262,
				"comment": " Thrown on an invalid memory operation.\n\n An invalid memory operation error occurs in circumstances when the garbage\n collector has detected an operation it cannot reliably handle. The default\n D GC is not re-entrant, so this can happen due to allocations done from\n within finalizers called during a garbage collection cycle.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "SwitchError",
				"line": 299,
				"comment": " Thrown on a switch error.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "UnicodeException",
				"line": 330,
				"comment": " Thrown on a unicode conversion error.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "AssertHandler",
				"line": 378,
				"comment": "Gets/sets assert hander. null means the default handler is used.\n",
				"deco": "PFNbAyamAyaZv",
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "assertHandler",
				"line": 381,
				"comment": "ditto\n",
				"deco": "FNbNdNiNeZPFNbAyamAyaZv",
				"endline": 384,
				"originalType": "nothrow @nogc @property @trusted AssertHandler()",
				"char": 25,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "assertHandler",
				"line": 387,
				"comment": "ditto\n",
				"deco": "FNbNdNiNePFNbAyamAyaZvZv",
				"parameters": [
					{
						"name": "handler",
						"deco": "PFNbAyamAyaZv"
					}
				],
				"endline": 390,
				"originalType": "nothrow @nogc @property @trusted void(AssertHandler handler)",
				"char": 16,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "setAssertHandler",
				"line": 400,
				"comment": " Overrides the default assert hander with a user-supplied version.\n $(RED Deprecated.\n   Please use $(LREF assertHandler) instead.)\n\n Params:\n  h = The new assert handler.  Set to null to use the default handler.\n",
				"deco": "FNbNiNePFNbAyamAyaZvZv",
				"parameters": [
					{
						"name": "h",
						"deco": "PFNbAyamAyaZv"
					}
				],
				"endline": 403,
				"originalType": "nothrow @nogc @trusted void(AssertHandler h)",
				"char": 17,
				"kind": "function",
				"storageClass": [
					"deprecated"
				]
			},
			{
				"endchar": 1,
				"name": "onAssertError",
				"line": 420,
				"comment": "\n\n\n\n A callback for assert errors in D.  The user-supplied assert handler will\n be called if one has been supplied, otherwise an $(LREF AssertError) will be\n thrown.\n\n Params:\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n",
				"deco": "UNbAyamZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya",
						"default": "__FILE__"
					},
					{
						"name": "line",
						"deco": "m",
						"default": "cast(ulong)__LINE__"
					}
				],
				"endline": 425,
				"originalType": "nothrow extern (C) void(string file = __FILE__, size_t line = __LINE__)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onAssertErrorMsg",
				"line": 438,
				"comment": " A callback for assert errors in D.  The user-supplied assert handler will\n be called if one has been supplied, otherwise an $(LREF AssertError) will be\n thrown.\n\n Params:\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n  msg  = An error message supplied by the user.\n",
				"deco": "UNbAyamAyaZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "m"
					},
					{
						"name": "msg",
						"deco": "Aya"
					}
				],
				"endline": 443,
				"originalType": "nothrow extern (C) void(string file, size_t line, string msg)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onUnittestErrorMsg",
				"line": 456,
				"comment": " A callback for unittest errors in D.  The user-supplied unittest handler\n will be called if one has been supplied, otherwise the error will be\n written to stderr.\n\n Params:\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n  msg  = An error message supplied by the user.\n",
				"deco": "UNbAyamAyaZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "m"
					},
					{
						"name": "msg",
						"deco": "Aya"
					}
				],
				"endline": 459,
				"originalType": "nothrow extern (C) void(string file, size_t line, string msg)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onRangeError",
				"line": 476,
				"comment": "\n\n\n\n A callback for array bounds errors in D.  A $(LREF RangeError) will be thrown.\n\n Params:\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n\n Throws:\n  $(LREF RangeError).\n",
				"deco": "UNaNbNfAyamZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya",
						"default": "__FILE__"
					},
					{
						"name": "line",
						"deco": "m",
						"default": "cast(ulong)__LINE__"
					}
				],
				"endline": 479,
				"originalType": "pure nothrow @safe extern (C) void(string file = __FILE__, size_t line = __LINE__)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onFinalizeError",
				"line": 494,
				"comment": " A callback for finalize errors in D.  A $(LREF FinalizeError) will be thrown.\n\n Params:\n  info = The TypeInfo instance for the object that failed finalization.\n  e = The exception thrown during finalization.\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n\n Throws:\n  $(LREF FinalizeError).\n",
				"deco": "UNbNeC8TypeInfoC6object9ThrowableAyamZv",
				"parameters": [
					{
						"name": "info",
						"deco": "C8TypeInfo"
					},
					{
						"name": "e",
						"deco": "C6object9Throwable"
					},
					{
						"name": "file",
						"deco": "Aya",
						"default": "__FILE__"
					},
					{
						"name": "line",
						"deco": "m",
						"default": "cast(ulong)__LINE__"
					}
				],
				"endline": 499,
				"originalType": "nothrow @trusted extern (C) void(TypeInfo info, Throwable e, string file = __FILE__, size_t line = __LINE__)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onHiddenFuncError",
				"line": 511,
				"comment": " A callback for hidden function errors in D.  A $(LREF HiddenFuncError) will be\n thrown.\n $(RED Deprecated.\n   This feature is not longer part of the language.)\n\n Throws:\n  $(LREF HiddenFuncError).\n",
				"deco": "UNaNbNfC6ObjectZv",
				"parameters": [
					{
						"name": "o",
						"deco": "C6Object"
					}
				],
				"endline": 514,
				"char": 28,
				"kind": "function",
				"storageClass": [
					"deprecated"
				]
			},
			{
				"endchar": 1,
				"name": "onOutOfMemoryError",
				"line": 524,
				"comment": " A callback for out of memory errors in D.  An $(LREF OutOfMemoryError) will be\n thrown.\n\n Throws:\n  $(LREF OutOfMemoryError).\n",
				"deco": "UNaNbNiNePvZv",
				"parameters": [
					{
						"name": "pretend_sideffect",
						"deco": "Pv",
						"default": "null"
					}
				],
				"endline": 529,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onInvalidMemoryOperationError",
				"line": 545,
				"comment": " A callback for invalid memory operations in D.  An\n $(LREF InvalidMemoryOperationError) will be thrown.\n\n Throws:\n  $(LREF InvalidMemoryOperationError).\n",
				"deco": "UNaNbNiNePvZv",
				"parameters": [
					{
						"name": "pretend_sideffect",
						"deco": "Pv",
						"default": "null"
					}
				],
				"endline": 550,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onSwitchError",
				"line": 563,
				"comment": " A callback for switch errors in D.  A $(LREF SwitchError) will be thrown.\n\n Params:\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n\n Throws:\n  $(LREF SwitchError).\n",
				"deco": "UNaNbNfAyamZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya",
						"default": "__FILE__"
					},
					{
						"name": "line",
						"deco": "m",
						"default": "cast(ulong)__LINE__"
					}
				],
				"endline": 566,
				"originalType": "pure nothrow @safe extern (C) void(string file = __FILE__, size_t line = __LINE__)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onUnicodeError",
				"line": 581,
				"comment": " A callback for unicode errors in D.  A $(LREF UnicodeException) will be thrown.\n\n Params:\n  msg = Information about the error.\n  idx = String index where this error was detected.\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n\n Throws:\n  $(LREF UnicodeException).\n",
				"deco": "UNaNfAyamAyamZv",
				"parameters": [
					{
						"name": "msg",
						"deco": "Aya"
					},
					{
						"name": "idx",
						"deco": "m"
					},
					{
						"name": "file",
						"deco": "Aya",
						"default": "__FILE__"
					},
					{
						"name": "line",
						"deco": "m",
						"default": "cast(ulong)__LINE__"
					}
				],
				"endline": 584,
				"originalType": "pure @safe extern (C) void(string msg, size_t idx, string file = __FILE__, size_t line = __LINE__)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_assertm",
				"line": 610,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UPyS6object10ModuleInfokZv",
				"parameters": [
					{
						"name": "m",
						"deco": "PyS6object10ModuleInfo"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 613,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_assert_msg",
				"line": 615,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UAyaAyakZv",
				"parameters": [
					{
						"name": "msg",
						"deco": "Aya"
					},
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 618,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_assert",
				"line": 620,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UAyakZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 623,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_unittestm",
				"line": 627,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UPyS6object10ModuleInfokZv",
				"parameters": [
					{
						"name": "m",
						"deco": "PyS6object10ModuleInfo"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 630,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_unittest_msg",
				"line": 632,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UAyaAyakZv",
				"parameters": [
					{
						"name": "msg",
						"deco": "Aya"
					},
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 635,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_unittest",
				"line": 637,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UAyakZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 640,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_array_bounds",
				"line": 644,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UPyS6object10ModuleInfokZv",
				"parameters": [
					{
						"name": "m",
						"deco": "PyS6object10ModuleInfo"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 647,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_arraybounds",
				"line": 649,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UAyakZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 652,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_switch_error",
				"line": 656,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UPyS6object10ModuleInfokZv",
				"parameters": [
					{
						"name": "m",
						"deco": "PyS6object10ModuleInfo"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 659,
				"char": 10,
				"kind": "function"
			}
		],
		"comment": " The exception module defines all system-level exceptions and provides a\n mechanism to alter system-level error handling.\n\n Copyright: Copyright Sean Kelly 2005 - 2013.\n License: Distributed under the\n      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n    (See accompanying file LICENSE)\n Authors:   Sean Kelly and Jonathan M Davis\n Source:    $(DRUNTIMESRC core/_exception.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/vararg.d",
		"name": "core.vararg",
		"members": [],
		"comment": " The vararg module is intended to facilitate vararg manipulation in D.\n It should be interface compatible with the C module \"stdarg,\" and the\n two modules may share a common implementation if possible (as is done\n here).\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Walter Bright, Hauke Duden\n Source:    $(DRUNTIMESRC core/_vararg.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/condition.d",
		"name": "core.sync.condition",
		"members": [
			{
				"name": "Condition",
				"line": 56,
				"comment": "\n\n\n\n This class represents a condition variable as conceived by C.A.R. Hoare.  As\n per Mesa type monitors however, \"signal\" has been replaced with \"notify\" to\n indicate that control is not transferred to the waiter when a notification\n is sent.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 72,
						"comment": "\n\n\n\n Initializes a condition object which is associated with the supplied\n mutex object.\n\n Params:\n  m = The mutex with which this condition will be associated.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FNbNfC4core4sync5mutex5MutexZC4core4sync9condition9Condition",
						"parameters": [
							{
								"name": "m",
								"deco": "C4core4sync5mutex5Mutex"
							}
						],
						"endline": 96,
						"originalType": "nothrow @safe (Mutex m)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "mutex",
						"line": 128,
						"comment": "\n\n\n\n Gets the mutex associated with this condition.\n\n Returns:\n  The mutex associated with this condition.\n",
						"deco": "FNdZC4core4sync5mutex5Mutex",
						"endline": 131,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "wait",
						"line": 151,
						"comment": "\n\n\n\n Wait until notified.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 163,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 184,
							"deco": "FZv",
							"endline": 184,
							"char": 5,
							"kind": "function"
						},
						"name": "wait",
						"line": 182,
						"comment": " Suspends the calling thread until a notification occurs or until the\n supplied time period has elapsed.\n\n Params:\n  val = The time to wait.\n\n In:\n  val must be non-negative.\n\n Throws:\n  SyncError on error.\n\n Returns:\n  true if notified before the timeout and false if not.\n",
						"deco": "FS4core4time8DurationZb",
						"parameters": [
							{
								"name": "val",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 216,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "notify",
						"line": 225,
						"comment": " Notifies one waiter.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 237,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "notifyAll",
						"line": 246,
						"comment": " Notifies all waiters.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 258,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The condition module provides a primitive for synchronized condition\n checking.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_condition.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/barrier.d",
		"name": "core.sync.barrier",
		"members": [
			{
				"name": "Barrier",
				"line": 41,
				"comment": "\n\n\n\n This class represents a barrier across which threads may only travel in\n groups of a specific size.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 58,
						"comment": "\n\n\n\n Initializes a barrier object which releases threads in groups of limit\n in size.\n\n Params:\n  limit = The number of waiting threads to release in unison.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FkZC4core4sync7barrier7Barrier",
						"parameters": [
							{
								"name": "limit",
								"deco": "k"
							}
						],
						"endline": 70,
						"originalType": "(uint limit)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "wait",
						"line": 84,
						"comment": "\n\n\n\n Wait for the pre-determined number of threads and then proceed.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 99,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The barrier module provides a primitive for synchronizing the progress of\n a group of threads.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_barrier.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/semaphore.d",
		"name": "core.sync.semaphore",
		"members": [
			{
				"name": "Semaphore",
				"line": 60,
				"comment": "\n\n\n\n This class represents a general counting semaphore as concieved by Edsger\n Dijkstra.  As per Mesa type monitors however, \"signal\" has been replaced\n with \"notify\" to indicate that control is not transferred to the waiter when\n a notification is sent.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 76,
						"comment": "\n\n\n\n Initializes a semaphore object with the specified initial count.\n\n Params:\n  count = The initial count for the semaphore.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FkZC4core4sync9semaphore9Semaphore",
						"parameters": [
							{
								"name": "count",
								"deco": "k",
								"default": "0u"
							}
						],
						"endline": 96,
						"originalType": "(uint count = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "wait",
						"line": 131,
						"comment": "\n\n\n\n Wait until the current count is above zero, then atomically decrement\n the count by one and return.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 161,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 184,
							"deco": "FZv",
							"endline": 184,
							"char": 5,
							"kind": "function"
						},
						"name": "wait",
						"line": 182,
						"comment": " Suspends the calling thread until the current count moves above zero or\n until the supplied time period has elapsed.  If the count moves above\n zero in this interval, then atomically decrement the count by one and\n return true.  Otherwise, return false.\n\n Params:\n  period = The time to wait.\n\n In:\n  period must be non-negative.\n\n Throws:\n  SyncError on error.\n\n Returns:\n  true if notified before the timeout and false if not.\n",
						"deco": "FS4core4time8DurationZb",
						"parameters": [
							{
								"name": "period",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 256,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "notify",
						"line": 266,
						"comment": " Atomically increment the current count by one.  This will notify one\n waiter, if there are any in the queue.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 285,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "tryWait",
						"line": 298,
						"comment": " If the current count is equal to zero, return.  Otherwise, atomically\n decrement the count by one and return true.\n\n Throws:\n  SyncError on error.\n\n Returns:\n  true if the count was above zero and false if not.\n",
						"deco": "FZb",
						"endline": 328,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The semaphore module provides a general use semaphore for synchronization.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_semaphore.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/rwmutex.d",
		"name": "core.sync.rwmutex",
		"members": [
			{
				"name": "ReadWriteMutex",
				"line": 51,
				"comment": "\n\n\n\n This class represents a mutex that allows any number of readers to enter,\n but when a writer enters, all other readers and writers are blocked.\n\n Please note that this mutex is not recursive and is intended to guard access\n to data only.  Also, no deadlock checking is in place because doing so would\n require dynamic memory allocation, which would reduce performance by an\n unacceptable amount.  As a result, any attempt to recursively acquire this\n mutex may well deadlock the caller, particularly if a write lock is acquired\n while holding a read lock, or vice-versa.  In practice, this should not be\n an issue however, because it is uncommon to call deeply into unknown code\n while holding a lock that simply protects data.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL394_436)\n---\nimport core.atomic, core.thread, core.sync.semaphore;\n\nstatic void runTest(ReadWriteMutex.Policy policy)\n{\n    scope mutex = new ReadWriteMutex(policy);\n    scope rdSemA = new Semaphore, rdSemB = new Semaphore,\n          wrSemA = new Semaphore, wrSemB = new Semaphore;\n    shared size_t numReaders, numWriters;\n\n    void readerFn()\n    {\n        synchronized (mutex.reader)\n        {\n            atomicOp!\"+=\"(numReaders, 1);\n            rdSemA.notify();\n            rdSemB.wait();\n            atomicOp!\"-=\"(numReaders, 1);\n        }\n    }\n\n    void writerFn()\n    {\n        synchronized (mutex.writer)\n        {\n            atomicOp!\"+=\"(numWriters, 1);\n            wrSemA.notify();\n            wrSemB.wait();\n            atomicOp!\"-=\"(numWriters, 1);\n        }\n    }\n\n    void waitQueued(size_t queuedReaders, size_t queuedWriters)\n    {\n        for (;;)\n        {\n            synchronized (mutex.m_commonMutex)\n            {\n                if (mutex.m_numQueuedReaders == queuedReaders &&\n                    mutex.m_numQueuedWriters == queuedWriters)\n                    break;\n            }\n            Thread.yield();\n        }\n    }\n\n    scope group = new ThreadGroup;\n\n    // 2 simultaneous readers\n    group.create(&readerFn); group.create(&readerFn);\n    rdSemA.wait(); rdSemA.wait();\n    assert(numReaders == 2);\n    rdSemB.notify(); rdSemB.notify();\n    group.joinAll();\n    assert(numReaders == 0);\n    foreach (t; group) group.remove(t);\n\n    // 1 writer at a time\n    group.create(&writerFn); group.create(&writerFn);\n    wrSemA.wait();\n    assert(!wrSemA.tryWait());\n    assert(numWriters == 1);\n    wrSemB.notify();\n    wrSemA.wait();\n    assert(numWriters == 1);\n    wrSemB.notify();\n    group.joinAll();\n    assert(numWriters == 0);\n    foreach (t; group) group.remove(t);\n\n    // reader and writer are mutually exclusive\n    group.create(&readerFn);\n    rdSemA.wait();\n    group.create(&writerFn);\n    waitQueued(0, 1);\n    assert(!wrSemA.tryWait());\n    assert(numReaders == 1 && numWriters == 0);\n    rdSemB.notify();\n    wrSemA.wait();\n    assert(numReaders == 0 && numWriters == 1);\n    wrSemB.notify();\n    group.joinAll();\n    assert(numReaders == 0 && numWriters == 0);\n    foreach (t; group) group.remove(t);\n\n    // writer and reader are mutually exclusive\n    group.create(&writerFn);\n    wrSemA.wait();\n    group.create(&readerFn);\n    waitQueued(1, 0);\n    assert(!rdSemA.tryWait());\n    assert(numReaders == 0 && numWriters == 1);\n    wrSemB.notify();\n    rdSemA.wait();\n    assert(numReaders == 1 && numWriters == 0);\n    rdSemB.notify();\n    group.joinAll();\n    assert(numReaders == 0 && numWriters == 0);\n    foreach (t; group) group.remove(t);\n\n    // policy determines whether queued reader or writers progress first\n    group.create(&writerFn);\n    wrSemA.wait();\n    group.create(&readerFn);\n    group.create(&writerFn);\n    waitQueued(1, 1);\n    assert(numReaders == 0 && numWriters == 1);\n    wrSemB.notify();\n\n    if (policy == ReadWriteMutex.Policy.PREFER_READERS)\n    {\n        rdSemA.wait();\n        assert(numReaders == 1 && numWriters == 0);\n        rdSemB.notify();\n        wrSemA.wait();\n        assert(numReaders == 0 && numWriters == 1);\n        wrSemB.notify();\n    }\n    else if (policy == ReadWriteMutex.Policy.PREFER_WRITERS)\n    {\n        wrSemA.wait();\n        assert(numReaders == 0 && numWriters == 1);\n        wrSemB.notify();\n        rdSemA.wait();\n        assert(numReaders == 1 && numWriters == 0);\n        rdSemB.notify();\n    }\n    group.joinAll();\n    assert(numReaders == 0 && numWriters == 0);\n    foreach (t; group) group.remove(t);\n}\nrunTest(ReadWriteMutex.Policy.PREFER_READERS);\nrunTest(ReadWriteMutex.Policy.PREFER_WRITERS);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL394_436)\n",
				"members": [
					{
						"members": [
							{
								"name": "PREFER_READERS",
								"line": 70,
								"value": "0",
								"comment": "Readers get preference.  This may starve writers.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "PREFER_WRITERS",
								"line": 71,
								"value": "1",
								"comment": "Writers get preference.  This may starve readers.\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "Policy",
						"line": 68,
						"comment": " Defines the policy used by this mutex.  Currently, two policies are\n defined.\n\n The first will queue writers until no readers hold the mutex, then\n pass the writers through one at a time.  If a reader acquires the mutex\n while there are still writers queued, the reader will take precedence.\n\n The second will queue readers if there are any writers queued.  Writers\n are passed through one at a time, and once there are no writers present,\n all queued readers will be alerted.\n\n Future policies may offer a more even balance between reader and writer\n precedence.\n",
						"baseDeco": "i",
						"char": 5,
						"kind": "enum"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 89,
						"comment": "\n\n\n\n Initializes a read/write mutex object with the supplied policy.\n\n Params:\n  policy = The policy to use.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FE4core4sync7rwmutex14ReadWriteMutex6PolicyZC4core4sync7rwmutex14ReadWriteMutex",
						"parameters": [
							{
								"name": "policy",
								"deco": "E4core4sync7rwmutex14ReadWriteMutex6Policy",
								"default": "cast(Policy)1"
							}
						],
						"endline": 106,
						"originalType": "(Policy policy = Policy.PREFER_WRITERS)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "policy",
						"line": 119,
						"comment": "\n\n\n\n Gets the policy used by this mutex.\n\n Returns:\n  The policy used by this mutex.\n",
						"deco": "FNdZE4core4sync7rwmutex14ReadWriteMutex6Policy",
						"endline": 122,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "reader",
						"line": 136,
						"comment": "\n\n\n\n Gets an object representing the reader lock for the associated mutex.\n\n Returns:\n  A reader sub-mutex.\n",
						"deco": "FNdZC4core4sync7rwmutex14ReadWriteMutex6Reader",
						"endline": 139,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "writer",
						"line": 148,
						"comment": " Gets an object representing the writer lock for the associated mutex.\n\n Returns:\n  A writer sub-mutex.\n",
						"deco": "FNdZC4core4sync7rwmutex14ReadWriteMutex6Writer",
						"endline": 151,
						"char": 22,
						"kind": "function"
					},
					{
						"interfaces": [
							"object.Object.Monitor"
						],
						"members": [
							{
								"endchar": 9,
								"name": "this",
								"line": 169,
								"comment": " Initializes a read/write mutex reader proxy object.\n",
								"deco": "FZC4core4sync7rwmutex14ReadWriteMutex6Reader",
								"endline": 173,
								"originalType": "()",
								"char": 9,
								"kind": "constructor"
							},
							{
								"endchar": 9,
								"name": "lock",
								"line": 179,
								"comment": " Acquires a read lock on the enclosing mutex.\n",
								"deco": "FNeZv",
								"endline": 190,
								"char": 23,
								"kind": "function",
								"overrides": [
									"object.Object.Monitor.lock"
								]
							},
							{
								"endchar": 9,
								"name": "unlock",
								"line": 196,
								"comment": " Releases a read lock on the enclosing mutex.\n",
								"deco": "FNeZv",
								"endline": 206,
								"char": 23,
								"kind": "function",
								"overrides": [
									"object.Object.Monitor.unlock"
								]
							},
							{
								"endchar": 9,
								"name": "tryLock",
								"line": 217,
								"comment": " Attempts to acquire a read lock on the enclosing mutex.  If one can\n be obtained without blocking, the lock is acquired and true is\n returned.  If not, the lock is not acquired and false is returned.\n\n Returns:\n  true if the lock was acquired and false if not.\n",
								"deco": "FZb",
								"endline": 226,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "Reader",
						"line": 163,
						"comment": "\n\n\n\n This class can be considered a mutex in its own right, and is used to\n negotiate a read lock for the enclosing mutex.\n",
						"char": 5,
						"kind": "class"
					},
					{
						"interfaces": [
							"object.Object.Monitor"
						],
						"members": [
							{
								"endchar": 9,
								"name": "this",
								"line": 272,
								"comment": " Initializes a read/write mutex writer proxy object.\n",
								"deco": "FZC4core4sync7rwmutex14ReadWriteMutex6Writer",
								"endline": 276,
								"originalType": "()",
								"char": 9,
								"kind": "constructor"
							},
							{
								"endchar": 9,
								"name": "lock",
								"line": 282,
								"comment": " Acquires a write lock on the enclosing mutex.\n",
								"deco": "FNeZv",
								"endline": 293,
								"char": 23,
								"kind": "function",
								"overrides": [
									"object.Object.Monitor.lock"
								]
							},
							{
								"endchar": 9,
								"name": "unlock",
								"line": 299,
								"comment": " Releases a write lock on the enclosing mutex.\n",
								"deco": "FNeZv",
								"endline": 322,
								"char": 23,
								"kind": "function",
								"overrides": [
									"object.Object.Monitor.unlock"
								]
							},
							{
								"endchar": 9,
								"name": "tryLock",
								"line": 333,
								"comment": " Attempts to acquire a write lock on the enclosing mutex.  If one can\n be obtained without blocking, the lock is acquired and true is\n returned.  If not, the lock is not acquired and false is returned.\n\n Returns:\n  true if the lock was acquired and false if not.\n",
								"deco": "FZb",
								"endline": 342,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "Writer",
						"line": 266,
						"comment": "\n\n\n\n This class can be considered a mutex in its own right, and is used to\n negotiate a write lock for the enclosing mutex.\n",
						"char": 5,
						"kind": "class"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The read/write mutex module provides a primitive for maintaining shared read\n access and mutually exclusive write access.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_rwmutex.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/config.d",
		"name": "core.sync.config",
		"members": [],
		"comment": " The config module contains utility routines and configuration information\n specific to this package.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_config.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/mutex.d",
		"name": "core.sync.mutex",
		"members": [
			{
				"interfaces": [
					"object.Object.Monitor"
				],
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 61,
						"comment": "\n\n\n\n Initializes a mutex object.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FNbNeZC4core4sync5mutex5Mutex",
						"endline": 83,
						"originalType": "nothrow @trusted ()",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 92,
						"comment": " Initializes a mutex object and sets it as the monitor for o.\n\n In:\n  o must not already have a monitor.\n",
						"deco": "FNbNeC6ObjectZC4core4sync5mutex5Mutex",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 101,
						"originalType": "nothrow @trusted (Object o)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "lock",
						"line": 131,
						"comment": "\n\n\n\n If this lock is not already held by the caller, the lock is acquired,\n then the internal counter is incremented by one.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FNeZv",
						"endline": 134,
						"char": 19,
						"kind": "function",
						"overrides": [
							"object.Object.Monitor.lock"
						]
					},
					{
						"endchar": 5,
						"name": "unlock",
						"line": 162,
						"comment": " Decrements the internal lock count by one.  If this brings the count to\n zero, the lock is released.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FNeZv",
						"endline": 165,
						"char": 19,
						"kind": "function",
						"overrides": [
							"object.Object.Monitor.unlock"
						]
					},
					{
						"endchar": 5,
						"name": "tryLock",
						"line": 197,
						"comment": " If the lock is held by another caller, the method returns.  Otherwise,\n the lock is acquired if it is not already held, and then the internal\n counter is incremented by one.\n\n Throws:\n  SyncError on error.\n\n Returns:\n  true if the lock was acquired and false if not.\n",
						"deco": "FZb",
						"endline": 207,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "Mutex",
				"line": 47,
				"comment": "\n\n\n\n This class represents a general purpose, recursive mutex.\n",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The mutex module provides a primitive for maintaining mutually exclusive\n access.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_mutex.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/exception.d",
		"name": "core.sync.exception",
		"members": [
			{
				"members": [],
				"name": "SyncError",
				"line": 21,
				"comment": " Base class for synchronization errors.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " Define base class for synchronization exceptions.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_exception.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/cpuid.d",
		"name": "core.cpuid",
		"members": [
			{
				"name": "CacheInfo",
				"line": 96,
				"comment": "Cache size and behaviour\n",
				"members": [
					{
						"offset": 0,
						"name": "size",
						"line": 102,
						"comment": "Size of the cache, in kilobytes, per CPU.\n\nFor L1 unified (data + code) caches, this size is half the physical size.\n\n(we don't halve it for larger sizes, since normally\n\ndata size is much greater than code size for critical loops).\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@trusted"
						]
					},
					{
						"offset": 8,
						"name": "associativity",
						"line": 110,
						"comment": "Number of ways of associativity, eg:\n\n$(UL\n\n$(LI 1 = direct mapped)\n\n$(LI 2 = 2-way set associative)\n\n$(LI 3 = 3-way set associative)\n\n$(LI ubyte.max = fully associative)\n\n)\n",
						"deco": "h",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"@trusted"
						]
					},
					{
						"offset": 12,
						"name": "lineSize",
						"line": 112,
						"comment": "Number of bytes read into the cache when a cache miss occurs.\n",
						"deco": "k",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"@trusted"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "datacache",
				"line": 118,
				"comment": "$(RED Scheduled for deprecation. Please use $(D dataCaches) instead.)\n",
				"deco": "G5S4core5cpuid9CacheInfo",
				"char": 28,
				"kind": "variable",
				"storageClass": [
					"nothrow",
					"__gshared",
					"@nogc",
					"@trusted"
				]
			},
			{
				"endchar": 60,
				"name": "dataCaches",
				"line": 124,
				"comment": "The data caches. If there are fewer than 5 physical caches levels,\n\nthe remaining levels are set to size_t.max (== entire memory space)\n",
				"deco": "FNaNbNdNiNeZxG5S4core5cpuid9CacheInfo",
				"endline": 124,
				"originalType": "pure nothrow @nogc @property @trusted const(CacheInfo)[5]()",
				"char": 25,
				"kind": "function"
			},
			{
				"endchar": 41,
				"name": "vendor",
				"line": 129,
				"comment": "Returns vendor string, for display purposes only.\n\nDo NOT use this to determine features!\n\nNote that some CPUs have programmable vendorIDs.\n",
				"deco": "FNaNbNdNiNeZAya",
				"endline": 129,
				"char": 12,
				"kind": "function"
			},
			{
				"endchar": 44,
				"name": "processor",
				"line": 131,
				"comment": "Returns processor string, for display purposes only\n",
				"deco": "FNaNbNdNiNeZAya",
				"endline": 131,
				"char": 12,
				"kind": "function"
			},
			{
				"endchar": 44,
				"name": "x87onChip",
				"line": 134,
				"comment": "Does it have an x87 FPU on-chip?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 134,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 38,
				"name": "mmx",
				"line": 136,
				"comment": "Is MMX supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 136,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 38,
				"name": "sse",
				"line": 138,
				"comment": "Is SSE supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 138,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 39,
				"name": "sse2",
				"line": 140,
				"comment": "Is SSE2 supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 140,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 39,
				"name": "sse3",
				"line": 142,
				"comment": "Is SSE3 supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 142,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 41,
				"name": "ssse3",
				"line": 144,
				"comment": "Is SSSE3 supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 144,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 40,
				"name": "sse41",
				"line": 146,
				"comment": "Is SSE4.1 supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 146,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 40,
				"name": "sse42",
				"line": 148,
				"comment": "Is SSE4.2 supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 148,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 40,
				"name": "sse4a",
				"line": 150,
				"comment": "Is SSE4a supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 150,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 38,
				"name": "aes",
				"line": 152,
				"comment": "Is AES supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 152,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 47,
				"name": "hasPclmulqdq",
				"line": 154,
				"comment": "Is pclmulqdq supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 154,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 44,
				"name": "hasRdrand",
				"line": 156,
				"comment": "Is rdrand supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 156,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 38,
				"name": "avx",
				"line": 158,
				"comment": "Is AVX supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 158,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 39,
				"name": "vaes",
				"line": 160,
				"comment": "Is VEX-Encoded AES supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 160,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 49,
				"name": "hasVpclmulqdq",
				"line": 162,
				"comment": "Is vpclmulqdq supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 162,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 38,
				"name": "fma",
				"line": 164,
				"comment": "Is FMA supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 164,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 40,
				"name": "fp16c",
				"line": 166,
				"comment": "Is FP16C supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 166,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 39,
				"name": "avx2",
				"line": 168,
				"comment": "Is AVX2 supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 168,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 38,
				"name": "hle",
				"line": 170,
				"comment": "Is HLE (hardware lock elision) supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 170,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 38,
				"name": "rtm",
				"line": 172,
				"comment": "Is RTM (restricted transactional memory) supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 172,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 44,
				"name": "hasRdseed",
				"line": 174,
				"comment": "Is rdseed supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 174,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 41,
				"name": "hasSha",
				"line": 176,
				"comment": "Is SHA supported\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 176,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 43,
				"name": "amd3dnow",
				"line": 178,
				"comment": "Is AMD 3DNOW supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 178,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 46,
				"name": "amd3dnowExt",
				"line": 180,
				"comment": "Is AMD 3DNOW Ext supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 180,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 41,
				"name": "amdMmx",
				"line": 182,
				"comment": "Are AMD extensions to MMX supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 182,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 46,
				"name": "hasFxsr",
				"line": 184,
				"comment": "Is fxsave/fxrstor supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 184,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 46,
				"name": "hasCmov",
				"line": 186,
				"comment": "Is cmov supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 186,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 47,
				"name": "hasRdtsc",
				"line": 188,
				"comment": "Is rdtsc supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 188,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 51,
				"name": "hasCmpxchg8b",
				"line": 190,
				"comment": "Is cmpxchg8b supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 190,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 52,
				"name": "hasCmpxchg16b",
				"line": 192,
				"comment": "Is cmpxchg8b supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 192,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 59,
				"name": "hasSysEnterSysExit",
				"line": 194,
				"comment": "Is SYSENTER/SYSEXIT supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 194,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 57,
				"name": "has3dnowPrefetch",
				"line": 196,
				"comment": "Is 3DNow prefetch supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 196,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 52,
				"name": "hasLahfSahf",
				"line": 198,
				"comment": "Are LAHF and SAHF supported in 64-bit mode?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 198,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 48,
				"name": "hasPopcnt",
				"line": 200,
				"comment": "Is POPCNT supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 200,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 47,
				"name": "hasLzcnt",
				"line": 202,
				"comment": "Is LZCNT supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 202,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 47,
				"name": "isX86_64",
				"line": 204,
				"comment": "Is this an Intel64 or AMD 64?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 204,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 50,
				"name": "isItanium",
				"line": 207,
				"comment": "Is this an IA64 (Itanium) processor?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 207,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 55,
				"name": "hyperThreading",
				"line": 210,
				"comment": "Is hyperthreading supported?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 210,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 52,
				"name": "threadsPerCPU",
				"line": 212,
				"comment": "Returns number of threads per CPU\n",
				"deco": "FNaNbNdNiNeZk",
				"endline": 212,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 50,
				"name": "coresPerCPU",
				"line": 214,
				"comment": "Returns number of cores in CPU\n",
				"deco": "FNaNbNdNiNeZk",
				"endline": 214,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 49,
				"name": "preferAthlon",
				"line": 246,
				"comment": "Optimisation hints for assembly code.\n\n\n\nFor forward compatibility, the CPU is compared against different\n\nmicroarchitectures. For 32-bit x86, comparisons are made against\n\nthe Intel PPro/PII/PIII/PM family.\n\n\n\nThe major 32-bit x86 microarchitecture 'dynasties' have been:\n\n\n\n$(UL\n\n$(LI Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2). )\n\n$(LI AMD Athlon (K7, K8, K10). )\n\n$(LI Intel NetBurst (Pentium 4, Pentium D). )\n\n$(LI In-order Pentium (Pentium1, PMMX, Atom) )\n\n)\n\n\n\nOther early CPUs (Nx586, AMD K5, K6, Centaur C3, Transmeta,\n\nCyrix, Rise) were mostly in-order.\n\n\n\nSome new processors do not fit into the existing categories:\n\n\n\n$(UL\n\n$(LI Intel Atom 230/330 (family 6, model 0x1C) is an in-order core. )\n\n$(LI Centaur Isiah = VIA Nano (family 6, model F) is an out-of-order core. )\n\n)\n\n\n\nWithin each dynasty, the optimisation techniques are largely\n\nidentical (eg, use instruction pairing for group 4). Major\n\ninstruction set improvements occur within each dynasty.\n\nDoes this CPU perform better on AMD K7 code than PentiumPro..Core2 code?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 246,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 53,
				"name": "preferPentium4",
				"line": 248,
				"comment": "Does this CPU perform better on Pentium4 code than PentiumPro..Core2 code?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 248,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 53,
				"name": "preferPentium1",
				"line": 250,
				"comment": "Does this CPU perform better on Pentium I code than Pentium Pro code?\n",
				"deco": "FNaNbNdNiNeZb",
				"endline": 250,
				"char": 10,
				"kind": "function"
			},
			{
				"name": "stepping",
				"line": 314,
				"comment": "$(RED Warning: This field will be turned into a property in a future release.)\n\n\n\nProcessor type (vendor-dependent).\n\nThis should be visible ONLY for display purposes.\n",
				"deco": "k",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"nothrow",
					"__gshared",
					"@nogc",
					"@trusted"
				]
			},
			{
				"name": "model",
				"line": 314,
				"comment": "$(RED Warning: This field will be turned into a property in a future release.)\n\n\n\nProcessor type (vendor-dependent).\n\nThis should be visible ONLY for display purposes.\n",
				"deco": "k",
				"char": 20,
				"kind": "variable",
				"storageClass": [
					"nothrow",
					"__gshared",
					"@nogc",
					"@trusted"
				]
			},
			{
				"name": "family",
				"line": 314,
				"comment": "$(RED Warning: This field will be turned into a property in a future release.)\n\n\n\nProcessor type (vendor-dependent).\n\nThis should be visible ONLY for display purposes.\n",
				"deco": "k",
				"char": 27,
				"kind": "variable",
				"storageClass": [
					"nothrow",
					"__gshared",
					"@nogc",
					"@trusted"
				]
			},
			{
				"name": "numCacheLevels",
				"line": 316,
				"comment": "$(RED This field has been deprecated. Please use $(D cacheLevels) instead.)\n",
				"deco": "k",
				"init": "1u",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"nothrow",
					"__gshared",
					"@nogc",
					"@trusted"
				]
			},
			{
				"endchar": 59,
				"name": "cacheLevels",
				"line": 318,
				"comment": "The number of cache levels in the CPU.\n",
				"deco": "FNbNdNiNeZk",
				"endline": 318,
				"char": 20,
				"kind": "function",
				"storageClass": [
					"__gshared"
				]
			}
		],
		"comment": " Identify the characteristics of the host CPU, providing information\n about cache sizes and assembly optimisation hints. This module is\n provided primarily for assembly language programmers.\n\n References:\n Some of this information was extremely difficult to track down. Some of the\n documents below were found only in cached versions stored by search engines!\n This code relies on information found in:\n\n $(UL\n $(LI \"Intel(R) 64 and IA-32 Architectures Software Developers Manual,\n    Volume 2A: Instruction Set Reference, A-M\" (2007).\n )\n $(LI \"AMD CPUID Specification\", Advanced Micro Devices, Rev 2.28 (2008).\n )\n $(LI \"AMD Processor Recognition Application Note For Processors Prior to AMD\n    Family 0Fh Processors\", Advanced Micro Devices, Rev 3.13 (2005).\n )\n $(LI \"AMD Geode(TM) GX Processors Data Book\",\n    Advanced Micro Devices, Publication ID 31505E, (2005).\n )\n $(LI \"AMD K6 Processor Code Optimisation\", Advanced Micro Devices, Rev D (2000).\n )\n $(LI \"Application note 106: Software Customization for the 6x86 Family\",\n    Cyrix Corporation, Rev 1.5 (1998)\n )\n $(LI $(LINK http://www.datasheetcatalog.org/datasheet/nationalsemiconductor/GX1.pdf))\n $(LI \"Geode(TM) GX1 Processor Series Low Power Integrated X86 Solution\",\n   National Semiconductor, (2002)\n )\n $(LI \"The VIA Isaiah Architecture\", G. Glenn Henry, Centaur Technology, Inc (2008).\n )\n $(LI $(LINK http://www.sandpile.org/ia32/cpuid.htm))\n $(LI $(LINK http://www.akkadia.org/drepper/cpumemory.pdf))\n $(LI \"What every programmer should know about memory\",\n    Ulrich Depper, Red Hat, Inc., (2007).\n )\n $(LI \"CPU Identification by the Windows Kernel\", G. Chappell (2009).\n   $(LINK http://www.geoffchappell.com/viewer.htm?doc=studies/windows/km/cpu/cx8.htm)\n )\n $(LI \"Intel(R) Processor Identification and the CPUID Instruction, Application\n    Note 485\" (2009).\n )\n )\n\n Bugs: Currently only works on x86 and Itanium CPUs.\n      Many processors have bugs in their microcode for the CPUID instruction,\n      so sometimes the cache information may be incorrect.\n\n Copyright: Copyright Don Clugston 2007 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Don Clugston, Tomas Lindquist Olsen &lt;tomas@famolsen.dk&gt;\n Source:    $(DRUNTIMESRC core/_cpuid.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/memory.d",
		"name": "core.memory",
		"members": [
			{
				"name": "GC",
				"line": 155,
				"comment": " This struct encapsulates all garbage collection functionality for the D\n programming language.\n",
				"members": [
					{
						"endchar": 5,
						"name": "enable",
						"line": 165,
						"comment": " Enables automatic garbage collection behavior if collections have\n previously been suspended by a call to disable.  This function is\n reentrant, and must be called once for every call to disable before\n automatic collections are enabled.\n",
						"deco": "FNbZv",
						"endline": 168,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "disable",
						"line": 178,
						"comment": " Disables automatic garbage collections performed to minimize the\n process footprint.  Collections may continue to occur in instances\n where the implementation deems necessary for correct program behavior,\n such as during an out of memory condition.  This function is reentrant,\n but enable must be called once for each call to disable.\n",
						"deco": "FNbZv",
						"endline": 181,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "collect",
						"line": 191,
						"comment": " Begins a full collection.  While the meaning of this may change based\n on the garbage collector implementation, typical behavior is to scan\n all stack segments for roots, mark accessible memory blocks as alive,\n and then to reclaim free space.  This action may need to suspend all\n running threads for at least part of the collection process.\n",
						"deco": "FNbZv",
						"endline": 194,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "minimize",
						"line": 201,
						"comment": " Indicates that the managed memory space be minimized by returning free\n physical memory to the operating system.  The amount of free memory\n returned depends on the allocator design and on program behavior.\n",
						"deco": "FNbZv",
						"endline": 204,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"members": [
							{
								"name": "NONE",
								"line": 213,
								"value": "0u",
								"comment": "No attributes set.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "FINALIZE",
								"line": 214,
								"value": "1u",
								"comment": "Finalize the data in this block on collect.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "NO_SCAN",
								"line": 215,
								"value": "2u",
								"comment": "Do not scan through this block on collect.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "NO_MOVE",
								"line": 216,
								"value": "4u",
								"comment": "Do not move this memory block on collect.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "APPENDABLE",
								"line": 238,
								"value": "8u",
								"comment": "        This block contains the info to allow appending.\n\n        This can be used to manually allocate arrays. Initial slice size is 0.\n\n        Note: The slice's useable size will not match the block size. Use\n        $(LREF capacity) to retrieve actual useable capacity.\n\n        Example:\n        ----\n        // Allocate the underlying array.\n        int*  pToArray = cast(int*)GC.malloc(10 * int.sizeof, GC.BlkAttr.NO_SCAN | GC.BlkAttr.APPENDABLE);\n        // Bind a slice. Check the slice has capacity information.\n        int[] slice = pToArray[0 .. 0];\n        assert(capacity(slice) > 0);\n        // Appending to the slice will not relocate it.\n        slice.length = 5;\n        slice ~= 1;\n        assert(slice.ptr == p);\n        ----\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "NO_INTERIOR",
								"line": 246,
								"value": "16u",
								"comment": "        This block is guaranteed to have a pointer to its base while it is\n        alive.  Interior pointers can be safely ignored.  This attribute is\n        useful for eliminating false pointers in very large data structures\n        and is only implemented for data structures at least a page in size.\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "BlkAttr",
						"line": 211,
						"comment": " Elements for a bit field representing memory block attributes.  These\n are manipulated via the getAttr, setAttr, clrAttr functions.\n",
						"baseDeco": "k",
						"char": 5,
						"kind": "enum"
					},
					{
						"name": "BlkInfo",
						"line": 261,
						"comment": " Contains aggregate information about a block of managed memory.  The\n purpose of this struct is to support a more efficient query style in\n instances where detailed information is needed.\n\n base = A pointer to the base of the block in question.\n size = The size of the block, calculated from base.\n attr = Attribute bits set on the memory block.\n",
						"deco": "S4core6memory8BlkInfo_",
						"char": 20,
						"kind": "alias"
					},
					{
						"endchar": 5,
						"name": "getAttr",
						"line": 277,
						"comment": " Returns a bit field representing all block attributes set for the memory\n referenced by p.  If p references memory not originally allocated by\n this garbage collector, points to the interior of a memory block, or if\n p is null, zero will be returned.\n\n Params:\n  p = A pointer to the root of a valid memory block or to null.\n\n Returns:\n  A bit field containing any bits set for the memory block referenced by\n  p or zero on error.\n",
						"deco": "FNbxPvZk",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 280,
						"originalType": "nothrow uint(in void* p)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getAttr",
						"line": 284,
						"comment": "ditto\n",
						"deco": "FNaNbPvZk",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 287,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "setAttr",
						"line": 304,
						"comment": " Sets the specified bits for the memory references by p.  If p references\n memory not originally allocated by this garbage collector, points to the\n interior of a memory block, or if p is null, no action will be\n performed.\n\n Params:\n  p = A pointer to the root of a valid memory block or to null.\n  a = A bit field containing any bits to set for this memory block.\n\n Returns:\n  The result of a call to getAttr after the specified bits have been\n  set.\n",
						"deco": "FNbxPvkZk",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							},
							{
								"name": "a",
								"deco": "k"
							}
						],
						"endline": 307,
						"originalType": "nothrow uint(in void* p, uint a)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "setAttr",
						"line": 311,
						"comment": "ditto\n",
						"deco": "FNaNbPvkZk",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							},
							{
								"name": "a",
								"deco": "k"
							}
						],
						"endline": 314,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "clrAttr",
						"line": 331,
						"comment": " Clears the specified bits for the memory references by p.  If p\n references memory not originally allocated by this garbage collector,\n points to the interior of a memory block, or if p is null, no action\n will be performed.\n\n Params:\n  p = A pointer to the root of a valid memory block or to null.\n  a = A bit field containing any bits to clear for this memory block.\n\n Returns:\n  The result of a call to getAttr after the specified bits have been\n  cleared.\n",
						"deco": "FNbxPvkZk",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							},
							{
								"name": "a",
								"deco": "k"
							}
						],
						"endline": 334,
						"originalType": "nothrow uint(in void* p, uint a)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "clrAttr",
						"line": 338,
						"comment": "ditto\n",
						"deco": "FNaNbPvkZk",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							},
							{
								"name": "a",
								"deco": "k"
							}
						],
						"endline": 341,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "malloc",
						"line": 364,
						"comment": " Requests an aligned block of managed memory from the garbage collector.\n This memory may be deleted at will with a call to free, or it may be\n discarded and cleaned up automatically during a collection run.  If\n allocation fails, this function will call onOutOfMemory which is\n expected to throw an OutOfMemoryError.\n\n Params:\n  sz = The desired allocation size in bytes.\n  ba = A bitmask of the attributes to set on this block.\n  ti = TypeInfo to describe the memory. The GC might use this information\n       to improve scanning for pointers or to call finalizers.\n\n Returns:\n  A reference to the allocated memory or null if insufficient memory\n  is available.\n\n Throws:\n  OutOfMemoryError on allocation failure.\n",
						"deco": "FNaNbmkxC8TypeInfoZPv",
						"parameters": [
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ba",
								"deco": "k",
								"default": "0u"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 367,
						"originalType": "pure nothrow void*(size_t sz, uint ba = 0, const TypeInfo ti = null)",
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "qalloc",
						"line": 390,
						"comment": " Requests an aligned block of managed memory from the garbage collector.\n This memory may be deleted at will with a call to free, or it may be\n discarded and cleaned up automatically during a collection run.  If\n allocation fails, this function will call onOutOfMemory which is\n expected to throw an OutOfMemoryError.\n\n Params:\n  sz = The desired allocation size in bytes.\n  ba = A bitmask of the attributes to set on this block.\n  ti = TypeInfo to describe the memory. The GC might use this information\n       to improve scanning for pointers or to call finalizers.\n\n Returns:\n  Information regarding the allocated memory block or BlkInfo.init on\n  error.\n\n Throws:\n  OutOfMemoryError on allocation failure.\n",
						"deco": "FNaNbmkxC8TypeInfoZS4core6memory8BlkInfo_",
						"parameters": [
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ba",
								"deco": "k",
								"default": "0u"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 393,
						"originalType": "pure nothrow BlkInfo(size_t sz, uint ba = 0, const TypeInfo ti = null)",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "calloc",
						"line": 417,
						"comment": " Requests an aligned block of managed memory from the garbage collector,\n which is initialized with all bits set to zero.  This memory may be\n deleted at will with a call to free, or it may be discarded and cleaned\n up automatically during a collection run.  If allocation fails, this\n function will call onOutOfMemory which is expected to throw an\n OutOfMemoryError.\n\n Params:\n  sz = The desired allocation size in bytes.\n  ba = A bitmask of the attributes to set on this block.\n  ti = TypeInfo to describe the memory. The GC might use this information\n       to improve scanning for pointers or to call finalizers.\n\n Returns:\n  A reference to the allocated memory or null if insufficient memory\n  is available.\n\n Throws:\n  OutOfMemoryError on allocation failure.\n",
						"deco": "FNaNbmkxC8TypeInfoZPv",
						"parameters": [
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ba",
								"deco": "k",
								"default": "0u"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 420,
						"originalType": "pure nothrow void*(size_t sz, uint ba = 0, const TypeInfo ti = null)",
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "realloc",
						"line": 457,
						"comment": " If sz is zero, the memory referenced by p will be deallocated as if\n by a call to free.  A new memory block of size sz will then be\n allocated as if by a call to malloc, or the implementation may instead\n resize the memory block in place.  The contents of the new memory block\n will be the same as the contents of the old memory block, up to the\n lesser of the new and old sizes.  Note that existing memory will only\n be freed by realloc if sz is equal to zero.  The garbage collector is\n otherwise expected to later reclaim the memory block if it is unused.\n If allocation fails, this function will call onOutOfMemory which is\n expected to throw an OutOfMemoryError.  If p references memory not\n originally allocated by this garbage collector, or if it points to the\n interior of a memory block, no action will be taken.  If ba is zero\n (the default) and p references the head of a valid, known memory block\n then any bits set on the current block will be set on the new block if a\n reallocation is required.  If ba is not zero and p references the head\n of a valid, known memory block then the bits in ba will replace those on\n the current memory block and will also be set on the new block if a\n reallocation is required.\n\n Params:\n  p  = A pointer to the root of a valid memory block or to null.\n  sz = The desired allocation size in bytes.\n  ba = A bitmask of the attributes to set on this block.\n  ti = TypeInfo to describe the memory. The GC might use this information\n       to improve scanning for pointers or to call finalizers.\n\n Returns:\n  A reference to the allocated memory on success or null if sz is\n  zero.  On failure, the original value of p is returned.\n\n Throws:\n  OutOfMemoryError on allocation failure.\nExample:\nIssue 13111$(DDOX_UNITTEST_HEADER __unittestL463_439)\n---\nenum size1 = 1 << 11 + 1; // page in large object pool\nenum size2 = 1 << 22 + 1; // larger than large object pool size\n\nauto data1 = cast(ubyte*)GC.calloc(size1);\nauto data2 = cast(ubyte*)GC.realloc(data1, size2);\n\nBlkInfo info = query(data2);\nassert(info.size >= size2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL463_439)\n",
						"deco": "FNaNbPvmkxC8TypeInfoZPv",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							},
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ba",
								"deco": "k",
								"default": "0u"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 460,
						"originalType": "pure nothrow void*(void* p, size_t sz, uint ba = 0, const TypeInfo ti = null)",
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "extend",
						"line": 501,
						"comment": " Requests that the managed memory block referenced by p be extended in\n place by at least mx bytes, with a desired extension of sz bytes.  If an\n extension of the required size is not possible or if p references memory\n not originally allocated by this garbage collector, no action will be\n taken.\n\n Params:\n  p  = A pointer to the root of a valid memory block or to null.\n  mx = The minimum extension size in bytes.\n  sz = The desired extension size in bytes.\n  ti = TypeInfo to describe the full memory block. The GC might use\n       this information to improve scanning for pointers or to\n       call finalizers.\n\n Returns:\n  The size in bytes of the extended memory block referenced by p or zero\n  if no extension occurred.\n\n Note:\n  Extend may also be used to extend slices (or memory blocks with\n  $(LREF APPENDABLE) info). However, use the return value only\n  as an indicator of success. $(LREF capacity) should be used to\n  retrieve actual useable slice capacity.\nExample:\nStandard extending$(DDOX_UNITTEST_HEADER __unittestL506_440)\n---\nsize_t size = 1000;\nint* p = cast(int*)GC.malloc(size * int.sizeof, GC.BlkAttr.NO_SCAN);\n\n//Try to extend the allocated data by 1000 elements, preferred 2000.\nsize_t u = GC.extend(p, 1000 * int.sizeof, 2000 * int.sizeof);\nif (u != 0)\n    size = u / int.sizeof;\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL506_440)\nExample:\nslice extending$(DDOX_UNITTEST_HEADER __unittestL517_441)\n---\nint[] slice = new int[](1000);\nint*  p     = slice.ptr;\n\n//Check we have access to capacity before attempting the extend\nif (slice.capacity)\n{\n    //Try to extend slice by 1000 elements, preferred 2000.\n    size_t u = GC.extend(p, 1000 * int.sizeof, 2000 * int.sizeof);\n    if (u != 0)\n    {\n        slice.length = slice.capacity;\n        assert(slice.length >= 2000);\n    }\n}\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL517_441)\n",
						"deco": "FNaNbPvmmxC8TypeInfoZm",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							},
							{
								"name": "mx",
								"deco": "m"
							},
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 504,
						"originalType": "pure nothrow size_t(void* p, size_t mx, size_t sz, const TypeInfo ti = null)",
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "reserve",
						"line": 546,
						"comment": " Requests that at least sz bytes of memory be obtained from the operating\n system and marked as free.\n\n Params:\n  sz = The desired size in bytes.\n\n Returns:\n  The actual number of bytes reserved or zero on error.\n",
						"deco": "FNbmZm",
						"parameters": [
							{
								"name": "sz",
								"deco": "m"
							}
						],
						"endline": 549,
						"originalType": "nothrow size_t(size_t sz)",
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "free",
						"line": 563,
						"comment": " Deallocates the memory referenced by p.  If p is null, no action\n occurs.  If p references memory not originally allocated by this\n garbage collector, or if it points to the interior of a memory block,\n no action will be taken.  The block will not be finalized regardless\n of whether the FINALIZE attribute is set.  If finalization is desired,\n use delete instead.\n\n Params:\n  p = A pointer to the root of a valid memory block or to null.\n",
						"deco": "FNaNbPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 566,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "addrOf",
						"line": 584,
						"comment": " Returns the base address of the memory block containing p.  This value\n is useful to determine whether p is an interior pointer, and the result\n may be passed to routines such as sizeOf which may otherwise fail.  If p\n references memory not originally allocated by this garbage collector, if\n p is null, or if the garbage collector does not support this operation,\n null will be returned.\n\n Params:\n  p = A pointer to the root or the interior of a valid memory block or to\n      null.\n\n Returns:\n  The base address of the memory block referenced by p or null on error.\n",
						"deco": "FNbPNgvZPNgv",
						"parameters": [
							{
								"name": "p",
								"deco": "PNgv"
							}
						],
						"endline": 587,
						"char": 25,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "addrOf",
						"line": 591,
						"comment": "ditto\n",
						"deco": "FNaNbPvZPv",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 594,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "sizeOf",
						"line": 610,
						"comment": " Returns the true size of the memory block referenced by p.  This value\n represents the maximum number of bytes for which a call to realloc may\n resize the existing block in place.  If p references memory not\n originally allocated by this garbage collector, points to the interior\n of a memory block, or if p is null, zero will be returned.\n\n Params:\n  p = A pointer to the root of a valid memory block or to null.\n\n Returns:\n  The size in bytes of the memory block referenced by p or zero on error.\n",
						"deco": "FNbxPvZm",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 613,
						"originalType": "nothrow size_t(in void* p)",
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "sizeOf",
						"line": 617,
						"comment": "ditto\n",
						"deco": "FNaNbPvZm",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 620,
						"originalType": "pure nothrow size_t(void* p)",
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "query",
						"line": 648,
						"comment": " Returns aggregate information about the memory block containing p.  If p\n references memory not originally allocated by this garbage collector, if\n p is null, or if the garbage collector does not support this operation,\n BlkInfo.init will be returned.  Typically, support for this operation\n is dependent on support for addrOf.\n\n Params:\n  p = A pointer to the root or the interior of a valid memory block or to\n      null.\n\n Returns:\n  Information regarding the memory block referenced by p or BlkInfo.init\n  on error.\n",
						"deco": "FNbxPvZS4core6memory8BlkInfo_",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 651,
						"originalType": "nothrow BlkInfo(in void* p)",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "query",
						"line": 655,
						"comment": "ditto\n",
						"deco": "FNaNbPvZS4core6memory8BlkInfo_",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 658,
						"originalType": "pure nothrow BlkInfo(void* p)",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "addRoot",
						"line": 706,
						"comment": " Adds an internal root pointing to the GC memory block referenced by p.\n As a result, the block referenced by p itself and any blocks accessible\n via it will be considered live until the root is removed again.\n\n If p is null, no operation is performed.\n\n Params:\n  p = A pointer into a GC-managed memory block or null.\n\n Example:\n ---\n // Typical C-style callback mechanism; the passed function\n // is invoked with the user-supplied context pointer at a\n // later point.\n extern(C) void addCallback(void function(void*), void*);\n\n // Allocate an object on the GC heap (this would usually be\n // some application-specific context data).\n auto context = new Object;\n\n // Make sure that it is not collected even if it is no\n // longer referenced from D code (stack, GC heap, …).\n GC.addRoot(cast(void*)context);\n\n // Also ensure that a moving collector does not relocate\n // the object.\n GC.setAttr(cast(void*)context, GC.BlkAttr.NO_MOVE);\n\n // Now context can be safely passed to the C library.\n addCallback(&myHandler, cast(void*)context);\n\n extern(C) void myHandler(void* ctx)\n {\n     // Assuming that the callback is invoked only once, the\n     // added root can be removed again now to allow the GC\n     // to collect it later.\n     GC.removeRoot(ctx);\n     GC.clrAttr(ctx, GC.BlkAttr.NO_MOVE);\n\n     auto context = cast(Object)ctx;\n     // Use context here…\n }\n ---\n",
						"deco": "FNbxPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 709,
						"originalType": "nothrow void(in void* p)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "removeRoot",
						"line": 720,
						"comment": " Removes the memory block referenced by p from an internal list of roots\n to be scanned during a collection.  If p is null or is not a value\n previously passed to addRoot() then no operation is performed.\n\n Params:\n  p = A pointer into a GC-managed memory block or null.\n",
						"deco": "FNbxPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 723,
						"originalType": "nothrow void(in void* p)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "addRange",
						"line": 754,
						"comment": " Adds $(D p[0 .. sz]) to the list of memory ranges to be scanned for\n pointers during a collection. If p is null, no operation is performed.\n\n Note that $(D p[0 .. sz]) is treated as an opaque range of memory assumed\n to be suitably managed by the caller. In particular, if p points into a\n GC-managed memory block, addRange does $(I not) mark this block as live.\n\n Params:\n  p  = A pointer to a valid memory address or to null.\n  sz = The size in bytes of the block to add. If sz is zero then the\n       no operation will occur. If p is null then sz must be zero.\n  ti = TypeInfo to describe the memory. The GC might use this information\n       to improve scanning for pointers or to call finalizers\n\n Example:\n ---\n // Allocate a piece of memory on the C heap.\n enum size = 1_000;\n auto rawMemory = core.stdc.stdlib.malloc(size);\n\n // Add it as a GC range.\n GC.addRange(rawMemory, size);\n\n // Now, pointers to GC-managed memory stored in\n // rawMemory will be recognized on collection.\n ---\n",
						"deco": "FNbNixPvmxC8TypeInfoZv",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							},
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 757,
						"originalType": "nothrow @nogc void(in void* p, size_t sz, const TypeInfo ti = null)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "removeRange",
						"line": 769,
						"comment": " Removes the memory range starting at p from an internal list of ranges\n to be scanned during a collection. If p is null or does not represent\n a value previously passed to addRange() then no operation is\n performed.\n\n Params:\n  p  = A pointer to a valid memory address or to null.\n",
						"deco": "FNbNixPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 772,
						"originalType": "nothrow @nogc void(in void* p)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "runFinalizers",
						"line": 785,
						"comment": " Runs any finalizer that is located in address range of the\n given code segment.  This is used before unloading shared\n libraries.  All matching objects which have a finalizer in this\n code segment are assumed to be dead, using them while or after\n calling this method has undefined behavior.\n\n Params:\n  segment = address range of a code segment.\n",
						"deco": "FxAvZv",
						"parameters": [
							{
								"name": "segment",
								"deco": "xAv"
							}
						],
						"endline": 788,
						"originalType": "void(in void[] segment)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			}
		],
		"comment": " This module provides an interface to the garbage collector used by\n applications written in the D programming language. It allows the\n garbage collector in the runtime to be swapped without affecting\n binary compatibility of applications.\n\n Using this module is not necessary in typical D code. It is mostly\n useful when doing low-level _memory management.\n\n Notes_to_users:\n\n   $(OL\n   $(LI The GC is a conservative mark-and-sweep collector. It only runs a\n        collection cycle when an allocation is requested of it, never\n        otherwise. Hence, if the program is not doing allocations,\n        there will be no GC collection pauses. The pauses occur because\n        all threads the GC knows about are halted so the threads' stacks\n        and registers can be scanned for references to GC allocated data.\n   )\n\n   $(LI The GC does not know about threads that were created by directly calling\n        the OS/C runtime thread creation APIs and D threads that were detached\n        from the D runtime after creation.\n        Such threads will not be paused for a GC collection, and the GC might not detect\n        references to GC allocated data held by them. This can cause memory corruption.\n        There are several ways to resolve this issue:\n        $(OL\n        $(LI Do not hold references to GC allocated data in such threads.)\n        $(LI Register/unregister such data with calls to $(LREF addRoot)/$(LREF removeRoot) and\n        $(LREF addRange)/$(LREF removeRange).)\n        $(LI Maintain another reference to that same data in another thread that the\n        GC does know about.)\n        $(LI Disable GC collection cycles while that thread is active with $(LREF disable)/$(LREF enable).)\n        $(LI Register the thread with the GC using $(CXREF thread, thread_attachThis)/$(CXREF thread, thread_detachThis).)\n        )\n   )\n   )\n\n Notes_to_implementors:\n $(UL\n $(LI On POSIX systems, the signals SIGUSR1 and SIGUSR2 are reserved\n   by this module for use in the garbage collector implementation.\n   Typically, they will be used to stop and resume other threads\n   when performing a collection, but an implementation may choose\n   not to use this mechanism (or not stop the world at all, in the\n   case of concurrent garbage collectors).)\n\n $(LI Registers, the stack, and any other _memory locations added through\n   the $(D GC.$(LREF addRange)) function are always scanned conservatively.\n   This means that even if a variable is e.g. of type $(D float),\n   it will still be scanned for possible GC pointers. And, if the\n   word-interpreted representation of the variable matches a GC-managed\n   _memory block's address, that _memory block is considered live.)\n\n $(LI Implementations are free to scan the non-root heap in a precise\n   manner, so that fields of types like $(D float) will not be considered\n   relevant when scanning the heap. Thus, casting a GC pointer to an\n   integral type (e.g. $(D size_t)) and storing it in a field of that\n   type inside the GC heap may mean that it will not be recognized\n   if the _memory block was allocated with precise type info or with\n   the $(D GC.BlkAttr.$(LREF NO_SCAN)) attribute.)\n\n $(LI Destructors will always be executed while other threads are\n   active; that is, an implementation that stops the world must not\n   execute destructors until the world has been resumed.)\n\n $(LI A destructor of an object must not access object references\n   within the object. This means that an implementation is free to\n   optimize based on this rule.)\n\n $(LI An implementation is free to perform heap compaction and copying\n   so long as no valid GC pointers are invalidated in the process.\n   However, _memory allocated with $(D GC.BlkAttr.$(LREF NO_MOVE)) must\n   not be moved/copied.)\n\n $(LI Implementations must support interior pointers. That is, if the\n   only reference to a GC-managed _memory block points into the\n   middle of the block rather than the beginning (for example), the\n   GC must consider the _memory block live. The exception to this\n   rule is when a _memory block is allocated with the\n   $(D GC.BlkAttr.$(LREF NO_INTERIOR)) attribute; it is the user's\n   responsibility to make sure such _memory blocks have a proper pointer\n   to them when they should be considered live.)\n\n $(LI It is acceptable for an implementation to store bit flags into\n   pointer values and GC-managed _memory blocks, so long as such a\n   trick is not visible to the application. In practice, this means\n   that only a stop-the-world collector can do this.)\n\n $(LI Implementations are free to assume that GC pointers are only\n   stored on word boundaries. Unaligned pointers may be ignored\n   entirely.)\n\n $(LI Implementations are free to run collections at any point. It is,\n   however, recommendable to only do so when an allocation attempt\n   happens and there is insufficient _memory available.)\n )\n\n Copyright: Copyright Sean Kelly 2005 - 2015.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly, Alex Rønne Petersen\n Source:    $(DRUNTIMESRC core/_memory.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/functional.d",
		"name": "std.functional",
		"members": [
			{
				"members": [],
				"name": "unaryFun",
				"line": 107,
				"comment": "Transforms a string representing an expression into a unary\nfunction. The string must either use symbol name $(D a) as\nthe parameter or provide the symbol via the $(D parmName) argument.\nIf $(D fun) is not a string, $(D unaryFun) aliases itself away to $(D fun).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL134_443)\n---\n// Strings are compiled into functions:\nalias isEven = unaryFun!(\"(a & 1) == 0\");\nassert(isEven(2) && !isEven(1));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL134_443)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "parmName",
						"defaultValue": "\"a\"",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "binaryFun",
				"line": 191,
				"comment": "Transforms a string representing an expression into a binary function. The\nstring must either use symbol names $(D a) and $(D b) as the parameters or\nprovide the symbols via the $(D parm1Name) and $(D parm2Name) arguments.\nIf $(D fun) is not a string, $(D binaryFun) aliases itself away to\n$(D fun).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL221_445)\n---\nalias less = binaryFun!(\"a < b\");\nassert(less(1, 2) && !less(2, 1));\nalias greater = binaryFun!(\"a > b\");\nassert(!greater(\"1\", \"2\") && greater(\"2\", \"1\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL221_445)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "parm1Name",
						"defaultValue": "\"a\"",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "parm2Name",
						"defaultValue": "\"b\"",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "lessThan",
				"line": 484,
				"comment": "   Predicate that returns $(D_PARAM a < b).\n   Correctly compares signed and unsigned integers, ie. -1 < 2U.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL487_450)\n---\nassert(lessThan(2, 3));\nassert(lessThan(2U, 3U));\nassert(lessThan(2, 3.0));\nassert(lessThan(-2, 3U));\nassert(lessThan(2, 3U));\nassert(!lessThan(3U, -2));\nassert(!lessThan(3U, 2));\nassert(!lessThan(0, 0));\nassert(!lessThan(0U, 0));\nassert(!lessThan(0, 0U));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL487_450)\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "greaterThan",
				"line": 505,
				"comment": "   Predicate that returns $(D_PARAM a > b).\n   Correctly compares signed and unsigned integers, ie. 2U > -1.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL508_451)\n---\nassert(!greaterThan(2, 3));\nassert(!greaterThan(2U, 3U));\nassert(!greaterThan(2, 3.0));\nassert(!greaterThan(-2, 3U));\nassert(!greaterThan(2, 3U));\nassert(greaterThan(3U, -2));\nassert(greaterThan(3U, 2));\nassert(!greaterThan(0, 0));\nassert(!greaterThan(0U, 0));\nassert(!greaterThan(0, 0U));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL508_451)\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "equalTo",
				"line": 526,
				"comment": "   Predicate that returns $(D_PARAM a == b).\n   Correctly compares signed and unsigned integers, ie. !(-1 == ~0U).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL529_452)\n---\nassert(equalTo(0U, 0));\nassert(equalTo(0, 0U));\nassert(!equalTo(-1, ~0U));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL529_452)\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "reverseArgs",
								"line": 541,
								"type": "(auto ref Args args)",
								"parameters": [
									{
										"name": "args",
										"type": "Args",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 545,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "reverseArgs",
						"line": 541,
						"parameters": [
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"constraint": "is(typeof(pred(Reverse!args)))",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "reverseArgs",
				"line": 539,
				"comment": "   N-ary predicate that reverses the order of arguments, e.g., given\n   $(D pred(a, b, c)), returns $(D pred(c, b, a)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL549_453)\n---\nalias gt = reverseArgs!(binaryFun!(\"a < b\"));\nassert(gt(2, 1) && !gt(1, 1));\nint x = 42;\nbool xyz(int a, int b) { return a * x < b / x; }\nauto foo = &xyz;\nfoo(4, 5);\nalias zyx = reverseArgs!(foo);\nassert(zyx(5, 4) == foo(4, 5));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL549_453)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL562_454)\n---\nint abc(int a, int b, int c) { return a * b + c; }\nalias cba = reverseArgs!abc;\nassert(abc(91, 17, 32) == cba(32, 17, 91));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL562_454)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL570_455)\n---\nint a(int a) { return a * 2; }\nalias _a = reverseArgs!a;\nassert(a(2) == _a(2));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL570_455)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL578_456)\n---\nint b() { return 4; }\nalias _b = reverseArgs!b;\nassert(b() == _b());\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL578_456)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "binaryReverseArgs",
								"line": 591,
								"type": "(auto ref ElementType1 a, auto ref ElementType2 b)",
								"parameters": [
									{
										"name": "a",
										"type": "ElementType1",
										"storageClass": [
											"auto",
											"ref"
										]
									},
									{
										"name": "b",
										"type": "ElementType2",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 595,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "binaryReverseArgs",
						"line": 591,
						"parameters": [
							{
								"name": "ElementType1",
								"kind": "type"
							},
							{
								"name": "ElementType2",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "binaryReverseArgs",
				"line": 589,
				"comment": "   Binary predicate that reverses the order of arguments, e.g., given\n   $(D pred(a, b)), returns $(D pred(b, a)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL599_457)\n---\nalias gt = binaryReverseArgs!(binaryFun!(\"a < b\"));\nassert(gt(2, 1) && !gt(1, 1));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL599_457)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL606_458)\n---\nint x = 42;\nbool xyz(int a, int b) { return a * x < b / x; }\nauto foo = &xyz;\nfoo(4, 5);\nalias zyx = binaryReverseArgs!(foo);\nassert(zyx(5, 4) == foo(4, 5));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL606_458)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "not",
								"line": 621,
								"type": "(auto ref T args)",
								"parameters": [
									{
										"name": "args",
										"type": "T",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 631,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "not",
						"line": 621,
						"parameters": [
							{
								"name": "T",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "not",
				"line": 619,
				"comment": "Negates predicate $(D pred).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL635_459)\n---\nimport std.functional;\nimport std.algorithm : find;\nimport std.uni : isWhite;\nstring a = \"   Hello, world!\";\nassert(find!(not!isWhite)(a) == \"Hello, world!\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL635_459)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "partial",
				"line": 671,
				"comment": "$(LINK2 http://en.wikipedia.org/wiki/Partial_application, Partially\napplies) $(D_PARAM fun) by tying its first argument to $(D_PARAM arg).\n\nExample:\n\n----\nint fun(int a, int b) { return a + b; }\nalias partial!(fun, 5) fun5;\nassert(fun5(6) == 11);\n----\n\nNote that in most cases you'd use an alias instead of a value\nassignment. Using an alias allows you to partially evaluate template\nfunctions without committing to a particular type of the function.\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "arg",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "adjoin",
						"line": 807,
						"type": "F[0]",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "adjoin",
				"line": 805,
				"comment": "Takes multiple functions and adjoins them together. The result is a\n$(XREF typecons, Tuple) with one element per passed-in function. Upon\ninvocation, the returned tuple is the adjoined results of all\nfunctions.\n\nNote: In the special case where only a single function is provided\n($(D F.length == 1)), adjoin simply aliases to the single passed function\n($(D F[0])).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL833_469)\n---\nimport std.functional, std.typecons;\nstatic bool f1(int a) { return a != 0; }\nstatic int f2(int a) { return a / 2; }\nauto x = adjoin!(f1, f2)(5);\nassert(is(typeof(x) == Tuple!(bool, int)));\nassert(x[0] == true && x[1] == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL833_469)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "tuple"
					}
				],
				"constraint": "F.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "adjoin",
								"line": 812,
								"type": "(auto ref V a)",
								"parameters": [
									{
										"name": "a",
										"type": "V",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 829,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "adjoin",
						"line": 812,
						"parameters": [
							{
								"name": "V",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "adjoin",
				"line": 810,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "F",
						"kind": "tuple"
					}
				],
				"constraint": "F.length > 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "compose",
				"line": 901,
				"comment": "   Composes passed-in functions $(D fun[0], fun[1], ...) returning a\n   function $(D f(x)) that in turn returns $(D\n   fun[0](fun[1](...(x)))...). Each function can be a regular\n   functions, a delegate, or a string.\n\n   Example:\n----\n// First split a string in whitespace-separated tokens and then\n// convert each token into an integer\nassert(compose!(map!(to!(int)), split)(\"1 2 3\") == [1, 2, 3]);\n----\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "pipe",
						"line": 941,
						"type": "compose!(Reverse!fun)",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "pipe",
				"line": 941,
				"comment": "   Pipes functions in sequence. Offers the same functionality as $(D\n   compose), but with functions specified in reverse order. This may\n   lead to more readable code in some situation because the order of\n   execution is the same as lexical order.\n\n   Example:\n\n----\n// Read an entire text file, split the resulting string in\n// whitespace-separated tokens, and then convert each token into an\n// integer\nint[] a = pipe!(readText, split, map!(to!(int)))(\"file.txt\");\n----\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "memoize",
						"line": 991,
						"type": "ReturnType!fun(Parameters!fun args)",
						"parameters": [
							{
								"name": "args",
								"type": "Parameters!fun"
							}
						],
						"endline": 1001,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "memoize",
				"line": 987,
				"comment": " $(LUCKY Memoizes) a function so as to avoid repeated\n computation. The memoization structure is a hash table keyed by a\n tuple of the function's arguments. There is a speed gain if the\n function is repeatedly called with the same arguments and is more\n expensive than a hash table lookup. For more information on memoization, refer to $(WEB docs.google.com/viewer?url=http%3A%2F%2Fhop.perl.plover.com%2Fbook%2Fpdf%2F03CachingAndMemoization.pdf, this book chapter).\n\nExample:\n----\ndouble transmogrify(int a, string b)\n{\n   ... expensive computation ...\n}\nalias fastTransmogrify = memoize!transmogrify;\nunittest\n{\n    auto slow = transmogrify(2, \"hello\");\n    auto fast = fastTransmogrify(2, \"hello\");\n    assert(slow == fast);\n}\n----\n\nTechnically the memoized function should be pure because $(D memoize) assumes it will\nalways return the same result for a given tuple of arguments. However, $(D memoize) does not\nenforce that because sometimes it\nis useful to memoize an impure function, too.\nExample:\nTo _memoize a recursive function, simply insert the memoized call in lieu of the plain recursive call.\n For example, to transform the exponential-time Fibonacci implementation into a linear-time computation:$(DDOX_UNITTEST_HEADER __unittestL1062_473)\n---\nulong fib(ulong n)\n{\n    return n < 2 ? 1 : memoize!fib(n - 2) + memoize!fib(n - 1);\n}\nassert(fib(10) == 89);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1062_473)\nExample:\nTo improve the speed of the factorial function,$(DDOX_UNITTEST_HEADER __unittestL1074_474)\n---\nulong fact(ulong n)\n{\n    return n < 2 ? 1 : n * memoize!fact(n - 1);\n}\nassert(fact(10) == 3628800);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1074_474)\nExample:\nThis memoizes all values of $(D fact) up to the largest argument. To only cache the final\n result, move $(D memoize) outside the function as shown below.$(DDOX_UNITTEST_HEADER __unittestL1087_475)\n---\nulong factImpl(ulong n)\n{\n    return n < 2 ? 1 : n * factImpl(n - 1);\n}\nalias fact = memoize!factImpl;\nassert(fact(10) == 3628800);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1087_475)\nExample:\nWhen the $(D maxSize) parameter is specified, memoize will used\n a fixed size hash table to limit the number of cached entries.$(DDOX_UNITTEST_HEADER __unittestL1101_476)\n---\nulong fact(ulong n)\n{\n    // Memoize no more than 8 values\n    return n < 2 ? 1 : n * memoize!(fact, 8)(n - 1);\n}\nassert(fact(8) == 40320);\n// using more entries than maxSize will overwrite existing entries\nassert(fact(10) == 3628800);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1101_476)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "memoize",
						"line": 1008,
						"type": "ReturnType!fun(Parameters!fun args)",
						"parameters": [
							{
								"name": "args",
								"type": "Parameters!fun"
							}
						],
						"endline": 1055,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "memoize",
				"line": 1005,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "maxSize",
						"deco": "k",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toDelegate",
						"line": 1238,
						"type": "(auto ref F fp)",
						"parameters": [
							{
								"name": "fp",
								"type": "F",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 1278,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toDelegate",
				"line": 1238,
				"comment": " Convert a callable to a delegate with the same parameter list and\n return type, avoiding heap allocations and use of auxiliary storage.\n\n Example:\n ----\n void doStuff() {\n     writeln(\"Hello, world.\");\n }\n\n void runDelegate(void delegate() myDelegate) {\n     myDelegate();\n }\n\n auto delegateToPass = toDelegate(&doStuff);\n runDelegate(delegateToPass);  // Calls doStuff, prints \"Hello, world.\"\n ----\n\n BUGS:\n $(UL\n   $(LI Does not work with $(D @safe) functions.)\n   $(LI Ignores C-style / D-style variadic arguments.)\n )\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isCallable!F",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [],
				"name": "forward",
				"line": 1375,
				"comment": "Forwards function arguments with saving ref-ness.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1395_479)\n---\nclass C\n{\n    static int foo(int n) { return 1; }\n    static int foo(ref int n) { return 2; }\n}\nint bar()(auto ref int x) { return C.foo(forward!x); }\n\nassert(bar(1) == 1);\nint i;\nassert(bar(i) == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1395_479)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1410_480)\n---\nvoid foo(int n, ref string s) { s = null; foreach (i; 0..n) s ~= \"Hello\"; }\n\n// forwards all arguments which are bound to parameter tuple\nvoid bar(Args...)(auto ref Args args) { return foo(forward!args); }\n\n// forwards all arguments with swapping order\nvoid baz(Args...)(auto ref Args args) { return foo(forward!args[$/2..$], forward!args[0..$/2]); }\n\nstring s;\nbar(1, s);\nassert(s == \"Hello\");\nbaz(s, 2);\nassert(s == \"HelloHello\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1410_480)\n",
				"parameters": [
					{
						"name": "args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "Functions that manipulate other functions.\n\nThis module provides functions for compile time function composition. These\nfunctions are helpful when constructing predicates for the algorithms in\n$(LINK2 std_algorithm.html, std.algorithm) or $(LINK2 std_range.html,\nstd.range).\n\n$(BOOKTABLE ,\n$(TR $(TH Function Name) $(TH Description)\n)\n    $(TR $(TD $(D $(LREF adjoin)))\n        $(TD Joins a couple of functions into one that executes the original\n        functions independently and returns a tuple with all the results.\n    ))\n    $(TR $(TD $(D $(LREF compose)), $(D $(LREF pipe)))\n        $(TD Join a couple of functions into one that executes the original\n        functions one after the other, using one function's result for the next\n        function's argument.\n    ))\n    $(TR $(TD $(D $(LREF forward)))\n        $(TD Forwards function arguments while saving ref-ness.\n    ))\n    $(TR $(TD $(D $(LREF lessThan)), $(D $(LREF greaterThan)), $(D $(LREF equalTo)))\n        $(TD Ready-made predicate functions to compare two values.\n    ))\n    $(TR $(TD $(D $(LREF memoize)))\n        $(TD Creates a function that caches its result for fast re-evalation.\n    ))\n    $(TR $(TD $(D $(LREF not)))\n        $(TD Creates a function that negates another.\n    ))\n    $(TR $(TD $(D $(LREF partial)))\n        $(TD Creates a function that binds the first argument of a given function\n        to a given value.\n    ))\n    $(TR $(TD $(D $(LREF reverseArgs)), $(D $(LREF binaryReverseArgs)))\n        $(TD Predicate that reverses the order of its arguments.\n    ))\n    $(TR $(TD $(D $(LREF toDelegate)))\n        $(TD Converts a callable to a delegate.\n    ))\n    $(TR $(TD $(D $(LREF unaryFun)), $(D $(LREF binaryFun)))\n        $(TD Create a unary or binary function from a string. Most often\n        used when defining algorithms on ranges.\n    ))\n)\n\nMacros:\n\nWIKI = Phobos/StdFunctional\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\nSource:    $(PHOBOSSRC std/_functional.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/math.d",
		"name": "std.math",
		"members": [
			{
				"name": "E",
				"line": 474,
				"comment": " e = 2.718281...\n",
				"deco": "e",
				"init": "2.71828L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LOG2T",
				"line": 475,
				"comment": " $(SUB log, 2)10 = 3.321928...\n",
				"deco": "e",
				"init": "3.32193L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LOG2E",
				"line": 476,
				"comment": " $(SUB log, 2)e = 1.442695...\n",
				"deco": "e",
				"init": "1.4427L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LOG2",
				"line": 477,
				"comment": " $(SUB log, 10)2 = 0.301029...\n",
				"deco": "e",
				"init": "0.30103L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LOG10E",
				"line": 478,
				"comment": " $(SUB log, 10)e = 0.434294...\n",
				"deco": "e",
				"init": "0.434294L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LN2",
				"line": 479,
				"comment": " ln 2  = 0.693147...\n",
				"deco": "e",
				"init": "0.693147L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LN10",
				"line": 480,
				"comment": " ln 10 = 2.302585...\n",
				"deco": "e",
				"init": "2.30259L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "PI",
				"line": 481,
				"comment": " $(_PI) = 3.141592...\n",
				"deco": "e",
				"init": "3.14159L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "PI_2",
				"line": 482,
				"comment": " $(PI) / 2 = 1.570796...\n",
				"deco": "e",
				"init": "1.5708L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "PI_4",
				"line": 483,
				"comment": " $(PI) / 4 = 0.785398...\n",
				"deco": "e",
				"init": "0.785398L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "M_1_PI",
				"line": 484,
				"comment": " 1 / $(PI) = 0.318309...\n",
				"deco": "e",
				"init": "0.31831L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "M_2_PI",
				"line": 485,
				"comment": " 2 / $(PI) = 0.636619...\n",
				"deco": "e",
				"init": "0.63662L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "M_2_SQRTPI",
				"line": 486,
				"comment": " 2 / $(SQRT)$(PI) = 1.128379...\n",
				"deco": "e",
				"init": "1.12838L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "SQRT2",
				"line": 487,
				"comment": " $(SQRT)2 = 1.414213...\n",
				"deco": "e",
				"init": "1.41421L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "SQRT1_2",
				"line": 488,
				"comment": " $(SQRT)$(HALF) = 0.707106...\n",
				"deco": "e",
				"init": "0.707107L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "abs",
						"line": 510,
						"type": "pure nothrow @safe Num(Num x)",
						"parameters": [
							{
								"name": "x",
								"type": "Num"
							}
						],
						"endline": 519,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "abs",
				"line": 510,
				"comment": " Calculates the absolute value of a number\n\n Params:\n     Num = (template parameter) type of number\n       x = real number value\n       z = complex number value\n       y = imaginary number value\n\n Returns:\n     The absolute value of the number.  If floating-point or integral,\n     the return type will be the same as the input; if complex or\n     imaginary, the returned value will be the corresponding floating\n     point type.\n\n For complex numbers, abs(z) = sqrt( $(POWER z.re, 2) + $(POWER z.im, 2) )\n = hypot(z.re, z.im).\nExample:\nditto$(DDOX_UNITTEST_HEADER __unittestL538_483)\n---\nassert(isIdentical(abs(-0.0L), 0.0L));\nassert(isNaN(abs(real.nan)));\nassert(abs(-real.infinity) == real.infinity);\nassert(abs(-3.2Li) == 3.2L);\nassert(abs(71.6Li) == 71.6L);\nassert(abs(-56) == 56);\nassert(abs(2321312L)  == 2321312L);\nassert(abs(-1L+1i) == sqrt(2.0L));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL538_483)\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(Num.init >= 0)) && is(typeof(-Num.init)) && !(is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*)))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "abs",
						"line": 522,
						"type": "pure nothrow @nogc @safe (Num z)",
						"parameters": [
							{
								"name": "z",
								"type": "Num"
							}
						],
						"endline": 527,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "abs",
				"line": 522,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "is(Num* : const(cfloat*)) || is(Num* : const(cdouble*)) || is(Num* : const(creal*))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "abs",
						"line": 530,
						"type": "pure nothrow @nogc @safe (Num y)",
						"parameters": [
							{
								"name": "y",
								"type": "Num"
							}
						],
						"endline": 535,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "abs",
				"line": 530,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "conj",
						"line": 575,
						"type": "pure nothrow @nogc @safe (Num z)",
						"parameters": [
							{
								"name": "z",
								"type": "Num"
							}
						],
						"endline": 585,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "conj",
				"line": 575,
				"comment": " Complex conjugate\n\n  conj(x + iy) = x - iy\n\n Note that z * conj(z) = $(POWER z.re, 2) - $(POWER z.im, 2)\n is always a real number\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL596_485)\n---\ncreal c = 7 + 3Li;\nassert(conj(c) == 7-3Li);\nireal z = -3.2Li;\nassert(conj(z) == -z);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL596_485)\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "is(Num* : const(cfloat*)) || is(Num* : const(cdouble*)) || is(Num* : const(creal*))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "conj",
						"line": 588,
						"type": "pure nothrow @nogc @safe (Num y)",
						"parameters": [
							{
								"name": "y",
								"type": "Num"
							}
						],
						"endline": 593,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "conj",
				"line": 588,
				"comment": " ditto\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*))",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 92,
				"name": "cos",
				"line": 632,
				"comment": " Returns cosine of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH cos(x)) $(TH invalid?))\n      $(TR $(TD $(NAN))            $(TD $(NAN)) $(TD yes)     )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(NAN)) $(TD yes)     )\n      )\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 632,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 74,
				"name": "cos",
				"line": 635,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 635,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 72,
				"name": "cos",
				"line": 638,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 638,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 92,
				"name": "sin",
				"line": 666,
				"comment": " Returns $(WEB en.wikipedia.org/wiki/Sine, sine) of x. x is in $(WEB en.wikipedia.org/wiki/Radian, radians).\n\n      $(TABLE_SV\n      $(TH3 x           ,  sin(x)      ,  invalid?)\n      $(TD3 $(NAN)      ,  $(NAN)      ,  yes     )\n      $(TD3 $(PLUSMN)0.0,  $(PLUSMN)0.0,  no      )\n      $(TD3 $(PLUSMNINF),  $(NAN)      ,  yes     )\n      )\n\n Params:\n      x = angle in radians (not degrees)\n Returns:\n      sine of x\n See_Also:\n      $(MYREF cos), $(MYREF tan), $(MYREF asin)\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL675_489)\n---\nimport std.math : sin, PI;\nimport std.stdio : writefln;\n\nvoid someFunc()\n{\n  real x = 30.0;\n  auto result = sin(x * (PI / 180)); // convert degrees to radians\n  writefln(\"The sine of %s degrees is %s\", x, result);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL675_489)\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 666,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 74,
				"name": "sin",
				"line": 669,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 669,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 72,
				"name": "sin",
				"line": 672,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 672,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sin",
				"line": 702,
				"comment": "  Returns sine for complex and imaginary arguments.\n\n  sin(z) = sin(z.re)*cosh(z.im) + cos(z.re)*sinh(z.im)i\n\n If both sin($(THETA)) and cos($(THETA)) are required,\n it is most efficient to use expi($(THETA)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL716_491)\n---\nassert(sin(0.0+0.0i) == 0.0);\nassert(sin(2.0+0.0i) == sin(2.0L) );\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL716_491)\n",
				"deco": "FNaNbNiNfcZc",
				"parameters": [
					{
						"name": "z",
						"deco": "c"
					}
				],
				"endline": 707,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sin",
				"line": 710,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfjZj",
				"parameters": [
					{
						"name": "y",
						"deco": "j"
					}
				],
				"endline": 713,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "cos",
				"line": 727,
				"comment": "  cosine, complex and imaginary\n\n  cos(z) = cos(z.re)*cosh(z.im) - sin(z.re)*sinh(z.im)i\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL741_492)\n---\nassert(cos(0.0+0.0i)==1.0);\nassert(cos(1.3L+0.0i)==cos(1.3L));\nassert(cos(5.2Li)== cosh(5.2L));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL741_492)\n",
				"deco": "FNaNbNiNfcZc",
				"parameters": [
					{
						"name": "z",
						"deco": "c"
					}
				],
				"endline": 732,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "cos",
				"line": 735,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfjZe",
				"parameters": [
					{
						"name": "y",
						"deco": "j"
					}
				],
				"endline": 738,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "tan",
				"line": 759,
				"comment": " Returns tangent of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)             $(TH tan(x))       $(TH invalid?))\n      $(TR $(TD $(NAN))        $(TD $(NAN))       $(TD yes))\n      $(TR $(TD $(PLUSMN)0.0)  $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMNINF))  $(TD $(NAN))       $(TD yes))\n      )\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 908,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "acos",
				"line": 980,
				"comment": " Calculates the arc cosine of x,\n returning a value ranging from 0 to $(PI).\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH acos(x)) $(TH invalid?))\n      $(TR $(TD $(GT)1.0)  $(TD $(NAN))  $(TD yes))\n      $(TR $(TD $(LT)-1.0) $(TD $(NAN))  $(TD yes))\n      $(TR $(TD $(NAN))    $(TD $(NAN))  $(TD yes))\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 983,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "acos",
				"line": 986,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 986,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "acos",
				"line": 989,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 989,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "asin",
				"line": 1007,
				"comment": " Calculates the arc sine of x,\n returning a value ranging from -$(PI)/2 to $(PI)/2.\n\n      $(TABLE_SV\n      $(TR $(TH x)            $(TH asin(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0) $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(GT)1.0)     $(TD $(NAN))       $(TD yes))\n      $(TR $(TD $(LT)-1.0)    $(TD $(NAN))       $(TD yes))\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1010,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "asin",
				"line": 1013,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1013,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "asin",
				"line": 1016,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1016,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "atan",
				"line": 1033,
				"comment": " Calculates the arc tangent of x,\n returning a value ranging from -$(PI)/2 to $(PI)/2.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH atan(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(NAN))       $(TD yes))\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1098,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "atan",
				"line": 1101,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1101,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "atan",
				"line": 1104,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1104,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "atan2",
				"line": 1132,
				"comment": " Calculates the arc tangent of y / x,\n returning a value ranging from -$(PI) to $(PI).\n\n      $(TABLE_SV\n      $(TR $(TH y)                 $(TH x)            $(TH atan(y, x)))\n      $(TR $(TD $(NAN))            $(TD anything)     $(TD $(NAN)) )\n      $(TR $(TD anything)          $(TD $(NAN))       $(TD $(NAN)) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(GT)0.0)     $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0)         $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(LT)0.0)     $(TD $(PLUSMN)$(PI)))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD -0.0)         $(TD $(PLUSMN)$(PI)))\n      $(TR $(TD $(GT)0.0)          $(TD $(PLUSMN)0.0) $(TD $(PI)/2) )\n      $(TR $(TD $(LT)0.0)          $(TD $(PLUSMN)0.0) $(TD -$(PI)/2) )\n      $(TR $(TD $(GT)0.0)          $(TD $(INFIN))     $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD anything)     $(TD $(PLUSMN)$(PI)/2))\n      $(TR $(TD $(GT)0.0)          $(TD -$(INFIN))    $(TD $(PLUSMN)$(PI)) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(INFIN))     $(TD $(PLUSMN)$(PI)/4))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD -$(INFIN))    $(TD $(PLUSMN)3$(PI)/4))\n      )\n",
				"deco": "FNaNbNiNeeeZe",
				"parameters": [
					{
						"name": "y",
						"deco": "e"
					},
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1205,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "atan2",
				"line": 1208,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfddZd",
				"parameters": [
					{
						"name": "y",
						"deco": "d"
					},
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1211,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "atan2",
				"line": 1214,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfffZf",
				"parameters": [
					{
						"name": "y",
						"deco": "f"
					},
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1217,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "cosh",
				"line": 1232,
				"comment": " Calculates the hyperbolic cosine of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH cosh(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)0.0) $(TD no) )\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1238,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "cosh",
				"line": 1241,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1241,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "cosh",
				"line": 1244,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1244,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sinh",
				"line": 1260,
				"comment": " Calculates the hyperbolic sine of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH sinh(x))           $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0)      $(TD no))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)$(INFIN)) $(TD no))\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1273,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "sinh",
				"line": 1276,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1276,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "sinh",
				"line": 1279,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1279,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "tanh",
				"line": 1295,
				"comment": " Calculates the hyperbolic tangent of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH tanh(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) $(TD no) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)1.0) $(TD no))\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1305,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "tanh",
				"line": 1308,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1308,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 74,
				"name": "tanh",
				"line": 1311,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1311,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "acosh",
				"line": 1363,
				"comment": " Calculates the inverse hyperbolic cosine of x.\n\n  Mathematically, acosh(x) = log(x + sqrt( x*x - 1))\n\n $(TABLE_DOMRG\n  $(DOMAIN 1..$(INFIN))\n  $(RANGE  1..log(real.max), $(INFIN)) )\n      $(TABLE_SV\n    $(SVH  x,     acosh(x) )\n    $(SV  $(NAN), $(NAN) )\n    $(SV  $(LT)1,     $(NAN) )\n    $(SV  1,      0       )\n    $(SV  +$(INFIN),+$(INFIN))\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1369,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 78,
				"name": "acosh",
				"line": 1372,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1372,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 77,
				"name": "acosh",
				"line": 1375,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1375,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "asinh",
				"line": 1404,
				"comment": " Calculates the inverse hyperbolic sine of x.\n\n  Mathematically,\n  ---------------\n  asinh(x) =  log( x + sqrt( x*x + 1 )) // if x >= +0\n  asinh(x) = -log(-x + sqrt( x*x + 1 )) // if x <= -0\n  -------------\n\n    $(TABLE_SV\n    $(SVH x,                asinh(x)       )\n    $(SV  $(NAN),           $(NAN)         )\n    $(SV  $(PLUSMN)0,       $(PLUSMN)0      )\n    $(SV  $(PLUSMN)$(INFIN),$(PLUSMN)$(INFIN))\n    )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1411,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 78,
				"name": "asinh",
				"line": 1414,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1414,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "asinh",
				"line": 1417,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1417,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "atanh",
				"line": 1446,
				"comment": " Calculates the inverse hyperbolic tangent of x,\n returning a value from ranging from -1 to 1.\n\n Mathematically, atanh(x) = log( (1+x)/(1-x) ) / 2\n\n\n $(TABLE_DOMRG\n  $(DOMAIN -$(INFIN)..$(INFIN))\n  $(RANGE  -1..1) )\n $(TABLE_SV\n    $(SVH  x,     acosh(x) )\n    $(SV  $(NAN), $(NAN) )\n    $(SV  $(PLUSMN)0, $(PLUSMN)0)\n    $(SV  -$(INFIN), -0)\n )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1450,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 78,
				"name": "atanh",
				"line": 1453,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1453,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "atanh",
				"line": 1456,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1456,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 98,
				"name": "rndtol",
				"line": 1475,
				"comment": " Returns x rounded to a long value using the current rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n",
				"deco": "FNaNbNiNfeZl",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1475,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 78,
				"name": "rndtol",
				"line": 1478,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZl",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1478,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 77,
				"name": "rndtol",
				"line": 1481,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZl",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1481,
				"char": 6,
				"kind": "function"
			},
			{
				"name": "rndtonl",
				"line": 1495,
				"comment": " Returns x rounded to a long value using the FE_TONEAREST rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n",
				"deco": "UeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 96,
				"name": "sqrt",
				"line": 1507,
				"comment": " Compute square root of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH sqrt(x))   $(TH invalid?))\n      $(TR $(TD -0.0)      $(TD -0.0)      $(TD no))\n      $(TR $(TD $(LT)0.0)  $(TD $(NAN))    $(TD yes))\n      $(TR $(TD +$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      )\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1507,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 98,
				"name": "sqrt",
				"line": 1510,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1510,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 94,
				"name": "sqrt",
				"line": 1513,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1513,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "exp",
				"line": 1588,
				"comment": " Calculates e$(SUPERSCRIPT x).\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH e$(SUPERSCRIPT x)) )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN)) )\n    $(TR $(TD -$(INFIN))     $(TD +0.0)      )\n    $(TR $(TD $(NAN))        $(TD $(NAN))    )\n  )\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1684,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "exp",
				"line": 1687,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1687,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "exp",
				"line": 1690,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1690,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "expm1",
				"line": 1712,
				"comment": " Calculates the value of the natural logarithm base (e)\n raised to the power of x, minus 1.\n\n For very small x, expm1(x) is more accurate\n than exp(x)-1.\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH e$(SUPERSCRIPT x)-1)  )\n    $(TR $(TD $(PLUSMN)0.0)  $(TD $(PLUSMN)0.0) )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN))    )\n    $(TR $(TD -$(INFIN))     $(TD -1.0)         )\n    $(TR $(TD $(NAN))        $(TD $(NAN))       )\n  )\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1929,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "exp2",
				"line": 1943,
				"comment": " Calculates 2$(SUPERSCRIPT x).\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH exp2(x))   )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN)) )\n    $(TR $(TD -$(INFIN))     $(TD +0.0)      )\n    $(TR $(TD $(NAN))        $(TD $(NAN))    )\n  )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2178_510)\n---\nassert(feqrel(exp2(0.5L), SQRT2) >= real.mant_dig -1);\nassert(exp2(8.0L) == 256.0);\nassert(exp2(-9.0L)== 1.0L/512.0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2178_510)\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 2175,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "expi",
				"line": 2303,
				"comment": " Calculate cos(y) + i sin(y).\n\n On many CPUs (such as x86), this is a very efficient operation;\n almost twice as fast as calculating sin(y) and cos(y) separately,\n and is the preferred method when both are required.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2335_513)\n---\nassert(expi(1.3e5L) == cos(1.3e5L) + sin(1.3e5L) * 1i);\nassert(expi(0.0L) == 1L + 0.0Li);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2335_513)\n",
				"deco": "FNaNbNiNeeZc",
				"parameters": [
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 2332,
				"char": 7,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "frexp",
						"line": 2359,
						"type": "pure nothrow @nogc @trusted T(const T value, out int exp)",
						"parameters": [
							{
								"name": "value",
								"type": "T",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "exp",
								"storageClass": [
									"out"
								],
								"deco": "i"
							}
						],
						"endline": 2538,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "frexp",
				"line": 2359,
				"comment": " Separate floating point value into significand and exponent.\n\n Returns:\n      Calculate and return $(I x) and $(I exp) such that\n      value =$(I x)*2$(SUPERSCRIPT exp) and\n      .5 $(LT)= |$(I x)| $(LT) 1.0\n\n      $(I x) has same sign as value.\n\n      $(TABLE_SV\n      $(TR $(TH value)           $(TH returns)         $(TH exp))\n      $(TR $(TD $(PLUSMN)0.0)    $(TD $(PLUSMN)0.0)    $(TD 0))\n      $(TR $(TD +$(INFIN))       $(TD +$(INFIN))       $(TD int.max))\n      $(TR $(TD -$(INFIN))       $(TD -$(INFIN))       $(TD int.min))\n      $(TR $(TD $(PLUSMN)$(NAN)) $(TD $(PLUSMN)$(NAN)) $(TD int.min))\n      )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2541_514)\n---\nint exp;\nreal mantissa = frexp(123.456L, exp);\n\n// check if values are equal to 19 decimal digits of precision\nassert(equalsDigit(mantissa * pow(2.0L, cast(real)exp), 123.456L, 19));\n\nassert(frexp(-real.nan, exp) && exp == int.min);\nassert(frexp(real.nan, exp) && exp == int.min);\nassert(frexp(-real.infinity, exp) == -real.infinity && exp == int.min);\nassert(frexp(real.infinity, exp) == real.infinity && exp == int.max);\nassert(frexp(-0.0, exp) == -0.0 && exp == 0);\nassert(frexp(0.0, exp) == 0.0 && exp == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2541_514)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ilogb",
						"line": 2656,
						"type": "pure nothrow @nogc @trusted int(const T x)",
						"parameters": [
							{
								"name": "x",
								"type": "T",
								"storageClass": [
									"const"
								]
							}
						],
						"endline": 2804,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "ilogb",
				"line": 2656,
				"comment": " Extracts the exponent of x as a signed integral value.\n\n If x is not a special value, the result is the same as\n $(D cast(int)logb(x)).\n\n      $(TABLE_SV\n      $(TR $(TH x)                $(TH ilogb(x))     $(TH Range error?))\n      $(TR $(TD 0)                 $(TD FP_ILOGB0)   $(TD yes))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD int.max)     $(TD no))\n      $(TR $(TD $(NAN))            $(TD FP_ILOGBNAN) $(TD no))\n      )\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T",
				"char": 5,
				"kind": "template"
			},
			{
				"endchar": 110,
				"name": "ldexp",
				"line": 2901,
				"comment": " Compute n * 2$(SUPERSCRIPT exp)\n References: frexp\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2910_518)\n---\nimport std.meta;\nforeach(T; AliasSeq!(float, double, real))\n{\n    T r;\n\n    r = ldexp(3.0L, 3);\n    assert(r == 24);\n\n    r = ldexp(cast(T)3.0, cast(int) 3);\n    assert(r == 24);\n\n    T n = 3.0;\n    int exp = 3;\n    r = ldexp(n, exp);\n    assert(r == 24);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2910_518)\n",
				"deco": "FNaNbNiNfeiZe",
				"parameters": [
					{
						"name": "n",
						"deco": "e"
					},
					{
						"name": "exp",
						"deco": "i"
					}
				],
				"endline": 2901,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 92,
				"name": "ldexp",
				"line": 2904,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdiZd",
				"parameters": [
					{
						"name": "n",
						"deco": "d"
					},
					{
						"name": "exp",
						"deco": "i"
					}
				],
				"endline": 2904,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 90,
				"name": "ldexp",
				"line": 2907,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffiZf",
				"parameters": [
					{
						"name": "n",
						"deco": "f"
					},
					{
						"name": "exp",
						"deco": "i"
					}
				],
				"endline": 2907,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "log",
				"line": 3019,
				"comment": " Calculate the natural logarithm of x.\n\n    $(TABLE_SV\n    $(TR $(TH x)            $(TH log(x))    $(TH divide by 0?) $(TH invalid?))\n    $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no))\n    $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes))\n    $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no))\n    )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3131_521)\n---\nassert(log(E) == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3131_521)\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3128,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "log10",
				"line": 3146,
				"comment": " Calculate the base-10 logarithm of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)            $(TH log10(x))  $(TH divide by 0?) $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no))\n      $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes))\n      $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no))\n      )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3262_522)\n---\nassert(fabs(log10(1000) - 3) < .000001);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3262_522)\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3259,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "log1p",
				"line": 3281,
				"comment": "      Calculates the natural logarithm of 1 + x.\n\n      For very small x, log1p(x) will be more accurate than\n      log(1 + x).\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH log1p(x))     $(TH divide by 0?) $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0) $(TD $(PLUSMN)0.0) $(TD no)           $(TD no))\n  $(TR $(TD -1.0)         $(TD -$(INFIN))    $(TD yes)          $(TD no))\n  $(TR $(TD $(LT)-1.0)    $(TD $(NAN))       $(TD no)           $(TD yes))\n  $(TR $(TD +$(INFIN))    $(TD -$(INFIN))    $(TD no)           $(TD no))\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3303,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "log2",
				"line": 3316,
				"comment": " Calculates the base-2 logarithm of x:\n $(SUB log, 2)x\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH log2(x))   $(TH divide by 0?) $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no) )\n  $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes) )\n  $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no) )\n  )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3423_523)\n---\n// check if values are equal to 19 decimal digits of precision\nassert(equalsDigit(log2(1024.0L), 10, 19));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3423_523)\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3420,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "logb",
				"line": 3443,
				"comment": " Extracts the exponent of x as a signed integral value.\n\n If x is subnormal, it is treated as if it were normalized.\n For a positive, finite x:\n\n 1 $(LT)= $(I x) * FLT_RADIX$(SUPERSCRIPT -logb(x)) $(LT) FLT_RADIX\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH logb(x))   $(TH divide by 0?) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD -$(INFIN)) $(TD yes) )\n      )\n",
				"deco": "FNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3467,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "fmod",
				"line": 3483,
				"comment": " Calculates the remainder from the calculation x/y.\n Returns:\n The value of x - i * y, where i is the number of times that y can\n be completely subtracted from x. The result has the same sign as x.\n\n $(TABLE_SV\n  $(TR $(TH x)              $(TH y)             $(TH fmod(x, y))   $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0)   $(TD not 0.0)       $(TD $(PLUSMN)0.0) $(TD no))\n  $(TR $(TD $(PLUSMNINF))   $(TD anything)      $(TD $(NAN))       $(TD yes))\n  $(TR $(TD anything)       $(TD $(PLUSMN)0.0)  $(TD $(NAN))       $(TD yes))\n  $(TR $(TD !=$(PLUSMNINF)) $(TD $(PLUSMNINF))  $(TD x)            $(TD no))\n )\n",
				"deco": "FNbNiNeeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 3491,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "modf",
				"line": 3504,
				"comment": " Breaks x into an integral part and a fractional part, each of which has\n the same sign as x. The integral part is stored in i.\n Returns:\n The fractional part of x.\n\n $(TABLE_SV\n  $(TR $(TH x)              $(TH i (on input))  $(TH modf(x, i))   $(TH i (on return)))\n  $(TR $(TD $(PLUSMNINF))   $(TD anything)      $(TD $(PLUSMN)0.0) $(TD $(PLUSMNINF)))\n )\n",
				"deco": "FNbNiNeeKeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "i",
						"storageClass": [
							"ref"
						],
						"deco": "e"
					}
				],
				"endline": 3513,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "scalbn",
				"line": 3527,
				"comment": " Efficiently calculates x * 2$(SUPERSCRIPT n).\n\n scalbn handles underflow and overflow in\n the same fashion as the basic arithmetic operators.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH scalb(x)))\n      $(TR $(TD $(PLUSMNINF))      $(TD $(PLUSMNINF)) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) )\n      )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3560_524)\n---\nassert(scalbn(-real.infinity, 5) == -real.infinity);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3560_524)\n",
				"deco": "FNbNiNeeiZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "n",
						"deco": "i"
					}
				],
				"endline": 3557,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "cbrt",
				"line": 3575,
				"comment": " Calculates the cube root of x.\n\n      $(TABLE_SV\n      $(TR $(TH $(I x))            $(TH cbrt(x))           $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0)      $(TD no) )\n      $(TR $(TD $(NAN))            $(TD $(NAN))            $(TD yes) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)$(INFIN)) $(TD no) )\n      )\n",
				"deco": "FNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3586,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 94,
				"name": "fabs",
				"line": 3598,
				"comment": " Returns |x|\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH fabs(x)))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) )\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3598,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "fabs",
				"line": 3601,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 3601,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 74,
				"name": "fabs",
				"line": 3604,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 3604,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "hypot",
				"line": 3631,
				"comment": " Calculates the length of the\n hypotenuse of a right-angled triangle with sides of length x and y.\n The hypotenuse is the value of the square root of\n the sums of the squares of x and y:\n\n      sqrt($(POWER x, 2) + $(POWER y, 2))\n\n Note that hypot(x, y), hypot(y, x) and\n hypot(x, -y) are equivalent.\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH y)            $(TH hypot(x, y)) $(TH invalid?))\n  $(TR $(TD x)            $(TD $(PLUSMN)0.0) $(TD |x|)         $(TD no))\n  $(TR $(TD $(PLUSMNINF)) $(TD y)            $(TD +$(INFIN))   $(TD no))\n  $(TR $(TD $(PLUSMNINF)) $(TD $(NAN))       $(TD +$(INFIN))   $(TD no))\n  )\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 3683,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "ceil",
				"line": 3721,
				"comment": " Returns the value of x rounded upward to the next integer\n (toward positive infinity).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3775_527)\n---\nassert(ceil(+123.456L) == +124);\nassert(ceil(-123.456L) == -123);\nassert(ceil(-1.234L) == -1);\nassert(ceil(-0.123L) == 0);\nassert(ceil(0.0L) == 0);\nassert(ceil(+0.123L) == 1);\nassert(ceil(+1.234L) == 2);\nassert(ceil(real.infinity) == real.infinity);\nassert(isNaN(ceil(real.nan)));\nassert(isNaN(ceil(real.init)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3775_527)\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3772,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "floor",
				"line": 3849,
				"comment": " Returns the value of x rounded downward to the next integer\n (toward negative infinity).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3899_530)\n---\nassert(floor(+123.456L) == +123);\nassert(floor(-123.456L) == -124);\nassert(floor(-1.234L) == -2);\nassert(floor(-0.123L) == -1);\nassert(floor(0.0L) == 0);\nassert(floor(+0.123L) == 0);\nassert(floor(+1.234L) == 1);\nassert(floor(real.infinity) == real.infinity);\nassert(isNaN(floor(real.nan)));\nassert(isNaN(floor(real.init)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3899_530)\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3896,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nearbyint",
				"line": 3968,
				"comment": " Rounds x to the nearest integer value, using the current rounding\n mode.\n\n Unlike the rint functions, nearbyint does not raise the\n FE_INEXACT exception.\n",
				"deco": "FNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3976,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 94,
				"name": "rint",
				"line": 3986,
				"comment": " Rounds x to the nearest integer value, using the current rounding\n mode.\n If the return value is not equal to x, the FE_INEXACT\n exception is raised.\n $(B nearbyint) performs\n the same operation, but does not set the FE_INEXACT exception.\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3986,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "rint",
				"line": 3989,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 3989,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 74,
				"name": "rint",
				"line": 3992,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 3992,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "lrint",
				"line": 4010,
				"comment": " Rounds x to the nearest integer value, using the current rounding\n mode.\n\n This is generally the fastest method to convert a floating-point number\n to an integer. Note that the results from this function\n depend on the rounding mode, if the fractional part of x is exactly 0.5.\n If using the default rounding mode (ties round to even integers)\n lrint(4.5) == 4, lrint(5.5)==6.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4146_534)\n---\nassert(lrint(4.5) == 4);\nassert(lrint(5.5) == 6);\nassert(lrint(-4.5) == -4);\nassert(lrint(-5.5) == -6);\n\nassert(lrint(int.max - 0.5) == 2147483646L);\nassert(lrint(int.max + 0.5) == 2147483648L);\nassert(lrint(int.min - 0.5) == -2147483648L);\nassert(lrint(int.min + 0.5) == -2147483648L);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4146_534)\n",
				"deco": "FNaNbNiNeeZl",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 4143,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "round",
				"line": 4164,
				"comment": " Return the value of x rounded to the nearest integer.\n If the fractional part of x is exactly 0.5, the return value is\n rounded away from zero.\n",
				"deco": "FNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 4176,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "lround",
				"line": 4184,
				"comment": " Return the value of x rounded to the nearest integer.\n\n If the fractional part of x is exactly 0.5, the return value is rounded\n away from zero.\n",
				"deco": "FNbNiNeeZl",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 4190,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "trunc",
				"line": 4207,
				"comment": " Returns the integer portion of x, dropping the fractional portion.\n\n This is also known as \"chop\" rounding.\n",
				"deco": "FNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 4248,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "remainder",
				"line": 4272,
				"comment": " Calculate the remainder x REM y, following IEC 60559.\n\n REM is the value of x - y * n, where n is the integer nearest the exact\n value of x / y.\n If |n - x / y| == 0.5, n is even.\n If the result is zero, it has the same sign as x.\n Otherwise, the sign of the result is the sign of x / y.\n Precision mode has no effect on the remainder functions.\n\n remquo returns n in the parameter n.\n\n $(TABLE_SV\n  $(TR $(TH x)               $(TH y)            $(TH remainder(x, y)) $(TH n)   $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0)    $(TD not 0.0)      $(TD $(PLUSMN)0.0)    $(TD 0.0) $(TD no))\n  $(TR $(TD $(PLUSMNINF))    $(TD anything)     $(TD $(NAN))          $(TD ?)   $(TD yes))\n  $(TR $(TD anything)        $(TD $(PLUSMN)0.0) $(TD $(NAN))          $(TD ?)   $(TD yes))\n  $(TR $(TD != $(PLUSMNINF)) $(TD $(PLUSMNINF)) $(TD x)               $(TD ?)   $(TD no))\n )\n\n Note: remquo not supported on windows\n",
				"deco": "FNbNiNeeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 4281,
				"char": 6,
				"kind": "function"
			},
			{
				"name": "IeeeFlags",
				"line": 4299,
				"comment": " IEEE exception status flags ('sticky bits')\n\n These flags indicate that an exceptional floating-point condition has occurred.\n They indicate that a NaN or an infinity has been generated, that a result\n is inexact, or that a signalling NaN has been encountered. If floating-point\n exceptions are enabled (unmasked), a hardware exception will be generated\n instead of setting these flags.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4442_536)\n---\nstatic void func() {\n    int a = 10 * 10;\n}\n\nreal a=3.5;\n// Set all the flags to zero\nresetIeeeFlags();\nassert(!ieeeFlags.divByZero);\n// Perform a division by zero.\na/=0.0L;\nassert(a==real.infinity);\nassert(ieeeFlags.divByZero);\n// Create a NaN\na*=0.0L;\nassert(ieeeFlags.invalid);\nassert(isNaN(a));\n\n// Check that calling func() has no effect on the\n// status flags.\nIeeeFlags f = ieeeFlags;\nfunc();\nassert(ieeeFlags == f);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4442_536)\n",
				"members": [
					{
						"endchar": 69,
						"name": "inexact",
						"line": 4424,
						"comment": "The result cannot be represented exactly, so rounding occurred.\n\n(example: x = sin(0.1); )\n",
						"deco": "FNdZb",
						"endline": 4424,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 73,
						"name": "underflow",
						"line": 4427,
						"comment": "A zero was generated by underflow (example: x = real.min*real.epsilon/2;)\n",
						"deco": "FNdZb",
						"endline": 4427,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 71,
						"name": "overflow",
						"line": 4430,
						"comment": "An infinity was generated by overflow (example: x = real.max*2;)\n",
						"deco": "FNdZb",
						"endline": 4430,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 73,
						"name": "divByZero",
						"line": 4433,
						"comment": "An infinity was generated by division by zero (example: x = 3/0.0; )\n",
						"deco": "FNdZb",
						"endline": 4433,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 69,
						"name": "invalid",
						"line": 4436,
						"comment": "A machine NaN was generated. (example: x = real.infinity * 0.0; )\n",
						"deco": "FNdZb",
						"endline": 4436,
						"char": 21,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 53,
				"name": "resetIeeeFlags",
				"line": 4478,
				"comment": "Set all of the floating-point status flags to false.\n",
				"deco": "FZv",
				"endline": 4478,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "ieeeFlags",
				"line": 4481,
				"comment": "Return a snapshot of the current state of the floating-point status flags.\n",
				"deco": "FNdZS3std4math9IeeeFlags",
				"endline": 4484,
				"char": 21,
				"kind": "function"
			},
			{
				"name": "FloatingPointControl",
				"line": 4535,
				"comment": " Control the Floating point hardware\n\n  Change the IEEE754 floating-point rounding mode and the floating-point\n  hardware exceptions.\n\n  By default, the rounding mode is roundToNearest and all hardware exceptions\n  are disabled. For most applications, debugging is easier if the $(I division\n  by zero), $(I overflow), and $(I invalid operation) exceptions are enabled.\n  These three are combined into a $(I severeExceptions) value for convenience.\n  Note in particular that if $(I invalidException) is enabled, a hardware trap\n  will be generated whenever an uninitialized floating-point variable is used.\n\n  All changes are temporary. The previous state is restored at the\n  end of the scope.\n\n\nExample:\n----\n{\n    FloatingPointControl fpctrl;\n\n    // Enable hardware exceptions for division by zero, overflow to infinity,\n    // invalid operations, and uninitialized floating-point variables.\n    fpctrl.enableExceptions(FloatingPointControl.severeExceptions);\n\n    // This will generate a hardware exception, if x is a\n    // default-initialized floating point variable:\n    real x; // Add `= 0` or even `= real.nan` to not throw the exception.\n    real y = x * 3.0;\n\n    // The exception is only thrown for default-uninitialized NaN-s.\n    // NaN-s with other payload are valid:\n    real z = y * real.nan; // ok\n\n    // Changing the rounding mode:\n    fpctrl.rounding = FloatingPointControl.roundUp;\n    assert(rint(1.1) == 2);\n\n    // The set hardware exceptions will be disabled when leaving this scope.\n    // The original rounding mode will also be restored.\n}\n\n// Ensure previous values are returned:\nassert(!FloatingPointControl.enabledExceptions);\nassert(FloatingPointControl.rounding == FloatingPointControl.roundToNearest);\nassert(rint(1.1) == 1);\n----\n\n",
				"members": [
					{
						"name": "severeExceptions",
						"line": 4620,
						"value": "13u",
						"comment": "Severe = The overflow, division by zero, and invalid exceptions.\n",
						"char": 13,
						"kind": "enum member"
					},
					{
						"endchar": 5,
						"name": "hasExceptionTraps",
						"line": 4653,
						"comment": "Returns true if the current FPU supports exception trapping\n",
						"deco": "FNbNdNiNfZb",
						"endline": 4671,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "enableExceptions",
						"line": 4674,
						"comment": "Enable (unmask) specific hardware exceptions. Multiple exceptions may be ORed together.\n",
						"deco": "FNikZv",
						"parameters": [
							{
								"name": "exceptions",
								"deco": "k"
							}
						],
						"endline": 4682,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "disableExceptions",
						"line": 4685,
						"comment": "Disable (mask) specific hardware exceptions. Multiple exceptions may be ORed together.\n",
						"deco": "FNikZv",
						"parameters": [
							{
								"name": "exceptions",
								"deco": "k"
							}
						],
						"endline": 4693,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "rounding",
						"line": 4696,
						"comment": "Change the floating-point hardware rounding mode\n",
						"deco": "FNdNikZv",
						"parameters": [
							{
								"name": "newMode",
								"deco": "k"
							}
						],
						"endline": 4700,
						"originalType": "@nogc @property void(RoundingMode newMode)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "enabledExceptions",
						"line": 4703,
						"comment": "Return the exceptions which are currently enabled (unmasked)\n",
						"deco": "FNdNiZk",
						"endline": 4710,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "rounding",
						"line": 4713,
						"comment": "Return the currently active rounding mode\n",
						"deco": "FNdNiZk",
						"endline": 4716,
						"originalType": "@nogc @property RoundingMode()",
						"char": 35,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "~this",
						"line": 4719,
						"comment": "Clear all pending exceptions, then restore the original exception state and rounding mode.\n",
						"deco": "FNiZv",
						"endline": 4724,
						"char": 5,
						"kind": "destructor"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isNaN",
						"line": 4870,
						"type": "pure nothrow @nogc @trusted bool(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 4905,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isNaN",
				"line": 4870,
				"comment": " Determines if $(D_PARAM x) is NaN.\n params:\n  x = a floating point number.\n returns:\n  $(D true) if $(D_PARAM x) is Nan.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4908_538)\n---\nassert( isNaN(float.init));\nassert( isNaN(-double.init));\nassert( isNaN(real.nan));\nassert( isNaN(-real.nan));\nassert(!isNaN(cast(float)53.6));\nassert(!isNaN(cast(real)-53.6));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4908_538)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!X",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isFinite",
						"line": 4965,
						"type": "pure nothrow @nogc @trusted bool(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 4970,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isFinite",
				"line": 4965,
				"comment": " Determines if $(D_PARAM x) is finite.\n params:\n  x = a floating point number.\n returns:\n  $(D true) if $(D_PARAM x) is finite.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4973_540)\n---\nassert( isFinite(1.23f));\nassert( isFinite(float.max));\nassert( isFinite(float.min_normal));\nassert(!isFinite(float.nan));\nassert(!isFinite(float.infinity));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4973_540)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isNormal",
						"line": 5019,
						"type": "pure nothrow @nogc @trusted bool(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 5032,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isNormal",
				"line": 5019,
				"comment": " Determines if $(D_PARAM x) is normalized.\n\n A normalized number must not be zero, subnormal, infinite nor $(NAN).\n\n params:\n  x = a floating point number.\n returns:\n  $(D true) if $(D_PARAM x) is normalized.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5035_542)\n---\nfloat f = 3;\ndouble d = 500;\nreal e = 10e+48;\n\nassert(isNormal(f));\nassert(isNormal(d));\nassert(isNormal(e));\nf = d = e = 0;\nassert(!isNormal(f));\nassert(!isNormal(d));\nassert(!isNormal(e));\nassert(!isNormal(real.infinity));\nassert(isNormal(-real.max));\nassert(!isNormal(real.min_normal/4));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5035_542)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isSubnormal",
						"line": 5065,
						"type": "pure nothrow @nogc @trusted bool(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 5105,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isSubnormal",
				"line": 5065,
				"comment": " Determines if $(D_PARAM x) is subnormal.\n\n Subnormals (also known as \"denormal number\"), have a 0 exponent\n and a 0 most significant mantissa bit.\n\n params:\n  x = a floating point number.\n returns:\n  $(D true) if $(D_PARAM x) is a denormal number.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5108_543)\n---\nimport std.meta;\n\nforeach (T; AliasSeq!(float, double, real))\n{\n    T f;\n    for (f = 1.0; !isSubnormal(f); f /= 2)\n        assert(f != 0);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5108_543)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isInfinity",
						"line": 5134,
						"type": "pure nothrow @nogc @trusted bool(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 5171,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isInfinity",
				"line": 5134,
				"comment": " Determines if $(D_PARAM x) is $(PLUSMN)$(INFIN).\n params:\n  x = a floating point number.\n returns:\n  $(D true) if $(D_PARAM x) is $(PLUSMN)$(INFIN).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5174_544)\n---\nassert(!isInfinity(float.init));\nassert(!isInfinity(-float.init));\nassert(!isInfinity(float.nan));\nassert(!isInfinity(-float.nan));\nassert(isInfinity(float.infinity));\nassert(isInfinity(-float.infinity));\nassert(isInfinity(-1.0f / 0.0f));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5174_544)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!X",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "isIdentical",
				"line": 5251,
				"comment": " Is the binary representation of x identical to y?\n\n Same as ==, except that positive and negative zero are not identical,\n and two $(NAN)s are identical if they have the same 'payload'.\n",
				"deco": "FNaNbNiNeeeZb",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 5272,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "signbit",
						"line": 5277,
						"type": "pure nothrow @nogc @trusted int(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 5281,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "signbit",
				"line": 5277,
				"comment": " Return 1 if sign bit of e is set, 0 if not.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5284_546)\n---\ndebug (math) printf(\"math.signbit.unittest\\n\");\nassert(!signbit(float.nan));\nassert(signbit(-float.nan));\nassert(!signbit(168.1234f));\nassert(signbit(-168.1234f));\nassert(!signbit(0.0f));\nassert(signbit(-0.0f));\nassert(signbit(-float.max));\nassert(!signbit(float.max));\n\nassert(!signbit(double.nan));\nassert(signbit(-double.nan));\nassert(!signbit(168.1234));\nassert(signbit(-168.1234));\nassert(!signbit(0.0));\nassert(signbit(-0.0));\nassert(signbit(-double.max));\nassert(!signbit(double.max));\n\nassert(!signbit(real.nan));\nassert(signbit(-real.nan));\nassert(!signbit(168.1234L));\nassert(signbit(-168.1234L));\nassert(!signbit(0.0L));\nassert(signbit(-0.0L));\nassert(signbit(-real.max));\nassert(!signbit(real.max));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5284_546)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "copysign",
						"line": 5326,
						"type": "pure nothrow @nogc @trusted R(R to, X from)",
						"parameters": [
							{
								"name": "to",
								"type": "R"
							},
							{
								"name": "from",
								"type": "X"
							}
						],
						"endline": 5337,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "copysign",
				"line": 5326,
				"comment": " Return a value composed of to with from's sign bit.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "X",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!R && isFloatingPoint!X",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sgn",
						"line": 5393,
						"type": "pure nothrow @nogc @safe F(F x)",
						"parameters": [
							{
								"name": "x",
								"type": "F"
							}
						],
						"endline": 5397,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "sgn",
				"line": 5393,
				"comment": "Returns $(D -1) if $(D x < 0), $(D x) if $(D x == 0), $(D 1) if\n$(D x > 0), and $(NAN) if x==$(NAN).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5400_548)\n---\nassert(sgn(168.1234) == 1);\nassert(sgn(-168.1234) == -1);\nassert(sgn(0.0) == 0);\nassert(sgn(-0.0) == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5400_548)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "NaN",
				"line": 5422,
				"comment": " Create a quiet $(NAN), storing an integer inside the payload.\n\n For floats, the largest possible payload is 0x3F_FFFF.\n For doubles, it is 0x3_FFFF_FFFF_FFFF.\n For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.\n",
				"deco": "FNaNbNiNemZe",
				"parameters": [
					{
						"name": "payload",
						"deco": "m"
					}
				],
				"endline": 5487,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "getNaNPayload",
				"line": 5510,
				"comment": " Extract an integral payload from a $(NAN).\n\n Returns:\n the integer payload as a ulong.\n\n For floats, the largest possible payload is 0x3F_FFFF.\n For doubles, it is 0x3_FFFF_FFFF_FFFF.\n For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.\n",
				"deco": "FNaNbNiNeeZm",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 5548,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextUp",
				"line": 5592,
				"comment": " Calculate the next largest floating point value after x.\n\n Return the least number greater than x that is representable as a real;\n thus, it gives the next point on the IEEE number line.\n\n  $(TABLE_SV\n    $(SVH x,            nextUp(x)   )\n    $(SV  -$(INFIN),    -real.max   )\n    $(SV  $(PLUSMN)0.0, real.min_normal*real.epsilon )\n    $(SV  real.max,     $(INFIN) )\n    $(SV  $(INFIN),     $(INFIN) )\n    $(SV  $(NAN),       $(NAN)   )\n )\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 5689,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextUp",
				"line": 5692,
				"comment": " ditto\n",
				"deco": "FNaNbNiNedZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 5716,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextUp",
				"line": 5719,
				"comment": " ditto\n",
				"deco": "FNaNbNiNefZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 5746,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextDown",
				"line": 5763,
				"comment": " Calculate the next smallest floating point value before x.\n\n Return the greatest number less than x that is representable as a real;\n thus, it gives the previous point on the IEEE number line.\n\n  $(TABLE_SV\n    $(SVH x,            nextDown(x)   )\n    $(SV  $(INFIN),     real.max  )\n    $(SV  $(PLUSMN)0.0, -real.min_normal*real.epsilon )\n    $(SV  -real.max,    -$(INFIN) )\n    $(SV  -$(INFIN),    -$(INFIN) )\n    $(SV  $(NAN),       $(NAN)    )\n )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5781_551)\n---\nassert( nextDown(1.0 + real.epsilon) == 1.0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5781_551)\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 5766,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextDown",
				"line": 5769,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 5772,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextDown",
				"line": 5775,
				"comment": " ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 5778,
				"char": 7,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nextafter",
						"line": 5869,
						"type": "pure nothrow @nogc @safe T(const T x, const T y)",
						"parameters": [
							{
								"name": "x",
								"type": "T",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "y",
								"type": "T",
								"storageClass": [
									"const"
								]
							}
						],
						"endline": 5873,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "nextafter",
				"line": 5869,
				"comment": " Calculates the next representable value after x in the direction of y.\n\n If y > x, the result will be the next largest floating-point value;\n if y < x, the result will be the next smallest value.\n If x == y, the result is y.\n\n Remarks:\n This function is not generally very useful; it's almost always better to use\n the faster functions nextUp() or nextDown() instead.\n\n The FE_INEXACT and FE_OVERFLOW exceptions will be raised if x is finite and\n the function result is infinite. The FE_INEXACT and FE_UNDERFLOW\n exceptions will be raised if the function value is subnormal, and x is\n not equal to y.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5876_553)\n---\nfloat a = 1;\nassert(is(typeof(nextafter(a, a)) == float));\nassert(nextafter(a, a.infinity) > a);\n\ndouble b = 2;\nassert(is(typeof(nextafter(b, b)) == double));\nassert(nextafter(b, b.infinity) > b);\n\nreal c = 3;\nassert(is(typeof(nextafter(c, c)) == real));\nassert(nextafter(c, c.infinity) > c);\n}\n\n//real nexttoward(real x, real y) { return core.stdc.math.nexttowardl(x, y); }\n\n/*******************************************\n* Returns the positive difference between x and y.\n* Returns:\n*      $(TABLE_SV\n*      $(TR $(TH x, y)       $(TH fdim(x, y)))\n*      $(TR $(TD x $(GT) y)  $(TD x - y))\n*      $(TR $(TD x $(LT)= y) $(TD +0.0))\n*      )\n*/\nreal fdim(real x, real y) @safe pure nothrow @nogc { return (x > y) ? x - y : +0.0; \n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5876_553)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"endchar": 85,
				"name": "fdim",
				"line": 5902,
				"comment": " Returns the positive difference between x and y.\n Returns:\n      $(TABLE_SV\n      $(TR $(TH x, y)       $(TH fdim(x, y)))\n      $(TR $(TD x $(GT) y)  $(TD x - y))\n      $(TR $(TD x $(LT)= y) $(TD +0.0))\n      )\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 5902,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "fmax",
				"line": 5907,
				"comment": " Returns the larger of x and y.\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 5907,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "fmin",
				"line": 5912,
				"comment": " Returns the smaller of x and y.\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 5912,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 81,
				"name": "fma",
				"line": 5920,
				"comment": " Returns (x * y) + z, rounding only once according to the\n current rounding mode.\n\n BUGS: Not currently implemented - rounds twice.\n",
				"deco": "FNaNbNiNfeeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					},
					{
						"name": "z",
						"deco": "e"
					}
				],
				"endline": 5920,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "pow",
						"line": 5925,
						"type": "pure nothrow @nogc @trusted Unqual!F(F x, G n)",
						"parameters": [
							{
								"name": "x",
								"type": "F"
							},
							{
								"name": "n",
								"type": "G"
							}
						],
						"endline": 5970,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "pow",
				"line": 5925,
				"comment": " Compute the value of x $(SUPERSCRIPT n), where n is an integer\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "G",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!F && isIntegral!G",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "pow",
						"line": 6027,
						"type": "pure nothrow @nogc @trusted typeof(Unqual!F.init * Unqual!G.init)(F x, G n)",
						"parameters": [
							{
								"name": "x",
								"type": "F"
							},
							{
								"name": "n",
								"type": "G"
							}
						],
						"endline": 6062,
						"char": 43,
						"kind": "function"
					}
				],
				"name": "pow",
				"line": 6027,
				"comment": " Compute the value of an integer x, raised to the power of a positive\n integer n.\n\n  If both x and n are 0, the result is 1.\n  If n is negative, an integer divide error will occur at runtime,\n regardless of the value of x.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6065_556)\n---\nimmutable int one = 1;\nimmutable byte two = 2;\nimmutable ubyte three = 3;\nimmutable short four = 4;\nimmutable long ten = 10;\n\nassert(pow(two, three) == 8);\nassert(pow(two, ten) == 1024);\nassert(pow(one, ten) == 1);\nassert(pow(ten, four) == 10_000);\nassert(pow(four, 10) == 1_048_576);\nassert(pow(three, four) == 81);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6065_556)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "G",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!F && isIntegral!G",
				"char": 43,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "pow",
						"line": 6083,
						"type": "pure nothrow @nogc @trusted real(I x, F y)",
						"parameters": [
							{
								"name": "x",
								"type": "I"
							},
							{
								"name": "y",
								"type": "F"
							}
						],
						"endline": 6087,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "pow",
				"line": 6083,
				"comment": "Computes integer to floating point powers.\n",
				"parameters": [
					{
						"name": "I",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!I && isFloatingPoint!F",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "pow",
						"line": 6131,
						"type": "pure nothrow @nogc @trusted Unqual!(Largest!(F, G))(F x, G y)",
						"parameters": [
							{
								"name": "x",
								"type": "F"
							},
							{
								"name": "y",
								"type": "G"
							}
						],
						"endline": 6330,
						"char": 25,
						"kind": "function"
					}
				],
				"name": "pow",
				"line": 6131,
				"comment": " Calculates x$(SUPERSCRIPT y).\n\n $(TABLE_SV\n $(TR $(TH x) $(TH y) $(TH pow(x, y))\n      $(TH div 0) $(TH invalid?))\n $(TR $(TD anything)      $(TD $(PLUSMN)0.0)                $(TD 1.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD +$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD +$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD -$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD -$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(GT) 0.0)                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(LT) 0.0)                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD odd integer $(GT) 0.0)      $(TD -$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(GT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD no)        $(TD no))\n $(TR $(TD -$(INFIN))      $(TD odd integer $(LT) 0.0)      $(TD -0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(LT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)1.0)   $(TD $(PLUSMN)$(INFIN))          $(TD $(NAN))\n      $(TD no)        $(TD yes) )\n $(TR $(TD $(LT) 0.0)      $(TD finite, nonintegral)        $(TD $(NAN))\n      $(TD no)        $(TD yes))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(LT) 0.0)      $(TD $(PLUSMNINF))\n      $(TD yes)       $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(LT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD yes)       $(TD no))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(GT) 0.0)      $(TD $(PLUSMN)0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(GT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n )\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "G",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!F && isFloatingPoint!G",
				"char": 25,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "feqrel",
						"line": 6414,
						"type": "pure nothrow @nogc @trusted int(const X x, const X y)",
						"parameters": [
							{
								"name": "x",
								"type": "X",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "y",
								"type": "X",
								"storageClass": [
									"const"
								]
							}
						],
						"endline": 6484,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "feqrel",
				"line": 6414,
				"comment": " To what precision is x equal to y?\n\n Returns: the number of mantissa bits which are equal in x and y.\n eg, 0x1.F8p+60 and 0x1.F1p+60 are equal to 5 bits of precision.\n\n      $(TABLE_SV\n      $(TR $(TH x)      $(TH y)          $(TH feqrel(x, y)))\n      $(TR $(TD x)      $(TD x)          $(TD real.mant_dig))\n      $(TR $(TD x)      $(TD $(GT)= 2*x) $(TD 0))\n      $(TR $(TD x)      $(TD $(LT)= x/2) $(TD 0))\n      $(TR $(TD $(NAN)) $(TD any)        $(TD 0))\n      $(TR $(TD any)    $(TD $(NAN))     $(TD 0))\n      )\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!X",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "poly",
						"line": 6701,
						"type": "pure nothrow @nogc @trusted Unqual!(CommonType!(T1, T2))(T1 x, in T2[] A)",
						"parameters": [
							{
								"name": "x",
								"type": "T1"
							},
							{
								"name": "A",
								"type": "T2[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 6717,
						"char": 30,
						"kind": "function"
					}
				],
				"name": "poly",
				"line": 6701,
				"comment": " Evaluate polynomial A(x) = $(SUB a, 0) + $(SUB a, 1)x + $(SUB a, 2)$(POWER x,2)\n                          + $(SUB a,3)$(POWER x,3); ...\n\n Uses Horner's rule A(x) = $(SUB a, 0) + x($(SUB a, 1) + x($(SUB a, 2)\n                         + x($(SUB a, 3) + ...)))\n Params:\n      x =     the value to evaluate.\n      A =     array of coefficients $(SUB a, 0), $(SUB a, 1), etc.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6720_560)\n---\ndouble x = 3.1;\nstatic real[] pp = [56.1, 32.7, 6];\n\nassert(poly(x, pp) == (56.1L + (32.7L + 6.0L * x) * x));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6720_560)\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T1 && isFloatingPoint!T2",
				"char": 30,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "approxEqual",
						"line": 6899,
						"type": "bool(T lhs, U rhs, V maxRelDiff, V maxAbsDiff = 1e-05)",
						"parameters": [
							{
								"name": "lhs",
								"type": "T"
							},
							{
								"name": "rhs",
								"type": "U"
							},
							{
								"name": "maxRelDiff",
								"type": "V"
							},
							{
								"name": "maxAbsDiff",
								"type": "V",
								"default": "1e-05"
							}
						],
						"endline": 6960,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "approxEqual",
				"line": 6899,
				"comment": "   Computes whether $(D lhs) is approximately equal to $(D rhs)\n   admitting a maximum relative difference $(D maxRelDiff) and a\n   maximum absolute difference $(D maxAbsDiff).\n\n   If the two inputs are ranges, $(D approxEqual) returns true if and\n   only if the ranges have the same number of elements and if $(D\n   approxEqual) evaluates to $(D true) for each pair of elements.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "type"
					},
					{
						"name": "V",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "approxEqual",
						"line": 6965,
						"type": "bool(T lhs, U rhs)",
						"parameters": [
							{
								"name": "lhs",
								"type": "T"
							},
							{
								"name": "rhs",
								"type": "U"
							}
						],
						"endline": 6968,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "approxEqual",
				"line": 6965,
				"comment": "   Returns $(D approxEqual(lhs, rhs, 1e-2, 1e-5)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6971_563)\n---\nassert(approxEqual(1.0, 1.0099));\nassert(!approxEqual(1.0, 1.011));\nfloat[] arr1 = [ 1.0, 2.0, 3.0 ];\ndouble[] arr2 = [ 1.001, 1.999, 3 ];\nassert(approxEqual(arr1, arr2));\n\nreal num = real.infinity;\nassert(num == real.infinity);  // Passes.\nassert(approxEqual(num, real.infinity));  // Fails.\nnum = -real.infinity;\nassert(num == -real.infinity);  // Passes.\nassert(approxEqual(num, -real.infinity));  // Fails.\n\nassert(!approxEqual(3, 0));\nassert(approxEqual(3, 3));\nassert(approxEqual(3.0, 3));\nassert(approxEqual([3, 3, 3], 3.0));\nassert(approxEqual([3.0, 3.0, 3.0], 3));\nint a = 10;\nassert(approxEqual(10, a));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6971_563)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cmp",
						"line": 7117,
						"type": "pure nothrow @nogc @trusted int(const(T) x, const(T) y)",
						"parameters": [
							{
								"name": "x",
								"type": "const(T)"
							},
							{
								"name": "y",
								"type": "const(T)"
							}
						],
						"endline": 7252,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "cmp",
				"line": 7117,
				"comment": " Defines a total order on all floating-point numbers.\n\n The order is defined as follows:\n $(UL\n      $(LI All numbers in [-$(INFIN), +$(INFIN)] are ordered\n          the same way as by built-in comparison, with the exception of\n          -0.0, which is less than +0.0;)\n      $(LI If the sign bit is set (that is, it's 'negative'), $(NAN) is less\n          than any number; if the sign bit is not set (it is 'positive'),\n          $(NAN) is greater than any number;)\n      $(LI $(NAN)s of the same sign are ordered by the payload ('negative'\n          ones - in reverse order).)\n )\n\n Returns:\n      negative value if $(D x) precedes $(D y) in the order specified above;\n      0 if $(D x) and $(D y) are identical, and positive value otherwise.\n\n See_Also:\n      $(MYREF isIdentical)\n Standards: Conforms to IEEE 754-2008\nExample:\nMost numbers are ordered naturally.$(DDOX_UNITTEST_HEADER __unittestL7255_572)\n---\nassert(cmp(-double.infinity, -double.max) < 0);\nassert(cmp(-double.max, -100.0) < 0);\nassert(cmp(-100.0, -0.5) < 0);\nassert(cmp(-0.5, 0.0) < 0);\nassert(cmp(0.0, 0.5) < 0);\nassert(cmp(0.5, 100.0) < 0);\nassert(cmp(100.0, double.max) < 0);\nassert(cmp(double.max, double.infinity) < 0);\n\nassert(cmp(1.0, 1.0) == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7255_572)\nExample:\nPositive and negative zeroes are distinct.$(DDOX_UNITTEST_HEADER __unittestL7270_573)\n---\nassert(cmp(-0.0, +0.0) < 0);\nassert(cmp(+0.0, -0.0) > 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7270_573)\nExample:\nDepending on the sign, $(NAN)s go to either end of the spectrum.$(DDOX_UNITTEST_HEADER __unittestL7277_574)\n---\nassert(cmp(-double.nan, -double.infinity) < 0);\nassert(cmp(double.infinity, double.nan) < 0);\nassert(cmp(-double.nan, double.nan) < 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7277_574)\nExample:\n$(NAN)s of the same sign are ordered by the payload.$(DDOX_UNITTEST_HEADER __unittestL7285_575)\n---\nassert(cmp(NaN(10), NaN(20)) < 0);\nassert(cmp(-NaN(20), -NaN(10)) < 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7285_575)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T",
				"char": 5,
				"kind": "template"
			}
		],
		"comment": " Contains the elementary mathematical functions (powers, roots,\n and trigonometric functions), and low-level floating-point operations.\n Mathematical special functions are available in $(D std.mathspecial).\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Members) )\n$(TR $(TDNW Constants) $(TD\n    $(MYREF E) $(MYREF PI) $(MYREF PI_2) $(MYREF PI_4) $(MYREF M_1_PI)\n    $(MYREF M_2_PI) $(MYREF M_2_SQRTPI) $(MYREF LN10) $(MYREF LN2)\n    $(MYREF LOG2) $(MYREF LOG2E) $(MYREF LOG2T) $(MYREF LOG10E)\n    $(MYREF SQRT2) $(MYREF SQRT1_2)\n))\n$(TR $(TDNW Classics) $(TD\n $(MYREF abs) $(MYREF fabs) $(MYREF sqrt) $(MYREF cbrt) $(MYREF hypot) $(MYREF poly)\n))\n$(TR $(TDNW Trigonometry) $(TD\n    $(MYREF sin) $(MYREF cos) $(MYREF tan) $(MYREF asin) $(MYREF acos)\n    $(MYREF atan) $(MYREF atan2) $(MYREF sinh) $(MYREF cosh) $(MYREF tanh)\n    $(MYREF asinh) $(MYREF acosh) $(MYREF atanh) $(MYREF expi)\n))\n$(TR $(TDNW Rounding) $(TD\n    $(MYREF ceil) $(MYREF floor) $(MYREF round) $(MYREF lround)\n    $(MYREF trunc) $(MYREF rint) $(MYREF lrint) $(MYREF nearbyint)\n    $(MYREF rndtol)\n))\n$(TR $(TDNW Exponentiation & Logarithms) $(TD\n    $(MYREF pow) $(MYREF exp) $(MYREF exp2) $(MYREF expm1) $(MYREF ldexp)\n    $(MYREF frexp) $(MYREF log) $(MYREF log2) $(MYREF log10) $(MYREF logb)\n    $(MYREF ilogb) $(MYREF log1p) $(MYREF scalbn)\n))\n$(TR $(TDNW Modulus) $(TD\n    $(MYREF fmod) $(MYREF modf) $(MYREF remainder)\n))\n$(TR $(TDNW Floating-point operations) $(TD\n    $(MYREF approxEqual) $(MYREF feqrel) $(MYREF fdim) $(MYREF fmax)\n    $(MYREF fmin) $(MYREF fma) $(MYREF nextDown) $(MYREF nextUp)\n    $(MYREF nextafter) $(MYREF NaN) $(MYREF getNaNPayload)\n    $(MYREF cmp)\n))\n$(TR $(TDNW Introspection) $(TD\n    $(MYREF isFinite) $(MYREF isIdentical) $(MYREF isInfinity) $(MYREF isNaN)\n    $(MYREF isNormal) $(MYREF isSubnormal) $(MYREF signbit) $(MYREF sgn)\n    $(MYREF copysign)\n))\n$(TR $(TDNW Complex Numbers) $(TD\n  $(MYREF abs) $(MYREF conj) $(MYREF sin) $(MYREF cos) $(MYREF expi)\n))\n$(TR $(TDNW Hardware Control) $(TD\n    $(MYREF IeeeFlags) $(MYREF FloatingPointControl)\n))\n)\n)\n\n The functionality closely follows the IEEE754-2008 standard for\n floating-point arithmetic, including the use of camelCase names rather\n than C99-style lower case names. All of these functions behave correctly\n when presented with an infinity or NaN.\n\n The following IEEE 'real' formats are currently supported:\n $(UL\n $(LI 64 bit Big-endian  'double' (eg PowerPC))\n $(LI 128 bit Big-endian 'quadruple' (eg SPARC))\n $(LI 64 bit Little-endian 'double' (eg x86-SSE2))\n $(LI 80 bit Little-endian, with implied bit 'real80' (eg x87, Itanium))\n $(LI 128 bit Little-endian 'quadruple' (not implemented on any known processor!))\n $(LI Non-IEEE 128 bit Big-endian 'doubledouble' (eg PowerPC) has partial support)\n )\n Unlike C, there is no global 'errno' variable. Consequently, almost all of\n these functions are pure nothrow.\n\n Status:\n The semantics and names of feqrel and approxEqual will be revised.\n\n Macros:\n      WIKI = Phobos/StdMath\n\n      TABLE_SV = <table border=\"1\" cellpadding=\"4\" cellspacing=\"0\">\n              <caption>Special Values</caption>\n              $0</table>\n      SVH = $(TR $(TH $1) $(TH $2))\n      SV  = $(TR $(TD $1) $(TD $2))\n      TH3 = $(TR $(TH $1) $(TH $2) $(TH $3))\n      TD3 = $(TR $(TD $1) $(TD $2) $(TD $3))\n\n      NAN = $(RED NAN)\n      SUP = <span style=\"vertical-align:super;font-size:smaller\">$0</span>\n      GAMMA = &#915;\n      THETA = &theta;\n      INTEGRAL = &#8747;\n      INTEGRATE = $(BIG &#8747;<sub>$(SMALL $1)</sub><sup>$2</sup>)\n      POWER = $1<sup>$2</sup>\n      SUB = $1<sub>$2</sub>\n      BIGSUM = $(BIG &Sigma; <sup>$2</sup><sub>$(SMALL $1)</sub>)\n      CHOOSE = $(BIG &#40;) <sup>$(SMALL $1)</sup><sub>$(SMALL $2)</sub> $(BIG &#41;)\n      PLUSMN = &plusmn;\n      INFIN = &infin;\n      PLUSMNINF = &plusmn;&infin;\n      PI = &pi;\n      LT = &lt;\n      GT = &gt;\n      SQRT = &radic;\n      HALF = &frac12;\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n            D implementations of tan, atan, atan2, exp, expm1, exp2, log, log10, log1p,\n            log2, floor, ceil and lrint functions are based on the CEPHES math library,\n            which is Copyright (C) 2001 Stephen L. Moshier $(LT)steve@moshier.net$(GT)\n            and are incorporated herein by permission of the author.  The author\n            reserves the right to distribute this material elsewhere under different\n            copying permissions.  These modifications are distributed here under\n            the following terms:\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright), Don Clugston,\n            Conversion of CEPHES math library to D by Iain Buclaw\n Source: $(PHOBOSSRC std/_math.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/mathspecial.d",
		"name": "std.mathspecial",
		"members": [
			{
				"endchar": 1,
				"name": "gamma",
				"line": 90,
				"comment": " The Gamma function, $(GAMMA)(x)\n\n  $(GAMMA)(x) is a generalisation of the factorial function\n  to real and complex numbers.\n  Like x!, $(GAMMA)(x+1) = x * $(GAMMA)(x).\n\n  Mathematically, if z.re > 0 then\n   $(GAMMA)(z) = $(INTEGRATE 0, $(INFIN)) $(POWER t, z-1)$(POWER e, -t) dt\n\n  $(TABLE_SV\n    $(SVH  x,           $(GAMMA)(x) )\n    $(SV  $(NAN),       $(NAN)      )\n    $(SV  $(PLUSMN)0.0, $(PLUSMNINF))\n    $(SV integer > 0,   (x-1)!      )\n    $(SV integer < 0,   $(NAN)      )\n    $(SV +$(INFIN),      +$(INFIN)   )\n    $(SV -$(INFIN),      $(NAN)      )\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 93,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "logGamma",
				"line": 109,
				"comment": " Natural logarithm of the gamma function, $(GAMMA)(x)\n\n Returns the base e (2.718...) logarithm of the absolute\n value of the gamma function of the argument.\n\n For reals, logGamma is equivalent to log(fabs(gamma(x))).\n\n  $(TABLE_SV\n    $(SVH  x,             logGamma(x)   )\n    $(SV  $(NAN),         $(NAN)      )\n    $(SV integer <= 0,    +$(INFIN)    )\n    $(SV $(PLUSMNINF),    +$(INFIN)    )\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 112,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sgnGamma",
				"line": 122,
				"comment": " The sign of $(GAMMA)(x).\n\n Returns -1 if $(GAMMA)(x) < 0,  +1 if $(GAMMA)(x) > 0,\n $(NAN) if sign is indeterminate.\n\n Note that this function can be used in conjunction with logGamma(x) to\n evaluate gamma for very large values of x.\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 137,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "beta",
				"line": 154,
				"comment": " Beta function\n\n The beta function is defined as\n\n beta(x, y) = ($(GAMMA)(x) * $(GAMMA)(y)) / $(GAMMA)(x + y)\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 159,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "digamma",
				"line": 174,
				"comment": " Digamma function\n\n  The digamma function is the logarithmic derivative of the gamma function.\n\n  digamma(x) = d/dx logGamma(x)\n\n  See_Also: $(LREF logmdigamma), $(LREF logmdigammaInverse).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 177,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "logmdigamma",
				"line": 185,
				"comment": " Log Minus Digamma function\n\n  logmdigamma(x) = log(x) - digamma(x)\n\n  See_Also: $(LREF digamma), $(LREF logmdigammaInverse).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 188,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "logmdigammaInverse",
				"line": 196,
				"comment": " Inverse of the Log Minus Digamma function\n\n  Given y, the function finds x such log(x) - digamma(x) = y.\n\n  See_Also: $(LREF logmdigamma), $(LREF digamma).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 199,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "betaIncomplete",
				"line": 221,
				"comment": " Incomplete beta integral\n\n Returns incomplete beta integral of the arguments, evaluated\n from zero to x. The regularized incomplete beta function is defined as\n\n betaIncomplete(a, b, x) = $(GAMMA)(a + b) / ( $(GAMMA)(a) $(GAMMA)(b) ) *\n $(INTEGRATE 0, x) $(POWER t, a-1)$(POWER (1-t), b-1) dt\n\n and is the same as the the cumulative distribution function.\n\n The domain of definition is 0 <= x <= 1.  In this\n implementation a and b are restricted to positive values.\n The integral from x to 1 may be obtained by the symmetry\n relation\n\n    betaIncompleteCompl(a, b, x )  =  betaIncomplete( b, a, 1-x )\n\n The integral is evaluated by a continued fraction expansion\n or, when b * x is small, by a power series.\n",
				"deco": "FNaNbNiNfeeeZe",
				"parameters": [
					{
						"name": "a",
						"deco": "e"
					},
					{
						"name": "b",
						"deco": "e"
					},
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 224,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "betaIncompleteInverse",
				"line": 234,
				"comment": " Inverse of incomplete beta integral\n\n Given y, the function finds x such that\n\n  betaIncomplete(a, b, x) == y\n\n  Newton iterations or interval halving is used.\n",
				"deco": "FNaNbNiNfeeeZe",
				"parameters": [
					{
						"name": "a",
						"deco": "e"
					},
					{
						"name": "b",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 237,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "gammaIncomplete",
				"line": 253,
				"comment": " Incomplete gamma integral and its complement\n\n These functions are defined by\n\n   gammaIncomplete = ( $(INTEGRATE 0, x) $(POWER e, -t) $(POWER t, a-1) dt )/ $(GAMMA)(a)\n\n  gammaIncompleteCompl(a,x)   =   1 - gammaIncomplete(a,x)\n = ($(INTEGRATE x, $(INFIN)) $(POWER e, -t) $(POWER t, a-1) dt )/ $(GAMMA)(a)\n\n In this implementation both arguments must be positive.\n The integral is evaluated by either a power series or\n continued fraction expansion, depending on the relative\n values of a and x.\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "a",
						"deco": "e"
					},
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 260,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "gammaIncompleteCompl",
				"line": 263,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "a",
						"deco": "e"
					},
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 270,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "gammaIncompleteComplInverse",
				"line": 278,
				"comment": " Inverse of complemented incomplete gamma integral\n\n Given a and p, the function finds x such that\n\n  gammaIncompleteCompl( a, x ) = p.\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "a",
						"deco": "e"
					},
					{
						"name": "p",
						"deco": "e"
					}
				],
				"endline": 285,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "erf",
				"line": 302,
				"comment": " Error function\n\n The integral is\n\n  erf(x) =  2/ $(SQRT)($(PI))\n     $(INTEGRATE 0, x) exp( - $(POWER t, 2)) dt\n\n The magnitude of x is limited to about 106.56 for IEEE 80-bit\n arithmetic; 1 or -1 is returned outside this range.\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 305,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "erfc",
				"line": 316,
				"comment": " Complementary error function\n\n erfc(x) = 1 - erf(x)\n         = 2/ $(SQRT)($(PI))\n     $(INTEGRATE x, $(INFIN)) exp( - $(POWER t, 2)) dt\n\n This function has high relative accuracy for\n values of x far from zero. (For values near zero, use erf(x)).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 319,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "normalDistribution",
				"line": 339,
				"comment": " Normal distribution function.\n\n The normal (or Gaussian, or bell-shaped) distribution is\n defined as:\n\n normalDist(x) = 1/$(SQRT)(2$(PI)) $(INTEGRATE -$(INFIN), x) exp( - $(POWER t, 2)/2) dt\n   = 0.5 + 0.5 * erf(x/sqrt(2))\n   = 0.5 * erfc(- x/sqrt(2))\n\n To maintain accuracy at values of x near 1.0, use\n      normalDistribution(x) = 1.0 - normalDistribution(-x).\n\n References:\n $(LINK http://www.netlib.org/cephes/ldoubdoc.html),\n G. Marsaglia, \"Evaluating the Normal Distribution\",\n Journal of Statistical Software <b>11</b>, (July 2004).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 342,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "normalDistributionInverse",
				"line": 350,
				"comment": " Inverse of Normal distribution function\n\n Returns the argument, x, for which the area under the\n Normal probability density function (integrated from\n minus infinity to x) is equal to p.\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "p",
						"deco": "e"
					}
				],
				"endline": 357,
				"char": 6,
				"kind": "function"
			}
		],
		"comment": " Mathematical Special Functions\n\n The technical term 'Special Functions' includes several families of\n transcendental functions, which have important applications in particular\n branches of mathematics and physics.\n\n The gamma and related functions, and the error function are crucial for\n mathematical statistics.\n The Bessel and related functions arise in problems involving wave propagation\n (especially in optics).\n Other major categories of special functions include the elliptic integrals\n (related to the arc length of an ellipse), and the hypergeometric functions.\n\n Status:\n  Many more functions will be added to this module.\n  The naming convention for the distribution functions (gammaIncomplete, etc)\n  is not yet finalized and will probably change.\n\n Macros:\n      WIKI = Phobos/StdMathSpecial\n\n      TABLE_SV = <table border=\"1\" cellpadding=\"4\" cellspacing=\"0\">\n              <caption>Special Values</caption>\n              $0</table>\n      SVH = $(TR $(TH $1) $(TH $2))\n      SV  = $(TR $(TD $1) $(TD $2))\n\n      NAN = $(RED NAN)\n      SUP = <span style=\"vertical-align:super;font-size:smaller\">$0</span>\n      GAMMA = &#915;\n      THETA = &theta;\n      INTEGRAL = &#8747;\n      INTEGRATE = $(BIG &#8747;<sub>$(SMALL $1)</sub><sup>$2</sup>)\n      POWER = $1<sup>$2</sup>\n      SUB = $1<sub>$2</sub>\n      BIGSUM = $(BIG &Sigma; <sup>$2</sup><sub>$(SMALL $1)</sub>)\n      CHOOSE = $(BIG &#40;) <sup>$(SMALL $1)</sup><sub>$(SMALL $2)</sub> $(BIG &#41;)\n      PLUSMN = &plusmn;\n      INFIN = &infin;\n      PLUSMNINF = &plusmn;&infin;\n      PI = &pi;\n      LT = &lt;\n      GT = &gt;\n      SQRT = &radic;\n      HALF = &frac12;\n\n\n Copyright: Based on the CEPHES math library, which is\n            Copyright (C) 1994 Stephen L. Moshier (moshier@world.std.com).\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Stephen L. Moshier (original C code). Conversion to D by Don Clugston\n Source:    $(PHOBOSSRC std/_mathspecial.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/process.d",
		"name": "std.process",
		"members": [
			{
				"endchar": 1,
				"name": "spawnProcess",
				"line": 289,
				"comment": "Spawns a new _process, optionally assigning it an arbitrary set of standard\ninput, output, and error streams.\n\nThe function returns immediately, leaving the child _process to execute\nin parallel with its parent.  It is recommended to always call $(LREF wait)\non the returned $(LREF Pid), as detailed in the documentation for $(D wait).\n\nCommand_line:\nThere are four overloads of this function.  The first two take an array\nof strings, $(D args), which should contain the program name as the\nzeroth element and any command-line arguments in subsequent elements.\nThe third and fourth versions are included for convenience, and may be\nused when there are no command-line arguments.  They take a single string,\n$(D program), which specifies the program name.\n\nUnless a directory is specified in $(D args[0]) or $(D program),\n$(D spawnProcess) will search for the program in a platform-dependent\nmanner.  On POSIX systems, it will look for the executable in the\ndirectories listed in the PATH environment variable, in the order\nthey are listed.  On Windows, it will search for the executable in\nthe following sequence:\n$(OL\n    $(LI The directory from which the application loaded.)\n    $(LI The current directory for the parent process.)\n    $(LI The 32-bit Windows system directory.)\n    $(LI The 16-bit Windows system directory.)\n    $(LI The Windows directory.)\n    $(LI The directories listed in the PATH environment variable.)\n)\n---\n// Run an executable called \"prog\" located in the current working\n// directory:\nauto pid = spawnProcess(\"./prog\");\nscope(exit) wait(pid);\n// We can do something else while the program runs.  The scope guard\n// ensures that the process is waited for at the end of the scope.\n...\n\n// Run DMD on the file \"myprog.d\", specifying a few compiler switches:\nauto dmdPid = spawnProcess([\"dmd\", \"-O\", \"-release\", \"-inline\", \"myprog.d\" ]);\nif (wait(dmdPid) != 0)\n    writeln(\"Compilation failed!\");\n---\n\nEnvironment_variables:\nBy default, the child process inherits the environment of the parent\nprocess, along with any additional variables specified in the $(D env)\nparameter.  If the same variable exists in both the parent's environment\nand in $(D env), the latter takes precedence.\n\nIf the $(LREF Config.newEnv) flag is set in $(D config), the child\nprocess will $(I not) inherit the parent's environment.  Its entire\nenvironment will then be determined by $(D env).\n---\nwait(spawnProcess(\"myapp\", [\"foo\" : \"bar\"], Config.newEnv));\n---\n\nStandard_streams:\nThe optional arguments $(D stdin), $(D stdout) and $(D stderr) may\nbe used to assign arbitrary $(XREF stdio,File) objects as the standard\ninput, output and error streams, respectively, of the child process.  The\nformer must be opened for reading, while the latter two must be opened for\nwriting.  The default is for the child process to inherit the standard\nstreams of its parent.\n---\n// Run DMD on the file myprog.d, logging any error messages to a\n// file named errors.log.\nauto logFile = File(\"errors.log\", \"w\");\nauto pid = spawnProcess([\"dmd\", \"myprog.d\"],\n                        std.stdio.stdin,\n                        std.stdio.stdout,\n                        logFile);\nif (wait(pid) != 0)\n    writeln(\"Compilation failed. See errors.log for details.\");\n---\n\nNote that if you pass a $(D File) object that is $(I not)\none of the standard input/output/error streams of the parent process,\nthat stream will by default be $(I closed) in the parent process when\nthis function returns.  See the $(LREF Config) documentation below for\ninformation about how to disable this behaviour.\n\nBeware of buffering issues when passing $(D File) objects to\n$(D spawnProcess).  The child process will inherit the low-level raw\nread/write offset associated with the underlying file descriptor, but\nit will not be aware of any buffered data.  In cases where this matters\n(e.g. when a file should be aligned before being passed on to the\nchild process), it may be a good idea to use unbuffered streams, or at\nleast ensure all relevant buffers are flushed.\n\nParams:\nargs    = An array which contains the program name as the zeroth element\n          and any command-line arguments in the following elements.\nstdin   = The standard input stream of the child process.\n          This can be any $(XREF stdio,File) that is opened for reading.\n          By default the child process inherits the parent's input\n          stream.\nstdout  = The standard output stream of the child process.\n          This can be any $(XREF stdio,File) that is opened for writing.\n          By default the child process inherits the parent's output stream.\nstderr  = The standard error stream of the child process.\n          This can be any $(XREF stdio,File) that is opened for writing.\n          By default the child process inherits the parent's error stream.\nenv     = Additional environment variables for the child process.\nconfig  = Flags that control process creation. See $(LREF Config)\n          for an overview of available flags.\nworkDir = The working directory for the new process.\n          By default the child process inherits the parent's working\n          directory.\n\nReturns:\nA $(LREF Pid) object that corresponds to the spawned process.\n\nThrows:\n$(LREF ProcessException) on failure to start the process.$(BR)\n$(XREF stdio,StdioException) on failure to pass one of the streams\n    to the child process (Windows only).$(BR)\n$(CXREF exception,RangeError) if $(D args) is empty.\n",
				"deco": "FNexAAaS3std5stdio4FileS3std5stdio4FileS3std5stdio4FilexHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "args",
						"deco": "xAAa"
					},
					{
						"name": "stdin",
						"deco": "S3std5stdio4File",
						"default": "stdin"
					},
					{
						"name": "stdout",
						"deco": "S3std5stdio4File",
						"default": "stdout"
					},
					{
						"name": "stderr",
						"deco": "S3std5stdio4File",
						"default": "stderr"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 301,
				"originalType": "@trusted Pid(in char[][] args, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "spawnProcess",
				"line": 304,
				"comment": "ditto\n",
				"deco": "FNexAAaxHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "args",
						"deco": "xAAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 317,
				"originalType": "@trusted Pid(in char[][] args, const string[string] env, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "spawnProcess",
				"line": 320,
				"comment": "ditto\n",
				"deco": "FNexAaS3std5stdio4FileS3std5stdio4FileS3std5stdio4FilexHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "program",
						"deco": "xAa"
					},
					{
						"name": "stdin",
						"deco": "S3std5stdio4File",
						"default": "stdin"
					},
					{
						"name": "stdout",
						"deco": "S3std5stdio4File",
						"default": "stdout"
					},
					{
						"name": "stderr",
						"deco": "S3std5stdio4File",
						"default": "stderr"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 331,
				"originalType": "@trusted Pid(in char[] program, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "spawnProcess",
				"line": 334,
				"comment": "ditto\n",
				"deco": "FNexAaxHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "program",
						"deco": "xAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 341,
				"originalType": "@trusted Pid(in char[] program, const string[string] env, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "spawnShell",
				"line": 957,
				"comment": "A variation on $(LREF spawnProcess) that runs the given _command through\nthe current user's preferred _command interpreter (aka. shell).\n\nThe string $(D command) is passed verbatim to the shell, and is therefore\nsubject to its rules about _command structure, argument/filename quoting\nand escaping of special characters.\nThe path to the shell executable is always $(CODE /bin/sh) on POSIX, and\ndetermined by the $(LREF userShell) function on Windows.\n\nIn all other respects this function works just like $(D spawnProcess).\nPlease refer to the $(LREF spawnProcess) documentation for descriptions\nof the other function parameters, the return value and any exceptions\nthat may be thrown.\n---\n// Run the command/program \"foo\" on the file named \"my file.txt\", and\n// redirect its output into foo.log.\nauto pid = spawnShell(`foo \"my file.txt\" > foo.log`);\nwait(pid);\n---\n\nSee_also:\n$(LREF escapeShellCommand), which may be helpful in constructing a\nproperly quoted and escaped shell _command line for the current platform.\n",
				"deco": "FNexAaS3std5stdio4FileS3std5stdio4FileS3std5stdio4FilexHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "command",
						"deco": "xAa"
					},
					{
						"name": "stdin",
						"deco": "S3std5stdio4File",
						"default": "stdin"
					},
					{
						"name": "stdout",
						"deco": "S3std5stdio4File",
						"default": "stdout"
					},
					{
						"name": "stderr",
						"deco": "S3std5stdio4File",
						"default": "stderr"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 983,
				"originalType": "@trusted Pid(in char[] command, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "spawnShell",
				"line": 986,
				"comment": "ditto\n",
				"deco": "FNexAaxHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "command",
						"deco": "xAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 999,
				"originalType": "@trusted Pid(in char[] command, const string[string] env, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "newEnv",
						"line": 1072,
						"value": "1",
						"comment": "    By default, the child process inherits the parent's environment,\n    and any environment variables passed to $(LREF spawnProcess) will\n    be added to it.  If this flag is set, the only variables in the\n    child process' environment will be those given to spawnProcess.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "retainStdin",
						"line": 1081,
						"value": "2",
						"comment": "    Unless the child process inherits the standard input/output/error\n    streams of its parent, one almost always wants the streams closed\n    in the parent when $(LREF spawnProcess) returns.  Therefore, by\n    default, this is done.  If this is not desirable, pass any of these\n    options to spawnProcess.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "retainStdout",
						"line": 1082,
						"value": "4",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "retainStderr",
						"line": 1083,
						"value": "8",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "suppressConsole",
						"line": 1090,
						"value": "16",
						"comment": "    On Windows, if the child process is a console application, this\n    flag will prevent the creation of a console window.  Otherwise,\n    it will be ignored. On POSIX, $(D suppressConsole) has no effect.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "inheritFDs",
						"line": 1105,
						"value": "32",
						"comment": "    On POSIX, open $(LINK2 http://en.wikipedia.org/wiki/File_descriptor,file descriptors)\n    are by default inherited by the child process.  As this may lead\n    to subtle bugs when pipes or multiple threads are involved,\n    $(LREF spawnProcess) ensures that all file descriptors except the\n    ones that correspond to standard input/output/error are closed\n    in the child process when it starts.  Use $(D inheritFDs) to prevent\n    this.\n\n    On Windows, this option has no effect, and any handles which have been\n    explicitly marked as inheritable will always be inherited by the child\n    process.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Config",
				"line": 1062,
				"comment": "Flags that control the behaviour of $(LREF spawnProcess) and\n$(LREF spawnShell).\n\nUse bitwise OR to combine flags.\n\nExample:\n---\nauto logFile = File(\"myapp_error.log\", \"w\");\n\n// Start program, suppressing the console window (Windows only),\n// redirect its error stream to logFile, and leave logFile open\n// in the parent process as well.\nauto pid = spawnProcess(\"myapp\", stdin, stdout, logFile,\n                        Config.retainStderr | Config.suppressConsole);\nscope(exit)\n{\n    auto exitCode = wait(pid);\n    logFile.writeln(\"myapp exited with code \", exitCode);\n    logFile.close();\n}\n---\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Pid",
				"line": 1110,
				"comment": "A handle that corresponds to a spawned process.\n",
				"members": [
					{
						"endchar": 5,
						"name": "processID",
						"line": 1120,
						"comment": "    The process ID number.\n\n    This is a number that uniquely identifies the process on the operating\n    system, for at least as long as the process is running.  Once $(LREF wait)\n    has been called on the $(LREF Pid), this method will return an\n    invalid (negative) process ID.\n",
						"deco": "xFNaNbNdNfZi",
						"endline": 1123,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "osHandle",
						"line": 1143,
						"comment": "    An operating system handle to the process.\n\n    This handle is used to specify the process in OS-specific APIs.\n    On POSIX, this function returns a $(D core.sys.posix.sys.types.pid_t)\n    with the same value as $(LREF Pid.processID), while on Windows it returns\n    a $(D core.sys.windows.windows.HANDLE).\n\n    Once $(LREF wait) has been called on the $(LREF Pid), this method\n    will return an invalid handle.\n",
						"deco": "FNaNbNdNfZi",
						"endline": 1146,
						"originalType": "pure nothrow @property @safe pid_t()",
						"char": 21,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "wait",
				"line": 1301,
				"comment": "Waits for the process associated with $(D pid) to terminate, and returns\nits exit status.\n\nIn general one should always _wait for child processes to terminate\nbefore exiting the parent process.  Otherwise, they may become\n\"$(WEB en.wikipedia.org/wiki/Zombie_process,zombies)\" – processes\nthat are defunct, yet still occupy a slot in the OS process table.\n\nIf the process has already terminated, this function returns directly.\nThe exit code is cached, so that if wait() is called multiple times on\nthe same $(LREF Pid) it will always return the same value.\n\nPOSIX_specific:\nIf the process is terminated by a signal, this function returns a\nnegative number whose absolute value is the signal number.\nSince POSIX restricts normal exit codes to the range 0-255, a\nnegative return value will always indicate termination by signal.\nSignal codes are defined in the $(D core.sys.posix.signal) module\n(which corresponds to the $(D signal.h) POSIX header).\n\nThrows:\n$(LREF ProcessException) on failure.\n\nExample:\nSee the $(LREF spawnProcess) documentation.\n\nSee_also:\n$(LREF tryWait), for a non-blocking function.\n",
				"deco": "FNfC3std7process3PidZi",
				"parameters": [
					{
						"name": "pid",
						"deco": "C3std7process3Pid"
					}
				],
				"endline": 1305,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "tryWait",
				"line": 1370,
				"comment": "A non-blocking version of $(LREF wait).\n\nIf the process associated with $(D pid) has already terminated,\n$(D tryWait) has the exact same effect as $(D wait).\nIn this case, it returns a tuple where the $(D terminated) field\nis set to $(D true) and the $(D status) field has the same\ninterpretation as the return value of $(D wait).\n\nIf the process has $(I not) yet terminated, this function differs\nfrom $(D wait) in that does not wait for this to happen, but instead\nreturns immediately.  The $(D terminated) field of the returned\ntuple will then be set to $(D false), while the $(D status) field\nwill always be 0 (zero).  $(D wait) or $(D tryWait) should then be\ncalled again on the same $(D Pid) at some later time; not only to\nget the exit code, but also to avoid the process becoming a \"zombie\"\nwhen it finally terminates.  (See $(LREF wait) for details).\n\nReturns:\nAn $(D std.typecons.Tuple!(bool, \"terminated\", int, \"status\")).\n\nThrows:\n$(LREF ProcessException) on failure.\n\nExample:\n---\nauto pid = spawnProcess(\"dmd myapp.d\");\nscope(exit) wait(pid);\n...\nauto dmd = tryWait(pid);\nif (dmd.terminated)\n{\n    if (dmd.status == 0) writeln(\"Compilation succeeded!\");\n    else writeln(\"Compilation failed\");\n}\nelse writeln(\"Still compiling...\");\n...\n---\nNote that in this example, the first $(D wait) call will have no\neffect if the process has already terminated by the time $(D tryWait)\nis called.  In the opposite case, however, the $(D scope) statement\nensures that we always wait for the process if it hasn't terminated\nby the time we reach the end of the scope.\n",
				"deco": "FNfC3std7process3PidZS3std8typecons61__T5TupleTbVAyaa10_7465726d696e61746564TiVAyaa6_737461747573Z5Tuple",
				"parameters": [
					{
						"name": "pid",
						"deco": "C3std7process3Pid"
					}
				],
				"endline": 1376,
				"originalType": "@safe (Pid pid)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"endchar": 1,
				"name": "kill",
				"line": 1429,
				"comment": "Attempts to terminate the process associated with $(D pid).\n\nThe effect of this function, as well as the meaning of $(D codeOrSignal),\nis highly platform dependent.  Details are given below.  Common to all\nplatforms is that this function only $(I initiates) termination of the process,\nand returns immediately.  It does not wait for the process to end,\nnor does it guarantee that the process does in fact get terminated.\n\nAlways call $(LREF wait) to wait for a process to complete, even if $(D kill)\nhas been called on it.\n\nWindows_specific:\nThe process will be\n$(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx,\nforcefully and abruptly terminated).  If $(D codeOrSignal) is specified, it\nmust be a nonnegative number which will be used as the exit code of the process.\nIf not, the process wil exit with code 1.  Do not use $(D codeOrSignal = 259),\nas this is a special value (aka. $(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx,STILL_ACTIVE))\nused by Windows to signal that a process has in fact $(I not) terminated yet.\n---\nauto pid = spawnProcess(\"some_app\");\nkill(pid, 10);\nassert (wait(pid) == 10);\n---\n\nPOSIX_specific:\nA $(LINK2 http://en.wikipedia.org/wiki/Unix_signal,signal) will be sent to\nthe process, whose value is given by $(D codeOrSignal).  Depending on the\nsignal sent, this may or may not terminate the process.  Symbolic constants\nfor various $(LINK2 http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals,\nPOSIX signals) are defined in $(D core.sys.posix.signal), which corresponds to the\n$(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html,\n$(D signal.h) POSIX header).  If $(D codeOrSignal) is omitted, the\n$(D SIGTERM) signal will be sent.  (This matches the behaviour of the\n$(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/kill.html,\n$(D _kill)) shell command.)\n---\nimport core.sys.posix.signal: SIGKILL;\nauto pid = spawnProcess(\"some_app\");\nkill(pid, SIGKILL);\nassert (wait(pid) == -SIGKILL); // Negative return value on POSIX!\n---\n\nThrows:\n$(LREF ProcessException) on error (e.g. if codeOrSignal is invalid).\n    Note that failure to terminate the process is considered a \"normal\"\n    outcome, not an error.$(BR)\n",
				"deco": "FC3std7process3PidZv",
				"parameters": [
					{
						"name": "pid",
						"deco": "C3std7process3Pid"
					}
				],
				"endline": 1437,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "kill",
				"line": 1440,
				"comment": "ditto\n",
				"deco": "FC3std7process3PidiZv",
				"parameters": [
					{
						"name": "pid",
						"deco": "C3std7process3Pid"
					},
					{
						"name": "codeOrSignal",
						"deco": "i"
					}
				],
				"endline": 1458,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "pipe",
				"line": 1529,
				"comment": "Creates a unidirectional _pipe.\n\nData is written to one end of the _pipe and read from the other.\n---\nauto p = pipe();\np.writeEnd.writeln(\"Hello World\");\nassert (p.readEnd.readln().chomp() == \"Hello World\");\n---\nPipes can, for example, be used for interprocess communication\nby spawning a new process and passing one end of the _pipe to\nthe child, while the parent uses the other end.\n(See also $(LREF pipeProcess) and $(LREF pipeShell) for an easier\nway of doing this.)\n---\n// Use cURL to download the dlang.org front page, pipe its\n// output to grep to extract a list of links to ZIP files,\n// and write the list to the file \"D downloads.txt\":\nauto p = pipe();\nauto outFile = File(\"D downloads.txt\", \"w\");\nauto cpid = spawnProcess([\"curl\", \"http://dlang.org/download.html\"],\n                         std.stdio.stdin, p.writeEnd);\nscope(exit) wait(cpid);\nauto gpid = spawnProcess([\"grep\", \"-o\", `http://\\S*\\.zip`],\n                         p.readEnd, outFile);\nscope(exit) wait(gpid);\n---\n\nReturns:\nA $(LREF Pipe) object that corresponds to the created _pipe.\n\nThrows:\n$(XREF stdio,StdioException) on failure.\n",
				"deco": "FNeZS3std7process4Pipe",
				"endline": 1544,
				"char": 6,
				"kind": "function"
			},
			{
				"name": "Pipe",
				"line": 1580,
				"comment": "An interface to a pipe created by the $(LREF pipe) function.\n",
				"members": [
					{
						"endchar": 60,
						"name": "readEnd",
						"line": 1583,
						"comment": "The read end of the pipe.\n",
						"deco": "FNbNdNfZS3std5stdio4File",
						"endline": 1583,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 62,
						"name": "writeEnd",
						"line": 1587,
						"comment": "The write end of the pipe.\n",
						"deco": "FNbNdNfZS3std5stdio4File",
						"endline": 1587,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "close",
						"line": 1604,
						"comment": "    Closes both ends of the pipe.\n\n    Normally it is not necessary to do this manually, as $(XREF stdio,File)\n    objects are automatically closed when there are no more references\n    to them.\n\n    Note that if either end of the pipe has been passed to a child process,\n    it will only be closed in the parent process.  (What happens in the\n    child process is platform dependent.)\n\n    Throws:\n    $(XREF exception,ErrnoException) if an error occurs.\n",
						"deco": "FNfZv",
						"endline": 1608,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "pipeProcess",
				"line": 1711,
				"comment": "Starts a new process, creating pipes to redirect its standard\ninput, output and/or error streams.\n\n$(D pipeProcess) and $(D pipeShell) are convenient wrappers around\n$(LREF spawnProcess) and $(LREF spawnShell), respectively, and\nautomate the task of redirecting one or more of the child process'\nstandard streams through pipes.  Like the functions they wrap,\nthese functions return immediately, leaving the child process to\nexecute in parallel with the invoking process.  It is recommended\nto always call $(LREF wait) on the returned $(LREF ProcessPipes.pid),\nas detailed in the documentation for $(D wait).\n\nThe $(D args)/$(D program)/$(D command), $(D env) and $(D config)\nparameters are forwarded straight to the underlying spawn functions,\nand we refer to their documentation for details.\n\nParams:\nargs     = An array which contains the program name as the zeroth element\n           and any command-line arguments in the following elements.\n           (See $(LREF spawnProcess) for details.)\nprogram  = The program name, $(I without) command-line arguments.\n           (See $(LREF spawnProcess) for details.)\ncommand  = A shell command which is passed verbatim to the command\n           interpreter.  (See $(LREF spawnShell) for details.)\nredirect = Flags that determine which streams are redirected, and\n           how.  See $(LREF Redirect) for an overview of available\n           flags.\nenv      = Additional environment variables for the child process.\n           (See $(LREF spawnProcess) for details.)\nconfig   = Flags that control process creation. See $(LREF Config)\n           for an overview of available flags, and note that the\n           $(D retainStd...) flags have no effect in this function.\nworkDir  = The working directory for the new process.\n           By default the child process inherits the parent's working\n           directory.\n\nReturns:\nA $(LREF ProcessPipes) object which contains $(XREF stdio,File)\nhandles that communicate with the redirected streams of the child\nprocess, along with a $(LREF Pid) object that corresponds to the\nspawned process.\n\nThrows:\n$(LREF ProcessException) on failure to start the process.$(BR)\n$(XREF stdio,StdioException) on failure to redirect any of the streams.$(BR)\n\nExample:\n---\n// my_application writes to stdout and might write to stderr\nauto pipes = pipeProcess(\"my_application\", Redirect.stdout | Redirect.stderr);\nscope(exit) wait(pipes.pid);\n\n// Store lines of output.\nstring[] output;\nforeach (line; pipes.stdout.byLine) output ~= line.idup;\n\n// Store lines of errors.\nstring[] errors;\nforeach (line; pipes.stderr.byLine) errors ~= line.idup;\n\n\n// sendmail expects to read from stdin\npipes = pipeProcess([\"/usr/bin/sendmail\", \"-t\"], Redirect.stdin);\npipes.stdin.writeln(\"To: you\");\npipes.stdin.writeln(\"From: me\");\npipes.stdin.writeln(\"Subject: dlang\");\npipes.stdin.writeln(\"\");\npipes.stdin.writeln(message);\n\n// a single period tells sendmail we are finished\npipes.stdin.writeln(\".\");\n\n// but at this point sendmail might not see it, we need to flush\npipes.stdin.flush();\n\n// sendmail happens to exit on \".\", but some you have to close the file:\npipes.stdin.close();\n\n// otherwise this wait will wait forever\nwait(pipes.pid);\n\n---\n",
				"deco": "FNfxAAaE3std7process8RedirectxHAyaAyaE3std7process6ConfigxAaZS3std7process12ProcessPipes",
				"parameters": [
					{
						"name": "args",
						"deco": "xAAa"
					},
					{
						"name": "redirect",
						"deco": "E3std7process8Redirect",
						"default": "cast(Redirect)7"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 1719,
				"originalType": "@safe ProcessPipes(in char[][] args, Redirect redirect = Redirect.all, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 14,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "pipeProcess",
				"line": 1722,
				"comment": "ditto\n",
				"deco": "FNfxAaE3std7process8RedirectxHAyaAyaE3std7process6ConfigxAaZS3std7process12ProcessPipes",
				"parameters": [
					{
						"name": "program",
						"deco": "xAa"
					},
					{
						"name": "redirect",
						"deco": "E3std7process8Redirect",
						"default": "cast(Redirect)7"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 1730,
				"originalType": "@safe ProcessPipes(in char[] program, Redirect redirect = Redirect.all, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 14,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "pipeShell",
				"line": 1733,
				"comment": "ditto\n",
				"deco": "FNfxAaE3std7process8RedirectxHAyaAyaE3std7process6ConfigxAaZS3std7process12ProcessPipes",
				"parameters": [
					{
						"name": "command",
						"deco": "xAa"
					},
					{
						"name": "redirect",
						"deco": "E3std7process8Redirect",
						"default": "cast(Redirect)7"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 1741,
				"originalType": "@safe ProcessPipes(in char[] command, Redirect redirect = Redirect.all, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 14,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "stdin",
						"line": 1829,
						"value": "1",
						"comment": "Redirect the standard input, output or error streams, respectively.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stdout",
						"line": 1830,
						"value": "2",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stderr",
						"line": 1831,
						"value": "4",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 1837,
						"value": "7",
						"comment": "    Redirect _all three streams.  This is equivalent to\n    $(D Redirect.stdin | Redirect.stdout | Redirect.stderr).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stderrToStdout",
						"line": 1843,
						"value": "8",
						"comment": "    Redirect the standard error stream into the standard output stream.\n    This can not be combined with $(D Redirect.stderr).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stdoutToStderr",
						"line": 1849,
						"value": "16",
						"comment": "    Redirect the standard output stream into the standard error stream.\n    This can not be combined with $(D Redirect.stdout).\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Redirect",
				"line": 1826,
				"comment": "Flags that can be passed to $(LREF pipeProcess) and $(LREF pipeShell)\nto specify which of the child process' standard streams are redirected.\nUse bitwise OR to combine flags.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "ProcessPipes",
				"line": 1932,
				"comment": "Object which contains $(XREF stdio,File) handles that allow communication\nwith a child process through its standard streams.\n",
				"members": [
					{
						"endchar": 5,
						"name": "pid",
						"line": 1935,
						"comment": "The $(LREF Pid) of the child process.\n",
						"deco": "FNbNdNfZC3std7process3Pid",
						"endline": 1939,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stdin",
						"line": 1949,
						"comment": "    An $(XREF stdio,File) that allows writing to the child process'\n    standard input stream.\n\n    Throws:\n    $(OBJECTREF Error) if the child process' standard input stream hasn't\n    been redirected.\n",
						"deco": "FNbNdNfZS3std5stdio4File",
						"endline": 1955,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stdout",
						"line": 1965,
						"comment": "    An $(XREF stdio,File) that allows reading from the child process'\n    standard output stream.\n\n    Throws:\n    $(OBJECTREF Error) if the child process' standard output stream hasn't\n    been redirected.\n",
						"deco": "FNbNdNfZS3std5stdio4File",
						"endline": 1971,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stderr",
						"line": 1981,
						"comment": "    An $(XREF stdio,File) that allows reading from the child process'\n    standard error stream.\n\n    Throws:\n    $(OBJECTREF Error) if the child process' standard error stream hasn't\n    been redirected.\n",
						"deco": "FNbNdNfZS3std5stdio4File",
						"endline": 1987,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "execute",
				"line": 2050,
				"comment": "Executes the given program or shell command and returns its exit\ncode and output.\n\n$(D execute) and $(D executeShell) start a new process using\n$(LREF spawnProcess) and $(LREF spawnShell), respectively, and wait\nfor the process to complete before returning.  The functions capture\nwhat the child process prints to both its standard output and\nstandard error streams, and return this together with its exit code.\n---\nauto dmd = execute([\"dmd\", \"myapp.d\"]);\nif (dmd.status != 0) writeln(\"Compilation failed:\\n\", dmd.output);\n\nauto ls = executeShell(\"ls -l\");\nif (ls.status != 0) writeln(\"Failed to retrieve file listing\");\nelse writeln(ls.output);\n---\n\nThe $(D args)/$(D program)/$(D command), $(D env) and $(D config)\nparameters are forwarded straight to the underlying spawn functions,\nand we refer to their documentation for details.\n\nParams:\nargs      = An array which contains the program name as the zeroth element\n            and any command-line arguments in the following elements.\n            (See $(LREF spawnProcess) for details.)\nprogram   = The program name, $(I without) command-line arguments.\n            (See $(LREF spawnProcess) for details.)\ncommand   = A shell command which is passed verbatim to the command\n            interpreter.  (See $(LREF spawnShell) for details.)\nenv       = Additional environment variables for the child process.\n            (See $(LREF spawnProcess) for details.)\nconfig    = Flags that control process creation. See $(LREF Config)\n            for an overview of available flags, and note that the\n            $(D retainStd...) flags have no effect in this function.\nmaxOutput = The maximum number of bytes of output that should be\n            captured.\nworkDir   = The working directory for the new process.\n            By default the child process inherits the parent's working\n            directory.\n\nReturns:\nAn $(D std.typecons.Tuple!(int, \"status\", string, \"output\")).\n\nPOSIX_specific:\nIf the process is terminated by a signal, the $(D status) field of\nthe return value will contain a negative number whose absolute\nvalue is the signal number.  (See $(LREF wait) for details.)\n\nThrows:\n$(LREF ProcessException) on failure to start the process.$(BR)\n$(XREF stdio,StdioException) on failure to capture output.\n",
				"deco": "FNexAAaxHAyaAyaE3std7process6ConfigmxAaZS3std8typecons54__T5TupleTiVAyaa6_737461747573TAyaVAyaa6_6f7574707574Z5Tuple",
				"parameters": [
					{
						"name": "args",
						"deco": "xAAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "maxOutput",
						"deco": "m",
						"default": "18446744073709551615LU"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 2058,
				"originalType": "@trusted (in char[][] args, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max, in char[] workDir = null)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"endchar": 1,
				"name": "execute",
				"line": 2061,
				"comment": "ditto\n",
				"deco": "FNexAaxHAyaAyaE3std7process6ConfigmxAaZS3std8typecons54__T5TupleTiVAyaa6_737461747573TAyaVAyaa6_6f7574707574Z5Tuple",
				"parameters": [
					{
						"name": "program",
						"deco": "xAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "maxOutput",
						"deco": "m",
						"default": "18446744073709551615LU"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 2069,
				"originalType": "@trusted (in char[] program, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max, in char[] workDir = null)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"endchar": 1,
				"name": "executeShell",
				"line": 2072,
				"comment": "ditto\n",
				"deco": "FNexAaxHAyaAyaE3std7process6ConfigmxAaZS3std8typecons54__T5TupleTiVAyaa6_737461747573TAyaVAyaa6_6f7574707574Z5Tuple",
				"parameters": [
					{
						"name": "command",
						"deco": "xAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "maxOutput",
						"deco": "m",
						"default": "18446744073709551615LU"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 2080,
				"originalType": "@trusted (in char[] command, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max, in char[] workDir = null)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"members": [],
				"name": "ProcessException",
				"line": 2170,
				"comment": "An exception that signals a problem with starting or waiting for a process.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "userShell",
				"line": 2224,
				"comment": "Determines the path to the current user's default command interpreter.\n\nOn Windows, this function returns the contents of the COMSPEC environment\nvariable, if it exists.  Otherwise, it returns the string $(D \"cmd.exe\").\n\nOn POSIX, $(D userShell) returns the contents of the SHELL environment\nvariable, if it exists and is non-empty.  Otherwise, it returns\n$(D \"/bin/sh\").\n",
				"deco": "FNdNfZAya",
				"endline": 2229,
				"char": 18,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thisProcessID",
				"line": 2247,
				"comment": " Returns the process ID of the current process,\n which is guaranteed to be unique on the system.\n\n Example:\n ---\n writefln(\"Current process ID: %d\", thisProcessID);\n ---\n",
				"deco": "FNbNdNeZi",
				"endline": 2251,
				"char": 15,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thisThreadID",
				"line": 2266,
				"comment": " Returns the process ID of the current thread,\n which is guaranteed to be unique within the current process.\n\n Returns:\n A $(CXREF thread, ThreadID) value for the calling thread.\n\n Example:\n ---\n writefln(\"Current thread ID: %s\", thisThreadID);\n ---\n",
				"deco": "FNbNdNeZm",
				"endline": 2276,
				"originalType": "nothrow @property @trusted ThreadID()",
				"char": 20,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "escapeShellCommand",
				"line": 2403,
				"comment": "Escapes an argv-style argument array to be used with $(LREF spawnShell),\n$(LREF pipeShell) or $(LREF executeShell).\n---\nstring url = \"http://dlang.org/\";\nexecuteShell(escapeShellCommand(\"wget\", url, \"-O\", \"dlang-index.html\"));\n---\n\nConcatenate multiple $(D escapeShellCommand) and\n$(LREF escapeShellFileName) results to use shell redirection or\npiping operators.\n---\nexecuteShell(\n    escapeShellCommand(\"curl\", \"http://dlang.org/download.html\") ~\n    \"|\" ~\n    escapeShellCommand(\"grep\", \"-o\", `http://\\S*\\.zip`) ~\n    \">\" ~\n    escapeShellFileName(\"D download links.txt\"));\n---\n\nThrows:\n$(OBJECTREF Exception) if any part of the command line contains unescapable\ncharacters (NUL on all platforms, as well as CR and LF on Windows).\n",
				"deco": "FNaNfxAAaXAya",
				"parameters": [
					{
						"name": "args",
						"deco": "xAAa"
					}
				],
				"endline": 2424,
				"originalType": "pure @safe string(in char[][] args...)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "escapeWindowsArgument",
				"line": 2548,
				"comment": "Quotes a command-line argument in a manner conforming to the behavior of\n$(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/bb776391(v=vs.85).aspx,\nCommandLineToArgvW).\n",
				"deco": "FNaNbNexAaZAya",
				"parameters": [
					{
						"name": "arg",
						"deco": "xAa"
					}
				],
				"endline": 2556,
				"originalType": "pure nothrow @trusted string(in char[] arg)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "escapeShellFileName",
				"line": 2732,
				"comment": "Escapes a filename to be used for shell redirection with $(LREF spawnShell),\n$(LREF pipeShell) or $(LREF executeShell).\n",
				"deco": "FNaNbNexAaZAya",
				"parameters": [
					{
						"name": "fileName",
						"deco": "xAa"
					}
				],
				"endline": 2753,
				"originalType": "pure nothrow @trusted string(in char[] fileName)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "environment",
				"line": 2877,
				"comment": "Manipulates _environment variables using an associative-array-like\ninterface.\n\nThis class contains only static methods, and cannot be instantiated.\nSee below for examples of use.\n",
				"members": [
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 2894,
						"comment": "    Retrieves the value of the environment variable with the given $(D name).\n    ---\n    auto path = environment[\"PATH\"];\n    ---\n\n    Throws:\n    $(OBJECTREF Exception) if the environment variable does not exist,\n    or $(XREF utf,UTFException) if the variable contains invalid UTF-16\n    characters (Windows only).\n\n    See_also:\n    $(LREF environment.get), which doesn't throw on failure.\n",
						"deco": "FNfxAaZAya",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							}
						],
						"endline": 2899,
						"originalType": "@safe string(in char[] name)",
						"char": 12,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "get",
						"line": 2926,
						"comment": "    Retrieves the value of the environment variable with the given $(D name),\n    or a default value if the variable doesn't exist.\n\n    Unlike $(LREF environment.opIndex), this function never throws.\n    ---\n    auto sh = environment.get(\"SHELL\", \"/bin/sh\");\n    ---\n    This function is also useful in checking for the existence of an\n    environment variable.\n    ---\n    auto myVar = environment.get(\"MYVAR\");\n    if (myVar is null)\n    {\n        // Environment variable doesn't exist.\n        // Note that we have to use 'is' for the comparison, since\n        // myVar == null is also true if the variable exists but is\n        // empty.\n    }\n    ---\n\n    Throws:\n    $(XREF utf,UTFException) if the variable contains invalid UTF-16\n    characters (Windows only).\n",
						"deco": "FNfxAaAyaZAya",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							},
							{
								"name": "defaultValue",
								"deco": "Aya",
								"default": "null"
							}
						],
						"endline": 2931,
						"originalType": "@safe string(in char[] name, string defaultValue = null)",
						"char": 12,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "opIndexAssign",
						"line": 2947,
						"comment": "    Assigns the given $(D value) to the environment variable with the given\n    $(D name).\n\n    If the variable does not exist, it will be created. If it already exists,\n    it will be overwritten.\n    ---\n    environment[\"foo\"] = \"bar\";\n    ---\n\n    Throws:\n    $(OBJECTREF Exception) if the environment variable could not be added\n        (e.g. if the name is invalid).\n",
						"deco": "FNeNgAaxAaZANga",
						"parameters": [
							{
								"name": "value",
								"deco": "NgAa"
							},
							{
								"name": "name",
								"deco": "xAa"
							}
						],
						"endline": 2972,
						"originalType": "@trusted inout(char)[](inout char[] value, in char[] name)",
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "remove",
						"line": 2980,
						"comment": "    Removes the environment variable with the given $(D name).\n\n    If the variable isn't in the environment, this function returns\n    successfully without doing anything.\n",
						"deco": "FNbNiNexAaZv",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							}
						],
						"endline": 2985,
						"originalType": "nothrow @nogc @trusted void(in char[] name)",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "toAA",
						"line": 2999,
						"comment": "    Copies all environment variables into an associative array.\n\n    Windows_specific:\n    While Windows environment variable names are case insensitive, D's\n    built-in associative arrays are not.  This function will store all\n    variable names in uppercase (e.g. $(D PATH)).\n\n    Throws:\n    $(OBJECTREF Exception) if the environment variables could not\n        be retrieved (Windows only).\n",
						"deco": "FNeZHAyaAya",
						"endline": 3053,
						"char": 20,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 16,
				"kind": "class"
			},
			{
				"name": "execv",
				"line": 3406,
				"comment": "    Replaces the current process by executing a command, $(D pathname), with\n    the arguments in $(D argv).\n\n    $(BLUE This functions is Posix-Only.)\n\n    Typically, the first element of $(D argv) is\n    the command being executed, i.e. $(D argv[0] == pathname). The 'p'\n    versions of $(D exec) search the PATH environment variable for $(D\n    pathname). The 'e' versions additionally take the new process'\n    environment variables as an array of strings of the form key=value.\n\n    Does not return on success (the current process will have been\n    replaced). Returns -1 on failure with no indication of the\n    underlying error.\n\n    Windows_specific:\n    These functions are only supported on POSIX platforms, as the Windows\n    operating systems do not provide the ability to overwrite the current\n    process image with another. In single-threaded programs it is possible\n    to approximate the effect of $(D execv*) by using $(LREF spawnProcess)\n    and terminating the current process once the child process has returned.\n    For example:\n    ---\n    auto commandLine = [ \"program\", \"arg1\", \"arg2\" ];\n    version (Posix)\n    {\n        execv(commandLine[0], commandLine);\n        throw new Exception(\"Failed to execute program\");\n    }\n    else version (Windows)\n    {\n        import core.stdc.stdlib: _exit;\n        _exit(wait(spawnProcess(commandLine)));\n    }\n    ---\n    This is, however, NOT equivalent to POSIX' $(D execv*).  For one thing, the\n    executed program is started as a separate process, with all this entails.\n    Secondly, in a multithreaded program, other threads will continue to do\n    work while the current thread is waiting for the child process to complete.\n\n    A better option may sometimes be to terminate the current program immediately\n    after spawning the child process.  This is the behaviour exhibited by the\n    $(LINK2 http://msdn.microsoft.com/en-us/library/431x4c1w.aspx,$(D __exec))\n    functions in Microsoft's C runtime library, and it is how D's now-deprecated\n    Windows $(D execv*) functions work. Example:\n    ---\n    auto commandLine = [ \"program\", \"arg1\", \"arg2\" ];\n    version (Posix)\n    {\n        execv(commandLine[0], commandLine);\n        throw new Exception(\"Failed to execute program\");\n    }\n    else version (Windows)\n    {\n        spawnProcess(commandLine);\n        import core.stdc.stdlib: _exit;\n        _exit(0);\n    }\n    ---\n",
				"deco": "FxAyaxAAyaZi",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAya"
					},
					{
						"name": "argv",
						"deco": "xAAya"
					}
				],
				"originalType": "int(in string pathname, in string[] argv)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "execve",
				"line": 3408,
				"comment": "ditto\n",
				"deco": "FxAyaxAAyaxAAyaZi",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAya"
					},
					{
						"name": "argv",
						"deco": "xAAya"
					},
					{
						"name": "envp",
						"deco": "xAAya"
					}
				],
				"originalType": "int(in string pathname, in string[] argv, in string[] envp)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "execvp",
				"line": 3410,
				"comment": "ditto\n",
				"deco": "FxAyaxAAyaZi",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAya"
					},
					{
						"name": "argv",
						"deco": "xAAya"
					}
				],
				"originalType": "int(in string pathname, in string[] argv)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "execvpe",
				"line": 3412,
				"comment": "ditto\n",
				"deco": "FxAyaxAAyaxAAyaZi",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAya"
					},
					{
						"name": "argv",
						"deco": "xAAya"
					},
					{
						"name": "envp",
						"deco": "xAAya"
					}
				],
				"originalType": "int(in string pathname, in string[] argv, in string[] envp)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "browse",
				"line": 3651,
				"comment": " Start up the browser and set it to viewing the page at url.\n",
				"deco": "FAyaZv",
				"parameters": [
					{
						"name": "url",
						"deco": "Aya"
					}
				],
				"char": 10,
				"kind": "function"
			}
		],
		"comment": "Functions for starting and interacting with other processes, and for\nworking with the current _process' execution environment.\n\nProcess_handling:\n$(UL $(LI\n    $(LREF spawnProcess) spawns a new _process, optionally assigning it an\n    arbitrary set of standard input, output, and error streams.\n    The function returns immediately, leaving the child _process to execute\n    in parallel with its parent.  All other functions in this module that\n    spawn processes are built around $(D spawnProcess).)\n$(LI\n    $(LREF wait) makes the parent _process wait for a child _process to\n    terminate.  In general one should always do this, to avoid\n    child processes becoming \"zombies\" when the parent _process exits.\n    Scope guards are perfect for this – see the $(LREF spawnProcess)\n    documentation for examples.  $(LREF tryWait) is similar to $(D wait),\n    but does not block if the _process has not yet terminated.)\n$(LI\n    $(LREF pipeProcess) also spawns a child _process which runs\n    in parallel with its parent.  However, instead of taking\n    arbitrary streams, it automatically creates a set of\n    pipes that allow the parent to communicate with the child\n    through the child's standard input, output, and/or error streams.\n    This function corresponds roughly to C's $(D popen) function.)\n$(LI\n    $(LREF execute) starts a new _process and waits for it\n    to complete before returning.  Additionally, it captures\n    the _process' standard output and error streams and returns\n    the output of these as a string.)\n$(LI\n    $(LREF spawnShell), $(LREF pipeShell) and $(LREF executeShell) work like\n    $(D spawnProcess), $(D pipeProcess) and $(D execute), respectively,\n    except that they take a single command string and run it through\n    the current user's default command interpreter.\n    $(D executeShell) corresponds roughly to C's $(D system) function.)\n$(LI\n    $(LREF kill) attempts to terminate a running _process.)\n)\n\nThe following table compactly summarises the different _process creation\nfunctions and how they relate to each other:\n$(BOOKTABLE,\n    $(TR $(TH )\n         $(TH Runs program directly)\n         $(TH Runs shell command))\n    $(TR $(TD Low-level _process creation)\n         $(TD $(LREF spawnProcess))\n         $(TD $(LREF spawnShell)))\n    $(TR $(TD Automatic input/output redirection using pipes)\n         $(TD $(LREF pipeProcess))\n         $(TD $(LREF pipeShell)))\n    $(TR $(TD Execute and wait for completion, collect output)\n         $(TD $(LREF execute))\n         $(TD $(LREF executeShell)))\n)\n\nOther_functionality:\n$(UL\n$(LI\n    $(LREF pipe) is used to create unidirectional pipes.)\n$(LI\n    $(LREF environment) is an interface through which the current _process'\n    environment variables can be read and manipulated.)\n$(LI\n    $(LREF escapeShellCommand) and $(LREF escapeShellFileName) are useful\n    for constructing shell command lines in a portable way.)\n)\n\nAuthors:\n    $(LINK2 https://github.com/kyllingstad, Lars Tandle Kyllingstad),\n    $(LINK2 https://github.com/schveiguy, Steven Schveighoffer),\n    $(WEB thecybershadow.net, Vladimir Panteleev)\nCopyright:\n    Copyright (c) 2013, the authors. All rights reserved.\nLicense:\n   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nSource:\n    $(PHOBOSSRC std/_process.d)\nMacros:\n    WIKI=Phobos/StdProcess\n    OBJECTREF=$(D $(LINK2 object.html#$0,$0))\n    LREF=$(D $(LINK2 #.$0,$0))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/zlib.d",
		"name": "std.zlib",
		"members": [
			{
				"members": [],
				"name": "ZlibException",
				"line": 42,
				"comment": " Errors throw a ZlibException.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "adler32",
				"line": 79,
				"comment": " $(P Compute the Adler-32 checksum of a buffer's worth of data.)\n\n Params:\n     adler = the starting checksum for the computation. Use 1\n             for a new checksum. Use the output of this function\n             for a cumulative checksum.\n     buf = buffer containing input data\n\n Returns:\n     A $(D uint) checksum for the provided input data and starting checksum\n\n See_Also:\n     $(LINK http://en.wikipedia.org/wiki/Adler-32)\n",
				"deco": "FkAxvZk",
				"parameters": [
					{
						"name": "adler",
						"deco": "k"
					},
					{
						"name": "buf",
						"deco": "Axv"
					}
				],
				"endline": 87,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "crc32",
				"line": 121,
				"comment": " $(P Compute the CRC32 checksum of a buffer's worth of data.)\n\n Params:\n     crc = the starting checksum for the computation. Use 0\n             for a new checksum. Use the output of this function\n             for a cumulative checksum.\n     buf = buffer containing input data\n\n Returns:\n     A $(D uint) checksum for the provided input data and starting checksum\n\n See_Also:\n     $(LINK http://en.wikipedia.org/wiki/Cyclic_redundancy_check)\n",
				"deco": "FkAxvZk",
				"parameters": [
					{
						"name": "crc",
						"deco": "k"
					},
					{
						"name": "buf",
						"deco": "Axv"
					}
				],
				"endline": 129,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "compress",
				"line": 156,
				"comment": " $(P Compress data)\n\n Params:\n     srcbuf = buffer containing the data to compress\n     level = compression level. Legal values are -1..9, with -1 indicating\n             the default level (6), 0 indicating no compression, 1 being the\n             least compression and 9 being the most.\n\n Returns:\n     the compressed data\n",
				"deco": "FAxviZAh",
				"parameters": [
					{
						"name": "srcbuf",
						"deco": "Axv"
					},
					{
						"name": "level",
						"deco": "i"
					}
				],
				"endline": 173,
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "compress",
				"line": 179,
				"comment": " ditto\n",
				"deco": "FAxvZAh",
				"parameters": [
					{
						"name": "srcbuf",
						"deco": "Axv"
					}
				],
				"endline": 182,
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "uncompress",
				"line": 195,
				"comment": " Decompresses the data in srcbuf[].\n Params:\n  srcbuf  = buffer containing the compressed data.\n  destlen = size of the uncompressed data.\n            It need not be accurate, but the decompression will be faster\n            if the exact size is supplied.\n  winbits = the base two logarithm of the maximum window size.\n Returns: the decompressed data.\n",
				"deco": "FAxvmiZAv",
				"parameters": [
					{
						"name": "srcbuf",
						"deco": "Axv"
					},
					{
						"name": "destlen",
						"deco": "m",
						"default": "0LU"
					},
					{
						"name": "winbits",
						"deco": "i",
						"default": "15"
					}
				],
				"endline": 243,
				"originalType": "void[](const(void)[] srcbuf, size_t destlen = 0u, int winbits = 15)",
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "deflate",
						"line": 291,
						"value": "0",
						"comment": "a standard zlib header\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "gzip",
						"line": 292,
						"value": "1",
						"comment": "a gzip file format header\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "determineFromData",
						"line": 293,
						"value": "2",
						"comment": "used when decompressing. Try to automatically detect the stream format by looking at the data\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "HeaderFormat",
				"line": 290,
				"comment": "the header format the compressed stream is wrapped in\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Compress",
				"line": 300,
				"comment": " Used when the data to be compressed is not all in one buffer.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 333,
						"comment": " Constructor.\n\n Params:\n    level = compression level. Legal values are 1..9, with 1 being the least\n            compression and 9 being the most. The default value is 6.\n    header = sets the compression type to one of the options available\n             in $(LREF HeaderFormat). Defaults to HeaderFormat.deflate.\n\n See_Also:\n    $(LREF compress), $(LREF HeaderFormat)\n",
						"deco": "FiE3std4zlib12HeaderFormatZC3std4zlib8Compress",
						"parameters": [
							{
								"name": "level",
								"deco": "i"
							},
							{
								"name": "header",
								"deco": "E3std4zlib12HeaderFormat",
								"default": "cast(HeaderFormat)0"
							}
						],
						"endline": 342,
						"originalType": "(int level, HeaderFormat header = HeaderFormat.deflate)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 345,
						"comment": "ditto\n",
						"deco": "FE3std4zlib12HeaderFormatZC3std4zlib8Compress",
						"parameters": [
							{
								"name": "header",
								"deco": "E3std4zlib12HeaderFormat",
								"default": "cast(HeaderFormat)0"
							}
						],
						"endline": 348,
						"originalType": "(HeaderFormat header = HeaderFormat.deflate)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "compress",
						"line": 369,
						"comment": " Compress the data in buf and return the compressed data.\n Params:\n    buf = data to compress\n\n Returns:\n    the compressed data. The buffers returned from successive calls to this should be concatenated together.\n\n",
						"deco": "FAxvZAxv",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							}
						],
						"endline": 401,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 423,
							"deco": "FZv",
							"endline": 423,
							"char": 5,
							"kind": "function"
						},
						"name": "flush",
						"line": 421,
						"comment": " Compress and return any remaining data.\n The returned data should be appended to that returned by compress().\n Params:\n  mode = one of the following:\n          $(DL\n                    $(DT Z_SYNC_FLUSH )\n                    $(DD Syncs up flushing to the next byte boundary.\n                        Used when more data is to be compressed later on.)\n                    $(DT Z_FULL_FLUSH )\n                    $(DD Syncs up flushing to the next byte boundary.\n                        Used when more data is to be compressed later on,\n                        and the decompressor needs to be restartable at this\n                        point.)\n                    $(DT Z_FINISH)\n                    $(DD (default) Used when finished compressing the data. )\n                )\n",
						"deco": "FiZAv",
						"parameters": [
							{
								"name": "mode",
								"deco": "i",
								"default": "4"
							}
						],
						"endline": 470,
						"originalType": "void[](int mode = Z_FINISH)",
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"name": "UnCompress",
				"line": 477,
				"comment": " Used when the data to be decompressed is not all in one buffer.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 503,
						"comment": " Construct. destbufsize is the same as for D.zlib.uncompress().\n",
						"deco": "FkZC3std4zlib10UnCompress",
						"parameters": [
							{
								"name": "destbufsize",
								"deco": "k"
							}
						],
						"endline": 506,
						"originalType": "(uint destbufsize)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 509,
						"comment": " ditto\n",
						"deco": "FE3std4zlib12HeaderFormatZC3std4zlib10UnCompress",
						"parameters": [
							{
								"name": "format",
								"deco": "E3std4zlib12HeaderFormat",
								"default": "cast(HeaderFormat)2"
							}
						],
						"endline": 512,
						"originalType": "(HeaderFormat format = HeaderFormat.determineFromData)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 532,
							"deco": "FZv",
							"endline": 532,
							"char": 5,
							"kind": "function"
						},
						"name": "uncompress",
						"line": 530,
						"comment": " Decompress the data in buf and return the decompressed data.\n The buffers returned from successive calls to this should be concatenated\n together.\n",
						"deco": "FAxvZAxv",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							}
						],
						"endline": 575,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 584,
							"deco": "FZv",
							"endline": 584,
							"char": 5,
							"kind": "function"
						},
						"name": "flush",
						"line": 582,
						"comment": " Decompress and return any remaining data.\n The returned data should be appended to that returned by uncompress().\n The UnCompress object cannot be used further.\n",
						"deco": "FZAv",
						"endline": 627,
						"out": {
							"endchar": 5,
							"name": "__ensure",
							"line": 588,
							"deco": "FKxAvZv",
							"parameters": [
								{
									"name": "__result",
									"storageClass": [
										"ref"
									],
									"deco": "xAv"
								}
							],
							"endline": 588,
							"originalType": "void(ref const void[] __result)",
							"char": 5,
							"kind": "function"
						},
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " Compress/decompress data using the $(WEB www._zlib.net, _zlib library).\n\n References:\n  $(WEB en.wikipedia.org/wiki/Zlib, Wikipedia)\n\n Macros:\n  WIKI = Phobos/StdZlib\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_zlib.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/ascii.d",
		"name": "std.ascii",
		"members": [
			{
				"name": "fullHexDigits",
				"line": 37,
				"comment": "0..9A..Fa..f\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"0123456789ABCDEFabcdef\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "hexDigits",
				"line": 38,
				"comment": "0..9A..F\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"0123456789ABCDEF\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "lowerHexDigits",
				"line": 39,
				"comment": "0..9a..f\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"0123456789abcdef\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "digits",
				"line": 40,
				"comment": "0..9\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"0123456789\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "octalDigits",
				"line": 41,
				"comment": "0..7\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"01234567\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "letters",
				"line": 42,
				"comment": "A..Za..z\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "uppercase",
				"line": 43,
				"comment": "A..Z\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "lowercase",
				"line": 44,
				"comment": "a..z\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"abcdefghijklmnopqrstuvwxyz\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "whitespace",
				"line": 45,
				"comment": "ASCII _whitespace\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\" \\x09\\x0b\\x0d\\x0a\\x0c\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"members": [
					{
						"name": "upper",
						"line": 52,
						"value": "false",
						"comment": "Upper case letters\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lower",
						"line": 53,
						"value": "1",
						"comment": "Lower case letters\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "LetterCase",
				"line": 50,
				"comment": "    Letter case specifier.\n",
				"baseDeco": "b",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "newline",
				"line": 60,
				"comment": "Newline sequence for this system.\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"\\x0a\"",
				"char": 15,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"endchar": 1,
				"name": "isAlphaNum",
				"line": 69,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a letter or a number (0..9, a..z, A..Z).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL75_632)\n---\nassert( isAlphaNum('A'));\nassert( isAlphaNum('1'));\nassert(!isAlphaNum('#'));\n\n// N.B.: does not return true for non-ASCII Unicode alphanumerics:\nassert(!isAlphaNum('á'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL75_632)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 72,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isAlpha",
				"line": 99,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is an ASCII letter (A..Z, a..z).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL106_634)\n---\nassert( isAlpha('A'));\nassert(!isAlpha('1'));\nassert(!isAlpha('#'));\n\n// N.B.: does not return true for non-ASCII Unicode alphabetic characters:\nassert(!isAlpha('á'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL106_634)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 103,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isLower",
				"line": 130,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a lowercase ASCII letter (a..z).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL136_636)\n---\nassert( isLower('a'));\nassert(!isLower('A'));\nassert(!isLower('#'));\n\n// N.B.: does not return true for non-ASCII Unicode lowercase letters\nassert(!isLower('á'));\nassert(!isLower('Á'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL136_636)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 133,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isUpper",
				"line": 161,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is an uppercase ASCII letter (A..Z).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL167_638)\n---\nassert( isUpper('A'));\nassert(!isUpper('a'));\nassert(!isUpper('#'));\n\n// N.B.: does not return true for non-ASCII Unicode uppercase letters\nassert(!isUpper('á'));\nassert(!isUpper('Á'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL167_638)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 164,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isDigit",
				"line": 192,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a digit (0..9).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL198_640)\n---\nassert( isDigit('3'));\nassert( isDigit('8'));\nassert(!isDigit('B'));\nassert(!isDigit('#'));\n\n// N.B.: does not return true for non-ASCII Unicode numbers\nassert(!isDigit('０')); // full-width digit zero (U+FF10)\nassert(!isDigit('４')); // full-width digit four (U+FF14)\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL198_640)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 195,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isOctalDigit",
				"line": 224,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a digit in base 8 (0..7).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL230_642)\n---\nassert( isOctalDigit('0'));\nassert( isOctalDigit('7'));\nassert(!isOctalDigit('8'));\nassert(!isOctalDigit('A'));\nassert(!isOctalDigit('#'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL230_642)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 227,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isHexDigit",
				"line": 253,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a digit in base 16 (0..9, A..F, a..f).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL259_644)\n---\nassert( isHexDigit('0'));\nassert( isHexDigit('A'));\nassert( isHexDigit('f')); // lowercase hex digits are accepted\nassert(!isHexDigit('g'));\nassert(!isHexDigit('G'));\nassert(!isHexDigit('#'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL259_644)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 256,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isWhite",
				"line": 285,
				"comment": "    Params: c = The character to test.\n    Returns: Whether or not $(D c) is a whitespace character. That includes the\n    space, tab, vertical tab, form feed, carriage return, and linefeed\n    characters.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL291_646)\n---\nassert( isWhite(' '));\nassert( isWhite('\\t'));\nassert( isWhite('\\n'));\nassert(!isWhite('1'));\nassert(!isWhite('a'));\nassert(!isWhite('#'));\n\n// N.B.: Does not return true for non-ASCII Unicode whitespace characters.\nstatic import std.uni;\nassert(std.uni.isWhite('\\u00A0'));\nassert(!isWhite('\\u00A0')); // std.ascii.isWhite\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL291_646)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 288,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isControl",
				"line": 320,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a control character.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL326_648)\n---\nassert( isControl('\\0'));\nassert( isControl('\\022'));\nassert( isControl('\\n')); // newline is both whitespace and control\nassert(!isControl(' '));\nassert(!isControl('1'));\nassert(!isControl('a'));\nassert(!isControl('#'));\n\n// N.B.: non-ASCII Unicode control characters are not recognized:\nassert(!isControl('\\u0080'));\nassert(!isControl('\\u2028'));\nassert(!isControl('\\u2029'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL326_648)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 323,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isPunctuation",
				"line": 359,
				"comment": "    Params: c = The character to test.\n    Returns: Whether or not $(D c) is a punctuation character. That includes\n    all ASCII characters which are not control characters, letters, digits, or\n    whitespace.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL365_650)\n---\nassert( isPunctuation('.'));\nassert( isPunctuation(','));\nassert( isPunctuation(':'));\nassert( isPunctuation('!'));\nassert( isPunctuation('#'));\nassert( isPunctuation('~'));\nassert( isPunctuation('+'));\nassert( isPunctuation('_'));\n\nassert(!isPunctuation('1'));\nassert(!isPunctuation('a'));\nassert(!isPunctuation(' '));\nassert(!isPunctuation('\\n'));\nassert(!isPunctuation('\\0'));\n\n// N.B.: Non-ASCII Unicode punctuation characters are not recognized.\nassert(!isPunctuation('\\u2012')); // (U+2012 = en-dash)\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL365_650)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 362,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isGraphical",
				"line": 403,
				"comment": "    Params: c = The character to test.\n    Returns: Whether or not $(D c) is a printable character other than the\n    space character.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL409_652)\n---\nassert( isGraphical('1'));\nassert( isGraphical('a'));\nassert( isGraphical('#'));\nassert(!isGraphical(' ')); // whitespace is not graphical\nassert(!isGraphical('\\n'));\nassert(!isGraphical('\\0'));\n\n// N.B.: Unicode graphical characters are not regarded as such.\nassert(!isGraphical('á'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL409_652)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 406,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isPrintable",
				"line": 439,
				"comment": "    Params: c = The character to test.\n    Returns: Whether or not $(D c) is a printable character - including the\n    space character.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL445_654)\n---\nassert( isPrintable(' '));  // whitespace is printable\nassert( isPrintable('1'));\nassert( isPrintable('a'));\nassert( isPrintable('#'));\nassert(!isPrintable('\\0')); // control characters are not printable\n\n// N.B.: Printable non-ASCII Unicode characters are not recognized.\nassert(!isPrintable('á'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL445_654)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 442,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isASCII",
				"line": 474,
				"comment": "    Params: c = The character to test.\n    Returns: Whether or not $(D c) is in the ASCII character set - i.e. in the\n    range 0..0x7F.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL480_656)\n---\nassert( isASCII('a'));\nassert(!isASCII('á'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL480_656)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 477,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toLower",
						"line": 506,
						"type": "(C c)",
						"parameters": [
							{
								"name": "c",
								"type": "C"
							}
						],
						"endline": 518,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toLower",
				"line": 506,
				"comment": "    Converts an ASCII letter to lowercase.\n\n    Params: c = A character of any type that implicitly converts to $(D dchar).\n    In the case where it's a built-in type, or an enum of a built-in type,\n    $(D Unqual!(OriginalType!C)) is returned, whereas if it's a user-defined\n    type, $(D dchar) is returned.\n\n    Returns: The corresponding lowercase letter, if $(D c) is an uppercase\n    ASCII character, otherwise $(D c) itself.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL521_658)\n---\nassert(toLower('a') == 'a');\nassert(toLower('A') == 'a');\nassert(toLower('#') == '#');\n\n// N.B.: Non-ASCII Unicode uppercase letters are not converted.\nassert(toLower('Á') == 'Á');\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL521_658)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(C : dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUpper",
						"line": 568,
						"type": "(C c)",
						"parameters": [
							{
								"name": "c",
								"type": "C"
							}
						],
						"endline": 580,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toUpper",
				"line": 568,
				"comment": "    Converts an ASCII letter to uppercase.\n\n    Params: c = Any type which implicitly converts to $(D dchar). In the case\n    where it's a built-in type, or an enum of a built-in type,\n    $(D Unqual!(OriginalType!C)) is returned, whereas if it's a user-defined\n    type, $(D dchar) is returned.\n\n    Returns: The corresponding uppercase letter, if $(D c) is a lowercase ASCII\n    character, otherwise $(D c) itself.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL583_660)\n---\nassert(toUpper('a') == 'A');\nassert(toUpper('A') == 'A');\nassert(toUpper('#') == '#');\n\n// N.B.: Non-ASCII Unicode lowercase letters are not converted.\nassert(toUpper('á') == 'á');\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL583_660)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(C : dchar)",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "    Functions which operate on ASCII characters.\n\n    All of the functions in std._ascii accept Unicode characters but\n    effectively ignore them if they're not ASCII. All $(D isX) functions return\n    $(D false) for non-ASCII characters, and all $(D toX) functions do nothing\n    to non-ASCII characters.\n\n    For functions which operate on Unicode characters, see\n    $(LINK2 std_uni.html, std.uni).\n\n    References:\n        $(LINK2 http://www.digitalmars.com/d/ascii-table.html, ASCII Table),\n        $(WEB en.wikipedia.org/wiki/Ascii, Wikipedia)\n\n    Macros:\n        WIKI=Phobos/StdASCII\n\n    Copyright: Copyright 2000 - 2013\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std/_ascii.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/getopt.d",
		"name": "std.getopt",
		"members": [
			{
				"members": [],
				"name": "GetOptException",
				"line": 46,
				"comment": "Thrown on one of the following conditions:\n$(UL\n  $(LI An unrecognized command-line argument is passed, and\n       $(D std.getopt.config.passThrough) was not present.)\n  $(LI A command-line option was not found, and\n       $(D std.getopt.config.required) was present.)\n)\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "getopt",
						"line": 436,
						"type": "GetoptResult(ref string[] args, T opts)",
						"parameters": [
							{
								"name": "args",
								"type": "string[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "opts",
								"type": "T"
							}
						],
						"endline": 453,
						"char": 14,
						"kind": "function"
					}
				],
				"name": "getopt",
				"line": 436,
				"comment": "   Parse and remove command line options from a string array.\n\n   Synopsis:\n\n---------\nimport std.getopt;\n\nstring data = \"file.dat\";\nint length = 24;\nbool verbose;\nenum Color { no, yes };\nColor color;\n\nvoid main(string[] args)\n{\n  auto helpInformation = getopt(\n    args,\n    \"length\",  &length,    // numeric\n    \"file\",    &data,      // string\n    \"verbose\", &verbose,   // flag\n    \"color\", \"Information about this color\", &color);    // enum\n  ...\n\n  if (helpInformation.helpWanted)\n  {\n    defaultGetoptPrinter(\"Some information about the program.\",\n      helpInformation.options);\n  }\n}\n---------\n\n The $(D getopt) function takes a reference to the command line\n (as received by $(D main)) as its first argument, and an\n unbounded number of pairs of strings and pointers. Each string is an\n option meant to \"fill\" the value referenced by the pointer to its\n right (the \"bound\" pointer). The option string in the call to\n $(D getopt) should not start with a dash.\n\n In all cases, the command-line options that were parsed and used by\n $(D getopt) are removed from $(D args). Whatever in the\n arguments did not look like an option is left in $(D args) for\n further processing by the program. Values that were unaffected by the\n options are not touched, so a common idiom is to initialize options\n to their defaults and then invoke $(D getopt). If a\n command-line argument is recognized as an option with a parameter and\n the parameter cannot be parsed properly (e.g., a number is expected\n but not present), a $(D ConvException) exception is thrown.\n If $(D std.getopt.config.passThrough) was not passed to $(D getopt)\n and an unrecognized command-line argument is found, a $(D GetOptException)\n is thrown.\n\n Depending on the type of the pointer being bound, $(D getopt)\n recognizes the following kinds of options:\n\n $(OL\n    $(LI $(I Boolean options). A lone argument sets the option to $(D true).\n    Additionally $(B true) or $(B false) can be set within the option separated\n    with an \"=\" sign:\n\n---------\n  bool verbose = false, debugging = true;\n  getopt(args, \"verbose\", &verbose, \"debug\", &debugging);\n---------\n\n    To set $(D verbose) to $(D true), invoke the program with either\n    $(D --verbose) or $(D --verbose=true).\n\n    To set $(D debugging) to $(D false), invoke the program with\n    $(D --debugging=false).\n    )\n\n    $(LI $(I Numeric options.) If an option is bound to a numeric type, a\n    number is expected as the next option, or right within the option separated\n    with an \"=\" sign:\n\n---------\n  uint timeout;\n  getopt(args, \"timeout\", &timeout);\n---------\n\n    To set $(D timeout) to $(D 5), invoke the program with either\n    $(D --timeout=5) or $(D --timeout 5).\n    )\n\n    $(LI $(I Incremental options.) If an option name has a \"+\" suffix and is\n    bound to a numeric type, then the option's value tracks the number of times\n    the option occurred on the command line:\n\n---------\n  uint paranoid;\n  getopt(args, \"paranoid+\", &paranoid);\n---------\n\n    Invoking the program with \"--paranoid --paranoid --paranoid\" will set $(D\n    paranoid) to 3. Note that an incremental option never expects a parameter,\n    e.g., in the command line \"--paranoid 42 --paranoid\", the \"42\" does not set\n    $(D paranoid) to 42; instead, $(D paranoid) is set to 2 and \"42\" is not\n    considered as part of the normal program arguments.\n    )\n\n    $(LI $(I Enum options.) If an option is bound to an enum, an enum symbol as\n    a string is expected as the next option, or right within the option\n    separated with an \"=\" sign:\n\n---------\n  enum Color { no, yes };\n  Color color; // default initialized to Color.no\n  getopt(args, \"color\", &color);\n---------\n\n    To set $(D color) to $(D Color.yes), invoke the program with either\n    $(D --color=yes) or $(D --color yes).\n    )\n\n    $(LI $(I String options.) If an option is bound to a string, a string is\n    expected as the next option, or right within the option separated with an\n    \"=\" sign:\n\n---------\nstring outputFile;\ngetopt(args, \"output\", &outputFile);\n---------\n\n    Invoking the program with \"--output=myfile.txt\" or \"--output myfile.txt\"\n    will set $(D outputFile) to \"myfile.txt\". If you want to pass a string\n    containing spaces, you need to use the quoting that is appropriate to your\n    shell, e.g. --output='my file.txt'.\n    )\n\n    $(LI $(I Array options.) If an option is bound to an array, a new element\n    is appended to the array each time the option occurs:\n\n---------\nstring[] outputFiles;\ngetopt(args, \"output\", &outputFiles);\n---------\n\n    Invoking the program with \"--output=myfile.txt --output=yourfile.txt\" or\n    \"--output myfile.txt --output yourfile.txt\" will set $(D outputFiles) to\n    $(D [ \"myfile.txt\", \"yourfile.txt\" ]).\n\n    Alternatively you can set $(LREF arraySep) as the element separator:\n\n---------\nstring[] outputFiles;\narraySep = \",\";  // defaults to \"\", separation by whitespace\ngetopt(args, \"output\", &outputFiles);\n---------\n\n    With the above code you can invoke the program with\n    \"--output=myfile.txt,yourfile.txt\", or \"--output myfile.txt,yourfile.txt\".)\n\n    $(LI $(I Hash options.) If an option is bound to an associative array, a\n    string of the form \"name=value\" is expected as the next option, or right\n    within the option separated with an \"=\" sign:\n\n---------\ndouble[string] tuningParms;\ngetopt(args, \"tune\", &tuningParms);\n---------\n\n    Invoking the program with e.g. \"--tune=alpha=0.5 --tune beta=0.6\" will set\n    $(D tuningParms) to [ \"alpha\" : 0.5, \"beta\" : 0.6 ].\n\n    Alternatively you can set $(LREF arraySep) as the element separator:\n\n---------\ndouble[string] tuningParms;\narraySep = \",\";  // defaults to \"\", separation by whitespace\ngetopt(args, \"tune\", &tuningParms);\n---------\n\n    With the above code you can invoke the program with\n    \"--tune=alpha=0.5,beta=0.6\", or \"--tune alpha=0.5,beta=0.6\".\n\n    In general, the keys and values can be of any parsable types.\n    )\n\n    $(LI $(I Callback options.) An option can be bound to a function or\n    delegate with the signature $(D void function()), $(D void function(string\n    option)), $(D void function(string option, string value)), or their\n    delegate equivalents.\n\n    $(UL\n        $(LI If the callback doesn't take any arguments, the callback is\n        invoked whenever the option is seen.\n        )\n\n        $(LI If the callback takes one string argument, the option string\n        (without the leading dash(es)) is passed to the callback.  After that,\n        the option string is considered handled and removed from the options\n        array.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option)\n  {\n    if (option == \"quiet\")\n    {\n      verbosityLevel = 0;\n    }\n    else\n    {\n      assert(option == \"verbose\");\n      verbosityLevel = 2;\n    }\n  }\n  getopt(args, \"verbose\", &myHandler, \"quiet\", &myHandler);\n}\n---------\n\n        )\n\n        $(LI If the callback takes two string arguments, the option string is\n        handled as an option with one argument, and parsed accordingly. The\n        option and its value are passed to the callback. After that, whatever\n        was passed to the callback is considered handled and removed from the\n        list.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option, string value)\n  {\n    switch (value)\n    {\n      case \"quiet\": verbosityLevel = 0; break;\n      case \"verbose\": verbosityLevel = 2; break;\n      case \"shouting\": verbosityLevel = verbosityLevel.max; break;\n      default :\n        stderr.writeln(\"Dunno how verbose you want me to be by saying \",\n          value);\n        exit(1);\n    }\n  }\n  getopt(args, \"verbosity\", &myHandler);\n}\n---------\n        )\n    ))\n)\n\nOptions_with_multiple_names:\nSometimes option synonyms are desirable, e.g. \"--verbose\",\n\"--loquacious\", and \"--garrulous\" should have the same effect. Such\nalternate option names can be included in the option specification,\nusing \"|\" as a separator:\n\n---------\nbool verbose;\ngetopt(args, \"verbose|loquacious|garrulous\", &verbose);\n---------\n\nCase:\nBy default options are case-insensitive. You can change that behavior\nby passing $(D getopt) the $(D caseSensitive) directive like this:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nIn the example above, \"--foo\", \"--bar\", \"--FOo\", \"--bAr\" etc. are recognized.\nThe directive is active til the end of $(D getopt), or until the\nconverse directive $(D caseInsensitive) is encountered:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    std.getopt.config.caseInsensitive,\n    \"bar\", &bar);\n---------\n\nThe option \"--Foo\" is rejected due to $(D\nstd.getopt.config.caseSensitive), but not \"--Bar\", \"--bAr\"\netc. because the directive $(D\nstd.getopt.config.caseInsensitive) turned sensitivity off before\noption \"bar\" was parsed.\n\nShort_versus_long_options:\nTraditionally, programs accepted single-letter options preceded by\nonly one dash (e.g. $(D -t)). $(D getopt) accepts such parameters\nseamlessly. When used with a double-dash (e.g. $(D --t)), a\nsingle-letter option behaves the same as a multi-letter option. When\nused with a single dash, a single-letter option is accepted. If the\noption has a parameter, that must be \"stuck\" to the option without\nany intervening space or \"=\":\n\n---------\nuint timeout;\ngetopt(args, \"timeout|t\", &timeout);\n---------\n\nTo set $(D timeout) to $(D 5), use either of the following: $(D --timeout=5),\n$(D --timeout 5), $(D --t=5), $(D --t 5), or $(D -t5). Forms such as $(D -t 5)\nand $(D -timeout=5) will be not accepted.\n\nFor more details about short options, refer also to the next section.\n\nBundling:\nSingle-letter options can be bundled together, i.e. \"-abc\" is the same as\n$(D \"-a -b -c\"). By default, this option is turned off. You can turn it on\nwith the $(D std.getopt.config.bundling) directive:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.bundling,\n    \"foo|f\", &foo,\n    \"bar|b\", &bar);\n---------\n\nIn case you want to only enable bundling for some of the parameters,\nbundling can be turned off with $(D std.getopt.config.noBundling).\n\nRequired:\nAn option can be marked as required. If that option is not present in the\narguments an exception will be thrown.\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.required,\n    \"foo|f\", &foo,\n    \"bar|b\", &bar);\n---------\n\nOnly the option directly following $(D std.getopt.config.required) is\nrequired.\n\nPassing_unrecognized_options_through:\nIf an application needs to do its own processing of whichever arguments\n$(D getopt) did not understand, it can pass the\n$(D std.getopt.config.passThrough) directive to $(D getopt):\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.passThrough,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nAn unrecognized option such as \"--baz\" will be found untouched in\n$(D args) after $(D getopt) returns.\n\nHelp_Information_Generation:\nIf an option string is followed by another string, this string serves as a\ndescription for this option. The $(D getopt) function returns a struct of type\n$(D GetoptResult). This return value contains information about all passed options\nas well a $(D bool GetoptResult.helpWanted) flag indicating whether information\nabout these options was requested. The $(getopt) function always adds an option for\n--help|-h` to set the flag if the option is seen on the command line.\n\nOptions_Terminator:\nA lone double-dash terminates $(D getopt) gathering. It is used to\nseparate program options from other parameters (e.g., options to be passed\nto another program). Invoking the example above with $(D \"--foo -- --bar\")\nparses foo but leaves \"--bar\" in $(D args). The double-dash itself is\nremoved from the argument array unless the $(D std.getopt.config.keepEndOfOptions)\ndirective is given.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL456_663)\n---\nauto args = [\"prog\", \"--foo\", \"-b\"];\n\nbool foo;\nbool bar;\nauto rslt = getopt(args, \"foo|f\", \"Some information about foo.\", &foo, \"bar|b\",\n    \"Some help message about bar.\", &bar);\n\nif (rslt.helpWanted)\n{\n    defaultGetoptPrinter(\"Some information about the program.\",\n        rslt.options);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL456_663)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 14,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "caseSensitive",
						"line": 480,
						"value": "0",
						"comment": "Turn case sensitivity on\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "caseInsensitive",
						"line": 482,
						"value": "1",
						"comment": "Turn case sensitivity off\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bundling",
						"line": 484,
						"value": "2",
						"comment": "Turn bundling on\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "noBundling",
						"line": 486,
						"value": "3",
						"comment": "Turn bundling off\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "passThrough",
						"line": 488,
						"value": "4",
						"comment": "Pass unrecognized arguments through\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "noPassThrough",
						"line": 490,
						"value": "5",
						"comment": "Signal unrecognized arguments as errors\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stopOnFirstNonOption",
						"line": 492,
						"value": "6",
						"comment": "Stop at first argument that does not look like an option\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "keepEndOfOptions",
						"line": 494,
						"value": "7",
						"comment": "Do not erase the endOfOptions separator from args\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "required",
						"line": 496,
						"value": "8",
						"comment": "Make the next option a required option\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "config",
				"line": 478,
				"comment": "   Configuration options for $(D getopt).\n\n   You can pass them to $(D getopt) in any position, except in between an option\n   string and its bound pointer.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "GetoptResult",
				"line": 503,
				"comment": " The result of the $(D getopt) function.\n\n$(D helpWanted) is set if the option `--help` or `-h` was passed to the option parser.\n",
				"members": [
					{
						"offset": 0,
						"name": "helpWanted",
						"line": 504,
						"comment": "Flag indicating if help was requested\n",
						"deco": "b",
						"char": 10,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "options",
						"line": 505,
						"comment": "All possible options\n",
						"deco": "AS3std6getopt6Option",
						"char": 14,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "Option",
				"line": 510,
				"comment": " Information about an option.\n",
				"members": [
					{
						"offset": 0,
						"name": "optShort",
						"line": 511,
						"comment": "The short symbol for this option\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "optLong",
						"line": 512,
						"comment": "The long symbol for this option\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "help",
						"line": 513,
						"comment": "The description of this option\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "required",
						"line": 514,
						"comment": "If a option is required, not passing it will result in an error\n",
						"deco": "b",
						"char": 10,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "optionChar",
				"line": 871,
				"comment": "   The option character (default '-').\n\n   Defaults to '-' but it can be assigned to prior to calling $(D getopt).\n",
				"deco": "w",
				"init": "'-'",
				"char": 7,
				"kind": "variable"
			},
			{
				"name": "endOfOptions",
				"line": 879,
				"comment": "   The string that conventionally marks the end of all options (default '--').\n\n   Defaults to \"--\" but can be assigned to prior to calling $(D getopt). Assigning an\n   empty string to $(D endOfOptions) effectively disables it.\n",
				"deco": "Aya",
				"init": "\"--\"",
				"char": 8,
				"kind": "variable"
			},
			{
				"name": "assignChar",
				"line": 886,
				"comment": "   The assignment character used in options with parameters (default '=').\n\n   Defaults to '=' but can be assigned to prior to calling $(D getopt).\n",
				"deco": "w",
				"init": "'='",
				"char": 7,
				"kind": "variable"
			},
			{
				"name": "arraySep",
				"line": 894,
				"comment": "   The string used to separate the elements of an array or associative array\n   (default is \"\" which means the elements are separated by whitespace).\n\n   Defaults to \"\" but can be assigned to prior to calling $(D getopt).\n",
				"deco": "Aya",
				"init": "\"\"",
				"char": 8,
				"kind": "variable"
			},
			{
				"endchar": 1,
				"name": "defaultGetoptPrinter",
				"line": 1423,
				"comment": " This function prints the passed $(D Option)s and text in an aligned manner on $(D stdout).\n\nThe passed text will be printed first, followed by a newline, then the short\nand long version of every option will be printed. The short and long version\nwill be aligned to the longest option of every $(D Option) passed. If the option\nis required, then \"Required:\" will be printed after the long version of the\n$(D Option). If a help message is present it will be printed next. The format is\nillustrated by this code:\n\n------------\nforeach(it; opt)\n{\n    writefln(\"%*s %*s%s%s\", lengthOfLongestShortOption, it.optShort,\n        lengthOfLongestLongOption, it.optLong,\n        it.required ? \" Required: \" : \" \", it.help);\n}\n------------\n\nParams:\n    text = The text to printed at the beginning of the help output.\n    opt = The $(D Option) extracted from the $(D getopt) parameter.\n",
				"deco": "FAyaAS3std6getopt6OptionZv",
				"parameters": [
					{
						"name": "text",
						"deco": "Aya"
					},
					{
						"name": "opt",
						"deco": "AS3std6getopt6Option"
					}
				],
				"endline": 1428,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "defaultGetoptFormatter",
						"line": 1439,
						"type": "void(Output output, string text, Option[] opt)",
						"parameters": [
							{
								"name": "output",
								"type": "Output"
							},
							{
								"name": "text",
								"type": "string"
							},
							{
								"name": "opt",
								"type": "Option[]"
							}
						],
						"endline": 1465,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "defaultGetoptFormatter",
				"line": 1439,
				"comment": " This function writes the passed text and $(D Option) into an output range\nin the manner described in the documentation of function\n$(D defaultGetoptPrinter).\n\nParams:\n    output = The output range used to write the help information.\n    text = The text to print at the beginning of the help output.\n    opt = The $(D Option) extracted from the $(D getopt) parameter.\n",
				"parameters": [
					{
						"name": "Output",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "Processing of command line options.\n\nThe getopt module implements a $(D getopt) function, which adheres to\nthe POSIX syntax for command line options. GNU extensions are\nsupported in the form of long options introduced by a double dash\n(\"--\"). Support for bundling of command line options, as was the case\nwith the more traditional single-letter approach, is provided but not\nenabled by default.\n\nMacros:\n\nWIKI = Phobos/StdGetopt\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2015.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\nCredits:   This module and its documentation are inspired by Perl's $(WEB\n           perldoc.perl.org/Getopt/Long.html, Getopt::Long) module. The syntax of\n           D's $(D getopt) is simpler than its Perl counterpart because $(D\n           getopt) infers the expected parameter types from the static types of\n           the passed-in pointers.\nSource:    $(PHOBOSSRC std/_getopt.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/compiler.d",
		"name": "std.compiler",
		"members": [
			{
				"name": "name",
				"line": 24,
				"comment": "Vendor specific string naming the compiler, for example: \"Digital Mars D\".\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"Digital Mars D\"",
				"char": 12,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"members": [
					{
						"name": "unknown",
						"line": 29,
						"value": "0",
						"comment": "Compiler vendor could not be detected\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "digitalMars",
						"line": 30,
						"value": "1",
						"comment": "Digital Mars D (DMD)\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "gnu",
						"line": 31,
						"value": "2",
						"comment": "GNU D Compiler (GDC)\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "llvm",
						"line": 32,
						"value": "3",
						"comment": "LLVM D Compiler (LDC)\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "dotNET",
						"line": 33,
						"value": "4",
						"comment": "D.NET\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "sdc",
						"line": 34,
						"value": "5",
						"comment": "Stupid D Compiler (SDC)\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "Vendor",
				"line": 27,
				"comment": "Master list of D compiler vendors.\n",
				"baseDeco": "i",
				"char": 5,
				"kind": "enum"
			},
			{
				"name": "vendor",
				"line": 38,
				"comment": "Which vendor produced this compiler.\n",
				"deco": "yE3std8compiler6Vendor",
				"originalType": "Vendor",
				"char": 38,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "version_major",
				"line": 51,
				"comment": " The vendor specific version number, as in\n version_major.version_minor\n",
				"deco": "yk",
				"originalType": "uint",
				"init": "2u",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "version_minor",
				"line": 52,
				"comment": "ditto\n",
				"deco": "yk",
				"originalType": "uint",
				"init": "69u",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "D_major",
				"line": 59,
				"comment": " The version of the D Programming Language Specification\n supported by the compiler.\n",
				"deco": "yk",
				"originalType": "uint",
				"init": "2u",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			}
		],
		"comment": " Identify the compiler used and its various features.\n\n Macros:\n      WIKI = Phobos/StdCompiler\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright), Alex Rønne Petersen\n Source:    $(PHOBOSSRC std/_compiler.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/datetime.d",
		"name": "std.datetime",
		"members": [
			{
				"members": [
					{
						"name": "jan",
						"line": 168,
						"value": "cast(ubyte)1u",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "feb",
						"line": 169,
						"value": "2",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "mar",
						"line": 170,
						"value": "3",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "apr",
						"line": 171,
						"value": "4",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "may",
						"line": 172,
						"value": "5",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "jun",
						"line": 173,
						"value": "6",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "jul",
						"line": 174,
						"value": "7",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "aug",
						"line": 175,
						"value": "8",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "sep",
						"line": 176,
						"value": "9",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "oct",
						"line": 177,
						"value": "10",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "nov",
						"line": 178,
						"value": "11",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "dec",
						"line": 179,
						"value": "12",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					}
				],
				"name": "Month",
				"line": 168,
				"comment": "    Represents the 12 months of the Gregorian year (January is 1).\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "sun",
						"line": 185,
						"value": "cast(ubyte)0u",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "mon",
						"line": 186,
						"value": "1",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "tue",
						"line": 187,
						"value": "2",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "wed",
						"line": 188,
						"value": "3",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "thu",
						"line": 189,
						"value": "4",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "fri",
						"line": 190,
						"value": "5",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "sat",
						"line": 191,
						"value": "6",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					}
				],
				"name": "DayOfWeek",
				"line": 185,
				"comment": "    Represents the 7 days of the Gregorian week (Sunday is 0).\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 209,
						"value": "0",
						"comment": "No, don't allow day overflow.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 212,
						"value": "1",
						"comment": "Yes, allow day overflow.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "AllowDayOverflow",
				"line": 206,
				"comment": "    In some date calculations, adding months or years can cause the date to fall\n    on a day of the month which is not valid (e.g. February 29th 2001 or\n    June 31st 2000). If overflow is allowed (as is the default), then the month\n    will be incremented accordingly (so, February 29th 2001 would become\n    March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow\n    is not allowed, then the day will be adjusted to the last valid day in that\n    month (so, February 29th 2001 would become February 28th 2001 and\n    June 31st 2000 would become June 30th 2000).\n\n    AllowDayOverflow only applies to calculations involving months or years.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "bwd",
						"line": 223,
						"value": "0",
						"comment": "Backward.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "fwd",
						"line": 226,
						"value": "1",
						"comment": "Forward.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "both",
						"line": 229,
						"value": "2",
						"comment": "Both backward and forward.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Direction",
				"line": 220,
				"comment": "    Indicates a direction in time. One example of its use is $(LREF2 .Interval, Interval)'s\n    $(LREF expand, expand) function which uses it to indicate whether the interval should\n    be expanded backwards (into the past), forwards (into the future), or both.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 260,
						"value": "0",
						"comment": "No, don't call popFront() before returning the range.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 263,
						"value": "1",
						"comment": "Yes, call popFront() before returning the range.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "PopFirst",
				"line": 257,
				"comment": "    Used to indicate whether $(D popFront) should be called immediately upon\n    creating a range. The idea is that for some functions used to generate a\n    range for an interval, $(D front) is not necessarily a time point which\n    would ever be generated by the range. To get the first time point\n    in the range to match what the function generates, then use\n    $(D PopFirst.yes) to indicate that the range should have $(D popFront)\n    called on it before the range is returned so that $(D front) is a time point\n    which the function would generate.\n\n    For instance, if the function used to generate a range of time points\n    generated successive Easters (i.e. you're iterating over all of the Easters\n    within the interval), the initial date probably isn't an Easter. Using\n    $(D PopFirst.yes) would tell the function which returned the\n    range that $(D popFront) was to be called so that front would then be\n    an Easter - the next one generated by the function (which when\n    iterating forward would be the Easter following the original $(D front),\n    while when iterating backward, it would be the Easter prior to the\n    original $(D front)). If $(D PopFirst.no) were used, then $(D front) would\n    remain the original time point and it would not necessarily be a time point\n    which would be generated by the range-generating function (which in many\n    cases is exactly what is desired -\n    e.g. if iterating over every day starting at the beginning\n    of the interval).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 273,
						"value": "0",
						"comment": "No, don't start the StopWatch when it is constructed.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 276,
						"value": "1",
						"comment": "Yes, do start the StopWatch when it is constructed.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "AutoStart",
				"line": 270,
				"comment": "   Used by StopWatch to indicate whether it should start immediately upon\n   construction.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "timeStrings",
				"line": 288,
				"comment": "    Array of the strings representing time units, starting with the smallest\n    unit and going to the largest. It does not include $(D \"nsecs\").\n\n   Includes $(D \"hnsecs\") (hecto-nanoseconds (100 ns)),\n   $(D \"usecs\") (microseconds), $(D \"msecs\") (milliseconds), $(D \"seconds\"),\n   $(D \"minutes\"), $(D \"hours\"), $(D \"days\"), $(D \"weeks\"), $(D \"months\"), and\n   $(D \"years\")\n",
				"deco": "yAAa",
				"originalType": "string[]",
				"init": "[\"hnsecs\", \"usecs\", \"msecs\", \"seconds\", \"minutes\", \"hours\", \"days\", \"weeks\", \"months\", \"years\"]",
				"char": 20,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "DateTimeException",
				"line": 301,
				"comment": "    Exception type used by std.datetime. It's an alias to $(CXREF time, TimeException).\n    Either can be caught without concern about which\n    module it came from.\n",
				"deco": "C4core4time13TimeException",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Clock",
				"line": 307,
				"comment": "    Effectively a namespace to make it clear that the methods it contains are\n    getting the time from the system clock. It cannot be instantiated.\n",
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "currTime",
								"line": 323,
								"type": "@safe SysTime(immutable TimeZone tz = LocalTime())",
								"parameters": [
									{
										"name": "tz",
										"type": "TimeZone",
										"storageClass": [
											"immutable"
										],
										"default": "LocalTime()"
									}
								],
								"endline": 326,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "currTime",
						"line": 323,
						"comment": "        Returns the current time in the given time zone.\n\n        Params:\n            clockType = The $(CXREF time, ClockType) indicates which system\n                        clock to use to get the current time. Very few programs\n                        need to use anything other than the default.\n            tz = The time zone for the SysTime that's returned.\n\n        Throws:\n            $(LREF DateTimeException) if it fails to get the time.\n",
						"parameters": [
							{
								"name": "clockType",
								"defaultValue": "ClockType.normal",
								"deco": "E4core4time9ClockType",
								"kind": "value"
							}
						],
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "currStdTime",
								"line": 375,
								"type": "@property @trusted long()",
								"endline": 477,
								"char": 27,
								"kind": "function"
							}
						],
						"name": "currStdTime",
						"line": 375,
						"comment": "        Returns the number of hnsecs since midnight, January 1st, 1 A.D. for the\n        current time.\n\n        Params:\n            clockType = The $(CXREF time, ClockType) indicates which system\n                        clock to use to get the current time. Very few programs\n                        need to use anything other than the default.\n\n        Throws:\n            $(LREF DateTimeException) if it fails to get the time.\n",
						"parameters": [
							{
								"name": "clockType",
								"defaultValue": "ClockType.normal",
								"deco": "E4core4time9ClockType",
								"kind": "value"
							}
						],
						"char": 27,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "currSystemTick",
						"line": 524,
						"comment": "        $(RED Deprecated. $(CXREF time, TickDuration) is going to be deprecated\n              in favor of $(CXREF time, MonoTime). Use $(D MonoTime.currTime)\n              instead. currSystemTick will be removed in January 2017.)\n\n        The current system tick. The number of ticks per second varies from\n        system to system. currSystemTick uses a monotonic clock, so it's\n        intended for precision timing by comparing relative time values, not\n        for getting the current system time.\n\n        Warning:\n            On some systems, the monotonic clock may stop counting when\n            the computer goes to sleep or hibernates. So, the monotonic\n            clock could be off if that occurs. This is known to happen\n            on Mac OS X. It has not been tested whether it occurs on\n            either Windows or Linux.\n\n        Throws:\n            $(LREF DateTimeException) if it fails to get the time.\n",
						"deco": "FNbNdNfZS4core4time12TickDuration",
						"endline": 527,
						"char": 35,
						"kind": "function",
						"storageClass": [
							"static",
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "currAppTick",
						"line": 571,
						"comment": "        $(RED Deprecated. $(CXREF time, TickDuration) is going to be deprecated\n              in favor of $(CXREF time, MonoTime). To duplicate the behavior\n              of currAppTick with $(D MonoTime), store the value of\n              $(D MonoTime.currTime) when the program starts, and then subtract\n              it from the current value of $(D MonoTime.currTime) in order to\n              determine how long the program has been running. currAppTick will\n              be removed in January 2017.)\n\n        --------------------\n        immutable MonoTime startupTime;\n        shared static this()\n        {\n            startupTime = MonoTime.currTime;\n        }\n        Duration timeSinceProgramStarted()\n        {\n            return MonoTime.currTime - startupTime;\n        }\n        --------------------\n\n        The current number of system ticks since the application started.\n        The number of ticks per second varies from system to system.\n        This uses a monotonic clock.\n\n        Warning:\n            On some systems, the monotonic clock may stop counting when\n            the computer goes to sleep or hibernates. So, the monotonic\n            clock could be off if that occurs. This is known to happen\n            on Mac OS X. It has not been tested whether it occurs on\n            either Windows or on Linux.\n\n        Throws:\n            $(LREF DateTimeException) if it fails to get the time.\n",
						"deco": "FNdNfZS4core4time12TickDuration",
						"endline": 574,
						"char": 35,
						"kind": "function",
						"storageClass": [
							"static",
							"deprecated"
						]
					}
				],
				"char": 7,
				"kind": "class"
			},
			{
				"name": "SysTime",
				"line": 636,
				"comment": "    $(D SysTime) is the type used to get the current time from the\n    system or doing anything that involves time zones. Unlike\n    $(LREF DateTime), the time zone is an integral part of $(D SysTime) (though for\n    local time applications, time zones can be ignored and\n    it will work, since it defaults to using the local time zone). It holds its\n    internal time in std time (hnsecs since midnight, January 1st, 1 A.D. UTC),\n    so it interfaces well with the system time. However, that means that, unlike\n    $(LREF DateTime), it is not optimized for calendar-based operations, and\n    getting individual units from it such as years or days is going to involve\n    conversions and be less efficient.\n\n    For calendar-based operations that don't\n    care about time zones, then $(LREF DateTime) would be the type to\n    use. For system time, use $(D SysTime).\n\n    $(LREF2 .Clock.currTime, Clock.currTime) will return the current time as a $(D SysTime).\n    To convert a $(D SysTime) to a $(LREF Date) or $(LREF DateTime), simply cast\n    it. To convert a $(LREF Date) or $(LREF DateTime) to a\n    $(D SysTime), use $(D SysTime)'s constructor, and pass in the\n    intended time zone with it (or don't pass in a $(LREF2 .TimeZone, TimeZone), and the local\n    time zone will be used). Be aware, however, that converting from a\n    $(LREF DateTime) to a $(D SysTime) will not necessarily be 100% accurate due to\n    DST (one hour of the year doesn't exist and another occurs twice).\n    To not risk any conversion errors, keep times as\n    $(D SysTime)s. Aside from DST though, there shouldn't be any conversion\n    problems.\n\n    For using time zones other than local time or UTC, use\n    $(LREF PosixTimeZone) on Posix systems (or on Windows, if providing the TZ\n    Database files), and use $(LREF WindowsTimeZone) on Windows systems.\n    The time in $(D SysTime) is kept internally in hnsecs from midnight,\n    January 1st, 1 A.D. UTC. Conversion error cannot happen when changing\n    the time zone of a $(D SysTime). $(LREF LocalTime) is the $(LREF2 .TimeZone, TimeZone) class\n    which represents the local time, and $(D UTC) is the $(LREF2 .TimeZone, TimeZone) class\n    which represents UTC. $(D SysTime) uses $(LREF LocalTime) if no $(LREF2 .TimeZone, TimeZone)\n    is provided. For more details on time zones, see the documentation for\n    $(LREF2 .TimeZone, TimeZone), $(LREF PosixTimeZone), and $(LREF WindowsTimeZone).\n\n    $(D SysTime)'s range is from approximately 29,000 B.C. to approximately\n    29,000 A.D.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 651,
						"comment": "        Params:\n            dateTime = The $(LREF DateTime) to use to set this $(LREF SysTime)'s\n                       internal std time. As $(LREF DateTime) has no concept of\n                       time zone, tz is used as its time zone.\n            tz       = The $(LREF2 .TimeZone, TimeZone) to use for this $(LREF SysTime). If null,\n                       $(LREF LocalTime) will be used. The given $(LREF DateTime) is\n                       assumed to be in the given time zone.\n",
						"deco": "FNbNcNfxS3std8datetime8DateTimeyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "dateTime",
								"deco": "xS3std8datetime8DateTime"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "null"
							}
						],
						"endline": 657,
						"originalType": "nothrow ref @safe (in DateTime dateTime, immutable TimeZone tz = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 696,
						"comment": "        Params:\n            dateTime = The $(LREF DateTime) to use to set this $(LREF SysTime)'s\n                       internal std time. As $(LREF DateTime) has no concept of\n                       time zone, tz is used as its time zone.\n            fracSecs = The fractional seconds portion of the time.\n            tz       = The $(LREF2 .TimeZone, TimeZone) to use for this $(LREF SysTime). If null,\n                       $(LREF LocalTime) will be used. The given $(LREF DateTime) is\n                       assumed to be in the given time zone.\n\n        Throws:\n            $(LREF DateTimeException) if $(D fracSecs) is negative or if it's\n            greater than or equal to one second.\n",
						"deco": "FNcNfxS3std8datetime8DateTimexS4core4time8DurationyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "dateTime",
								"deco": "xS3std8datetime8DateTime"
							},
							{
								"name": "fracSecs",
								"deco": "xS4core4time8Duration"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "null"
							}
						],
						"endline": 709,
						"originalType": "ref @safe (in DateTime dateTime, in Duration fracSecs, immutable TimeZone tz = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 755,
						"comment": "        $(RED Deprecated. Please use the overload which takes a\n              $(CXREF time, Duration) for the fractional seconds. This overload\n              will be removed in August 2016.)\n\n        Params:\n            dateTime = The $(LREF DateTime) to use to set this $(LREF SysTime)'s\n                       internal std time. As $(LREF DateTime) has no concept of\n                       time zone, tz is used as its time zone.\n            fracSec  = The fractional seconds portion of the time.\n            tz       = The $(LREF2 .TimeZone, TimeZone) to use for this $(LREF SysTime). If null,\n                       $(LREF LocalTime) will be used. The given $(LREF DateTime) is\n                       assumed to be in the given time zone.\n\n        Throws:\n            $(LREF DateTimeException) if $(D fracSec) is negative.\n",
						"deco": "FNcNfxS3std8datetime8DateTimexS4core4time7FracSecyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "dateTime",
								"deco": "xS3std8datetime8DateTime"
							},
							{
								"name": "fracSec",
								"deco": "xS4core4time7FracSec"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "null"
							}
						],
						"endline": 773,
						"originalType": "ref @safe (in DateTime dateTime, in FracSec fracSec, immutable TimeZone tz = null)",
						"char": 5,
						"kind": "constructor",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 812,
						"comment": "        Params:\n            date = The $(LREF Date) to use to set this $(LREF SysTime)'s internal std\n                   time. As $(LREF Date) has no concept of time zone, tz is used as\n                   its time zone.\n            tz   = The $(LREF2 .TimeZone, TimeZone) to use for this $(LREF SysTime). If null,\n                   $(LREF LocalTime) will be used. The given $(LREF Date) is assumed\n                   to be in the given time zone.\n",
						"deco": "FNbNcNfxS3std8datetime4DateyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "date",
								"deco": "xS3std8datetime4Date"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "null"
							}
						],
						"endline": 825,
						"originalType": "nothrow ref @safe (in Date date, immutable TimeZone tz = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 860,
						"comment": "        Note:\n            Whereas the other constructors take in the given date/time, assume\n            that it's in the given time zone, and convert it to hnsecs in UTC\n            since midnight, January 1st, 1 A.D. UTC - i.e. std time - this\n            constructor takes a std time, which is specifically already in UTC,\n            so no conversion takes place. Of course, the various getter\n            properties and functions will use the given time zone's conversion\n            function to convert the results to that time zone, but no conversion\n            of the arguments to this constructor takes place.\n\n        Params:\n            stdTime = The number of hnsecs since midnight, January 1st, 1 A.D. UTC.\n            tz      = The $(LREF2 .TimeZone, TimeZone) to use for this $(LREF SysTime). If null,\n                      $(LREF LocalTime) will be used.\n",
						"deco": "FNaNbNcNflyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "null"
							}
						],
						"endline": 864,
						"originalType": "pure nothrow ref @safe (long stdTime, immutable TimeZone tz = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opAssign",
						"line": 888,
						"comment": "        Params:\n            rhs = The $(LREF SysTime) to assign to this one.\n",
						"deco": "FNaNbNcNjNfKxS3std8datetime7SysTimeZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "rhs",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std8datetime7SysTime"
							}
						],
						"endline": 894,
						"originalType": "pure nothrow ref return @safe SysTime(ref const SysTime rhs)",
						"char": 17,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opAssign",
						"line": 900,
						"comment": "        Params:\n            rhs = The $(LREF SysTime) to assign to this one.\n",
						"deco": "FNaNbNcNjNfS3std8datetime7SysTimeZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "rhs",
								"deco": "S3std8datetime7SysTime"
							}
						],
						"endline": 906,
						"char": 17,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 915,
						"comment": "        Checks for equality between this $(LREF SysTime) and the given\n        $(LREF SysTime).\n\n        Note that the time zone is ignored. Only the internal\n        std times (which are in UTC) are compared.\n",
						"deco": "xFNaNbNfxS3std8datetime7SysTimeZb",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime7SysTime"
							}
						],
						"endline": 918,
						"originalType": "const pure nothrow @safe bool(const SysTime rhs)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 921,
						"comment": "ditto\n",
						"deco": "xFNaNbNfKxS3std8datetime7SysTimeZb",
						"parameters": [
							{
								"name": "rhs",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std8datetime7SysTime"
							}
						],
						"endline": 924,
						"originalType": "const pure nothrow @safe bool(ref const SysTime rhs)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 982,
						"comment": "        Compares this $(LREF SysTime) with the given $(LREF SysTime).\n\n        Time zone is irrelevant when comparing $(LREF SysTime)s.\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
						"deco": "xFNaNbNfxS3std8datetime7SysTimeZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime7SysTime"
							}
						],
						"endline": 990,
						"originalType": "const pure nothrow @safe int(in SysTime rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 1055,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n",
						"deco": "xFNbNdNfZs",
						"endline": 1058,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 1108,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this $(LREF SysTime)'s year to.\n\n        Throws:\n            $(LREF DateTimeException) if the new year is not a leap year and the\n            resulting date would be on February 29th.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1127_703)\n---\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).year == 1999);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).year == 2010);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).year == -7);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1127_703)\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 1124,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 1188,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(LREF DateTimeException) if $(D isAD) is true.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1194_705)\n---\nassert(SysTime(DateTime(0, 1, 1, 12, 30, 33)).yearBC == 1);\nassert(SysTime(DateTime(-1, 1, 1, 10, 7, 2)).yearBC == 2);\nassert(SysTime(DateTime(-100, 1, 1, 4, 59, 0)).yearBC == 101);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1194_705)\n",
						"deco": "xFNdNfZt",
						"endline": 1191,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 1233,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(LREF SysTime)'s year to.\n\n        Throws:\n            $(LREF DateTimeException) if a non-positive value is given.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 1249,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 1323,
						"comment": "        Month of a Gregorian Year.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1329_709)\n---\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).month == 7);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).month == 10);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).month == 4);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1329_709)\n",
						"deco": "xFNbNdNfZE3std8datetime5Month",
						"endline": 1326,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 1383,
						"comment": "        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(LREF SysTime)'s month to.\n\n        Throws:\n            $(LREF DateTimeException) if the given month is not a valid month.\n",
						"deco": "FNdNfE3std8datetime5MonthZv",
						"parameters": [
							{
								"name": "month",
								"deco": "E3std8datetime5Month"
							}
						],
						"endline": 1399,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 1483,
						"comment": "        Day of a Gregorian Month.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1489_713)\n---\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).day == 6);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).day == 4);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).day == 5);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1489_713)\n",
						"deco": "xFNbNdNfZh",
						"endline": 1486,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 1545,
						"comment": "        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(LREF SysTime)'s day to.\n\n        Throws:\n            $(LREF DateTimeException) if the given day is not a valid day of the\n            current month.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 1561,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 1638,
						"comment": "        Hours past midnight.\n",
						"deco": "xFNbNdNfZh",
						"endline": 1650,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 1708,
						"comment": "        Hours past midnight.\n\n        Params:\n            hour = The hours to set this $(LREF SysTime)'s hour to.\n\n        Throws:\n            $(LREF DateTimeException) if the given hour are not a valid hour of\n            the day.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "hour",
								"deco": "i"
							}
						],
						"endline": 1727,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 1761,
						"comment": "        Minutes past the current hour.\n",
						"deco": "xFNbNdNfZh",
						"endline": 1775,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 1833,
						"comment": "        Minutes past the current hour.\n\n        Params:\n            minute = The minute to set this $(LREF SysTime)'s minute to.\n\n        Throws:\n            $(LREF DateTimeException) if the given minute are not a valid minute\n            of an hour.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "minute",
								"deco": "i"
							}
						],
						"endline": 1855,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 1889,
						"comment": "        Seconds past the current minute.\n",
						"deco": "xFNbNdNfZh",
						"endline": 1904,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 1962,
						"comment": "        Seconds past the current minute.\n\n        Params:\n            second = The second to set this $(LREF SysTime)'s second to.\n\n        Throws:\n            $(LREF DateTimeException) if the given second are not a valid second\n            of a minute.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "second",
								"deco": "i"
							}
						],
						"endline": 1986,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fracSecs",
						"line": 2021,
						"comment": "        Fractional seconds past the second (i.e. the portion of a\n        $(LREF SysTime) which is less than a second).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2032_722)\n---\nauto dt = DateTime(1982, 4, 1, 20, 59, 22);\nassert(SysTime(dt, msecs(213)).fracSecs == msecs(213));\nassert(SysTime(dt, usecs(5202)).fracSecs == usecs(5202));\nassert(SysTime(dt, hnsecs(1234567)).fracSecs == hnsecs(1234567));\n\n// SysTime and Duration both have a precision of hnsecs (100 ns),\n// so nsecs are going to be truncated.\nassert(SysTime(dt, nsecs(123456789)).fracSecs == nsecs(123456700));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2032_722)\n",
						"deco": "xFNbNdNfZS4core4time8Duration",
						"endline": 2029,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fracSecs",
						"line": 2093,
						"comment": "        Fractional seconds past the second (i.e. the portion of a\n        $(LREF SysTime) which is less than a second).\n\n        Params:\n            fracSecs = The duration to set this $(LREF SysTime)'s fractional\n                       seconds to.\n\n        Throws:\n            $(LREF DateTimeException) if the given duration is negative or if\n            it's greater than or equal to one second.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2117_724)\n---\nauto st = SysTime(DateTime(1982, 4, 1, 20, 59, 22));\nassert(st.fracSecs == Duration.zero);\n\nst.fracSecs = msecs(213);\nassert(st.fracSecs == msecs(213));\n\nst.fracSecs = hnsecs(1234567);\nassert(st.fracSecs == hnsecs(1234567));\n\n// SysTime has a precision of hnsecs (100 ns), so nsecs are\n// going to be truncated.\nst.fracSecs = nsecs(123456789);\nassert(st.fracSecs == hnsecs(1234567));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2117_724)\n",
						"deco": "FNdNfS4core4time8DurationZv",
						"parameters": [
							{
								"name": "fracSecs",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 2114,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fracSec",
						"line": 2171,
						"comment": "        $(RED Deprecated. Please use $(LREF fracSecs) instead of fracSec. It\n              uses a $(CXREF time, Duration) to represent the fractional seconds\n              instead of a $(CXREF time, FracSec). This overload will be removed\n              in August 2016.)\n\n        Fractional seconds past the second.\n",
						"deco": "xFNbNdNfZS4core4time7FracSec",
						"endline": 2186,
						"char": 23,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "fracSec",
						"line": 2251,
						"comment": "        $(RED Deprecated. Please use $(LREF fracSecs) instead of fracSec. It\n              uses a $(CXREF time, Duration) to represent the fractional seconds\n              instead of a $(CXREF time, FracSec). This overload will be removed\n              in August 2016.)\n\n        Fractional seconds past the second.\n\n        Params:\n            fracSec = The fractional seconds to set this $(LREF SysTime)'s\n                      fractional seconds to.\n\n        Throws:\n            $(LREF DateTimeException) if $(D fracSec) is negative.\n",
						"deco": "FNdNfS4core4time7FracSecZv",
						"parameters": [
							{
								"name": "fracSec",
								"deco": "S4core4time7FracSec"
							}
						],
						"endline": 2277,
						"char": 20,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "stdTime",
						"line": 2309,
						"comment": "        The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the\n        internal representation of $(LREF SysTime).\n",
						"deco": "xFNaNbNdNfZl",
						"endline": 2312,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stdTime",
						"line": 2336,
						"comment": "        The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the\n        internal representation of $(LREF SysTime).\n\n        Params:\n            stdTime = The number of hnsecs since January 1st, 1 A.D. UTC.\n",
						"deco": "FNaNbNdNflZv",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 2339,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "timezone",
						"line": 2369,
						"comment": "        The current time zone of this $(LREF SysTime). Its internal time is always\n        kept in UTC, so there are no conversion issues between time zones due to\n        DST. Functions which return all or part of the time - such as hours -\n        adjust the time to this $(LREF SysTime)'s time zone before returning.\n",
						"deco": "xFNaNbNdNfZyC3std8datetime8TimeZone",
						"endline": 2372,
						"char": 35,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "timezone",
						"line": 2384,
						"comment": "        The current time zone of this $(LREF SysTime). It's internal time is always\n        kept in UTC, so there are no conversion issues between time zones due to\n        DST. Functions which return all or part of the time - such as hours -\n        adjust the time to this $(LREF SysTime)'s time zone before returning.\n\n        Params:\n            timezone = The $(LREF2 .TimeZone, TimeZone) to set this $(LREF SysTime)'s time zone to.\n",
						"deco": "FNaNbNdNfyC3std8datetime8TimeZoneZv",
						"parameters": [
							{
								"name": "timezone",
								"deco": "yC3std8datetime8TimeZone"
							}
						],
						"endline": 2390,
						"originalType": "pure nothrow @property @safe void(immutable TimeZone timezone)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dstInEffect",
						"line": 2396,
						"comment": "        Returns whether DST is in effect for this $(LREF SysTime).\n",
						"deco": "xFNbNdNfZb",
						"endline": 2400,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "utcOffset",
						"line": 2407,
						"comment": "        Returns what the offset from UTC is for this $(LREF SysTime).\n        It includes the DST offset in effect at that time (if any).\n",
						"deco": "xFNbNdNfZS4core4time8Duration",
						"endline": 2410,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toLocalTime",
						"line": 2417,
						"comment": "        Returns a $(LREF SysTime) with the same std time as this one, but with\n        $(LREF LocalTime) as its time zone.\n",
						"deco": "xFNaNbNfZS3std8datetime7SysTime",
						"endline": 2420,
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toUTC",
						"line": 2449,
						"comment": "        Returns a $(LREF SysTime) with the same std time as this one, but with\n        $(D UTC) as its time zone.\n",
						"deco": "xFNaNbNfZS3std8datetime7SysTime",
						"endline": 2452,
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toOtherTZ",
						"line": 2469,
						"comment": "        Returns a $(LREF SysTime) with the same std time as this one, but with\n        given time zone as its time zone.\n",
						"deco": "xFNaNbNfyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone"
							}
						],
						"endline": 2475,
						"originalType": "const pure nothrow @safe SysTime(immutable TimeZone tz)",
						"char": 13,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "toUnixTime",
								"line": 2518,
								"type": "const pure nothrow @safe T()",
								"endline": 2522,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "toUnixTime",
						"line": 2518,
						"comment": "        Converts this $(LREF SysTime) to unix time (i.e. seconds from midnight,\n        January 1st, 1970 in UTC).\n\n        The C standard does not specify the representation of time_t, so it is\n        implementation defined. On POSIX systems, unix time is equivalent to\n        time_t, but that's not necessarily true on other systems (e.g. it is\n        not true for the Digital Mars C runtime). So, be careful when using unix\n        time with C functions on non-POSIX systems.\n\n        By default, the return type is time_t (which is normally an alias for\n        int on 32-bit systems and long on 64-bit systems), but if a different\n        size is required than either int or long can be passed as a template\n        argument to get the desired size.\n\n        If the return type is int, and the result can't fit in an int, then the\n        closest value that can be held in 32 bits will be used (so $(D int.max)\n        if it goes over and $(D int.min) if it goes under). However, no attempt\n        is made to deal with integer overflow if the return type is long.\n\n        Params:\n            T = The return type (int or long). It defaults to time_t, which is\n                normally 32 bits on a 32-bit system and 64 bits on a 64-bit\n                system.\n\n        Returns:\n            A signed integer representing the unix time which is equivalent to\n            this SysTime.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2525_733)\n---\nassert(SysTime(DateTime(1970, 1, 1), UTC()).toUnixTime() == 0);\n\nauto pst = new immutable SimpleTimeZone(hours(-8));\nassert(SysTime(DateTime(1970, 1, 1), pst).toUnixTime() == 28800);\n\nauto utc = SysTime(DateTime(2007, 12, 22, 8, 14, 45), UTC());\nassert(utc.toUnixTime() == 1_198_311_285);\n\nauto ca = SysTime(DateTime(2007, 12, 22, 8, 14, 45), pst);\nassert(ca.toUnixTime() == 1_198_340_085);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2525_733)\n",
						"parameters": [
							{
								"name": "T",
								"default": "time_t",
								"kind": "type"
							}
						],
						"constraint": "is(T == int) || is(T == long)",
						"char": 7,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "fromUnixTime",
						"line": 2567,
						"comment": "        Converts from unix time (i.e. seconds from midnight, January 1st, 1970\n        in UTC) to a $(LREF SysTime).\n\n        The C standard does not specify the representation of time_t, so it is\n        implementation defined. On POSIX systems, unix time is equivalent to\n        time_t, but that's not necessarily true on other systems (e.g. it is\n        not true for the Digital Mars C runtime). So, be careful when using unix\n        time with C functions on non-POSIX systems.\n\n        Params:\n            unixTime = Seconds from midnight, January 1st, 1970 in UTC.\n            tz = The time zone for the SysTime that's returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2573_735)\n---\nassert(SysTime.fromUnixTime(0) ==\n       SysTime(DateTime(1970, 1, 1), UTC()));\n\nauto pst = new immutable SimpleTimeZone(hours(-8));\nassert(SysTime.fromUnixTime(28800) ==\n       SysTime(DateTime(1970, 1, 1), pst));\n\nauto st1 = SysTime.fromUnixTime(1_198_311_285, UTC());\nassert(st1 == SysTime(DateTime(2007, 12, 22, 8, 14, 45), UTC()));\nassert(st1.timezone is UTC());\nassert(st1 == SysTime(DateTime(2007, 12, 22, 0, 14, 45), pst));\n\nauto st2 = SysTime.fromUnixTime(1_198_311_285, pst);\nassert(st2 == SysTime(DateTime(2007, 12, 22, 8, 14, 45), UTC()));\nassert(st2.timezone is pst);\nassert(st2 == SysTime(DateTime(2007, 12, 22, 0, 14, 45), pst));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2573_735)\n",
						"deco": "FNaNbNflyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "unixTime",
								"deco": "l"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "opCall()"
							}
						],
						"endline": 2570,
						"originalType": "pure nothrow @safe SysTime(long unixTime, immutable TimeZone tz = LocalTime())",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "toTimeVal",
						"line": 2620,
						"comment": "        Returns a $(D timeval) which represents this $(LREF SysTime).\n\n        Note that like all conversions in std.datetime, this is a truncating\n        conversion.\n\n        If $(D timeval.tv_sec) is int, and the result can't fit in an int, then\n        the closest value that can be held in 32 bits will be used for\n        $(D tv_sec). (so $(D int.max) if it goes over and $(D int.min) if it\n        goes under).\n",
						"deco": "xFNaNbNfZS4core3sys5posix3sys4time7timeval",
						"endline": 2626,
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toTM",
						"line": 2654,
						"comment": "        Returns a $(D tm) which represents this $(LREF SysTime).\n",
						"deco": "xFNbNfZS4core4stdc4time2tm",
						"endline": 2678,
						"char": 8,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "add",
								"line": 2758,
								"type": "nothrow ref @safe SysTime(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 2786,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "add",
						"line": 2758,
						"comment": "        Adds the given number of years or months to this $(LREF SysTime). A\n        negative number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF SysTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\" || units == \"months\"",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 3921,
								"type": "nothrow ref @safe SysTime(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 3925,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 3921,
						"comment": "        Adds the given number of years or months to this $(LREF SysTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(LREF SysTime) 12 months\n        gets the exact same $(LREF SysTime). However, the days can still be affected\n        due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF SysTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3928_744)\n---\nauto st1 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst1.roll!\"months\"(1);\nassert(st1 == SysTime(DateTime(2010, 2, 1, 12, 33, 33)));\n\nauto st2 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst2.roll!\"months\"(-1);\nassert(st2 == SysTime(DateTime(2010, 12, 1, 12, 33, 33)));\n\nauto st3 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst3.roll!\"months\"(1);\nassert(st3 == SysTime(DateTime(1999, 3, 1, 12, 33, 33)));\n\nauto st4 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(st4 == SysTime(DateTime(1999, 2, 28, 12, 33, 33)));\n\nauto st5 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst5.roll!\"years\"(1);\nassert(st5 == SysTime(DateTime(2001, 3, 1, 12, 30, 33)));\n\nauto st6 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(st6 == SysTime(DateTime(2001, 2, 28, 12, 30, 33)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3928_744)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\"",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 4766,
								"type": "nothrow ref @safe SysTime(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 4791,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 4766,
						"comment": "        Adds the given number of units to this $(LREF SysTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(LREF SysTime) one\n        year's worth of days gets the exact same $(LREF SysTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), $(D \"seconds\"), $(D \"msecs\"), $(D \"usecs\"), and\n        $(D \"hnsecs\").\n\n        Note that when rolling msecs, usecs or hnsecs, they all add up to a\n        second. So, for example, rolling 1000 msecs is exactly the same as\n        rolling 100,000 usecs.\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(LREF SysTime).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4794_748)\n---\nauto st1 = SysTime(DateTime(2010, 1, 1, 11, 23, 12));\nst1.roll!\"days\"(1);\nassert(st1 == SysTime(DateTime(2010, 1, 2, 11, 23, 12)));\nst1.roll!\"days\"(365);\nassert(st1 == SysTime(DateTime(2010, 1, 26, 11, 23, 12)));\nst1.roll!\"days\"(-32);\nassert(st1 == SysTime(DateTime(2010, 1, 25, 11, 23, 12)));\n\nauto st2 = SysTime(DateTime(2010, 7, 4, 12, 0, 0));\nst2.roll!\"hours\"(1);\nassert(st2 == SysTime(DateTime(2010, 7, 4, 13, 0, 0)));\n\nauto st3 = SysTime(DateTime(2010, 2, 12, 12, 0, 0));\nst3.roll!\"hours\"(-1);\nassert(st3 == SysTime(DateTime(2010, 2, 12, 11, 0, 0)));\n\nauto st4 = SysTime(DateTime(2009, 12, 31, 0, 0, 0));\nst4.roll!\"minutes\"(1);\nassert(st4 == SysTime(DateTime(2009, 12, 31, 0, 1, 0)));\n\nauto st5 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));\nst5.roll!\"minutes\"(-1);\nassert(st5 == SysTime(DateTime(2010, 1, 1, 0, 59, 0)));\n\nauto st6 = SysTime(DateTime(2009, 12, 31, 0, 0, 0));\nst6.roll!\"seconds\"(1);\nassert(st6 == SysTime(DateTime(2009, 12, 31, 0, 0, 1)));\n\nauto st7 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));\nst7.roll!\"seconds\"(-1);\nassert(st7 == SysTime(DateTime(2010, 1, 1, 0, 0, 59)));\n\nauto dt = DateTime(2010, 1, 1, 0, 0, 0);\nauto st8 = SysTime(dt);\nst8.roll!\"msecs\"(1);\nassert(st8 == SysTime(dt, msecs(1)));\n\nauto st9 = SysTime(dt);\nst9.roll!\"msecs\"(-1);\nassert(st9 == SysTime(dt, msecs(999)));\n\nauto st10 = SysTime(dt);\nst10.roll!\"hnsecs\"(1);\nassert(st10 == SysTime(dt, hnsecs(1)));\n\nauto st11 = SysTime(dt);\nst11.roll!\"hnsecs\"(-1);\nassert(st11 == SysTime(dt, hnsecs(9_999_999)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4794_748)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"days\"",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 6208,
								"type": "const pure nothrow @safe SysTime(Duration duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "Duration"
									}
								],
								"endline": 6215,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 6208,
						"comment": "        Gives the result of adding or subtracting a $(CXREF time, Duration) from\n        this $(LREF SysTime).\n\n        The legal types of arithmetic for $(LREF SysTime) using this operator\n        are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD Duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD Duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The $(CXREF time, Duration) to add to or subtract from\n                       this $(LREF SysTime).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6218_756)\n---\nassert(SysTime(DateTime(2015, 12, 31, 23, 59, 59)) + seconds(1) ==\n       SysTime(DateTime(2016, 1, 1, 0, 0, 0)));\n\nassert(SysTime(DateTime(2015, 12, 31, 23, 59, 59)) + hours(1) ==\n       SysTime(DateTime(2016, 1, 1, 0, 59, 59)));\n\nassert(SysTime(DateTime(2016, 1, 1, 0, 0, 0)) - seconds(1) ==\n       SysTime(DateTime(2015, 12, 31, 23, 59, 59)));\n\nassert(SysTime(DateTime(2016, 1, 1, 0, 59, 59)) - hours(1) ==\n       SysTime(DateTime(2015, 12, 31, 23, 59, 59)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6218_756)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 13,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 6413,
								"type": "const pure nothrow @safe SysTime(TickDuration td)",
								"parameters": [
									{
										"name": "td",
										"type": "TickDuration"
									}
								],
								"endline": 6420,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 6413,
						"comment": "        $(RED Deprecated. $(CXREF time, TickDuration) is going to be deprecated\n              in favor of $(CXREF time, MonoTime) and $(CXREF time, Duration).\n              Use $(D Duration) instead. This overload will be removed in\n              January 2017.)\n\n        Defines + and - with $(CXREF time, TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 13,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 6455,
								"type": "pure nothrow ref @safe SysTime(Duration duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "Duration"
									}
								],
								"endline": 6461,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 6455,
						"comment": "        Gives the result of adding or subtracting a $(CXREF time, Duration) from\n        this $(LREF SysTime), as well as assigning the result to this\n        $(LREF SysTime).\n\n        The legal types of arithmetic for $(LREF SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD Duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD Duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The $(CXREF time, Duration) to add to or subtract from\n                       this $(LREF SysTime).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 6653,
								"type": "pure nothrow ref @safe SysTime(TickDuration td)",
								"parameters": [
									{
										"name": "td",
										"type": "TickDuration"
									}
								],
								"endline": 6659,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 6653,
						"comment": "        $(RED Deprecated. $(CXREF time, TickDuration) is going to be deprecated\n              in favor of $(CXREF time, MonoTime) and $(CXREF time, Duration).\n              Use $(D Duration) instead. This overload will be removed in\n              January 2017.)\n\n        Defines += and -= with $(CXREF time, TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 6701,
								"type": "const pure nothrow @safe Duration(in SysTime rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "SysTime",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 6705,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 6701,
						"comment": "        Gives the difference between two $(LREF SysTime)s.\n\n        The legal types of arithmetic for $(LREF SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD -) $(TD SysTime) $(TD -->) $(TD duration))\n        )\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "diffMonths",
						"line": 6809,
						"comment": "        Returns the difference between the two $(LREF SysTime)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(LREF SysTime)s. To get the difference in days or weeks,\n        subtract the $(LREF SysTime)s themselves and use the $(CXREF time, Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(CXREF time, Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either date is is irrelevant. It is the difference in the month property\n        combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(LREF SysTime) to subtract from this one.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6815_762)\n---\nassert(SysTime(Date(1999, 2, 1)).diffMonths(\n            SysTime(Date(1999, 1, 31))) == 1);\n\nassert(SysTime(Date(1999, 1, 31)).diffMonths(\n            SysTime(Date(1999, 2, 1))) == -1);\n\nassert(SysTime(Date(1999, 3, 1)).diffMonths(\n            SysTime(Date(1999, 1, 1))) == 2);\n\nassert(SysTime(Date(1999, 1, 1)).diffMonths(\n            SysTime(Date(1999, 3, 31))) == -2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6815_762)\n",
						"deco": "xFNbNfxS3std8datetime7SysTimeZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime7SysTime"
							}
						],
						"endline": 6812,
						"originalType": "const nothrow @safe int(in SysTime rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isLeapYear",
						"line": 6852,
						"comment": "        Whether this $(LREF SysTime) is in a leap year.\n",
						"deco": "xFNbNdNfZb",
						"endline": 6855,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfWeek",
						"line": 6871,
						"comment": "        Day of the week this $(LREF SysTime) is on.\n",
						"deco": "xFNbNdNfZE3std8datetime9DayOfWeek",
						"endline": 6874,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 6890,
						"comment": "        Day of the year this $(LREF SysTime) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6896_766)\n---\nassert(SysTime(DateTime(1999, 1, 1, 12, 22, 7)).dayOfYear == 1);\nassert(SysTime(DateTime(1999, 12, 31, 7, 2, 59)).dayOfYear == 365);\nassert(SysTime(DateTime(2000, 12, 31, 21, 20, 0)).dayOfYear == 366);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6896_766)\n",
						"deco": "xFNbNdNfZt",
						"endline": 6893,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 6921,
						"comment": "        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(LREF SysTime) is on.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 6933,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 6950,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF SysTime) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6967_769)\n---\nassert(SysTime(DateTime(1, 1, 1, 0, 0, 0)).dayOfGregorianCal == 1);\nassert(SysTime(DateTime(1, 12, 31, 23, 59, 59)).dayOfGregorianCal == 365);\nassert(SysTime(DateTime(2, 1, 1, 2, 2, 2)).dayOfGregorianCal == 366);\n\nassert(SysTime(DateTime(0, 12, 31, 7, 7, 7)).dayOfGregorianCal == 0);\nassert(SysTime(DateTime(0, 1, 1, 19, 30, 0)).dayOfGregorianCal == -365);\nassert(SysTime(DateTime(-1, 12, 31, 4, 7, 0)).dayOfGregorianCal == -366);\n\nassert(SysTime(DateTime(2000, 1, 1, 9, 30, 20)).dayOfGregorianCal == 730_120);\nassert(SysTime(DateTime(2010, 12, 31, 15, 45, 50)).dayOfGregorianCal == 734_137);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6967_769)\n",
						"deco": "xFNbNdNfZi",
						"endline": 6964,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 7321,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF SysTime) is on.\n        Setting this property does not affect the time portion of $(LREF SysTime).\n\n        Params:\n            days = The day of the Gregorian Calendar to set this $(LREF SysTime)\n                   to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7341_772)\n---\nauto st = SysTime(DateTime(0, 1, 1, 12, 0, 0));\nst.dayOfGregorianCal = 1;\nassert(st == SysTime(DateTime(1, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 365;\nassert(st == SysTime(DateTime(1, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = 366;\nassert(st == SysTime(DateTime(2, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 0;\nassert(st == SysTime(DateTime(0, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = -365;\nassert(st == SysTime(DateTime(-0, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = -366;\nassert(st == SysTime(DateTime(-1, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = 730_120;\nassert(st == SysTime(DateTime(2000, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 734_137;\nassert(st == SysTime(DateTime(2010, 12, 31, 12, 0, 0)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7341_772)\n",
						"deco": "FNbNdNfiZv",
						"parameters": [
							{
								"name": "days",
								"deco": "i"
							}
						],
						"endline": 7338,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isoWeek",
						"line": 7579,
						"comment": "        The ISO 8601 week of the year that this $(LREF SysTime) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/ISO_week_date, ISO Week Date).\n",
						"deco": "xFNbNdNfZh",
						"endline": 7582,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "endOfMonth",
						"line": 7599,
						"comment": "        $(LREF SysTime) for the last day in the month that this Date is in.\n        The time portion of endOfMonth is always 23:59:59.9999999.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7625_775)\n---\nassert(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).endOfMonth ==\n       SysTime(DateTime(1999, 1, 31, 23, 59, 59),\n               hnsecs(9_999_999)));\n\nassert(SysTime(DateTime(1999, 2, 7, 19, 30, 0),\n               msecs(24)).endOfMonth ==\n       SysTime(DateTime(1999, 2, 28, 23, 59, 59),\n               hnsecs(9_999_999)));\n\nassert(SysTime(DateTime(2000, 2, 7, 5, 12, 27),\n               usecs(5203)).endOfMonth ==\n       SysTime(DateTime(2000, 2, 29, 23, 59, 59),\n               hnsecs(9_999_999)));\n\nassert(SysTime(DateTime(2000, 6, 4, 12, 22, 9),\n               hnsecs(12345)).endOfMonth ==\n       SysTime(DateTime(2000, 6, 30, 23, 59, 59),\n               hnsecs(9_999_999)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7625_775)\n",
						"deco": "xFNbNdNfZS3std8datetime7SysTime",
						"endline": 7622,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "daysInMonth",
						"line": 7692,
						"comment": "        The last day in the month that this $(LREF SysTime) is in.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7698_777)\n---\nassert(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).daysInMonth == 31);\nassert(SysTime(DateTime(1999, 2, 7, 19, 30, 0)).daysInMonth == 28);\nassert(SysTime(DateTime(2000, 2, 7, 5, 12, 27)).daysInMonth == 29);\nassert(SysTime(DateTime(2000, 6, 4, 12, 22, 9)).daysInMonth == 30);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7698_777)\n",
						"deco": "xFNbNdNfZh",
						"endline": 7695,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isAD",
						"line": 7748,
						"comment": "        Whether the current year is a date in A.D.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7754_779)\n---\nassert(SysTime(DateTime(1, 1, 1, 12, 7, 0)).isAD);\nassert(SysTime(DateTime(2010, 12, 31, 0, 0, 0)).isAD);\nassert(!SysTime(DateTime(0, 12, 31, 23, 59, 59)).isAD);\nassert(!SysTime(DateTime(-2010, 1, 1, 2, 2, 2)).isAD);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7754_779)\n",
						"deco": "xFNbNdNfZb",
						"endline": 7751,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "julianDay",
						"line": 7785,
						"comment": "        The $(WEB en.wikipedia.org/wiki/Julian_day, Julian day)\n        for this $(LREF SysTime) at the given time. For example,\n        prior to noon, 1996-03-31 would be the Julian day number 2_450_173, so\n        this function returns 2_450_173, while from noon onward, the Julian\n        day number would be 2_450_174, so this function returns 2_450_174.\n",
						"deco": "xFNbNdNfZl",
						"endline": 7790,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "modJulianDay",
						"line": 7829,
						"comment": "        The modified $(WEB en.wikipedia.org/wiki/Julian_day, Julian day) for any time on this date (since, the modified\n        Julian day changes at midnight).\n",
						"deco": "xFNbNdNfZl",
						"endline": 7832,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 7852,
								"type": "const nothrow @safe Date()",
								"endline": 7856,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 7852,
						"comment": "        Returns a $(LREF Date) equivalent to this $(LREF SysTime).\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!T == Date)",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 7886,
								"type": "const nothrow @safe DateTime()",
								"endline": 7908,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 7886,
						"comment": "        Returns a $(LREF DateTime) equivalent to this $(LREF SysTime).\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!T == DateTime)",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 7945,
								"type": "const nothrow @safe TimeOfDay()",
								"endline": 7964,
								"char": 15,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 7945,
						"comment": "        Returns a $(LREF TimeOfDay) equivalent to this $(LREF SysTime).\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!T == TimeOfDay)",
						"char": 15,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "toISOString",
						"line": 8021,
						"comment": "        Converts this $(LREF SysTime) to a string with the format\n        YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds and TZ is time\n        zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(LREF SysTime)'s time zone is $(LREF LocalTime), then TZ is empty.\n        If its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the\n        offset from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC\n        is $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8062_786)\n---\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toISOString() ==\n       \"20100704T070612\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               msecs(24)).toISOString() ==\n       \"19981225T021500.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toISOString() ==\n       \"00000105T230959\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               hnsecs(520_920)).toISOString() ==\n       \"-00040105T000002.052092\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8062_786)\n",
						"deco": "xFNbNfZAya",
						"endline": 8059,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOExtString",
						"line": 8151,
						"comment": "        Converts this $(LREF SysTime) to a string with the format\n        YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ\n        is the time zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(LREF SysTime)'s time zone is $(LREF LocalTime), then TZ is empty. If\n        its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the offset\n        from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC is\n        $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8192_788)\n---\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toISOExtString() ==\n       \"2010-07-04T07:06:12\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               msecs(24)).toISOExtString() ==\n       \"1998-12-25T02:15:00.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toISOExtString() ==\n       \"0000-01-05T23:09:59\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               hnsecs(520_920)).toISOExtString() ==\n       \"-0004-01-05T00:00:02.052092\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8192_788)\n",
						"deco": "xFNbNfZAya",
						"endline": 8189,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toSimpleString",
						"line": 8285,
						"comment": "        Converts this $(LREF SysTime) to a string with the format\n        YYYY-Mon-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ\n        is the time zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(LREF SysTime)'s time zone is $(LREF LocalTime), then TZ is empty. If\n        its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the offset\n        from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC is\n        $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8326_790)\n---\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toSimpleString() ==\n       \"2010-Jul-04 07:06:12\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               msecs(24)).toSimpleString() ==\n       \"1998-Dec-25 02:15:00.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toSimpleString() ==\n       \"0000-Jan-05 23:09:59\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               hnsecs(520_920)).toSimpleString() ==\n        \"-0004-Jan-05 00:00:02.052092\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8326_790)\n",
						"deco": "xFNbNfZAya",
						"endline": 8323,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 8406,
						"comment": "        Converts this $(LREF SysTime) to a string.\n",
						"deco": "xFNbNfZAya",
						"endline": 8409,
						"char": 12,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOString",
								"line": 8452,
								"type": "@safe SysTime(in S isoString, immutable TimeZone tz = null)",
								"parameters": [
									{
										"name": "isoString",
										"type": "S",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "tz",
										"type": "TimeZone",
										"storageClass": [
											"immutable"
										],
										"default": "null"
									}
								],
								"endline": 8509,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "fromISOString",
						"line": 8452,
						"comment": "        Creates a $(LREF SysTime) from a string with the format\n        YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds is the time\n        zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toISOString) except that\n        trailing zeroes are permitted - including having fractional seconds with\n        all zeroes. However, a decimal point with nothing following it is\n        invalid.\n\n        If there is no time zone in the string, then $(LREF LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(LREF SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(LREF SysTime) to be a particular time\n        zone, pass in that time zone and the $(LREF SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates and times.\n            tz        = The time zone to convert the given time to (no\n                        conversion occurs if null).\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF SysTime) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8512_793)\n---\nassert(SysTime.fromISOString(\"20100704T070612\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromISOString(\"19981225T021500.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), msecs(7)));\nassert(SysTime.fromISOString(\"00000105T230959.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), usecs(20)));\nassert(SysTime.fromISOString(\"-00040105T000002\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromISOString(\" 20100704T070612 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromISOString(\"20100704T070612Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromISOString(\"20100704T070612-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(-8))));\nassert(SysTime.fromISOString(\"20100704T070612+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(8))));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8512_793)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOExtString",
								"line": 8673,
								"type": "@safe SysTime(in S isoExtString, immutable TimeZone tz = null)",
								"parameters": [
									{
										"name": "isoExtString",
										"type": "S",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "tz",
										"type": "TimeZone",
										"storageClass": [
											"immutable"
										],
										"default": "null"
									}
								],
								"endline": 8732,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "fromISOExtString",
						"line": 8673,
						"comment": "        Creates a $(LREF SysTime) from a string with the format\n        YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the\n        time zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toISOExtString)\n        except that trailing zeroes are permitted - including having fractional\n        seconds with all zeroes. However, a decimal point with nothing following\n        it is invalid.\n\n        If there is no time zone in the string, then $(LREF LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(LREF SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(LREF SysTime) to be a particular time\n        zone, pass in that time zone and the $(LREF SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n        Params:\n            isoExtString = A string formatted in the ISO Extended format for dates\n                           and times.\n            tz           = The time zone to convert the given time to (no\n                           conversion occurs if null).\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF SysTime) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8735_795)\n---\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromISOExtString(\"1998-12-25T02:15:00.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), msecs(7)));\nassert(SysTime.fromISOExtString(\"0000-01-05T23:09:59.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), usecs(20)));\nassert(SysTime.fromISOExtString(\"-0004-01-05T00:00:02\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromISOExtString(\" 2010-07-04T07:06:12 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(-8))));\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(8))));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8735_795)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromSimpleString",
								"line": 8899,
								"type": "@safe SysTime(in S simpleString, immutable TimeZone tz = null)",
								"parameters": [
									{
										"name": "simpleString",
										"type": "S",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "tz",
										"type": "TimeZone",
										"storageClass": [
											"immutable"
										],
										"default": "null"
									}
								],
								"endline": 8958,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "fromSimpleString",
						"line": 8899,
						"comment": "        Creates a $(LREF SysTime) from a string with the format\n        YYYY-MM-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the\n        time zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toSimpleString) except\n        that trailing zeroes are permitted - including having fractional seconds\n        with all zeroes. However, a decimal point with nothing following it is\n        invalid.\n\n        If there is no time zone in the string, then $(LREF LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(LREF SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(LREF SysTime) to be a particular time\n        zone, pass in that time zone and the $(LREF SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n\n        Params:\n            simpleString = A string formatted in the way that\n                           $(D toSimpleString) formats dates and times.\n            tz           = The time zone to convert the given time to (no\n                           conversion occurs if null).\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF SysTime) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8961_797)\n---\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromSimpleString(\"1998-Dec-25 02:15:00.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), msecs(7)));\nassert(SysTime.fromSimpleString(\"0000-Jan-05 23:09:59.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), usecs(20)));\nassert(SysTime.fromSimpleString(\"-0004-Jan-05 00:00:02\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromSimpleString(\" 2010-Jul-04 07:06:12 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(-8))));\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(8))));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8961_797)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 20,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "min",
						"line": 9099,
						"comment": "        Returns the $(LREF SysTime) farthest in the past which is representable\n        by $(LREF SysTime).\n\n        The $(LREF SysTime) which is returned is in UTC.\n",
						"deco": "FNaNbNdNfZS3std8datetime7SysTime",
						"endline": 9102,
						"char": 30,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "max",
						"line": 9117,
						"comment": "        Returns the $(LREF SysTime) farthest in the future which is representable\n        by $(LREF SysTime).\n\n        The $(LREF SysTime) which is returned is in UTC.\n",
						"deco": "FNaNbNdNfZS3std8datetime7SysTime",
						"endline": 9120,
						"char": 30,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "Date",
				"line": 9181,
				"comment": "    Represents a date in the\n    $(WEB en.wikipedia.org/wiki/Proleptic_Gregorian_calendar, Proleptic Gregorian Calendar)\n    ranging from\n    32,768 B.C. to 32,767 A.D. Positive years are A.D. Non-positive years are\n    B.C.\n\n    Year, month, and day are kept separately internally so that $(D Date) is\n    optimized for calendar-based operations.\n\n    $(D Date) uses the Proleptic Gregorian Calendar, so it assumes the Gregorian\n    leap year calculations for its entire length. As per\n    $(WEB en.wikipedia.org/wiki/ISO_8601, ISO 8601), it treats 1 B.C. as\n    year 0, i.e. 1 B.C. is 0, 2 B.C. is -1, etc. Use $(LREF yearBC) to use B.C. as\n    a positive integer with 1 B.C. being the year prior to 1 A.D.\n\n    Year 0 is a leap year.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 9196,
						"comment": "        Throws:\n            $(LREF DateTimeException) if the resulting $(LREF Date) would not be valid.\n\n        Params:\n            year  = Year of the Gregorian Calendar. Positive values are A.D.\n                    Non-positive values are B.C. with year 0 being the year\n                    prior to 1 A.D.\n            month = Month of the year.\n            day   = Day of the month.\n",
						"deco": "FNaNcNfiiiZS3std8datetime4Date",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							},
							{
								"name": "month",
								"deco": "i"
							},
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 9204,
						"originalType": "pure ref @safe (int year, int month, int day)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 9271,
						"comment": "        Params:\n            day = The Xth day of the Gregorian Calendar that the constructed\n                  $(LREF Date) will be for.\n",
						"deco": "FNaNbNcNfiZS3std8datetime4Date",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 9392,
						"originalType": "pure nothrow ref @safe (int day)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 9414,
						"comment": "        Compares this $(LREF Date) with the given $(LREF Date).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
						"deco": "xFNaNbNfxS3std8datetime4DateZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime4Date"
							}
						],
						"endline": 9432,
						"originalType": "const pure nothrow @safe int(in Date rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 9522,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9528_804)\n---\nassert(Date(1999, 7, 6).year == 1999);\nassert(Date(2010, 10, 4).year == 2010);\nassert(Date(-7, 4, 5).year == -7);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9528_804)\n",
						"deco": "xFNaNbNdNfZs",
						"endline": 9525,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 9558,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this Date's year to.\n\n        Throws:\n            $(LREF DateTimeException) if the new year is not a leap year and the\n            resulting date would be on February 29th.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9565_806)\n---\nassert(Date(1999, 7, 6).year == 1999);\nassert(Date(2010, 10, 4).year == 2010);\nassert(Date(-7, 4, 5).year == -7);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9565_806)\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 9562,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 9604,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(LREF DateTimeException) if $(D isAD) is true.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9614_808)\n---\nassert(Date(0, 1, 1).yearBC == 1);\nassert(Date(-1, 1, 1).yearBC == 2);\nassert(Date(-100, 1, 1).yearBC == 101);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9614_808)\n",
						"deco": "xFNaNdNfZt",
						"endline": 9611,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 9643,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(LREF Date)'s year to.\n\n        Throws:\n            $(LREF DateTimeException) if a non-positive value is given.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9652_810)\n---\nauto date = Date(2010, 1, 1);\ndate.yearBC = 1;\nassert(date == Date(0, 1, 1));\n\ndate.yearBC = 10;\nassert(date == Date(-9, 1, 1));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9652_810)\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 9649,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 9679,
						"comment": "        Month of a Gregorian Year.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9685_812)\n---\nassert(Date(1999, 7, 6).month == 7);\nassert(Date(2010, 10, 4).month == 10);\nassert(Date(-7, 4, 5).month == 4);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9685_812)\n",
						"deco": "xFNaNbNdNfZE3std8datetime5Month",
						"endline": 9682,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 9714,
						"comment": "        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(LREF Date)'s month to.\n\n        Throws:\n            $(LREF DateTimeException) if the given month is not a valid month or if\n            the current day would not be valid in the given month.\n",
						"deco": "FNaNdNfE3std8datetime5MonthZv",
						"parameters": [
							{
								"name": "month",
								"deco": "E3std8datetime5Month"
							}
						],
						"endline": 9719,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 9748,
						"comment": "        Day of a Gregorian Month.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9754_815)\n---\nassert(Date(1999, 7, 6).day == 6);\nassert(Date(2010, 10, 4).day == 4);\nassert(Date(-7, 4, 5).day == 5);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9754_815)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 9751,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 9794,
						"comment": "        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(LREF Date)'s day to.\n\n        Throws:\n            $(LREF DateTimeException) if the given day is not a valid day of the\n            current month.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 9798,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "add",
								"line": 9905,
								"type": "pure nothrow ref @safe Date(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 9924,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "add",
						"line": 9905,
						"comment": "        Adds the given number of years or months to this $(LREF Date). A negative\n        number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF Date).\n            allowOverflow = Whether the day should be allowed to overflow,\n                            causing the month to increment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9927_818)\n---\nauto d1 = Date(2010, 1, 1);\nd1.add!\"months\"(11);\nassert(d1 == Date(2010, 12, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.add!\"months\"(-11);\nassert(d2 == Date(2009, 2, 1));\n\nauto d3 = Date(2000, 2, 29);\nd3.add!\"years\"(1);\nassert(d3 == Date(2001, 3, 1));\n\nauto d4 = Date(2000, 2, 29);\nd4.add!\"years\"(1, AllowDayOverflow.no);\nassert(d4 == Date(2001, 2, 28));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9927_818)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 10687,
								"type": "pure nothrow ref @safe Date(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 10691,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 10687,
						"comment": "        Adds the given number of years or months to this $(LREF Date). A negative\n        number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(LREF Date) 12 months gets\n        the exact same $(LREF Date). However, the days can still be affected due to\n        the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF Date).\n            allowOverflow = Whether the day should be allowed to overflow,\n                            causing the month to increment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL10694_823)\n---\nauto d1 = Date(2010, 1, 1);\nd1.roll!\"months\"(1);\nassert(d1 == Date(2010, 2, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.roll!\"months\"(-1);\nassert(d2 == Date(2010, 12, 1));\n\nauto d3 = Date(1999, 1, 29);\nd3.roll!\"months\"(1);\nassert(d3 == Date(1999, 3, 1));\n\nauto d4 = Date(1999, 1, 29);\nd4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(d4 == Date(1999, 2, 28));\n\nauto d5 = Date(2000, 2, 29);\nd5.roll!\"years\"(1);\nassert(d5 == Date(2001, 3, 1));\n\nauto d6 = Date(2000, 2, 29);\nd6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(d6 == Date(2001, 2, 28));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL10694_823)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 11325,
								"type": "pure nothrow ref @safe Date(long days)",
								"parameters": [
									{
										"name": "days",
										"deco": "l"
									}
								],
								"endline": 11342,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 11325,
						"comment": "        Adds the given number of units to this $(LREF Date). A negative number will\n        subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(LREF Date) one\n        year's worth of days gets the exact same $(LREF Date).\n\n        The only accepted units are $(D \"days\").\n\n        Params:\n            units = The units to add. Must be $(D \"days\").\n            days  = The number of days to add to this $(LREF Date).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL11345_827)\n---\nauto d = Date(2010, 1, 1);\nd.roll!\"days\"(1);\nassert(d == Date(2010, 1, 2));\nd.roll!\"days\"(365);\nassert(d == Date(2010, 1, 26));\nd.roll!\"days\"(-32);\nassert(d == Date(2010, 1, 25));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL11345_827)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"days\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 11563,
								"type": "const pure nothrow @safe Date(Duration duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "Duration"
									}
								],
								"endline": 11569,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 11563,
						"comment": "        Gives the result of adding or subtracting a $(CXREF tiem, Duration) from\n        this $(LREF Date).\n\n        The legal types of arithmetic for $(LREF Date) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD Duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD Duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The $(CXREF time, Duration) to add to or subtract from\n                       this $(LREF Date).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL11572_829)\n---\nassert(Date(2015, 12, 31) + days(1) == Date(2016, 1, 1));\nassert(Date(2004, 2, 26) + days(4) == Date(2004, 3, 1));\n\nassert(Date(2016, 1, 1) - days(1) == Date(2015, 12, 31));\nassert(Date(2004, 3, 1) - days(4) == Date(2004, 2, 26));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL11572_829)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 11643,
								"type": "const pure nothrow @safe Date(TickDuration td)",
								"parameters": [
									{
										"name": "td",
										"type": "TickDuration"
									}
								],
								"endline": 11649,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 11643,
						"comment": "        $(RED Deprecated. $(CXREF time, TickDuration) is going to be deprecated\n              in favor of $(CXREF time, MonoTime) and $(CXREF time, Duration).\n              Use $(D Duration) instead. This overload will be removed in\n              January 2017.)\n\n        Defines + and - with $(CXREF time, TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 11683,
								"type": "pure nothrow ref @safe Date(Duration duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "Duration"
									}
								],
								"endline": 11688,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 11683,
						"comment": "        Gives the result of adding or subtracting a $(CXREF time, Duration) from\n        this $(LREF Date), as well as assigning the result to this $(LREF Date).\n\n        The legal types of arithmetic for $(LREF Date) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD Duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD Duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The $(CXREF time, Duration) to add to or subtract from\n                       this $(LREF Date).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 11757,
								"type": "pure nothrow ref @safe Date(TickDuration td)",
								"parameters": [
									{
										"name": "td",
										"type": "TickDuration"
									}
								],
								"endline": 11762,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 11757,
						"comment": "        $(RED Deprecated. $(CXREF time, TickDuration) is going to be deprecated\n              in favor of $(CXREF time, MonoTime) and $(CXREF time, Duration).\n              Use $(D Duration) instead. This overload will be removed in\n              January 2017.)\n\n        Defines += and -= with $(CXREF time, TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 11806,
								"type": "const pure nothrow @safe Duration(in Date rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Date",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 11810,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 11806,
						"comment": "        Gives the difference between two $(LREF Date)s.\n\n        The legal types of arithmetic for $(LREF Date) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD -) $(TD Date) $(TD -->) $(TD duration))\n        )\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "diffMonths",
						"line": 11860,
						"comment": "        Returns the difference between the two $(LREF Date)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(LREF SysTime)s. To get the difference in days or weeks,\n        subtract the $(LREF SysTime)s themselves and use the $(CXREF time, Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(CXREF time, Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either $(LREF Date) is is irrelevant. It is the difference in the month\n        property combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(LREF Date) to subtract from this one.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL11869_835)\n---\nassert(Date(1999, 2, 1).diffMonths(Date(1999, 1, 31)) == 1);\nassert(Date(1999, 1, 31).diffMonths(Date(1999, 2, 1)) == -1);\nassert(Date(1999, 3, 1).diffMonths(Date(1999, 1, 1)) == 2);\nassert(Date(1999, 1, 1).diffMonths(Date(1999, 3, 31)) == -2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL11869_835)\n",
						"deco": "xFNaNbNfxS3std8datetime4DateZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime4Date"
							}
						],
						"endline": 11866,
						"originalType": "const pure nothrow @safe int(in Date rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isLeapYear",
						"line": 12098,
						"comment": "        Whether this $(LREF Date) is in a leap year.\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 12101,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfWeek",
						"line": 12117,
						"comment": "        Day of the week this $(LREF Date) is on.\n",
						"deco": "xFNaNbNdNfZE3std8datetime9DayOfWeek",
						"endline": 12120,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 12136,
						"comment": "        Day of the year this $(LREF Date) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12149_839)\n---\nassert(Date(1999, 1, 1).dayOfYear == 1);\nassert(Date(1999, 12, 31).dayOfYear == 365);\nassert(Date(2000, 12, 31).dayOfYear == 366);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12149_839)\n",
						"deco": "xFNaNbNdNfZt",
						"endline": 12146,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 12197,
						"comment": "        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(LREF Date) is on.\n\n        Throws:\n            $(LREF DateTimeException) if the given day is an invalid day of the\n            year.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 12214,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 12247,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF Date) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12301_844)\n---\nassert(Date(1, 1, 1).dayOfGregorianCal == 1);\nassert(Date(1, 12, 31).dayOfGregorianCal == 365);\nassert(Date(2, 1, 1).dayOfGregorianCal == 366);\n\nassert(Date(0, 12, 31).dayOfGregorianCal == 0);\nassert(Date(0, 1, 1).dayOfGregorianCal == -365);\nassert(Date(-1, 12, 31).dayOfGregorianCal == -366);\n\nassert(Date(2000, 1, 1).dayOfGregorianCal == 730_120);\nassert(Date(2010, 12, 31).dayOfGregorianCal == 734_137);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12301_844)\n",
						"deco": "xFNaNbNdNfZi",
						"endline": 12298,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 12336,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF Date) is on.\n\n        Params:\n            day = The day of the Gregorian Calendar to set this $(LREF Date) to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12342_846)\n---\nauto date = Date.init;\ndate.dayOfGregorianCal = 1;\nassert(date == Date(1, 1, 1));\n\ndate.dayOfGregorianCal = 365;\nassert(date == Date(1, 12, 31));\n\ndate.dayOfGregorianCal = 366;\nassert(date == Date(2, 1, 1));\n\ndate.dayOfGregorianCal = 0;\nassert(date == Date(0, 12, 31));\n\ndate.dayOfGregorianCal = -365;\nassert(date == Date(-0, 1, 1));\n\ndate.dayOfGregorianCal = -366;\nassert(date == Date(-1, 12, 31));\n\ndate.dayOfGregorianCal = 730_120;\nassert(date == Date(2000, 1, 1));\n\ndate.dayOfGregorianCal = 734_137;\nassert(date == Date(2010, 12, 31));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12342_846)\n",
						"deco": "FNaNbNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 12339,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isoWeek",
						"line": 12388,
						"comment": "        The ISO 8601 week of the year that this $(LREF Date) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/ISO_week_date, ISO Week Date)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 12420,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "endOfMonth",
						"line": 12487,
						"comment": "        $(LREF Date) for the last day in the month that this $(LREF Date) is in.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12496_849)\n---\nassert(Date(1999, 1, 6).endOfMonth == Date(1999, 1, 31));\nassert(Date(1999, 2, 7).endOfMonth == Date(1999, 2, 28));\nassert(Date(2000, 2, 7).endOfMonth == Date(2000, 2, 29));\nassert(Date(2000, 6, 4).endOfMonth == Date(2000, 6, 30));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12496_849)\n",
						"deco": "xFNaNbNdNfZS3std8datetime4Date",
						"endline": 12493,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "daysInMonth",
						"line": 12546,
						"comment": "        The last day in the month that this $(LREF Date) is in.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12552_851)\n---\nassert(Date(1999, 1, 6).daysInMonth == 31);\nassert(Date(1999, 2, 7).daysInMonth == 28);\nassert(Date(2000, 2, 7).daysInMonth == 29);\nassert(Date(2000, 6, 4).daysInMonth == 30);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12552_851)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 12549,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isAD",
						"line": 12602,
						"comment": "        Whether the current year is a date in A.D.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12608_853)\n---\nassert(Date(1, 1, 1).isAD);\nassert(Date(2010, 12, 31).isAD);\nassert(!Date(0, 12, 31).isAD);\nassert(!Date(-2010, 1, 1).isAD);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12608_853)\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 12605,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "julianDay",
						"line": 12635,
						"comment": "        The $(WEB en.wikipedia.org/wiki/Julian_day, Julian day) for this $(LREF Date) at noon (since the Julian day changes\n        at noon).\n",
						"deco": "xFNaNbNdNfZl",
						"endline": 12638,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "modJulianDay",
						"line": 12662,
						"comment": "        The modified $(WEB en.wikipedia.org/wiki/Julian_day, Julian day) for any time on this date (since, the modified\n        Julian day changes at midnight).\n",
						"deco": "xFNaNbNdNfZl",
						"endline": 12665,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOString",
						"line": 12682,
						"comment": "        Converts this $(LREF Date) to a string with the format YYYYMMDD.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12704_857)\n---\nassert(Date(2010, 7, 4).toISOString() == \"20100704\");\nassert(Date(1998, 12, 25).toISOString() == \"19981225\");\nassert(Date(0, 1, 5).toISOString() == \"00000105\");\nassert(Date(-4, 1, 5).toISOString() == \"-00040105\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12704_857)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 12701,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOExtString",
						"line": 12738,
						"comment": "        Converts this $(LREF Date) to a string with the format YYYY-MM-DD.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12760_859)\n---\nassert(Date(2010, 7, 4).toISOExtString() == \"2010-07-04\");\nassert(Date(1998, 12, 25).toISOExtString() == \"1998-12-25\");\nassert(Date(0, 1, 5).toISOExtString() == \"0000-01-05\");\nassert(Date(-4, 1, 5).toISOExtString() == \"-0004-01-05\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12760_859)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 12757,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toSimpleString",
						"line": 12794,
						"comment": "        Converts this $(LREF Date) to a string with the format YYYY-Mon-DD.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12816_861)\n---\nassert(Date(2010, 7, 4).toSimpleString() == \"2010-Jul-04\");\nassert(Date(1998, 12, 25).toSimpleString() == \"1998-Dec-25\");\nassert(Date(0, 1, 5).toSimpleString() == \"0000-Jan-05\");\nassert(Date(-4, 1, 5).toSimpleString() == \"-0004-Jan-05\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12816_861)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 12813,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 12851,
						"comment": "        Converts this $(LREF Date) to a string.\n",
						"deco": "xFNaNbNfZAya",
						"endline": 12854,
						"char": 12,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOString",
								"line": 12878,
								"type": "pure @safe Date(in S isoString)",
								"parameters": [
									{
										"name": "isoString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 12909,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "fromISOString",
						"line": 12878,
						"comment": "        Creates a $(LREF Date) from a string with the format YYYYMMDD. Whitespace\n        is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF Date) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12912_864)\n---\nassert(Date.fromISOString(\"20100704\") == Date(2010, 7, 4));\nassert(Date.fromISOString(\"19981225\") == Date(1998, 12, 25));\nassert(Date.fromISOString(\"00000105\") == Date(0, 1, 5));\nassert(Date.fromISOString(\"-00040105\") == Date(-4, 1, 5));\nassert(Date.fromISOString(\" 20100704 \") == Date(2010, 7, 4));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12912_864)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOExtString",
								"line": 13000,
								"type": "pure @safe Date(in S isoExtString)",
								"parameters": [
									{
										"name": "isoExtString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 13036,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "fromISOExtString",
						"line": 13000,
						"comment": "        Creates a $(LREF Date) from a string with the format YYYY-MM-DD. Whitespace\n        is stripped from the given string.\n\n        Params:\n            isoExtString = A string formatted in the ISO Extended format for\n                           dates.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(LREF Date) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL13039_866)\n---\nassert(Date.fromISOExtString(\"2010-07-04\") == Date(2010, 7, 4));\nassert(Date.fromISOExtString(\"1998-12-25\") == Date(1998, 12, 25));\nassert(Date.fromISOExtString(\"0000-01-05\") == Date(0, 1, 5));\nassert(Date.fromISOExtString(\"-0004-01-05\") == Date(-4, 1, 5));\nassert(Date.fromISOExtString(\" 2010-07-04 \") == Date(2010, 7, 4));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL13039_866)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromSimpleString",
								"line": 13127,
								"type": "pure @safe Date(in S simpleString)",
								"parameters": [
									{
										"name": "simpleString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 13160,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "fromSimpleString",
						"line": 13127,
						"comment": "        Creates a $(LREF Date) from a string with the format YYYY-Mon-DD.\n        Whitespace is stripped from the given string.\n\n        Params:\n            simpleString = A string formatted in the way that toSimpleString\n                           formats dates.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the correct\n            format or if the resulting $(LREF Date) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL13163_868)\n---\nassert(Date.fromSimpleString(\"2010-Jul-04\") == Date(2010, 7, 4));\nassert(Date.fromSimpleString(\"1998-Dec-25\") == Date(1998, 12, 25));\nassert(Date.fromSimpleString(\"0000-Jan-05\") == Date(0, 1, 5));\nassert(Date.fromSimpleString(\"-0004-Jan-05\") == Date(-4, 1, 5));\nassert(Date.fromSimpleString(\" 2010-Jul-04 \") == Date(2010, 7, 4));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL13163_868)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 17,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "min",
						"line": 13243,
						"comment": "        Returns the $(LREF Date) farthest in the past which is representable by\n        $(LREF Date).\n",
						"deco": "FNaNbNdNfZS3std8datetime4Date",
						"endline": 13251,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "max",
						"line": 13264,
						"comment": "        Returns the $(LREF Date) farthest in the future which is representable by\n        $(LREF Date).\n",
						"deco": "FNaNbNdNfZS3std8datetime4Date",
						"endline": 13272,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "TimeOfDay",
				"line": 13501,
				"comment": "    Represents a time of day with hours, minutes, and seconds. It uses 24 hour\n    time.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 13515,
						"comment": "        Params:\n            hour   = Hour of the day [0 - 24$(RPAREN).\n            minute = Minute of the hour [0 - 60$(RPAREN).\n            second = Second of the minute [0 - 60$(RPAREN).\n\n        Throws:\n            $(LREF DateTimeException) if the resulting $(LREF TimeOfDay) would be not\n            be valid.\n",
						"deco": "FNaNcNfiiiZS3std8datetime9TimeOfDay",
						"parameters": [
							{
								"name": "hour",
								"deco": "i"
							},
							{
								"name": "minute",
								"deco": "i"
							},
							{
								"name": "second",
								"deco": "i",
								"default": "0"
							}
						],
						"endline": 13524,
						"originalType": "pure ref @safe (int hour, int minute, int second = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 13567,
						"comment": "        Compares this $(LREF TimeOfDay) with the given $(LREF TimeOfDay).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
						"deco": "xFNaNbNfxS3std8datetime9TimeOfDayZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime9TimeOfDay"
							}
						],
						"endline": 13585,
						"originalType": "const pure nothrow @safe int(in TimeOfDay rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 13627,
						"comment": "        Hours past midnight.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 13630,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 13654,
						"comment": "        Hours past midnight.\n\n        Params:\n            hour = The hour of the day to set this $(LREF TimeOfDay)'s hour to.\n\n        Throws:\n            $(LREF DateTimeException) if the given hour would result in an invalid\n            $(LREF TimeOfDay).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "hour",
								"deco": "i"
							}
						],
						"endline": 13658,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 13678,
						"comment": "        Minutes past the hour.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 13681,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 13705,
						"comment": "        Minutes past the hour.\n\n        Params:\n            minute = The minute to set this $(LREF TimeOfDay)'s minute to.\n\n        Throws:\n            $(LREF DateTimeException) if the given minute would result in an\n            invalid $(LREF TimeOfDay).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "minute",
								"deco": "i"
							}
						],
						"endline": 13709,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 13729,
						"comment": "        Seconds past the minute.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 13732,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 13756,
						"comment": "        Seconds past the minute.\n\n        Params:\n            second = The second to set this $(LREF TimeOfDay)'s second to.\n\n        Throws:\n            $(LREF DateTimeException) if the given second would result in an\n            invalid $(LREF TimeOfDay).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "second",
								"deco": "i"
							}
						],
						"endline": 13760,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 13793,
								"type": "pure nothrow ref @safe TimeOfDay(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 13797,
								"char": 19,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 13793,
						"comment": "        Adds the given number of units to this $(LREF TimeOfDay). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(LREF TimeOfDay)\n        one hours's worth of minutes gets the exact same\n        $(LREF TimeOfDay).\n\n        Accepted units are $(D \"hours\"), $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this\n                    $(LREF TimeOfDay).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL13800_882)\n---\nauto tod1 = TimeOfDay(7, 12, 0);\ntod1.roll!\"hours\"(1);\nassert(tod1 == TimeOfDay(8, 12, 0));\n\nauto tod2 = TimeOfDay(7, 12, 0);\ntod2.roll!\"hours\"(-1);\nassert(tod2 == TimeOfDay(6, 12, 0));\n\nauto tod3 = TimeOfDay(23, 59, 0);\ntod3.roll!\"minutes\"(1);\nassert(tod3 == TimeOfDay(23, 0, 0));\n\nauto tod4 = TimeOfDay(0, 0, 0);\ntod4.roll!\"minutes\"(-1);\nassert(tod4 == TimeOfDay(0, 59, 0));\n\nauto tod5 = TimeOfDay(23, 59, 59);\ntod5.roll!\"seconds\"(1);\nassert(tod5 == TimeOfDay(23, 59, 0));\n\nauto tod6 = TimeOfDay(0, 0, 0);\ntod6.roll!\"seconds\"(-1);\nassert(tod6 == TimeOfDay(0, 0, 59));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL13800_882)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"hours\"",
						"char": 19,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 14037,
								"type": "const pure nothrow @safe TimeOfDay(Duration duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "Duration"
									}
								],
								"endline": 14043,
								"char": 15,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 14037,
						"comment": "        Gives the result of adding or subtracting a $(CXREF time, Duration) from\n        this $(LREF TimeOfDay).\n\n        The legal types of arithmetic for $(LREF TimeOfDay) using this operator\n        are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD Duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD Duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The $(CXREF time, Duration) to add to or subtract from\n                       this $(LREF TimeOfDay).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14046_886)\n---\nassert(TimeOfDay(12, 12, 12) + seconds(1) == TimeOfDay(12, 12, 13));\nassert(TimeOfDay(12, 12, 12) + minutes(1) == TimeOfDay(12, 13, 12));\nassert(TimeOfDay(12, 12, 12) + hours(1) == TimeOfDay(13, 12, 12));\nassert(TimeOfDay(23, 59, 59) + seconds(1) == TimeOfDay(0, 0, 0));\n\nassert(TimeOfDay(12, 12, 12) - seconds(1) == TimeOfDay(12, 12, 11));\nassert(TimeOfDay(12, 12, 12) - minutes(1) == TimeOfDay(12, 11, 12));\nassert(TimeOfDay(12, 12, 12) - hours(1) == TimeOfDay(11, 12, 12));\nassert(TimeOfDay(0, 0, 0) - seconds(1) == TimeOfDay(23, 59, 59));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14046_886)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 15,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 14113,
								"type": "const pure nothrow @safe TimeOfDay(TickDuration td)",
								"parameters": [
									{
										"name": "td",
										"type": "TickDuration"
									}
								],
								"endline": 14119,
								"char": 15,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 14113,
						"comment": "        $(RED Deprecated. $(CXREF time, TickDuration) is going to be deprecated\n              in favor of $(CXREF time, MonoTime) and $(CXREF time, Duration).\n              Use $(D Duration) instead. This overload will be removed in\n              January 2017.)\n\n        Defines + and - with $(CXREF time, TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 15,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 14155,
								"type": "pure nothrow ref @safe TimeOfDay(Duration duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "Duration"
									}
								],
								"endline": 14160,
								"char": 19,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 14155,
						"comment": "        Gives the result of adding or subtracting a $(CXREF time, Duration) from\n        this $(LREF TimeOfDay), as well as assigning the result to this\n        $(LREF TimeOfDay).\n\n        The legal types of arithmetic for $(LREF TimeOfDay) using this operator\n        are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD Duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD Duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The $(CXREF time, Duration) to add to or subtract from\n                       this $(LREF TimeOfDay).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 19,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 14216,
								"type": "pure nothrow ref @safe TimeOfDay(TickDuration td)",
								"parameters": [
									{
										"name": "td",
										"type": "TickDuration"
									}
								],
								"endline": 14221,
								"char": 19,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 14216,
						"comment": "        $(RED Deprecated. $(CXREF time, TickDuration) is going to be deprecated\n              in favor of $(CXREF time, MonoTime) and $(CXREF time, Duration).\n              Use $(D Duration) instead. This overload will be removed in\n              January 2017.)\n\n        Defines += and -= with $(CXREF time, TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 19,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 14268,
								"type": "const pure nothrow @safe Duration(in TimeOfDay rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "TimeOfDay",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 14275,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 14268,
						"comment": "        Gives the difference between two $(LREF TimeOfDay)s.\n\n        The legal types of arithmetic for $(LREF TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD -) $(TD TimeOfDay) $(TD -->) $(TD duration))\n        )\n\n        Params:\n            rhs = The $(LREF TimeOfDay) to subtract from this one.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "toISOString",
						"line": 14309,
						"comment": "        Converts this $(LREF TimeOfDay) to a string with the format HHMMSS.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14319_892)\n---\nassert(TimeOfDay(0, 0, 0).toISOString() == \"000000\");\nassert(TimeOfDay(12, 30, 33).toISOString() == \"123033\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14319_892)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 14316,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOExtString",
						"line": 14339,
						"comment": "        Converts this $(LREF TimeOfDay) to a string with the format HH:MM:SS.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14349_894)\n---\nassert(TimeOfDay(0, 0, 0).toISOExtString() == \"00:00:00\");\nassert(TimeOfDay(12, 30, 33).toISOExtString() == \"12:30:33\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14349_894)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 14346,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 14369,
						"comment": "        Converts this TimeOfDay to a string.\n",
						"deco": "xFNaNbNfZAya",
						"endline": 14372,
						"char": 12,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOString",
								"line": 14396,
								"type": "pure @safe TimeOfDay(in S isoString)",
								"parameters": [
									{
										"name": "isoString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 14418,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "fromISOString",
						"line": 14396,
						"comment": "        Creates a $(LREF TimeOfDay) from a string with the format HHMMSS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for times.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF TimeOfDay) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14421_897)\n---\nassert(TimeOfDay.fromISOString(\"000000\") == TimeOfDay(0, 0, 0));\nassert(TimeOfDay.fromISOString(\"123033\") == TimeOfDay(12, 30, 33));\nassert(TimeOfDay.fromISOString(\" 123033 \") == TimeOfDay(12, 30, 33));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14421_897)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 22,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOExtString",
								"line": 14504,
								"type": "pure @safe TimeOfDay(in S isoExtString)",
								"parameters": [
									{
										"name": "isoExtString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 14531,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "fromISOExtString",
						"line": 14504,
						"comment": "        Creates a $(LREF TimeOfDay) from a string with the format HH:MM:SS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoExtString = A string formatted in the ISO Extended format for times.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(LREF TimeOfDay) would not be\n            valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14534_899)\n---\nassert(TimeOfDay.fromISOExtString(\"00:00:00\") == TimeOfDay(0, 0, 0));\nassert(TimeOfDay.fromISOExtString(\"12:30:33\") == TimeOfDay(12, 30, 33));\nassert(TimeOfDay.fromISOExtString(\" 12:30:33 \") == TimeOfDay(12, 30, 33));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14534_899)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 22,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "min",
						"line": 14608,
						"comment": "        Returns midnight.\n",
						"deco": "FNaNbNdNfZS3std8datetime9TimeOfDay",
						"endline": 14611,
						"char": 32,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "max",
						"line": 14625,
						"comment": "        Returns one second short of midnight.\n",
						"deco": "FNaNbNdNfZS3std8datetime9TimeOfDay",
						"endline": 14633,
						"char": 32,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "DateTime",
				"line": 14791,
				"comment": "   Combines the $(LREF Date) and $(LREF TimeOfDay) structs to give an object\n   which holds both the date and the time. It is optimized for calendar-based\n   operations and has no concept of time zone. For an object which is\n   optimized for time operations based on the system time, use\n   $(LREF SysTime). $(LREF SysTime) has a concept of time zone and has much higher\n   precision (hnsecs). $(D DateTime) is intended primarily for calendar-based\n   uses rather than precise time operations.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 14800,
						"comment": "        Params:\n            date = The date portion of $(LREF DateTime).\n            tod  = The time portion of $(LREF DateTime).\n",
						"deco": "FNaNbNcNfxS3std8datetime4DatexS3std8datetime9TimeOfDayZS3std8datetime8DateTime",
						"parameters": [
							{
								"name": "date",
								"deco": "xS3std8datetime4Date"
							},
							{
								"name": "tod",
								"deco": "xS3std8datetime9TimeOfDay",
								"default": "TimeOfDay(cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u)"
							}
						],
						"endline": 14804,
						"originalType": "pure nothrow ref @safe (in Date date, in TimeOfDay tod = TimeOfDay.init)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 14837,
						"comment": "        Params:\n            year   = The year portion of the date.\n            month  = The month portion of the date.\n            day    = The day portion of the date.\n            hour   = The hour portion of the time;\n            minute = The minute portion of the time;\n            second = The second portion of the time;\n",
						"deco": "FNaNcNfiiiiiiZS3std8datetime8DateTime",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							},
							{
								"name": "month",
								"deco": "i"
							},
							{
								"name": "day",
								"deco": "i"
							},
							{
								"name": "hour",
								"deco": "i",
								"default": "0"
							},
							{
								"name": "minute",
								"deco": "i",
								"default": "0"
							},
							{
								"name": "second",
								"deco": "i",
								"default": "0"
							}
						],
						"endline": 14841,
						"originalType": "pure ref @safe (int year, int month, int day, int hour = 0, int minute = 0, int second = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 14869,
						"comment": "        Compares this $(LREF DateTime) with the given $(D DateTime.).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
						"deco": "xFNaNbNfxS3std8datetime8DateTimeZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime8DateTime"
							}
						],
						"endline": 14877,
						"originalType": "const pure nothrow @safe int(in DateTime rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "date",
						"line": 15079,
						"comment": "        The date portion of $(LREF DateTime).\n",
						"deco": "xFNaNbNdNfZS3std8datetime4Date",
						"endline": 15082,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "date",
						"line": 15109,
						"comment": "        The date portion of $(LREF DateTime).\n\n        Params:\n            date = The Date to set this $(LREF DateTime)'s date portion to.\n",
						"deco": "FNaNbNdNfxS3std8datetime4DateZv",
						"parameters": [
							{
								"name": "date",
								"deco": "xS3std8datetime4Date"
							}
						],
						"endline": 15112,
						"originalType": "pure nothrow @property @safe void(in Date date)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "timeOfDay",
						"line": 15131,
						"comment": "        The time portion of $(LREF DateTime).\n",
						"deco": "xFNaNbNdNfZS3std8datetime9TimeOfDay",
						"endline": 15134,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "timeOfDay",
						"line": 15162,
						"comment": "        The time portion of $(LREF DateTime).\n\n        Params:\n            tod = The $(LREF TimeOfDay) to set this $(LREF DateTime)'s time portion\n                  to.\n",
						"deco": "FNaNbNdNfxS3std8datetime9TimeOfDayZv",
						"parameters": [
							{
								"name": "tod",
								"deco": "xS3std8datetime9TimeOfDay"
							}
						],
						"endline": 15165,
						"originalType": "pure nothrow @property @safe void(in TimeOfDay tod)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 15185,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n",
						"deco": "xFNaNbNdNfZs",
						"endline": 15188,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 15214,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this $(LREF DateTime)'s year to.\n\n        Throws:\n            $(LREF DateTimeException) if the new year is not a leap year and if the\n            resulting date would be on February 29th.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15220_913)\n---\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).year == 1999);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).year == 2010);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).year == -7);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15220_913)\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 15217,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 15252,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(LREF DateTimeException) if $(D isAD) is true.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15258_915)\n---\nassert(DateTime(Date(0, 1, 1), TimeOfDay(12, 30, 33)).yearBC == 1);\nassert(DateTime(Date(-1, 1, 1), TimeOfDay(10, 7, 2)).yearBC == 2);\nassert(DateTime(Date(-100, 1, 1), TimeOfDay(4, 59, 0)).yearBC == 101);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15258_915)\n",
						"deco": "xFNaNdNfZs",
						"endline": 15255,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 15288,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(LREF DateTime)'s year to.\n\n        Throws:\n            $(LREF DateTimeException) if a non-positive value is given.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15294_917)\n---\nauto dt = DateTime(Date(2010, 1, 1), TimeOfDay(7, 30, 0));\ndt.yearBC = 1;\nassert(dt == DateTime(Date(0, 1, 1), TimeOfDay(7, 30, 0)));\n\ndt.yearBC = 10;\nassert(dt == DateTime(Date(-9, 1, 1), TimeOfDay(7, 30, 0)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15294_917)\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 15291,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 15321,
						"comment": "        Month of a Gregorian Year.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15327_919)\n---\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).month == 7);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).month == 10);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).month == 4);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15327_919)\n",
						"deco": "xFNaNbNdNfZE3std8datetime5Month",
						"endline": 15324,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 15356,
						"comment": "        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(LREF DateTime)'s month to.\n\n        Throws:\n            $(LREF DateTimeException) if the given month is not a valid month.\n",
						"deco": "FNaNdNfE3std8datetime5MonthZv",
						"parameters": [
							{
								"name": "month",
								"deco": "E3std8datetime5Month"
							}
						],
						"endline": 15359,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 15386,
						"comment": "        Day of a Gregorian Month.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15392_922)\n---\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).day == 6);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).day == 4);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).day == 5);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15392_922)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 15389,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 15435,
						"comment": "        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(LREF DateTime)'s day to.\n\n        Throws:\n            $(LREF DateTimeException) if the given day is not a valid day of the\n            current month.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 15438,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 15527,
						"comment": "        Hours past midnight.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 15530,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 15554,
						"comment": "        Hours past midnight.\n\n        Params:\n            hour = The hour of the day to set this $(LREF DateTime)'s hour to.\n\n        Throws:\n            $(LREF DateTimeException) if the given hour would result in an invalid\n            $(LREF DateTime).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "hour",
								"deco": "i"
							}
						],
						"endline": 15557,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 15577,
						"comment": "        Minutes past the hour.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 15580,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 15604,
						"comment": "        Minutes past the hour.\n\n        Params:\n            minute = The minute to set this $(LREF DateTime)'s minute to.\n\n        Throws:\n            $(LREF DateTimeException) if the given minute would result in an\n            invalid $(LREF DateTime).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "minute",
								"deco": "i"
							}
						],
						"endline": 15607,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 15627,
						"comment": "        Seconds past the minute.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 15630,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 15654,
						"comment": "        Seconds past the minute.\n\n        Params:\n            second = The second to set this $(LREF DateTime)'s second to.\n\n        Throws:\n            $(LREF DateTimeException) if the given seconds would result in an\n            invalid $(LREF DateTime).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "second",
								"deco": "i"
							}
						],
						"endline": 15657,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "add",
								"line": 15693,
								"type": "pure nothrow ref @safe DateTime(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 15700,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "add",
						"line": 15693,
						"comment": "        Adds the given number of years or months to this $(LREF DateTime). A\n        negative number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15703_931)\n---\nauto dt1 = DateTime(2010, 1, 1, 12, 30, 33);\ndt1.add!\"months\"(11);\nassert(dt1 == DateTime(2010, 12, 1, 12, 30, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 30, 33);\ndt2.add!\"months\"(-11);\nassert(dt2 == DateTime(2009, 2, 1, 12, 30, 33));\n\nauto dt3 = DateTime(2000, 2, 29, 12, 30, 33);\ndt3.add!\"years\"(1);\nassert(dt3 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt4 = DateTime(2000, 2, 29, 12, 30, 33);\ndt4.add!\"years\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(2001, 2, 28, 12, 30, 33));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15703_931)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\" || units == \"months\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 15756,
								"type": "pure nothrow ref @safe DateTime(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 15763,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 15756,
						"comment": "        Adds the given number of years or months to this $(LREF DateTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(LREF DateTime) 12 months\n        gets the exact same $(LREF DateTime). However, the days can still be\n        affected due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15766_933)\n---\nauto dt1 = DateTime(2010, 1, 1, 12, 33, 33);\ndt1.roll!\"months\"(1);\nassert(dt1 == DateTime(2010, 2, 1, 12, 33, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 33, 33);\ndt2.roll!\"months\"(-1);\nassert(dt2 == DateTime(2010, 12, 1, 12, 33, 33));\n\nauto dt3 = DateTime(1999, 1, 29, 12, 33, 33);\ndt3.roll!\"months\"(1);\nassert(dt3 == DateTime(1999, 3, 1, 12, 33, 33));\n\nauto dt4 = DateTime(1999, 1, 29, 12, 33, 33);\ndt4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(1999, 2, 28, 12, 33, 33));\n\nauto dt5 = DateTime(2000, 2, 29, 12, 30, 33);\ndt5.roll!\"years\"(1);\nassert(dt5 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt6 = DateTime(2000, 2, 29, 12, 30, 33);\ndt6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(dt6 == DateTime(2001, 2, 28, 12, 30, 33));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15766_933)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\" || units == \"months\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 15823,
								"type": "pure nothrow ref @safe DateTime(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 15828,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 15823,
						"comment": "        Adds the given number of units to this $(LREF DateTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(LREF DateTime) one\n        year's worth of days gets the exact same $(LREF DateTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(LREF DateTime).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15831_935)\n---\nauto dt1 = DateTime(2010, 1, 1, 11, 23, 12);\ndt1.roll!\"days\"(1);\nassert(dt1 == DateTime(2010, 1, 2, 11, 23, 12));\ndt1.roll!\"days\"(365);\nassert(dt1 == DateTime(2010, 1, 26, 11, 23, 12));\ndt1.roll!\"days\"(-32);\nassert(dt1 == DateTime(2010, 1, 25, 11, 23, 12));\n\nauto dt2 = DateTime(2010, 7, 4, 12, 0, 0);\ndt2.roll!\"hours\"(1);\nassert(dt2 == DateTime(2010, 7, 4, 13, 0, 0));\n\nauto dt3 = DateTime(2010, 1, 1, 0, 0, 0);\ndt3.roll!\"seconds\"(-1);\nassert(dt3 == DateTime(2010, 1, 1, 0, 0, 59));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15831_935)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"days\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 16383,
								"type": "const pure nothrow @safe DateTime(Duration duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "Duration"
									}
								],
								"endline": 16389,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 16383,
						"comment": "        Gives the result of adding or subtracting a $(CXREF time, Duration) from\n        this $(LREF DateTime).\n\n        The legal types of arithmetic for $(LREF DateTime) using this operator\n        are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD Duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD Duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The $(CXREF time, Duration) to add to or subtract from\n                       this $(LREF DateTime).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16392_940)\n---\nassert(DateTime(2015, 12, 31, 23, 59, 59) + seconds(1) ==\n       DateTime(2016, 1, 1, 0, 0, 0));\n\nassert(DateTime(2015, 12, 31, 23, 59, 59) + hours(1) ==\n       DateTime(2016, 1, 1, 0, 59, 59));\n\nassert(DateTime(2016, 1, 1, 0, 0, 0) - seconds(1) ==\n       DateTime(2015, 12, 31, 23, 59, 59));\n\nassert(DateTime(2016, 1, 1, 0, 59, 59) - hours(1) ==\n       DateTime(2015, 12, 31, 23, 59, 59));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16392_940)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 16466,
								"type": "const pure nothrow @safe DateTime(in TickDuration td)",
								"parameters": [
									{
										"name": "td",
										"type": "TickDuration",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 16472,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 16466,
						"comment": "        $(RED Deprecated. $(CXREF time, TickDuration) is going to be deprecated\n              in favor of $(CXREF time, MonoTime) and $(CXREF time, Duration).\n              Use $(D Duration) instead. This overload will be removed in\n              January 2017.)\n\n        Defines + and - with $(CXREF time, TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 16506,
								"type": "pure nothrow ref @safe DateTime(in D duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 16521,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 16506,
						"comment": "        Gives the result of adding or subtracting a duration from this\n        $(LREF DateTime), as well as assigning the result to this $(LREF DateTime).\n\n        The legal types of arithmetic for $(LREF DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(LREF DateTime).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(Unqual!D == Duration) || is(Unqual!D == TickDuration))",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 16584,
								"type": "pure nothrow ref @safe DateTime(TickDuration td)",
								"parameters": [
									{
										"name": "td",
										"type": "TickDuration"
									}
								],
								"endline": 16590,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 16584,
						"comment": "        $(RED Deprecated. $(CXREF time, TickDuration) is going to be deprecated\n              in favor of $(CXREF time, MonoTime) and $(CXREF time, Duration).\n              Use $(D Duration) instead. This overload will be removed in\n              January 2017.)\n\n        Defines += and -= with $(CXREF time, TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 16634,
								"type": "const pure nothrow @safe Duration(in DateTime rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "DateTime",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 16641,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 16634,
						"comment": "        Gives the difference between two $(LREF DateTime)s.\n\n        The legal types of arithmetic for $(LREF DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD -) $(TD DateTime) $(TD -->) $(TD duration))\n        )\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "diffMonths",
						"line": 16731,
						"comment": "        Returns the difference between the two $(LREF DateTime)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(LREF SysTime)s. To get the difference in days or weeks,\n        subtract the $(LREF SysTime)s themselves and use the $(CXREF time, Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(CXREF time, Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either date is is irrelevant. It is the difference in the month property\n        combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(LREF DateTime) to subtract from this one.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16737_946)\n---\nassert(DateTime(1999, 2, 1, 12, 2, 3).diffMonths(\n            DateTime(1999, 1, 31, 23, 59, 59)) == 1);\n\nassert(DateTime(1999, 1, 31, 0, 0, 0).diffMonths(\n            DateTime(1999, 2, 1, 12, 3, 42)) == -1);\n\nassert(DateTime(1999, 3, 1, 5, 30, 0).diffMonths(\n            DateTime(1999, 1, 1, 2, 4, 7)) == 2);\n\nassert(DateTime(1999, 1, 1, 7, 2, 4).diffMonths(\n            DateTime(1999, 3, 31, 0, 30, 58)) == -2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16737_946)\n",
						"deco": "xFNaNbNfxS3std8datetime8DateTimeZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime8DateTime"
							}
						],
						"endline": 16734,
						"originalType": "const pure nothrow @safe int(in DateTime rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isLeapYear",
						"line": 16774,
						"comment": "        Whether this $(LREF DateTime) is in a leap year.\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 16777,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfWeek",
						"line": 16793,
						"comment": "        Day of the week this $(LREF DateTime) is on.\n",
						"deco": "xFNaNbNdNfZE3std8datetime9DayOfWeek",
						"endline": 16796,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 16812,
						"comment": "        Day of the year this $(LREF DateTime) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16818_950)\n---\nassert(DateTime(Date(1999, 1, 1), TimeOfDay(12, 22, 7)).dayOfYear == 1);\nassert(DateTime(Date(1999, 12, 31), TimeOfDay(7, 2, 59)).dayOfYear == 365);\nassert(DateTime(Date(2000, 12, 31), TimeOfDay(21, 20, 0)).dayOfYear == 366);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16818_950)\n",
						"deco": "xFNaNbNdNfZt",
						"endline": 16815,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 16843,
						"comment": "        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(LREF DateTime) is on.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 16846,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 16863,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF DateTime) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16869_953)\n---\nassert(DateTime(Date(1, 1, 1), TimeOfDay(0, 0, 0)).dayOfGregorianCal == 1);\nassert(DateTime(Date(1, 12, 31), TimeOfDay(23, 59, 59)).dayOfGregorianCal == 365);\nassert(DateTime(Date(2, 1, 1), TimeOfDay(2, 2, 2)).dayOfGregorianCal == 366);\n\nassert(DateTime(Date(0, 12, 31), TimeOfDay(7, 7, 7)).dayOfGregorianCal == 0);\nassert(DateTime(Date(0, 1, 1), TimeOfDay(19, 30, 0)).dayOfGregorianCal == -365);\nassert(DateTime(Date(-1, 12, 31), TimeOfDay(4, 7, 0)).dayOfGregorianCal == -366);\n\nassert(DateTime(Date(2000, 1, 1), TimeOfDay(9, 30, 20)).dayOfGregorianCal == 730_120);\nassert(DateTime(Date(2010, 12, 31), TimeOfDay(15, 45, 50)).dayOfGregorianCal == 734_137);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16869_953)\n",
						"deco": "xFNaNbNdNfZi",
						"endline": 16866,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 16901,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF DateTime) is on.\n        Setting this property does not affect the time portion of\n        $(LREF DateTime).\n\n        Params:\n            days = The day of the Gregorian Calendar to set this $(LREF DateTime)\n                   to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16907_955)\n---\nauto dt = DateTime(Date.init, TimeOfDay(12, 0, 0));\ndt.dayOfGregorianCal = 1;\nassert(dt == DateTime(Date(1, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 365;\nassert(dt == DateTime(Date(1, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 366;\nassert(dt == DateTime(Date(2, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 0;\nassert(dt == DateTime(Date(0, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = -365;\nassert(dt == DateTime(Date(-0, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = -366;\nassert(dt == DateTime(Date(-1, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 730_120;\nassert(dt == DateTime(Date(2000, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 734_137;\nassert(dt == DateTime(Date(2010, 12, 31), TimeOfDay(12, 0, 0)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16907_955)\n",
						"deco": "FNaNbNdNfiZv",
						"parameters": [
							{
								"name": "days",
								"deco": "i"
							}
						],
						"endline": 16904,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isoWeek",
						"line": 16950,
						"comment": "        The ISO 8601 week of the year that this $(LREF DateTime) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/ISO_week_date, ISO Week Date)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 16953,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "endOfMonth",
						"line": 16970,
						"comment": "        $(LREF DateTime) for the last day in the month that this $(LREF DateTime) is\n        in. The time portion of endOfMonth is always 23:59:59.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16979_958)\n---\nassert(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).endOfMonth ==\n       DateTime(Date(1999, 1, 31), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).endOfMonth ==\n       DateTime(Date(1999, 2, 28), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).endOfMonth ==\n       DateTime(Date(2000, 2, 29), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).endOfMonth ==\n       DateTime(Date(2000, 6, 30), TimeOfDay(23, 59, 59)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16979_958)\n",
						"deco": "xFNaNbNdNfZS3std8datetime8DateTime",
						"endline": 16976,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "daysInMonth",
						"line": 17036,
						"comment": "        The last day in the month that this $(LREF DateTime) is in.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL17042_960)\n---\nassert(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).daysInMonth == 31);\nassert(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).daysInMonth == 28);\nassert(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).daysInMonth == 29);\nassert(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).daysInMonth == 30);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL17042_960)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 17039,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isAD",
						"line": 17062,
						"comment": "        Whether the current year is a date in A.D.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL17068_962)\n---\nassert(DateTime(Date(1, 1, 1), TimeOfDay(12, 7, 0)).isAD);\nassert(DateTime(Date(2010, 12, 31), TimeOfDay(0, 0, 0)).isAD);\nassert(!DateTime(Date(0, 12, 31), TimeOfDay(23, 59, 59)).isAD);\nassert(!DateTime(Date(-2010, 1, 1), TimeOfDay(2, 2, 2)).isAD);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL17068_962)\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 17065,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "julianDay",
						"line": 17092,
						"comment": "        The $(WEB en.wikipedia.org/wiki/Julian_day, Julian day) for this\n        $(LREF DateTime) at the given time. For example, prior to noon,\n        1996-03-31 would be the Julian day number 2_450_173, so this function\n        returns 2_450_173, while from noon onward, the julian day number would\n        be 2_450_174, so this function returns 2_450_174.\n",
						"deco": "xFNaNbNdNfZl",
						"endline": 17098,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "modJulianDay",
						"line": 17137,
						"comment": "        The modified $(WEB en.wikipedia.org/wiki/Julian_day, Julian day) for any\n        time on this date (since, the modified Julian day changes at midnight).\n",
						"deco": "xFNaNbNdNfZl",
						"endline": 17140,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOString",
						"line": 17160,
						"comment": "        Converts this $(LREF DateTime) to a string with the format YYYYMMDDTHHMMSS.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL17170_966)\n---\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toISOString() ==\n       \"20100704T070612\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toISOString() ==\n       \"19981225T021500\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toISOString() ==\n       \"00000105T230959\");\n\nassert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toISOString() ==\n       \"-00040105T000002\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL17170_966)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 17167,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOExtString",
						"line": 17213,
						"comment": "        Converts this $(LREF DateTime) to a string with the format\n        YYYY-MM-DDTHH:MM:SS.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL17223_968)\n---\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toISOExtString() ==\n       \"2010-07-04T07:06:12\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toISOExtString() ==\n       \"1998-12-25T02:15:00\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toISOExtString() ==\n       \"0000-01-05T23:09:59\");\n\nassert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toISOExtString() ==\n       \"-0004-01-05T00:00:02\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL17223_968)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 17220,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toSimpleString",
						"line": 17265,
						"comment": "        Converts this $(LREF DateTime) to a string with the format\n        YYYY-Mon-DD HH:MM:SS.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL17275_970)\n---\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toSimpleString() ==\n       \"2010-Jul-04 07:06:12\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toSimpleString() ==\n       \"1998-Dec-25 02:15:00\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toSimpleString() ==\n       \"0000-Jan-05 23:09:59\");\n\nassert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toSimpleString() ==\n       \"-0004-Jan-05 00:00:02\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL17275_970)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 17272,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 17317,
						"comment": "        Converts this $(LREF DateTime) to a string.\n",
						"deco": "xFNaNbNfZAya",
						"endline": 17320,
						"char": 12,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOString",
								"line": 17345,
								"type": "pure @safe DateTime(in S isoString)",
								"parameters": [
									{
										"name": "isoString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17364,
								"char": 21,
								"kind": "function"
							}
						],
						"name": "fromISOString",
						"line": 17345,
						"comment": "        Creates a $(LREF DateTime) from a string with the format YYYYMMDDTHHMMSS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates and times.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF DateTime) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL17367_973)\n---\nassert(DateTime.fromISOString(\"20100704T070612\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\nassert(DateTime.fromISOString(\"19981225T021500\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\n\nassert(DateTime.fromISOString(\"00000105T230959\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\n\nassert(DateTime.fromISOString(\"-00040105T000002\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\n\nassert(DateTime.fromISOString(\" 20100704T070612 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL17367_973)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 21,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOExtString",
								"line": 17433,
								"type": "pure @safe DateTime(in S isoExtString)",
								"parameters": [
									{
										"name": "isoExtString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17452,
								"char": 21,
								"kind": "function"
							}
						],
						"name": "fromISOExtString",
						"line": 17433,
						"comment": "        Creates a $(LREF DateTime) from a string with the format\n        YYYY-MM-DDTHH:MM:SS. Whitespace is stripped from the given string.\n\n        Params:\n            isoExtString = A string formatted in the ISO Extended format for dates\n                           and times.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(LREF DateTime) would not be\n            valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL17455_975)\n---\nassert(DateTime.fromISOExtString(\"2010-07-04T07:06:12\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\nassert(DateTime.fromISOExtString(\"1998-12-25T02:15:00\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\n\nassert(DateTime.fromISOExtString(\"0000-01-05T23:09:59\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\n\nassert(DateTime.fromISOExtString(\"-0004-01-05T00:00:02\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\n\nassert(DateTime.fromISOExtString(\" 2010-07-04T07:06:12 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL17455_975)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 21,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromSimpleString",
								"line": 17519,
								"type": "pure @safe DateTime(in S simpleString)",
								"parameters": [
									{
										"name": "simpleString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17538,
								"char": 21,
								"kind": "function"
							}
						],
						"name": "fromSimpleString",
						"line": 17519,
						"comment": "        Creates a $(LREF DateTime) from a string with the format\n        YYYY-Mon-DD HH:MM:SS. Whitespace is stripped from the given string.\n\n        Params:\n            simpleString = A string formatted in the way that toSimpleString\n                           formats dates and times.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the correct\n            format or if the resulting $(LREF DateTime) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL17541_977)\n---\nassert(DateTime.fromSimpleString(\"2010-Jul-04 07:06:12\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\nassert(DateTime.fromSimpleString(\"1998-Dec-25 02:15:00\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\nassert(DateTime.fromSimpleString(\"0000-Jan-05 23:09:59\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\nassert(DateTime.fromSimpleString(\"-0004-Jan-05 00:00:02\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\nassert(DateTime.fromSimpleString(\" 2010-Jul-04 07:06:12 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL17541_977)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 21,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "min",
						"line": 17594,
						"comment": "        Returns the $(LREF DateTime) farthest in the past which is representable by\n        $(LREF DateTime).\n",
						"deco": "FNaNbNdNfZS3std8datetime8DateTime",
						"endline": 17608,
						"char": 31,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "max",
						"line": 17621,
						"comment": "        Returns the $(LREF DateTime) farthest in the future which is representable\n        by $(LREF DateTime).\n",
						"deco": "FNaNbNdNfZS3std8datetime8DateTime",
						"endline": 17638,
						"char": 31,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "Interval",
						"line": 17883,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 17901,
										"type": "pure (in TP begin, in U end)",
										"parameters": [
											{
												"name": "begin",
												"type": "TP",
												"storageClass": [
													"in"
												]
											},
											{
												"name": "end",
												"type": "U",
												"storageClass": [
													"in"
												]
											}
										],
										"endline": 17909,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 17901,
								"comment": "        Params:\n            begin = The time point which begins the interval.\n            end   = The time point which ends (but is not included in) the\n                    interval.\n\n        Throws:\n            $(LREF DateTimeException) if $(D_PARAM end) is before $(D_PARAM begin).\n\n        Example:\n--------------------\nInterval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\n--------------------\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "is(Unqual!TP == Unqual!U)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 17927,
										"type": "pure (in TP begin, in D duration)",
										"parameters": [
											{
												"name": "begin",
												"type": "TP",
												"storageClass": [
													"in"
												]
											},
											{
												"name": "duration",
												"type": "D",
												"storageClass": [
													"in"
												]
											}
										],
										"endline": 17935,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 17927,
								"comment": "        Params:\n            begin    = The time point which begins the interval.\n            duration = The duration from the starting point to the end point.\n\n        Throws:\n            $(LREF DateTimeException) if the resulting $(D end) is before\n            $(D begin).\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), dur!\"years\"(3)) ==\n       Interval!Date(Date(1996, 1, 2), Date(1999, 1, 2)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, begin + duration)",
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 17942,
								"comment": "        Params:\n            rhs = The $(LREF2 .Interval, Interval) to assign to this one.\n",
								"type": "pure nothrow ref Interval(ref const Interval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Interval",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 17947,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 17954,
								"comment": "        Params:\n            rhs = The $(LREF2 .Interval, Interval) to assign to this one.\n",
								"type": "pure nothrow ref Interval(Interval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Interval"
									}
								],
								"endline": 17959,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "begin",
								"line": 17971,
								"comment": "        The starting point of the interval. It is included in the interval.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).begin ==\n       Date(1996, 1, 2));\n--------------------\n",
								"type": "const pure nothrow @property TP()",
								"endline": 17974,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "begin",
								"line": 17986,
								"comment": "        The starting point of the interval. It is included in the interval.\n\n        Params:\n            timePoint = The time point to set $(D begin) to.\n\n        Throws:\n            $(LREF DateTimeException) if the resulting interval would be invalid.\n",
								"type": "pure @property void(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 17992,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "end",
								"line": 18004,
								"comment": "        The end point of the interval. It is excluded from the interval.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).end ==\n       Date(2012, 3, 1));\n--------------------\n",
								"type": "const pure nothrow @property TP()",
								"endline": 18007,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "end",
								"line": 18019,
								"comment": "        The end point of the interval. It is excluded from the interval.\n\n        Params:\n            timePoint = The time point to set end to.\n\n        Throws:\n            $(LREF DateTimeException) if the resulting interval would be invalid.\n",
								"type": "pure @property void(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 18025,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 18037,
								"comment": "        Returns the duration between $(D begin) and $(D end).\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).length ==\n       dur!\"days\"(5903));\n--------------------\n",
								"type": "const pure nothrow @property ()",
								"endline": 18040,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 18052,
								"comment": "        Whether the interval's length is 0, that is, whether $(D begin == end).\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(1996, 1, 2)).empty);\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).empty);\n--------------------\n",
								"type": "const pure nothrow @property bool()",
								"endline": 18055,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 18078,
								"comment": "        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(1994, 12, 24)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(2000, 1, 5)));\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18083,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 18107,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n",
								"type": "const pure bool(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18115,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 18137,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Always returns false (unless this interval is empty), because an\n        interval going to positive infinity can never be contained in a finite\n        interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n",
								"type": "const pure bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18142,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 18164,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Always returns false (unless this interval is empty), because an\n        interval beginning at negative infinity can never be contained in a\n        finite interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n",
								"type": "const pure bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18169,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 18194,
								"comment": "        Whether this interval is before the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is before\n                        it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(1994, 12, 24)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(2000, 1, 5)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18199,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 18224,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 1))));\n--------------------\n",
								"type": "const pure bool(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18230,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 18252,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(2013, 3, 7))));\n--------------------\n",
								"type": "const pure bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18257,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 18279,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Always returns false (unless this interval is empty) because a finite\n        interval can never be before an interval beginning at negative infinity.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n",
								"type": "const pure bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18284,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 18309,
								"comment": "        Whether this interval is after the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(1994, 12, 24)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(2000, 1, 5)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18314,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 18339,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18345,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 18367,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false (unless this interval is empty) because a finite\n        interval can never be after an interval going to positive infinity.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n",
								"type": "const pure bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18372,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 18391,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18396,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 18420,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18426,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 18447,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18452,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 18473,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(2000, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18478,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 18502,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect or if\n            either interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));\n--------------------\n",
								"type": "const Interval(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18512,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 18536,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect or if\n            this interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n",
								"type": "const Interval(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18543,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 18567,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect or if\n            this interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));\n--------------------\n",
								"type": "const Interval(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18574,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 18599,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1990, 7, 6), Date(1996, 1, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1989, 3, 1), Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure bool(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18605,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 18627,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18632,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 18654,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(2000, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18659,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 18683,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if either interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));\n--------------------\n",
								"type": "const Interval(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18694,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 18718,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if this interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            PosInfInterval!Date(Date(2012, 3, 1))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const PosInfInterval!TP(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18726,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 18750,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect and are not\n            adjacent or if this interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(1996, 1, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n",
								"type": "const NegInfInterval!TP(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18758,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 18783,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            Interval!Date(Date(1990, 7, 6), Date(1991, 1, 8))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));\n--------------------\n",
								"type": "const pure Interval(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18792,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 18817,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            PosInfInterval!Date(Date(2050, 1, 1))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const pure PosInfInterval!TP(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18822,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 18847,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Example:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(1602, 5, 21))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n",
								"type": "const pure NegInfInterval!TP(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18852,
								"char": 23,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "shift",
										"line": 18880,
										"type": "pure void(D duration)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											}
										],
										"endline": 18893,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "shift",
								"line": 18880,
								"comment": "        Shifts the interval forward or backwards in time by the given duration\n        (a positive duration shifts the interval forward; a negative duration\n        shifts it backward). Effectively, it does $(D begin += duration) and\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Throws:\n            $(LREF DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Example:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == Interval!Date(Date(1996, 2, 21), Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == Interval!Date(Date(1995, 11, 13), Date(2012, 2, 15)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, begin + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "expand",
										"line": 18977,
										"type": "pure void(D duration, Direction dir = Direction.both)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											},
											{
												"name": "dir",
												"type": "Direction",
												"default": "Direction.both"
											}
										],
										"endline": 19020,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "expand",
								"line": 18977,
								"comment": "        Expands the interval forwards and/or backwards in time. Effectively,\n        it does $(D begin -= duration) and/or $(D end += duration). Whether\n        it expands forwards and/or backwards in time is determined by\n        $(D_PARAM dir).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Throws:\n            $(LREF DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Example:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\n\ninterval1.expand(2);\nassert(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));\n\ninterval2.expand(-2);\nassert(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, begin + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "fwdRange",
								"line": 19189,
								"comment": "        Returns a range which iterates forward over the interval, starting\n        at $(D begin), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D begin). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point less than or equal to the\n        current $(D front) of the range, then a $(LREF DateTimeException) will be\n        thrown. The range will be empty and iteration complete when\n        $(D_PARAM func) generates a time point equal to or beyond the $(D end)\n        of the interval.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D fwdRange). Their documentation starts with\n        \"Range-generating function,\" making them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant if when creating a custom delegate.\n\n        Example:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date + dur!\"days\"(2);\n\n                return date + dur!\"days\"(1);\n            };\nauto range = interval.fwdRange(func);\n\n //An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).\nassert(range.front == Date(2010, 9, 1));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n",
								"type": "const IntervalRange!(TP, Direction.fwd)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
								"parameters": [
									{
										"name": "func",
										"type": "TP delegate(in TP)"
									},
									{
										"name": "popFirst",
										"type": "PopFirst",
										"default": "PopFirst.no"
									}
								],
								"endline": 19199,
								"char": 39,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "bwdRange",
								"line": 19282,
								"comment": "        Returns a range which iterates backwards over the interval, starting\n        at $(D end), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D end). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point greater than or equal to\n        the current $(D front) of the range, then a $(LREF DateTimeException) will\n        be thrown. The range will be empty and iteration complete when\n        $(D_PARAM func) generates a time point equal to or less than the\n        $(D begin) of the interval.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D bwdRange). Their documentation starts with\n        \"Range-generating function,\" making them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Example:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date - dur!\"days\"(2);\n\n                return date - dur!\"days\"(1);\n            };\nauto range = interval.bwdRange(func);\n\n//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).\nassert(range.front == Date(2010, 9, 9));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n",
								"type": "const IntervalRange!(TP, Direction.bwd)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
								"parameters": [
									{
										"name": "func",
										"type": "TP delegate(in TP)"
									},
									{
										"name": "popFirst",
										"type": "PopFirst",
										"default": "PopFirst.no"
									}
								],
								"endline": 19292,
								"char": 39,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 19313,
								"comment": "        Converts this interval to a string.\n",
								"type": "const nothrow string()",
								"endline": 19316,
								"char": 12,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Interval",
				"line": 17883,
				"comment": "    Represents an interval of time.\n\n    An $(D Interval) has a starting point and an end point. The interval of time\n    is therefore the time starting at the starting point up to, but not\n    including, the end point. e.g.\n\n    $(BOOKTABLE,\n    $(TR $(TD [January 5th, 2010 - March 10th, 2010$(RPAREN)))\n    $(TR $(TD [05:00:30 - 12:00:00$(RPAREN)))\n    $(TR $(TD [1982-01-04T08:59:00 - 2010-07-04T12:00:00$(RPAREN)))\n    )\n\n    A range can be obtained from an $(D Interval), allowing iteration over\n    that interval, with the exact time points which are iterated over depending\n    on the function which generates the range.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "PosInfInterval",
						"line": 20794,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 20807,
								"comment": "        Params:\n            begin = The time point which begins the interval.\n\n        Example:\n--------------------\nauto interval = PosInfInterval!Date(Date(1996, 1, 2));\n--------------------\n",
								"type": "pure nothrow (in TP begin)",
								"parameters": [
									{
										"name": "begin",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20810,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 20817,
								"comment": "        Params:\n            rhs = The $(D PosInfInterval) to assign to this one.\n",
								"type": "pure nothrow ref PosInfInterval(ref const PosInfInterval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "PosInfInterval",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 20821,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 20828,
								"comment": "        Params:\n            rhs = The $(D PosInfInterval) to assign to this one.\n",
								"type": "pure nothrow ref PosInfInterval(PosInfInterval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "PosInfInterval"
									}
								],
								"endline": 20832,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "begin",
								"line": 20843,
								"comment": "        The starting point of the interval. It is included in the interval.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).begin == Date(1996, 1, 2));\n--------------------\n",
								"type": "const pure nothrow @property TP()",
								"endline": 20846,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "begin",
								"line": 20855,
								"comment": "        The starting point of the interval. It is included in the interval.\n\n        Params:\n            timePoint = The time point to set $(D begin) to.\n",
								"type": "pure nothrow @property void(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 20858,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 20869,
								"comment": "        Whether the interval's length is 0. Always returns false.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).empty);\n--------------------\n",
								"type": "const pure nothrow @property bool()",
								"endline": 20872,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 20887,
								"comment": "        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(1994, 12, 24)));\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(2000, 1, 5)));\n--------------------\n",
								"type": "const pure nothrow bool(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 20890,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 20914,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20919,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 20937,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            PosInfInterval!Date(Date(1995, 7, 2))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20940,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 20958,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Always returns false because an interval going to positive infinity\n        can never contain an interval beginning at negative infinity.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20961,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 20980,
								"comment": "        Whether this interval is before the given time point.\n\n        Always returns false because an interval going to positive infinity\n        can never be before any time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is before\n                        it.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(1994, 12, 24)));\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(2000, 1, 5)));\n--------------------\n",
								"type": "const pure nothrow bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20983,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 21009,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false (unless the given interval is empty) because an\n        interval going to positive infinity can never be before any other\n        interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21014,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 21036,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval going to positive infinity can\n        never be before any other interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            PosInfInterval!Date(Date(1992, 5, 4))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            PosInfInterval!Date(Date(2013, 3, 7))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21039,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 21058,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval going to positive infinity can\n        never be before any other interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21061,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 21077,
								"comment": "        Whether this interval is after the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(1994, 12, 24)));\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(2000, 1, 5)));\n--------------------\n",
								"type": "const pure nothrow bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21080,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 21105,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21110,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 21132,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval going to positive infinity can\n        never be after another interval going to positive infinity.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21135,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 21154,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21157,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 21181,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21186,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 21208,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Always returns true because two intervals going to positive infinity\n        always overlap.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21211,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 21230,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21233,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 21257,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect or if\n            the given interval is empty.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));\n--------------------\n",
								"type": "const Interval!TP(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21266,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 21286,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1999, 1 , 12)));\n--------------------\n",
								"type": "const pure nothrow PosInfInterval(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21289,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 21312,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 1, 12)));\n--------------------\n",
								"type": "const Interval!TP(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21319,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 21341,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1999, 1, 12)).isAdjacent(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21346,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 21368,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Always returns false because two intervals going to positive infinity\n        can never be adjacent to one another.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Example:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            PosInfInterval!Date(Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21371,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 21390,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21393,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 21423,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if the given interval is empty.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const PosInfInterval(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21431,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 21457,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const pure nothrow PosInfInterval(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21460,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 21496,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(500, 8, 9), Date(1602, 1, 31))) ==\n       PosInfInterval!Date(Date(500, 8, 9)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const pure PosInfInterval(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21501,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 21530,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Example:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const pure nothrow PosInfInterval(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21533,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "shift",
										"line": 21557,
										"type": "pure nothrow void(D duration)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											}
										],
										"endline": 21561,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "shift",
								"line": 21557,
								"comment": "        Shifts the $(D begin) of this interval forward or backwards in time by\n        the given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D begin += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Example:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, begin + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "expand",
										"line": 21630,
										"type": "pure nothrow void(D duration)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											}
										],
										"endline": 21634,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "expand",
								"line": 21630,
								"comment": "        Expands the interval backwards in time. Effectively, it does\n        $(D begin -= duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n\n        Example:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == PosInfInterval!Date(Date(1995, 12, 31)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == PosInfInterval!Date(Date(1996, 1, 4)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, begin + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "fwdRange",
								"line": 21759,
								"comment": "        Returns a range which iterates forward over the interval, starting\n        at $(D begin), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D begin). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point less than or equal to the\n        current $(D front) of the range, then a $(LREF DateTimeException) will be\n        thrown.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D fwdRange). Their documentation starts with\n        \"Range-generating function,\" to make them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Example:\n--------------------\nauto interval = PosInfInterval!Date(Date(2010, 9, 1));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date + dur!\"days\"(2);\n\n                return date + dur!\"days\"(1);\n            };\nauto range = interval.fwdRange(func);\n\n//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).\nassert(range.front == Date(2010, 9, 1));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(!range.empty);\n--------------------\n",
								"type": "const PosInfIntervalRange!TP(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
								"parameters": [
									{
										"name": "func",
										"type": "TP delegate(in TP)"
									},
									{
										"name": "popFirst",
										"type": "PopFirst",
										"default": "PopFirst.no"
									}
								],
								"endline": 21767,
								"char": 30,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 21788,
								"comment": "        Converts this interval to a string.\n",
								"type": "const nothrow string()",
								"endline": 21791,
								"char": 12,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "PosInfInterval",
				"line": 20794,
				"comment": "    Represents an interval of time which has positive infinity as its end point.\n\n    Any ranges which iterate over a $(D PosInfInterval) are infinite. So, the\n    main purpose of using $(D PosInfInterval) is to create an infinite range\n    which starts at a fixed point in time and goes to positive infinity.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "NegInfInterval",
						"line": 22986,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 22999,
								"comment": "        Params:\n            end = The time point which ends the interval.\n\n        Example:\n--------------------\nauto interval = PosInfInterval!Date(Date(1996, 1, 2));\n--------------------\n",
								"type": "pure nothrow (in TP end)",
								"parameters": [
									{
										"name": "end",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23002,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 23009,
								"comment": "        Params:\n            rhs = The $(D NegInfInterval) to assign to this one.\n",
								"type": "pure nothrow ref NegInfInterval(ref const NegInfInterval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "NegInfInterval",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 23013,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 23020,
								"comment": "        Params:\n            rhs = The $(D NegInfInterval) to assign to this one.\n",
								"type": "pure nothrow ref NegInfInterval(NegInfInterval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "NegInfInterval"
									}
								],
								"endline": 23024,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "end",
								"line": 23035,
								"comment": "        The end point of the interval. It is excluded from the interval.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).end == Date(2012, 3, 1));\n--------------------\n",
								"type": "const pure nothrow @property TP()",
								"endline": 23038,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "end",
								"line": 23047,
								"comment": "        The end point of the interval. It is excluded from the interval.\n\n        Params:\n            timePoint = The time point to set end to.\n",
								"type": "pure nothrow @property void(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 23050,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 23061,
								"comment": "        Whether the interval's length is 0. Always returns false.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(1996, 1, 2)).empty);\n--------------------\n",
								"type": "const pure nothrow @property bool()",
								"endline": 23064,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 23080,
								"comment": "        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(1994, 12, 24)));\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2000, 1, 5)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure nothrow bool(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 23083,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 23107,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23112,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 23130,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Always returns false because an interval beginning at negative\n        infinity can never contain an interval going to positive infinity.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23133,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 23151,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23154,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 23171,
								"comment": "        Whether this interval is before the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is\n                        before it.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(1994, 12, 24)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2000, 1, 5)));\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure nothrow bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23174,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 23199,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23204,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 23223,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23226,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 23249,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval beginning at negative\n        infinity can never be before another interval beginning at negative\n        infinity.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23252,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 23272,
								"comment": "        Whether this interval is after the given time point.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(1994, 12, 24)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2000, 1, 5)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure nothrow bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23275,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 23304,
								"comment": "        Whether this interval is after the given interval and does not\n        intersect it.\n\n        Always returns false (unless the given interval is empty) because an\n        interval beginning at negative infinity can never be after any other\n        interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23309,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 23331,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any other interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23334,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 23356,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any other interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23359,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 23383,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23388,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 23407,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23410,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 23431,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Always returns true because two intervals beginning at negative infinity\n        always overlap.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23434,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 23458,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect or if\n            the given interval is empty.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2000, 8, 2)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n",
								"type": "const Interval!TP(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23467,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 23490,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n",
								"type": "const Interval!TP(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23497,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 23517,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(1999, 7 , 6)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n--------------------\n",
								"type": "const nothrow NegInfInterval(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23520,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 23548,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1999, 1, 12), Date(2012, 3, 1))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2012, 3, 1), Date(2019, 2, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23553,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 23572,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23575,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 23597,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Always returns false because two intervals beginning at negative\n        infinity can never be adjacent to one another.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Example:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23600,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 23630,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if the given interval is empty.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       NegInfInterval!Date(Date(2015, 9 , 2)));\n--------------------\n",
								"type": "const NegInfInterval(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23638,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 23664,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n",
								"type": "const pure nothrow NegInfInterval(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23667,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 23703,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       NegInfInterval!Date(Date(2015, 9 , 2)));\n\nassert(NegInfInterval!Date(Date(1600, 1, 7)).span(\n            Interval!Date(Date(2012, 3, 11), Date(2017, 7, 1))) ==\n       NegInfInterval!Date(Date(2017, 7 , 1)));\n--------------------\n",
								"type": "const pure NegInfInterval(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23708,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 23737,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Example:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n",
								"type": "const pure nothrow NegInfInterval(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23740,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "shift",
										"line": 23764,
										"type": "pure nothrow void(D duration)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											}
										],
										"endline": 23768,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "shift",
								"line": 23764,
								"comment": "        Shifts the $(D end) of this interval forward or backwards in time by the\n        given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Example:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 4, 5));\nauto interval2 = NegInfInterval!Date(Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == NegInfInterval!Date(Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == NegInfInterval!Date( Date(2012, 2, 15)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, end + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "expand",
										"line": 23836,
										"type": "pure nothrow void(D duration)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											}
										],
										"endline": 23840,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "expand",
								"line": 23836,
								"comment": "        Expands the interval forwards in time. Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n\n        Example:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 3, 1));\nauto interval2 = NegInfInterval!Date(Date(2012, 3, 1));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == NegInfInterval!Date(Date(2012, 3, 3)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == NegInfInterval!Date(Date(2012, 2, 28)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, end + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "bwdRange",
								"line": 23964,
								"comment": "        Returns a range which iterates backwards over the interval, starting\n        at $(D end), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D end). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point greater than or equal to\n        the current $(D front) of the range, then a $(LREF DateTimeException) will\n        be thrown.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D bwdRange). Their documentation starts with\n        \"Range-generating function,\" to make them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Example:\n--------------------\nauto interval = NegInfInterval!Date(Date(2010, 9, 9));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date - dur!\"days\"(2);\n\n                return date - dur!\"days\"(1);\n            };\nauto range = interval.bwdRange(func);\n\nassert(range.front == Date(2010, 9, 9)); //An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(!range.empty);\n--------------------\n",
								"type": "const NegInfIntervalRange!TP(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
								"parameters": [
									{
										"name": "func",
										"type": "TP delegate(in TP)"
									},
									{
										"name": "popFirst",
										"type": "PopFirst",
										"default": "PopFirst.no"
									}
								],
								"endline": 23972,
								"char": 30,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 23993,
								"comment": "        Converts this interval to a string.\n",
								"type": "const nothrow string()",
								"endline": 23996,
								"char": 12,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "NegInfInterval",
				"line": 22986,
				"comment": "    Represents an interval of time which has negative infinity as its starting\n    point.\n\n    Any ranges which iterate over a $(D NegInfInterval) are infinite. So, the\n    main purpose of using $(D NegInfInterval) is to create an infinite range\n    which starts at negative infinity and goes to a fixed end point.\n    Iterate over it in reverse.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "everyDayOfWeek",
						"line": 25208,
						"type": "nothrow TP delegate(in TP)(DayOfWeek dayOfWeek)",
						"parameters": [
							{
								"name": "dayOfWeek",
								"type": "DayOfWeek"
							}
						],
						"endline": 25229,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "everyDayOfWeek",
				"line": 25208,
				"comment": "    Range-generating function.\n\n    Returns a delegate which returns the next time point with the given\n    $(D DayOfWeek) in a range.\n\n    Using this delegate allows iteration over successive time points which\n    are all the same day of the week. e.g. passing $(D DayOfWeek.mon) to\n    $(D everyDayOfWeek) would result in a delegate which could be used to\n    iterate over all of the Mondays in a range.\n\n    Params:\n        dir       = The direction to iterate in. If passing the return value to\n                    $(D fwdRange), use $(D Direction.fwd). If passing it to\n                    $(D bwdRange), use $(D Direction.bwd).\n        dayOfWeek = The week that each time point in the range will be.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL25232_1046)\n---\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));\nauto func = everyDayOfWeek!Date(DayOfWeek.mon);\nauto range = interval.fwdRange(func);\n\n//A Thursday. Using PopFirst.yes would have made this Date(2010, 9, 6).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 13));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 20));\n\nrange.popFront();\nassert(range.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL25232_1046)\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					},
					{
						"name": "dir",
						"defaultValue": "Direction.fwd",
						"deco": "E3std8datetime9Direction",
						"kind": "value"
					}
				],
				"constraint": "isTimePoint!TP && (dir == Direction.fwd || dir == Direction.bwd) && __traits(hasMember, TP, \"dayOfWeek\") && !__traits(isStaticFunction, TP.dayOfWeek) && is(typeof(TP.dayOfWeek) == DayOfWeek)",
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "everyMonth",
						"line": 25312,
						"type": "TP delegate(in TP)(int month)",
						"parameters": [
							{
								"name": "month",
								"deco": "i"
							}
						],
						"endline": 25343,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "everyMonth",
				"line": 25312,
				"comment": "    Range-generating function.\n\n    Returns a delegate which returns the next time point with the given month\n    which would be reached by adding months to the given time point.\n\n    So, using this delegate allows iteration over successive time points\n    which are in the same month but different years. For example,\n    iterate over each successive December 25th in an interval by starting with a\n    date which had the 25th as its day and passed $(D Month.dec) to\n    $(D everyMonth) to create the delegate.\n\n    Since it wouldn't really make sense to be iterating over a specific month\n    and end up with some of the time points in the succeeding month or two years\n    after the previous time point, $(D AllowDayOverflow.no) is always used when\n    calculating the next time point.\n\n    Params:\n        dir   = The direction to iterate in. If passing the return value to\n                $(D fwdRange), use $(D Direction.fwd). If passing it to\n                $(D bwdRange), use $(D Direction.bwd).\n        month = The month that each time point in the range will be in.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL25346_1048)\n---\nauto interval = Interval!Date(Date(2000, 1, 30), Date(2004, 8, 5));\nauto func = everyMonth!(Date)(Month.feb);\nauto range = interval.fwdRange(func);\n\n//Using PopFirst.yes would have made this Date(2010, 2, 29).\nassert(range.front == Date(2000, 1, 30));\n\nrange.popFront();\nassert(range.front == Date(2000, 2, 29));\n\nrange.popFront();\nassert(range.front == Date(2001, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2002, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2003, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2004, 2, 28));\n\nrange.popFront();\nassert(range.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL25346_1048)\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					},
					{
						"name": "dir",
						"defaultValue": "Direction.fwd",
						"deco": "E3std8datetime9Direction",
						"kind": "value"
					}
				],
				"constraint": "isTimePoint!TP && (dir == Direction.fwd || dir == Direction.bwd) && __traits(hasMember, TP, \"month\") && !__traits(isStaticFunction, TP.month) && is(typeof(TP.month) == Month)",
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "everyDuration",
						"line": 25435,
						"type": "nothrow TP delegate(in TP)(D duration)",
						"parameters": [
							{
								"name": "duration",
								"type": "D"
							}
						],
						"endline": 25450,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "everyDuration",
				"line": 25435,
				"comment": "    Range-generating function.\n\n    Returns a delegate which returns the next time point which is the given\n    duration later.\n\n    Using this delegate allows iteration over successive time points which\n    are apart by the given duration e.g. passing $(D dur!\"days\"(3)) to\n    $(D everyDuration) would result in a delegate which could be used to iterate\n    over a range of days which are each 3 days apart.\n\n    Params:\n        dir      = The direction to iterate in. If passing the return value to\n                   $(D fwdRange), use $(D Direction.fwd). If passing it to\n                   $(D bwdRange), use $(D Direction.bwd).\n        duration = The duration which separates each successive time point in\n                   the range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL25453_1050)\n---\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));\nauto func = everyDuration!Date(dur!\"days\"(8));\nauto range = interval.fwdRange(func);\n\n//Using PopFirst.yes would have made this Date(2010, 9, 10).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 10));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 18));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 26));\n\nrange.popFront();\nassert(range.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL25453_1050)\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					},
					{
						"name": "dir",
						"defaultValue": "Direction.fwd",
						"deco": "E3std8datetime9Direction",
						"kind": "value"
					},
					{
						"name": "D",
						"kind": "type"
					}
				],
				"constraint": "isTimePoint!TP && __traits(compiles, TP.init + duration) && (dir == Direction.fwd || dir == Direction.bwd)",
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "everyDuration",
						"line": 25535,
						"type": "nothrow TP delegate(in TP)(int years, int months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes, D duration = dur!\"days\"(0))",
						"parameters": [
							{
								"name": "years",
								"deco": "i"
							},
							{
								"name": "months",
								"deco": "i",
								"default": "0"
							},
							{
								"name": "allowOverflow",
								"type": "AllowDayOverflow",
								"default": "AllowDayOverflow.yes"
							},
							{
								"name": "duration",
								"type": "D",
								"default": "dur!\"days\"(0)"
							}
						],
						"endline": 25569,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "everyDuration",
				"line": 25535,
				"comment": "    Range-generating function.\n\n    Returns a delegate which returns the next time point which is the given\n    number of years, month, and duration later.\n\n    The difference between this version of $(D everyDuration) and the version\n    which just takes a $(CXREF time, Duration) is that this one also takes the number of\n    years and months (along with an $(D AllowDayOverflow) to indicate whether\n    adding years and months should allow the days to overflow).\n\n    Note that if iterating forward, $(D add!\"years\"()) is called on the given\n    time point, then $(D add!\"months\"()), and finally the duration is added\n    to it. However, if iterating backwards, the duration is added first, then\n    $(D add!\"months\"()) is called, and finally $(D add!\"years\"()) is called.\n    That way, going backwards generates close to the same time points that\n    iterating forward does, but since adding years and months is not entirely\n    reversible (due to possible day overflow, regardless of whether\n    $(D AllowDayOverflow.yes) or $(D AllowDayOverflow.no) is used), it can't be\n    guaranteed that iterating backwards will give the same time points as\n    iterating forward would have (even assuming that the end of the range is a\n    time point which would be returned by the delegate when iterating forward\n    from $(D begin)).\n\n    Params:\n        dir           = The direction to iterate in. If passing the return\n                        value to $(D fwdRange), use $(D Direction.fwd). If\n                        passing it to $(D bwdRange), use $(D Direction.bwd).\n        years         = The number of years to add to the time point passed to\n                        the delegate.\n        months        = The number of months to add to the time point passed to\n                        the delegate.\n        allowOverflow = Whether the days should be allowed to overflow on\n                        $(D begin) and $(D end), causing their month to\n                        increment.\n        duration      = The duration to add to the time point passed to the\n                        delegate.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL25572_1052)\n---\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2025, 9, 27));\nauto func = everyDuration!Date(4, 1, AllowDayOverflow.yes, dur!\"days\"(2));\nauto range = interval.fwdRange(func);\n\n//Using PopFirst.yes would have made this Date(2014, 10, 12).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2014, 10, 4));\n\nrange.popFront();\nassert(range.front == Date(2018, 11, 6));\n\nrange.popFront();\nassert(range.front == Date(2022, 12, 8));\n\nrange.popFront();\nassert(range.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL25572_1052)\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					},
					{
						"name": "dir",
						"defaultValue": "Direction.fwd",
						"deco": "E3std8datetime9Direction",
						"kind": "value"
					},
					{
						"name": "D",
						"kind": "type"
					}
				],
				"constraint": "isTimePoint!TP && __traits(compiles, TP.init + duration) && __traits(compiles, TP.init.add!\"years\"(years)) && __traits(compiles, TP.init.add!\"months\"(months)) && (dir == Direction.fwd || dir == Direction.bwd)",
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "IntervalRange",
						"line": 25692,
						"members": [
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 25701,
								"comment": "        Params:\n            rhs = The $(D IntervalRange) to assign to this one.\n",
								"type": "pure nothrow ref IntervalRange(ref IntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "IntervalRange",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 25706,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 25710,
								"comment": " Ditto\n",
								"type": "pure nothrow ref IntervalRange(IntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "IntervalRange"
									}
								],
								"endline": 25713,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 25719,
								"comment": "        Whether this $(D IntervalRange) is empty.\n",
								"type": "const pure nothrow @property bool()",
								"endline": 25722,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 25731,
								"comment": "        The first time point in the range.\n\n        Throws:\n            $(LREF DateTimeException) if the range is empty.\n",
								"type": "const pure @property TP()",
								"endline": 25739,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 25758,
								"comment": "        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range. If the generated time point is beyond the edge\n        of the range, then $(D front) is set to that edge, and the range is then\n        empty. So, if iterating forwards, and the generated time point is\n        greater than the interval's $(D end), then $(D front) is set to\n        $(D end). If iterating backwards, and the generated time point is less\n        than the interval's $(D begin), then $(D front) is set to $(D begin).\n\n        Throws:\n            $(LREF DateTimeException) if the range is empty or if the generated\n            time point is in the wrong direction (i.e. if iterating\n            forward and the generated time point is before $(D front), or if\n            iterating backwards and the generated time point is after\n            $(D front)).\n",
								"type": "void()",
								"endline": 25784,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 25790,
								"comment": "        Returns a copy of $(D this).\n",
								"type": "pure nothrow @property IntervalRange()",
								"endline": 25793,
								"char": 29,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "interval",
								"line": 25799,
								"comment": "        The interval that this $(D IntervalRange) currently covers.\n",
								"type": "const pure nothrow @property Interval!TP()",
								"endline": 25802,
								"char": 27,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "func",
								"line": 25808,
								"comment": "        The function used to generate the next time point in the range.\n",
								"type": "pure nothrow @property TP delegate(in TP)()",
								"endline": 25811,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "direction",
								"line": 25817,
								"comment": "        The $(D Direction) that this range iterates in.\n",
								"type": "const pure nothrow @property Direction()",
								"endline": 25820,
								"char": 25,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "IntervalRange",
				"line": 25692,
				"comment": "    A range over an $(LREF2 .Interval, Interval).\n\n    $(D IntervalRange) is only ever constructed by $(LREF2 .Interval, Interval). However, when\n    it is constructed, it is given a function, $(D func), which is used to\n    generate the time points which are iterated over. $(D func) takes a time\n    point and returns a time point of the same type. For instance,\n    to iterate over all of the days in\n    the interval $(D Interval!Date), pass a function to $(LREF2 .Interval, Interval)'s $(D fwdRange)\n    where that function took a $(LREF Date) and returned a $(LREF Date) which was one\n    day later. That function would then be used by $(D IntervalRange)'s\n    $(D popFront) to iterate over the $(LREF Date)s in the interval.\n\n    If $(D dir == Direction.fwd), then a range iterates forward in time, whereas\n    if $(D dir == Direction.bwd), then it iterates backwards in time. So, if\n    $(D dir == Direction.fwd) then $(D front == interval.begin), whereas if\n    $(D dir == Direction.bwd) then $(D front == interval.end). $(D func) must\n    generate a time point going in the proper direction of iteration, or a\n    $(LREF DateTimeException) will be thrown. So, to iterate forward in\n    time, the time point that $(D func) generates must be later in time than the\n    one passed to it. If it's either identical or earlier in time, then a\n    $(LREF DateTimeException) will be thrown. To iterate backwards, then\n    the generated time point must be before the time point which was passed in.\n\n    If the generated time point is ever passed the edge of the range in the\n    proper direction, then the edge of that range will be used instead. So, if\n    iterating forward, and the generated time point is past the interval's\n    $(D end), then $(D front) becomes $(D end). If iterating backwards, and the\n    generated time point is before $(D begin), then $(D front) becomes\n    $(D begin). In either case, the range would then be empty.\n\n    Also note that while normally the $(D begin) of an interval is included in\n    it and its $(D end) is excluded from it, if $(D dir == Direction.bwd), then\n    $(D begin) is treated as excluded and $(D end) is treated as included. This\n    allows for the same behavior in both directions. This works because none of\n    $(LREF2 .Interval, Interval)'s functions which care about whether $(D begin) or $(D end) is\n    included or excluded are ever called by $(D IntervalRange). $(D interval)\n    returns a normal interval, regardless of whether $(D dir == Direction.fwd)\n    or if $(D dir == Direction.bwd), so any $(LREF2 .Interval, Interval) functions which are\n    called on it which care about whether $(D begin) or $(D end) are included or\n    excluded will treat $(D begin) as included and $(D end) as excluded.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					},
					{
						"name": "dir",
						"deco": "E3std8datetime9Direction",
						"kind": "value"
					}
				],
				"constraint": "isTimePoint!TP && dir != Direction.both",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "PosInfIntervalRange",
						"line": 26190,
						"members": [
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 26199,
								"comment": "        Params:\n            rhs = The $(D PosInfIntervalRange) to assign to this one.\n",
								"type": "pure nothrow ref PosInfIntervalRange(ref PosInfIntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "PosInfIntervalRange",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 26205,
								"char": 29,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 26209,
								"comment": " Ditto\n",
								"type": "pure nothrow ref PosInfIntervalRange(PosInfIntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "PosInfIntervalRange"
									}
								],
								"endline": 26212,
								"char": 29,
								"kind": "function"
							},
							{
								"name": "empty",
								"line": 26218,
								"comment": "        This is an infinite range, so it is never empty.\n",
								"deco": "b",
								"init": "false",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 26224,
								"comment": "        The first time point in the range.\n",
								"type": "const pure nothrow @property TP()",
								"endline": 26227,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 26238,
								"comment": "        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range.\n\n        Throws:\n            $(LREF DateTimeException) if the generated time point is less than\n            $(D front).\n",
								"type": "void()",
								"endline": 26245,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 26251,
								"comment": "        Returns a copy of $(D this).\n",
								"type": "pure nothrow @property PosInfIntervalRange()",
								"endline": 26254,
								"char": 35,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "interval",
								"line": 26260,
								"comment": "        The interval that this range currently covers.\n",
								"type": "const pure nothrow @property PosInfInterval!TP()",
								"endline": 26263,
								"char": 33,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "func",
								"line": 26269,
								"comment": "        The function used to generate the next time point in the range.\n",
								"type": "pure nothrow @property TP delegate(in TP)()",
								"endline": 26272,
								"char": 24,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "PosInfIntervalRange",
				"line": 26190,
				"comment": "    A range over a $(D PosInfInterval). It is an infinite range.\n\n    $(D PosInfIntervalRange) is only ever constructed by $(D PosInfInterval).\n    However, when it is constructed, it is given a function, $(D func), which\n    is used to generate the time points which are iterated over. $(D func)\n    takes a time point and returns a time point of the same type. For\n    instance, to iterate\n    over all of the days in the interval $(D PosInfInterval!Date), pass a function to\n    $(D PosInfInterval)'s $(D fwdRange) where that function took a $(LREF Date) and\n    returned a $(LREF Date) which was one day later. That function would then be\n    used by $(D PosInfIntervalRange)'s $(D popFront) to iterate over the\n    $(LREF Date)s in the interval - though obviously, since the range is infinite,\n    use a function such as $(D std.range.take) with it rather than\n    iterating over $(I all) of the dates.\n\n    As the interval goes to positive infinity, the range is always iterated over\n    forwards, never backwards. $(D func) must generate a time point going in\n    the proper direction of iteration, or a $(LREF DateTimeException) will be\n    thrown. So, the time points that $(D func) generates must be later in time\n    than the one passed to it. If it's either identical or earlier in time, then\n    a $(LREF DateTimeException) will be thrown.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					}
				],
				"constraint": "isTimePoint!TP",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "NegInfIntervalRange",
						"line": 26478,
						"members": [
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 26487,
								"comment": "        Params:\n            rhs = The $(D NegInfIntervalRange) to assign to this one.\n",
								"type": "pure nothrow ref NegInfIntervalRange(ref NegInfIntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "NegInfIntervalRange",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 26493,
								"char": 29,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 26497,
								"comment": " Ditto\n",
								"type": "pure nothrow ref NegInfIntervalRange(NegInfIntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "NegInfIntervalRange"
									}
								],
								"endline": 26500,
								"char": 29,
								"kind": "function"
							},
							{
								"name": "empty",
								"line": 26506,
								"comment": "        This is an infinite range, so it is never empty.\n",
								"deco": "b",
								"init": "false",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 26512,
								"comment": "        The first time point in the range.\n",
								"type": "const pure nothrow @property TP()",
								"endline": 26515,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 26526,
								"comment": "        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range.\n\n        Throws:\n            $(LREF DateTimeException) if the generated time point is greater than\n            $(D front).\n",
								"type": "void()",
								"endline": 26533,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 26539,
								"comment": "        Returns a copy of $(D this).\n",
								"type": "pure nothrow @property NegInfIntervalRange()",
								"endline": 26542,
								"char": 35,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "interval",
								"line": 26548,
								"comment": "        The interval that this range currently covers.\n",
								"type": "const pure nothrow @property NegInfInterval!TP()",
								"endline": 26551,
								"char": 33,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "func",
								"line": 26557,
								"comment": "        The function used to generate the next time point in the range.\n",
								"type": "pure nothrow @property TP delegate(in TP)()",
								"endline": 26560,
								"char": 24,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "NegInfIntervalRange",
				"line": 26478,
				"comment": "    A range over a $(D NegInfInterval). It is an infinite range.\n\n    $(D NegInfIntervalRange) is only ever constructed by $(D NegInfInterval).\n    However, when it is constructed, it is given a function, $(D func), which\n    is used to generate the time points which are iterated over. $(D func)\n    takes a time point and returns a time point of the same type. For\n    instance, to iterate\n    over all of the days in the interval $(D NegInfInterval!Date), pass a function to\n    $(D NegInfInterval)'s $(D bwdRange) where that function took a $(LREF Date) and\n    returned a $(LREF Date) which was one day earlier. That function would then be\n    used by $(D NegInfIntervalRange)'s $(D popFront) to iterate over the\n    $(LREF Date)s in the interval - though obviously, since the range is infinite,\n    use a function such as $(D std.range.take) with it rather than\n    iterating over $(I all) of the dates.\n\n    As the interval goes to negative infinity, the range is always iterated over\n    backwards, never forwards. $(D func) must generate a time point going in\n    the proper direction of iteration, or a $(LREF DateTimeException) will be\n    thrown. So, the time points that $(D func) generates must be earlier in time\n    than the one passed to it. If it's either identical or later in time, then a\n    $(LREF DateTimeException) will be thrown.\n\n    Also note that while normally the $(D end) of an interval is excluded from\n    it, $(D NegInfIntervalRange) treats it as if it were included. This allows\n    for the same behavior as with $(D PosInfIntervalRange). This works\n    because none of $(D NegInfInterval)'s functions which care about whether\n    $(D end) is included or excluded are ever called by\n    $(D NegInfIntervalRange). $(D interval) returns a normal interval, so any\n    $(D NegInfInterval) functions which are called on it which care about\n    whether $(D end) is included or excluded will treat $(D end) as excluded.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					}
				],
				"constraint": "isTimePoint!TP",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "TimeZone",
				"line": 26742,
				"comment": "    Represents a time zone. It is used with $(LREF SysTime) to indicate the time\n    zone of a $(LREF SysTime).\n",
				"members": [
					{
						"endchar": 5,
						"name": "name",
						"line": 26756,
						"comment": "        The name of the time zone per the TZ Database. This is the name used to\n        get a $(LREF2 .TimeZone, TimeZone) by name with $(D TimeZone.getTimeZone).\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of\n              Time Zones)\n",
						"deco": "xFNbNdNfZAya",
						"endline": 26759,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stdName",
						"line": 26769,
						"comment": "        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST is $(I not) in effect (e.g. PST). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Standard Time). Regardless, it is not the same as name.\n",
						"deco": "xFNbNdNfZAya",
						"endline": 26772,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dstName",
						"line": 26782,
						"comment": "        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST $(I is) in effect (e.g. PDT). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Daylight Time). Regardless, it is not the same as name.\n",
						"deco": "xFNbNdNfZAya",
						"endline": 26785,
						"char": 22,
						"kind": "function"
					},
					{
						"name": "hasDST",
						"line": 26794,
						"comment": "        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current dates\n        but will still return true for $(D hasDST) because the time zone did at\n        some point have DST.\n",
						"deco": "xFNbNdNfZb",
						"char": 29,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "dstInEffect",
						"line": 26806,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n",
						"deco": "xFNbNflZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"char": 19,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "utcToTZ",
						"line": 26817,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"char": 19,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "tzToUTC",
						"line": 26828,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"char": 19,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"endchar": 5,
						"name": "utcOffsetAt",
						"line": 26839,
						"comment": "        Returns what the offset from UTC is at the given std time.\n        It includes the DST offset in effect at that time (if any).\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n",
						"deco": "xFNbNflZS4core4time8Duration",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 26842,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getTimeZone",
						"line": 26873,
						"comment": "        Returns a $(LREF2 .TimeZone, TimeZone) with the give name per the TZ Database.\n\n        This returns a $(LREF PosixTimeZone) on Posix systems and a\n        $(LREF WindowsTimeZone) on Windows systems. For\n        $(LREF PosixTimeZone) on Windows, call $(D PosixTimeZone.getTimeZone)\n        directly and give it the location of the TZ Database time zone files on\n        disk.\n\n        On Windows, the given TZ Database name is converted to the corresponding\n        time zone name on Windows prior to calling\n        $(D WindowsTimeZone.getTimeZone). This function allows for\n        the same time zone names on both Windows and Posix systems.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of\n              Time Zones)<br>\n            $(WEB unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html,\n                  Windows <-> TZ Database Name Conversion Table)\n\n        Params:\n            name = The TZ Database name of the desired time zone\n\n        Throws:\n            $(LREF DateTimeException) if the given time zone could not be found.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL26899_1077)\n---\nauto tz = TimeZone.getTimeZone(\"America/Los_Angeles\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL26899_1077)\n",
						"deco": "FNfAyaZyC3std8datetime8TimeZone",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							}
						],
						"endline": 26896,
						"char": 32,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getInstalledTZNames",
						"line": 27227,
						"comment": "        Returns a list of the names of the time zones installed on the system.\n\n        Providing a sub-name narrows down the list of time zones (which\n        can number in the thousands). For example,\n        passing in \"America\" as the sub-name returns only the time zones which\n        begin with \"America\".\n\n        On Windows, this function will convert the Windows time zone names to\n        the corresponding TZ Database names with\n        $(D windowsTZNameToTZDatabaseName). To get the actual Windows time\n        zone names, use $(D WindowsTimeZone.getInstalledTZNames) directly.\n\n        Params:\n            subName = The first part of the time zones desired.\n\n        Throws:\n            $(D FileException) on Posix systems if it fails to read from disk.\n            $(LREF DateTimeException) on Windows systems if it fails to read the\n            registry.\n",
						"deco": "FNfAyaZAAya",
						"parameters": [
							{
								"name": "subName",
								"deco": "Aya",
								"default": "\"\""
							}
						],
						"endline": 27257,
						"char": 21,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 10,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "opCall",
						"line": 27317,
						"comment": "        $(LREF LocalTime) is a singleton class. $(LREF LocalTime) returns its only\n        instance.\n",
						"deco": "FNaNbNeZyC3std8datetime9LocalTime",
						"endline": 27321,
						"char": 33,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"name": "name",
						"line": 27342,
						"comment": "            The name of the time zone per the TZ Database. This is the name used to\n            get a $(LREF2 .TimeZone, TimeZone) by name with $(D TimeZone.getTimeZone).\n\n            Note that this always returns the empty string. This is because time\n            zones cannot be uniquely identified by the attributes given by the\n            OS (such as the $(D stdName) and $(D dstName)), and neither Posix\n            systems nor Windows systems provide an easy way to get the TZ\n            Database name of the local time zone.\n\n            See_Also:\n                $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n                  Database)<br>\n                $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List\n                  of Time Zones)\n",
						"deco": "xFNbNdNfZAya",
						"char": 35,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.name"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "stdName",
						"line": 27358,
						"comment": "        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST is $(I not) in effect (e.g. PST). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Standard Time). Regardless, it is not the same as name.\n\n        This property is overridden because the local time of the system could\n        change while the program is running and we need to determine it\n        dynamically rather than it being fixed like it would be with most time\n        zones.\n",
						"deco": "xFNbNdNeZAya",
						"endline": 27398,
						"char": 31,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.stdName"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "dstName",
						"line": 27429,
						"comment": "        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST $(I is) in effect (e.g. PDT). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Daylight Time). Regardless, it is not the same as name.\n\n        This property is overridden because the local time of the system could\n        change while the program is running and we need to determine it\n        dynamically rather than it being fixed like it would be with most time\n        zones.\n",
						"deco": "xFNbNdNeZAya",
						"endline": 27469,
						"char": 31,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstName"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "hasDST",
						"line": 27502,
						"comment": "        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current\n        dates but will still return true for $(D hasDST) because the time zone\n        did at some point have DST.\n",
						"deco": "xFNbNdNeZb",
						"endline": 27531,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.hasDST"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "dstInEffect",
						"line": 27562,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is in effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n",
						"deco": "xFNbNelZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27588,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstInEffect"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcToTZ",
						"line": 27609,
						"comment": "        Returns hnsecs in the local time zone using the standard C function\n        calls on Posix systems and the standard Windows system calls on Windows\n        systems to adjust the time to the appropriate time zone from std time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n\n        See_Also:\n            $(D TimeZone.utcToTZ)\n",
						"deco": "xFNbNelZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27625,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcToTZ"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "tzToUTC",
						"line": 27645,
						"comment": "        Returns std time using the standard C function calls on Posix systems\n        and the standard Windows system calls on Windows systems to adjust the\n        time to UTC from the appropriate time zone.\n\n        See_Also:\n            $(D TimeZone.tzToUTC)\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n",
						"deco": "xFNbNelZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"endline": 27677,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.tzToUTC"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "LocalTime",
				"line": 27309,
				"comment": "    A TimeZone which represents the current local time zone on\n    the system running your program.\n\n    This uses the underlying C calls to adjust the time rather than using\n    specific D code based off of system settings to calculate the time such as\n    $(LREF PosixTimeZone) and $(LREF WindowsTimeZone) do. That also means that it will\n    use whatever the current time zone is on the system, even if the system's\n    time zone changes while the program is running.\n",
				"base": "std.datetime.TimeZone",
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "opCall",
						"line": 27853,
						"comment": "        $(D UTC) is a singleton class. $(D UTC) returns its only instance.\n",
						"deco": "FNaNbNfZyC3std8datetime3UTC",
						"endline": 27856,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "hasDST",
						"line": 27862,
						"comment": "        Always returns false.\n",
						"deco": "xFNbNdNfZb",
						"endline": 27865,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.hasDST"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "dstInEffect",
						"line": 27871,
						"comment": "        Always returns false.\n",
						"deco": "xFNbNflZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27874,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstInEffect"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcToTZ",
						"line": 27887,
						"comment": "        Returns the given hnsecs without changing them at all.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n\n        See_Also:\n            $(D TimeZone.utcToTZ)\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27890,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcToTZ"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "tzToUTC",
						"line": 27919,
						"comment": "        Returns the given hnsecs without changing them at all.\n\n        See_Also:\n            $(D TimeZone.tzToUTC)\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"endline": 27922,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.tzToUTC"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcOffsetAt",
						"line": 27948,
						"comment": "        Returns a $(CXREF time, Duration) of 0.\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n",
						"deco": "xFNbNflZS4core4time8Duration",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27951,
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcOffsetAt"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "UTC",
				"line": 27846,
				"comment": "    A $(LREF2 .TimeZone, TimeZone) which represents UTC.\n",
				"base": "std.datetime.TimeZone",
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "hasDST",
						"line": 27985,
						"comment": "        Always returns false.\n",
						"deco": "xFNbNdNfZb",
						"endline": 27988,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.hasDST"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "dstInEffect",
						"line": 27994,
						"comment": "        Always returns false.\n",
						"deco": "xFNbNflZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27997,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstInEffect"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcToTZ",
						"line": 28008,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 28011,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcToTZ"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "tzToUTC",
						"line": 28035,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"endline": 28038,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.tzToUTC"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcOffsetAt",
						"line": 28061,
						"comment": "        Returns utcOffset as a $(CXREF time, Duration).\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n",
						"deco": "xFNbNflZS4core4time8Duration",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 28064,
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcOffsetAt"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 28073,
						"comment": "        Params:\n            utcOffset = This time zone's offset from UTC with west of UTC being\n                        negative (it is added to UTC to get the adjusted time).\n            stdName   = The $(D stdName) for this time zone.\n",
						"deco": "yFNaNfS4core4time8DurationAyaZyC3std8datetime14SimpleTimeZone",
						"parameters": [
							{
								"name": "utcOffset",
								"deco": "S4core4time8Duration"
							},
							{
								"name": "stdName",
								"deco": "Aya",
								"default": "\"\""
							}
						],
						"endline": 28081,
						"originalType": "immutable pure @safe (Duration utcOffset, string stdName = \"\")",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "utcOffset",
						"line": 28104,
						"comment": "        The amount of time the offset from UTC is (negative is west of UTC,\n        positive is east).\n",
						"deco": "xFNaNbNdNfZS4core4time8Duration",
						"endline": 28107,
						"char": 24,
						"kind": "function"
					}
				],
				"name": "SimpleTimeZone",
				"line": 27978,
				"comment": "    Represents a time zone with an offset (in minutes, west is negative) from\n    UTC but no DST.\n\n    It's primarily used as the time zone in the result of $(LREF SysTime)'s\n    $(D fromISOString), $(D fromISOExtString), and $(D fromSimpleString).\n\n    $(D name) and $(D dstName) are always the empty string since this time zone\n    has no DST, and while it may be meant to represent a time zone which is in\n    the TZ Database, obviously it's not likely to be following the exact rules\n    of any of the time zones in the TZ Database, so it makes no sense to set it.\n",
				"base": "std.datetime.TimeZone",
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "hasDST",
						"line": 28388,
						"comment": "        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current\n        dates but will still return true for $(D hasDST) because the time zone\n        did at some point have DST.\n",
						"deco": "xFNbNdNfZb",
						"endline": 28391,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.hasDST"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "dstInEffect",
						"line": 28403,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is in effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n",
						"deco": "xFNbNflZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 28416,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstInEffect"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcToTZ",
						"line": 28427,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 28441,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcToTZ"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "tzToUTC",
						"line": 28452,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"endline": 28487,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.tzToUTC"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"name": "defaultTZDatabaseDir",
						"line": 28496,
						"comment": "            The default directory where the TZ Database files are. It's empty\n            for Windows, since Windows doesn't have them.\n",
						"deco": "Aya",
						"init": "\"/usr/share/zoneinfo/\"",
						"char": 14,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					},
					{
						"endchar": 5,
						"name": "getTimeZone",
						"line": 28532,
						"comment": "        Returns a $(LREF2 .TimeZone, TimeZone) with the give name per the TZ Database. The time\n        zone information is fetched from the TZ Database time zone files in the\n        given directory.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of\n              Time Zones)\n\n        Params:\n            name          = The TZ Database name of the desired time zone\n            tzDatabaseDir = The directory where the TZ Database files are\n                            located. Because these files are not located on\n                            Windows systems, provide them\n                            and give their location here to\n                            use $(LREF PosixTimeZone)s.\n\n        Throws:\n            $(LREF DateTimeException) if the given time zone could not be found or\n            $(D FileException) if the TZ Database file could not be opened.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL28837_1094)\n---\nversion(Posix)\n{\n    auto tz = PosixTimeZone.getTimeZone(\"America/Los_Angeles\");\n\n    assert(tz.name == \"America/Los_Angeles\");\n    assert(tz.stdName == \"PST\");\n    assert(tz.dstName == \"PDT\");\n}\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL28837_1094)\n",
						"deco": "FNeAyaAyaZyC3std8datetime13PosixTimeZone",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							},
							{
								"name": "tzDatabaseDir",
								"deco": "Aya",
								"default": "\"/usr/share/zoneinfo/\""
							}
						],
						"endline": 28834,
						"originalType": "@trusted immutable(PosixTimeZone)(string name, string tzDatabaseDir = defaultTZDatabaseDir)",
						"char": 37,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getInstalledTZNames",
						"line": 28865,
						"comment": "        Returns a list of the names of the time zones installed on the system.\n\n        Providing a sub-name narrows down the list of time zones (which\n        can number in the thousands). For example,\n        passing in \"America\" as the sub-name returns only the time zones which\n        begin with \"America\".\n\n        Params:\n            subName       = The first part of the desired time zones.\n            tzDatabaseDir = The directory where the TZ Database files are\n                            located.\n\n        Throws:\n            $(D FileException) if it fails to read from disk.\n",
						"deco": "FNeAyaAyaZAAya",
						"parameters": [
							{
								"name": "subName",
								"deco": "Aya",
								"default": "\"\""
							},
							{
								"name": "tzDatabaseDir",
								"deco": "Aya",
								"default": "\"/usr/share/zoneinfo/\""
							}
						],
						"endline": 28905,
						"originalType": "@trusted string[](string subName = \"\", string tzDatabaseDir = defaultTZDatabaseDir)",
						"char": 21,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"name": "PosixTimeZone",
				"line": 28373,
				"comment": "    Represents a time zone from a TZ Database time zone file. Files from the TZ\n    Database are how Posix systems hold their time zone information.\n    Unfortunately, Windows does not use the TZ Database. To use the TZ Database,\n    use $(D PosixTimeZone) (which reads its information from the TZ Database\n    files on disk) on Windows by providing the TZ Database files and telling\n    $(D PosixTimeZone.getTimeZone) where the directory holding them is.\n\n    To get a $(D PosixTimeZone), either call $(D PosixTimeZone.getTimeZone)\n    (which allows specifying the location the time zone files) or call\n    $(D TimeZone.getTimeZone) (which will give a $(D PosixTimeZone) on Posix\n    systems and a $(LREF WindowsTimeZone) on Windows systems).\n\n    Note:\n        Unless your system's local time zone deals with leap seconds (which is\n        highly unlikely), then the only way to get a time zone which\n        takes leap seconds into account is to use $(D PosixTimeZone) with a\n        time zone whose name starts with \"right/\". Those time zone files do\n        include leap seconds, and $(D PosixTimeZone) will take them into account\n        (though posix systems which use a \"right/\" time zone as their local time\n        zone will $(I not) take leap seconds into account even though they're\n        in the file).\n\n    See_Also:\n        $(WEB www.iana.org/time-zones, Home of the TZ Database files)<br>\n        $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ Database)<br>\n        $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of Time\n          Zones)\n",
				"base": "std.datetime.TimeZone",
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "hasDST",
						"line": 29210,
						"comment": "            Whether this time zone has Daylight Savings Time at any point in\n            time. Note that for some time zone types it may not have DST for\n            current dates but will still return true for $(D hasDST) because the\n            time zone did at some point have DST.\n",
						"deco": "xFNbNdNfZb",
						"char": 33,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.hasDST"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"name": "dstInEffect",
						"line": 29222,
						"comment": "            Takes the number of hnsecs (100 ns) since midnight, January 1st,\n            1 A.D. in UTC time (i.e. std time) and returns whether DST is in\n            effect in this time zone at the given point in time.\n\n            Params:\n                stdTime = The UTC time that needs to be checked for DST in this\n                          time zone.\n",
						"deco": "xFNbNflZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstInEffect"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"name": "utcToTZ",
						"line": 29234,
						"comment": "            Takes the number of hnsecs (100 ns) since midnight, January 1st,\n            1 A.D. in UTC time (i.e. std time) and converts it to this time\n                zone's time.\n\n            Params:\n                stdTime = The UTC time that needs to be adjusted to this time\n                          zone's time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcToTZ"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"name": "tzToUTC",
						"line": 29246,
						"comment": "            Takes the number of hnsecs (100 ns) since midnight, January 1st,\n            1 A.D. in this time zone's time and converts it to UTC (i.e. std\n            time).\n\n            Params:\n                adjTime = The time in this time zone that needs to be adjusted\n                          to UTC time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.tzToUTC"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"name": "getTimeZone",
						"line": 29272,
						"comment": "            Returns a $(LREF2 .TimeZone, TimeZone) with the given name per the Windows time\n            zone names. The time zone information is fetched from the Windows\n            registry.\n\n            See_Also:\n                $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n                  Database)<br>\n                $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List\n                  of Time Zones)\n\n            Params:\n                name = The TZ Database name of the desired time zone.\n\n            Throws:\n                $(LREF DateTimeException) if the given time zone could not be\n                found.\n\n            Example:\n    --------------------\n    auto tz = TimeZone.getTimeZone(\"America/Los_Angeles\");\n    --------------------\n",
						"deco": "FNfAyaZyC3std8datetime15WindowsTimeZone",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							}
						],
						"char": 43,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"name": "getInstalledTZNames",
						"line": 29282,
						"comment": "            Returns a list of the names of the time zones installed on the\n            system. The list returned by WindowsTimeZone contains the Windows\n            TZ names, not the TZ Database names. However,\n            $(D TimeZone.getinstalledTZNames) will return the TZ Database names\n            which are equivalent to the Windows TZ names.\n",
						"deco": "FNfZAAya",
						"char": 25,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"name": "WindowsTimeZone",
				"line": 29200,
				"comment": "        $(BLUE This class is Windows-Only.)\n\n        Represents a time zone from the Windows registry. Unfortunately, Windows\n        does not use the TZ Database. To use the TZ Database, use\n        $(LREF PosixTimeZone) (which reads its information from the TZ Database\n        files on disk) on Windows by providing the TZ Database files and telling\n        $(D PosixTimeZone.getTimeZone) where the directory holding them is.\n\n        The TZ Database files and Windows' time zone information frequently\n        do not match. Windows has many errors with regards to when DST switches\n        occur (especially for historical dates). Also, the TZ Database files\n        include far more time zones than Windows does. So, for accurate\n        time zone information, use the TZ Database files with\n        $(LREF PosixTimeZone) rather than $(D WindowsTimeZone). However, because\n        $(D WindowsTimeZone) uses Windows system calls to deal with the time,\n        it's far more likely to match the behavior of other Windows programs.\n        Be aware of the differences when selecting a method.\n\n        $(D WindowsTimeZone) does not exist on Posix systems.\n\n        To get a $(D WindowsTimeZone), either call\n        $(D WindowsTimeZone.getTimeZone) or call $(D TimeZone.getTimeZone)\n        (which will give a $(LREF PosixTimeZone) on Posix systems and a\n         $(D WindowsTimeZone) on Windows systems).\n\n        See_Also:\n            $(WEB www.iana.org/time-zones, Home of the TZ Database files)\n",
				"base": "std.datetime.TimeZone",
				"char": 11,
				"kind": "class"
			},
			{
				"name": "setTZEnvVar",
				"line": 29632,
				"comment": "        $(BLUE This function is Posix-Only.)\n\n        Sets the local time zone on Posix systems with the TZ\n        Database name by setting the TZ environment variable.\n\n        Unfortunately, there is no way to do it on Windows using the TZ\n        Database name, so this function only exists on Posix systems.\n",
				"deco": "FNbNfAyaZv",
				"parameters": [
					{
						"name": "tzDatabaseName",
						"deco": "Aya"
					}
				],
				"char": 10,
				"kind": "function"
			},
			{
				"name": "clearTZEnvVar",
				"line": 29640,
				"comment": "        $(BLUE This function is Posix-Only.)\n\n        Clears the TZ environment variable.\n",
				"deco": "FNbNfZv",
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "tzDatabaseNameToWindowsTZName",
				"line": 29690,
				"comment": "    Converts the given TZ Database name to the corresponding Windows time zone\n    name.\n\n    Note that in a few cases, a TZ Dabatase name corresponds to two different\n    Windows time zone names. So, while in most cases converting from one to the\n    other and back again will result in the same time zone name started\n    with, in a few case, it'll get a different name.\n\n    Also, there are far more TZ Database names than Windows time zones, so some\n    of the more exotic TZ Database names don't have corresponding Windows time\n    zone names.\n\n    Returns null if the given time zone name cannot be converted.\n\n    See_Also:\n        $(WEB unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html,\n              Windows <-> TZ Database Name Conversion Table)\n\n    Params:\n        tzName = The TZ Database name to convert.\n",
				"deco": "FNaNbNiNfAyaZAya",
				"parameters": [
					{
						"name": "tzName",
						"deco": "Aya"
					}
				],
				"endline": 30127,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "windowsTZNameToTZDatabaseName",
				"line": 30150,
				"comment": "    Converts the given Windows time zone name to a corresponding TZ Database\n    name.\n\n    Returns null if the given time zone name cannot be converted.\n\n    See_Also:\n        $(WEB unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html,\n              Windows <-> TZ Database Name Conversion Table)\n\n    Params:\n        tzName = The TZ Database name to convert.\n",
				"deco": "FNaNbNiNfAyaZAya",
				"parameters": [
					{
						"name": "tzName",
						"deco": "Aya"
					}
				],
				"endline": 30273,
				"char": 8,
				"kind": "function"
			},
			{
				"name": "StopWatch",
				"line": 30300,
				"comment": "   $(D StopWatch) measures time as precisely as possible.\n\n   This class uses a high-performance counter. On Windows systems, it uses\n   $(D QueryPerformanceCounter), and on Posix systems, it uses\n   $(D clock_gettime) if available, and $(D gettimeofday) otherwise.\n\n   But the precision of $(D StopWatch) differs from system to system. It is\n   impossible to for it to be the same from system to system since the precision\n   of the system clock varies from system to system, and other system-dependent\n   and situation-dependent stuff (such as the overhead of a context switch\n   between threads) can also affect $(D StopWatch)'s accuracy.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL30502_1107)\n---\nvoid writeln(S...)(S args){}\nstatic void bar() {}\n\nStopWatch sw;\nenum n = 100;\nTickDuration[n] times;\nTickDuration last = TickDuration.from!\"seconds\"(0);\nforeach(i; 0..n)\n{\n   sw.start(); //start/resume mesuring.\n   foreach(unused; 0..1_000_000)\n       bar();\n   sw.stop();  //stop/pause measuring.\n   //Return value of peek() after having stopped are the always same.\n   writeln((i + 1) * 1_000_000, \" times done, lap time: \",\n           sw.peek().msecs, \"[ms]\");\n   times[i] = sw.peek() - last;\n   last = sw.peek();\n}\nreal sum = 0;\n// To get the number of seconds,\n// use properties of TickDuration.\n// (seconds, msecs, usecs, hnsecs)\nforeach(t; times)\n   sum += t.hnsecs;\nwriteln(\"Average time: \", sum/n, \" hnsecs\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL30502_1107)\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 30307,
						"comment": "       Auto start with constructor.\n",
						"deco": "FNcNfE3std8datetime9AutoStartZS3std8datetime9StopWatch",
						"parameters": [
							{
								"name": "autostart",
								"deco": "E3std8datetime9AutoStart"
							}
						],
						"endline": 30311,
						"originalType": "ref @safe (AutoStart autostart)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 30321,
						"comment": "\n",
						"deco": "xFNaNbNfxS3std8datetime9StopWatchZb",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime9StopWatch"
							}
						],
						"endline": 30324,
						"originalType": "const pure nothrow @safe bool(const StopWatch rhs)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 30327,
						"comment": "ditto\n",
						"deco": "xFNaNbNfKxS3std8datetime9StopWatchZb",
						"parameters": [
							{
								"name": "rhs",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std8datetime9StopWatch"
							}
						],
						"endline": 30331,
						"originalType": "const pure nothrow @safe bool(ref const StopWatch rhs)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "reset",
						"line": 30337,
						"comment": "       Resets the stop watch.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL30354_1101)\n---\nStopWatch sw;\nsw.start();\nsw.stop();\nsw.reset();\nassert(sw.peek().to!(\"seconds\", real)() == 0);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL30354_1101)\n",
						"deco": "FNfZv",
						"endline": 30351,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "start",
						"line": 30367,
						"comment": "       Starts the stop watch.\n",
						"deco": "FNfZv",
						"endline": 30372,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stop",
						"line": 30393,
						"comment": "       Stops the stop watch.\n",
						"deco": "FNfZv",
						"endline": 30398,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "peek",
						"line": 30420,
						"comment": "       Peek at the amount of time which has passed since the stop watch was\n       started.\n",
						"deco": "xFNfZS4core4time12TickDuration",
						"endline": 30426,
						"char": 18,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setMeasured",
						"line": 30445,
						"comment": "       Set the amount of time which has been measured since the stop watch was\n       started.\n",
						"deco": "FNfS4core4time12TickDurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time12TickDuration"
							}
						],
						"endline": 30449,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "running",
						"line": 30465,
						"comment": "       Confirm whether this stopwatch is measuring time.\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 30468,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "benchmark",
						"line": 30554,
						"type": "TickDuration[fun.length](uint n)",
						"parameters": [
							{
								"name": "n",
								"deco": "k"
							}
						],
						"endline": 30569,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "benchmark",
				"line": 30554,
				"comment": "    Benchmarks code for speed assessment and comparison.\n\n    Params:\n        fun = aliases of callable objects (e.g. function names). Each should\n              take no arguments.\n        n   = The number of times each function is to be executed.\n\n    Returns:\n        The amount of time (as a $(CXREF time, TickDuration)) that it took to\n        call each function $(D n) times. The first value is the length of time\n        that it took to call $(D fun[0]) $(D n) times. The second value is the\n        length of time it took to call $(D fun[1]) $(D n) times. Etc.\n\n    Note that casting the TickDurations to $(CXREF time, Duration)s will make\n    the results easier to deal with (and it may change in the future that\n    benchmark will return an array of Durations rather than TickDurations).\n\n    See_Also:\n        $(LREF measureTime)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL30572_1108)\n---\nimport std.conv : to;\nint a;\nvoid f0() {}\nvoid f1() {auto b = a;}\nvoid f2() {auto b = to!string(a);}\nauto r = benchmark!(f0, f1, f2)(10_000);\nauto f0Result = to!Duration(r[0]); // time f0 took to run 10,000 times\nauto f1Result = to!Duration(r[1]); // time f1 took to run 10,000 times\nauto f2Result = to!Duration(r[2]); // time f2 took to run 10,000 times\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL30572_1108)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "tuple"
					}
				],
				"char": 26,
				"kind": "template"
			},
			{
				"name": "ComparingBenchmarkResult",
				"line": 30598,
				"comment": "   Return value of benchmark with two functions comparing.\n",
				"members": [
					{
						"endchar": 5,
						"name": "point",
						"line": 30607,
						"comment": "       Evaluation value\n\n       This returns the evaluation value of performance as the ratio of\n       baseFunc's time over targetFunc's time. If performance is high, this\n       returns a high value.\n",
						"deco": "xFNaNbNdNfZe",
						"endline": 30610,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "baseTime",
						"line": 30616,
						"comment": "       The time required of the base function\n",
						"deco": "xFNaNbNdNfZS4core4time12TickDuration",
						"endline": 30619,
						"char": 35,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "targetTime",
						"line": 30625,
						"comment": "       The time required of the target function\n",
						"deco": "xFNaNbNdNfZS4core4time12TickDuration",
						"endline": 30628,
						"char": 35,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "comparingBenchmark",
						"line": 30651,
						"type": "ComparingBenchmarkResult()",
						"endline": 30657,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "comparingBenchmark",
				"line": 30651,
				"comment": "   Benchmark with two functions comparing.\n\n   Params:\n       baseFunc   = The function to become the base of the speed.\n       targetFunc = The function that wants to measure speed.\n       times      = The number of times each function is to be executed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL30660_1110)\n---\nvoid f1x() {}\nvoid f2x() {}\n@safe void f1o() {}\n@safe void f2o() {}\nauto b1 = comparingBenchmark!(f1o, f2o, 1)(); // OK\n//writeln(b1.point);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL30660_1110)\n",
				"parameters": [
					{
						"name": "baseFunc",
						"kind": "alias"
					},
					{
						"name": "targetFunc",
						"kind": "alias"
					},
					{
						"name": "times",
						"defaultValue": "4095",
						"deco": "i",
						"kind": "value"
					}
				],
				"char": 26,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isTimePoint",
						"line": 30711,
						"init": "hasMin && hasMax && hasOverloadedOpBinaryWithDuration && hasOverloadedOpAssignWithDuration && hasOverloadedOpBinaryWithSelf && !is(U == Duration)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isTimePoint",
				"line": 30709,
				"comment": "    Whether the given type defines all of the necessary functions for it to\n    function as a time point.\n\n    1. $(D T) must define a static property named $(D min) which is the smallest\n       value of $(D T) as $(Unqual!T).\n\n    2. $(D T) must define a static property named $(D max) which is the largest\n       value of $(D T) as $(Unqual!T).\n\n    3. $(D T) must define an $(D opBinary) for addition and subtraction that\n       accepts $(CXREF time, Duration) and returns $(D Unqual!T).\n\n    4. $(D T) must define an $(D opOpAssign) for addition and subtraction that\n       accepts $(CXREF time, Duration) and returns $(D ref Unqual!T).\n\n    5. $(D T) must define a $(D opBinary) for subtraction which accepts $(D T)\n       and returns returns $(CXREF time, Duration).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL30752_1112)\n---\nstatic assert(isTimePoint!Date);\nstatic assert(isTimePoint!DateTime);\nstatic assert(isTimePoint!SysTime);\nstatic assert(isTimePoint!TimeOfDay);\n\nstatic assert(!isTimePoint!int);\nstatic assert(!isTimePoint!Duration);\nstatic assert(!isTimePoint!(Interval!SysTime));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL30752_1112)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "yearIsLeapYear",
				"line": 30785,
				"comment": "    Whether the given Gregorian Year is a leap year.\n\n    Params:\n        year = The year to to be tested.\n",
				"deco": "FNaNbNfiZb",
				"parameters": [
					{
						"name": "year",
						"deco": "i"
					}
				],
				"endline": 30794,
				"char": 13,
				"kind": "function",
				"storageClass": [
					"static"
				]
			},
			{
				"endchar": 1,
				"name": "unixTimeToStdTime",
				"line": 30840,
				"comment": "    Converts from unix time (which uses midnight, January 1st, 1970 UTC as its\n    epoch and seconds as its units) to \"std time\" (which uses midnight,\n    January 1st, 1 A.D. UTC and hnsecs as its units).\n\n    The C standard does not specify the representation of time_t, so it is\n    implementation defined. On POSIX systems, unix time is equivalent to\n    time_t, but that's not necessarily true on other systems (e.g. it is\n    not true for the Digital Mars C runtime). So, be careful when using unix\n    time with C functions on non-POSIX systems.\n\n    \"std time\"'s epoch is based on the Proleptic Gregorian Calendar per ISO\n    8601 and is what $(LREF SysTime) uses internally. However, holding the time\n    as an integer in hnescs since that epoch technically isn't actually part of\n    the standard, much as it's based on it, so the name \"std time\" isn't\n    particularly good, but there isn't an official name for it. C# uses \"ticks\"\n    for the same thing, but they aren't actually clock ticks, and the term\n    \"ticks\" $(I is) used for actual clock ticks for $(CXREF time, MonoTime), so\n    it didn't make sense to use the term ticks here. So, for better or worse,\n    std.datetime uses the term \"std time\" for this.\n\n    Params:\n        unixTime = The unix time to convert.\n\n    See_Also:\n        SysTime.fromUnixTime\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL30846_1115)\n---\n// Midnight, January 1st, 1970\nassert(unixTimeToStdTime(0) == 621_355_968_000_000_000L);\nassert(SysTime(unixTimeToStdTime(0)) ==\n       SysTime(DateTime(1970, 1, 1), UTC()));\n\nassert(unixTimeToStdTime(int.max) == 642_830_804_470_000_000L);\nassert(SysTime(unixTimeToStdTime(int.max)) ==\n       SysTime(DateTime(2038, 1, 19, 3, 14, 07), UTC()));\n\nassert(unixTimeToStdTime(-127_127) == 621_354_696_730_000_000L);\nassert(SysTime(unixTimeToStdTime(-127_127)) ==\n       SysTime(DateTime(1969, 12, 30, 12, 41, 13), UTC()));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL30846_1115)\n",
				"deco": "FNaNbNflZl",
				"parameters": [
					{
						"name": "unixTime",
						"deco": "l"
					}
				],
				"endline": 30843,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stdTimeToUnixTime",
						"line": 30921,
						"type": "pure nothrow @safe T(long stdTime)",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 30938,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "stdTimeToUnixTime",
				"line": 30921,
				"comment": "    Converts std time (which uses midnight, January 1st, 1 A.D. UTC as its epoch\n    and hnsecs as its units) to unix time (which uses midnight, January 1st,\n    1970 UTC as its epoch and seconds as its units).\n\n    The C standard does not specify the representation of time_t, so it is\n    implementation defined. On POSIX systems, unix time is equivalent to\n    time_t, but that's not necessarily true on other systems (e.g. it is\n    not true for the Digital Mars C runtime). So, be careful when using unix\n    time with C functions on non-POSIX systems.\n\n    \"std time\"'s epoch is based on the Proleptic Gregorian Calendar per ISO\n    8601 and is what $(LREF SysTime) uses internally. However, holding the time\n    as an integer in hnescs since that epoch technically isn't actually part of\n    the standard, much as it's based on it, so the name \"std time\" isn't\n    particularly good, but there isn't an official name for it. C# uses \"ticks\"\n    for the same thing, but they aren't actually clock ticks, and the term\n    \"ticks\" $(I is) used for actual clock ticks for $(CXREF time, MonoTime), so\n    it didn't make sense to use the term ticks here. So, for better or worse,\n    std.datetime uses the term \"std time\" for this.\n\n    By default, the return type is time_t (which is normally an alias for\n    int on 32-bit systems and long on 64-bit systems), but if a different\n    size is required than either int or long can be passed as a template\n    argument to get the desired size.\n\n    If the return type is int, and the result can't fit in an int, then the\n    closest value that can be held in 32 bits will be used (so $(D int.max)\n    if it goes over and $(D int.min) if it goes under). However, no attempt\n    is made to deal with integer overflow if the return type is long.\n\n    Params:\n        T = The return type (int or long). It defaults to time_t, which is\n            normally 32 bits on a 32-bit system and 64 bits on a 64-bit\n            system.\n        stdTime = The std time to convert.\n\n    Returns:\n        A signed integer representing the unix time which is equivalent to\n        the given std time.\n\n    See_Also:\n        SysTime.toUnixTime\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL30941_1117)\n---\n// Midnight, January 1st, 1970 UTC\nassert(stdTimeToUnixTime(621_355_968_000_000_000L) == 0);\n\n// 2038-01-19 03:14:07 UTC\nassert(stdTimeToUnixTime(642_830_804_470_000_000L) == int.max);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL30941_1117)\n",
				"parameters": [
					{
						"name": "T",
						"default": "time_t",
						"kind": "type"
					}
				],
				"constraint": "is(T == int) || is(T == long)",
				"char": 3,
				"kind": "template"
			},
			{
				"name": "SYSTEMTIMEToSysTime",
				"line": 31013,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a $(D SYSTEMTIME) struct to a $(LREF SysTime).\n\n        Params:\n            st = The $(D SYSTEMTIME) struct to convert.\n            tz = The time zone that the time in the $(D SYSTEMTIME) struct is\n                 assumed to be (if the $(D SYSTEMTIME) was supplied by a Windows\n                 system call, the $(D SYSTEMTIME) will either be in local time\n                 or UTC, depending on the call).\n\n        Throws:\n            $(LREF DateTimeException) if the given $(D SYSTEMTIME) will not fit in\n            a $(LREF SysTime), which is highly unlikely to happen given that\n            $(D SysTime.max) is in 29,228 A.D. and the maximum $(D SYSTEMTIME)\n            is in 30,827 A.D.\n",
				"deco": "FNfxPPvyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
				"parameters": [
					{
						"name": "st",
						"deco": "xPPv"
					},
					{
						"name": "tz",
						"deco": "yC3std8datetime8TimeZone",
						"default": "opCall()"
					}
				],
				"originalType": "@safe SysTime(const SYSTEMTIME* st, immutable TimeZone tz = LocalTime())",
				"char": 13,
				"kind": "function"
			},
			{
				"name": "SysTimeToSYSTEMTIME",
				"line": 31033,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a $(LREF SysTime) to a $(D SYSTEMTIME) struct.\n\n        The $(D SYSTEMTIME) which is returned will be set using the given\n        $(LREF SysTime)'s time zone, so to get the $(D SYSTEMTIME) in\n        UTC, set the $(LREF SysTime)'s time zone to UTC.\n\n        Params:\n            sysTime = The $(LREF SysTime) to convert.\n\n        Throws:\n            $(LREF DateTimeException) if the given $(LREF SysTime) will not fit in a\n            $(D SYSTEMTIME). This will only happen if the $(LREF SysTime)'s date is\n            prior to 1601 A.D.\n",
				"deco": "FNfxS3std8datetime7SysTimeZPv",
				"parameters": [
					{
						"name": "sysTime",
						"deco": "xS3std8datetime7SysTime"
					}
				],
				"originalType": "@safe SYSTEMTIME(in SysTime sysTime)",
				"char": 16,
				"kind": "function"
			},
			{
				"name": "FILETIMEToStdTime",
				"line": 31049,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a $(D FILETIME) struct to the number of hnsecs since midnight,\n        January 1st, 1 A.D.\n\n        Params:\n            ft = The $(D FILETIME) struct to convert.\n\n        Throws:\n            $(LREF DateTimeException) if the given $(D FILETIME) cannot be\n            represented as the return value.\n",
				"deco": "FNfxPPvZl",
				"parameters": [
					{
						"name": "ft",
						"deco": "xPPv"
					}
				],
				"originalType": "@safe long(const FILETIME* ft)",
				"char": 10,
				"kind": "function"
			},
			{
				"name": "FILETIMEToSysTime",
				"line": 31066,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a $(D FILETIME) struct to a $(LREF SysTime).\n\n        Params:\n            ft = The $(D FILETIME) struct to convert.\n            tz = The time zone that the $(LREF SysTime) will be in ($(D FILETIME)s\n                 are in UTC).\n\n        Throws:\n            $(LREF DateTimeException) if the given $(D FILETIME) will not fit in a\n            $(LREF SysTime).\n",
				"deco": "FNfxPPvyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
				"parameters": [
					{
						"name": "ft",
						"deco": "xPPv"
					},
					{
						"name": "tz",
						"deco": "yC3std8datetime8TimeZone",
						"default": "opCall()"
					}
				],
				"originalType": "@safe SysTime(const FILETIME* ft, immutable TimeZone tz = LocalTime())",
				"char": 13,
				"kind": "function"
			},
			{
				"name": "stdTimeToFILETIME",
				"line": 31082,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a number of hnsecs since midnight, January 1st, 1 A.D. to a\n        $(D FILETIME) struct.\n\n        Params:\n            stdTime = The number of hnsecs since midnight, January 1st, 1 A.D. UTC.\n\n        Throws:\n            $(LREF DateTimeException) if the given value will not fit in a\n            $(D FILETIME).\n",
				"deco": "FNflZPv",
				"parameters": [
					{
						"name": "stdTime",
						"deco": "l"
					}
				],
				"originalType": "@safe FILETIME(long stdTime)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "SysTimeToFILETIME",
				"line": 31099,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a $(LREF SysTime) to a $(D FILETIME) struct.\n\n        $(D FILETIME)s are always in UTC.\n\n        Params:\n            sysTime = The $(LREF SysTime) to convert.\n\n        Throws:\n            $(LREF DateTimeException) if the given $(LREF SysTime) will not fit in a\n            $(D FILETIME).\n",
				"deco": "FNfS3std8datetime7SysTimeZPv",
				"parameters": [
					{
						"name": "sysTime",
						"deco": "S3std8datetime7SysTime"
					}
				],
				"originalType": "@safe FILETIME(SysTime sysTime)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "DosFileTime",
				"line": 31279,
				"comment": "    Type representing the DOS file date/time format.\n",
				"deco": "k",
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "DosFileTimeToSysTime",
				"line": 31291,
				"comment": "    Converts from DOS file date/time to $(LREF SysTime).\n\n    Params:\n        dft = The DOS file time to convert.\n        tz  = The time zone which the DOS file time is assumed to be in.\n\n    Throws:\n        $(LREF DateTimeException) if the $(D DosFileTime) is invalid.\n",
				"deco": "FNfkyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
				"parameters": [
					{
						"name": "dft",
						"deco": "k"
					},
					{
						"name": "tz",
						"deco": "yC3std8datetime8TimeZone",
						"default": "opCall()"
					}
				],
				"endline": 31309,
				"originalType": "@safe SysTime(DosFileTime dft, immutable TimeZone tz = LocalTime())",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "SysTimeToDosFileTime",
				"line": 31334,
				"comment": "    Converts from $(LREF SysTime) to DOS file date/time.\n\n    Params:\n        sysTime = The $(LREF SysTime) to convert.\n\n    Throws:\n        $(LREF DateTimeException) if the given $(LREF SysTime) cannot be converted to\n        a $(D DosFileTime).\n",
				"deco": "FNfS3std8datetime7SysTimeZk",
				"parameters": [
					{
						"name": "sysTime",
						"deco": "S3std8datetime7SysTime"
					}
				],
				"endline": 31353,
				"originalType": "@safe DosFileTime(SysTime sysTime)",
				"char": 13,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseRFC822DateTime",
						"line": 31402,
						"type": "@safe SysTime(in char[] value)",
						"parameters": [
							{
								"name": "value",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 31406,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "parseRFC822DateTime",
				"line": 31402,
				"comment": "    The given array of $(D char) or random-access range of $(D char) or\n    $(D ubyte) is expected to be in the format specified in\n    $(WEB tools.ietf.org/html/rfc5322, RFC 5322) section 3.3 with the\n    grammar rule $(I date-time). It is the date-time format commonly used in\n    internet messages such as e-mail and HTTP. The corresponding\n    $(LREF SysTime) will be returned.\n\n    RFC 822 was the original spec (hence the function's name), whereas RFC 5322\n    is the current spec.\n\n    The day of the week is ignored beyond verifying that it's a valid day of the\n    week, as the day of the week can be inferred from the date. It is not\n    checked whether the given day of the week matches the actual day of the week\n    of the given date (though it is technically invalid per the spec if the\n    day of the week doesn't match the actual day of the week of the given date).\n\n    If the time zone is $(D \"-0000\") (or considered to be equivalent to\n    $(D \"-0000\") by section 4.3 of the spec), a $(LREF SimpleTimeZone) with a\n    utc offset of $(D 0) is used rather than $(LREF UTC), whereas $(D \"+0000\")\n    uses $(LREF UTC).\n\n    Note that because $(LREF SysTime) does not currently support having a second\n    value of 60 (as is sometimes done for leap seconds), if the date-time value\n    does have a value of 60 for the seconds, it is treated as 59.\n\n    The one area in which this function violates RFC 5322 is that it accepts\n    $(D \"\\n\") in folding whitespace in the place of $(D \"\\r\\n\"), because the\n    HTTP spec requires it.\n\n    Throws:\n        $(LREF DateTimeException) if the given string doesn't follow the grammar\n        for a date-time field or if the resulting $(LREF SysTime) is invalid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL31612_1125)\n---\nauto tz = new immutable SimpleTimeZone(hours(-8));\nassert(parseRFC822DateTime(\"Sat, 6 Jan 1990 12:14:19 -0800\") ==\n       SysTime(DateTime(1990, 1, 6, 12, 14, 19), tz));\n\nassert(parseRFC822DateTime(\"9 Jul 2002 13:11 +0000\") ==\n       SysTime(DateTime(2002, 7, 9, 13, 11, 0), UTC()));\n\nauto badStr = \"29 Feb 2001 12:17:16 +0200\";\nassertThrown!DateTimeException(parseRFC822DateTime(badStr));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL31612_1125)\n",
				"parameters": [],
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseRFC822DateTime",
						"line": 31409,
						"type": "@safe SysTime(R value)",
						"parameters": [
							{
								"name": "value",
								"type": "R"
							}
						],
						"endline": 31609,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "parseRFC822DateTime",
				"line": 31409,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && hasLength!R && (is(Unqual!(ElementType!R) == char) || is(Unqual!(ElementType!R) == ubyte))",
				"char": 9,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "validTimeUnits",
				"line": 32134,
				"comment": "    Whether all of the given strings are valid units of time.\n\n    $(D \"nsecs\") is not considered a valid unit of time. Nothing in std.datetime\n    can handle precision greater than hnsecs, and the few functions in core.time\n    which deal with \"nsecs\" deal with it explicitly.\n",
				"deco": "FNaNbNfAAyaXb",
				"parameters": [
					{
						"name": "units",
						"deco": "AAya"
					}
				],
				"endline": 32144,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "cmpTimeUnits",
				"line": 32162,
				"comment": "    Compares two time unit strings. $(D \"years\") are the largest units and\n    $(D \"hnsecs\") are the smallest.\n\n    Returns:\n        $(BOOKTABLE,\n        $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n        $(TR $(TD this == rhs) $(TD 0))\n        $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n        )\n\n    Throws:\n        $(LREF DateTimeException) if either of the given strings is not a valid\n        time unit string.\n",
				"deco": "FNaNfAyaAyaZi",
				"parameters": [
					{
						"name": "lhs",
						"deco": "Aya"
					},
					{
						"name": "rhs",
						"deco": "Aya"
					}
				],
				"endline": 32180,
				"char": 5,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "CmpTimeUnits",
						"line": 32220,
						"init": "cmpTimeUnitsCTFE(lhs, rhs)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "CmpTimeUnits",
				"line": 32217,
				"comment": "    Compares two time unit strings at compile time. $(D \"years\") are the largest\n    units and $(D \"hnsecs\") are the smallest.\n\n    This template is used instead of $(D cmpTimeUnits) because exceptions\n    can't be thrown at compile time and $(D cmpTimeUnits) must enforce that\n    the strings it's given are valid time unit strings. This template uses a\n    template constraint instead.\n\n    Returns:\n        $(BOOKTABLE,\n        $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n        $(TR $(TD this == rhs) $(TD 0))\n        $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n        )\n",
				"parameters": [
					{
						"name": "lhs",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "rhs",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "validTimeUnits(lhs, rhs)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "valid",
						"line": 32279,
						"type": "pure nothrow @safe bool(int value)",
						"parameters": [
							{
								"name": "value",
								"deco": "i"
							}
						],
						"endline": 32293,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "valid",
				"line": 32279,
				"comment": "    Returns whether the given value is valid for the given unit type when in a\n    time point. Naturally, a duration is not held to a particular range, but\n    the values in a time point are (e.g. a month must be in the range of\n    1 - 12 inclusive).\n\n    Params:\n        units = The units of time to validate.\n        value = The number to validate.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL32296_1138)\n---\nassert(valid!\"hours\"(12));\nassert(!valid!\"hours\"(32));\nassert(valid!\"months\"(12));\nassert(!valid!\"months\"(13));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL32296_1138)\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "units == \"months\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\"",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "valid",
						"line": 32314,
						"type": "pure nothrow @safe bool(int year, int month, int day)",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							},
							{
								"name": "month",
								"deco": "i"
							},
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 32318,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "valid",
				"line": 32314,
				"comment": "    Returns whether the given day is valid for the given year and month.\n\n    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "units == \"days\"",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforceValid",
						"line": 32332,
						"type": "pure @safe void(int value, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "value",
								"deco": "i"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 32360,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "enforceValid",
				"line": 32332,
				"comment": "    Params:\n        units = The units of time to validate.\n        value = The number to validate.\n        file  = The file that the $(LREF DateTimeException) will list if thrown.\n        line  = The line number that the $(LREF DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(LREF DateTimeException) if $(D valid!units(value)) is false.\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "units == \"months\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\"",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforceValid",
						"line": 32376,
						"type": "pure @safe void(int year, Month month, int day, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							},
							{
								"name": "month",
								"type": "Month"
							},
							{
								"name": "day",
								"deco": "i"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 32383,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "enforceValid",
				"line": 32376,
				"comment": "    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n        file  = The file that the $(LREF DateTimeException) will list if thrown.\n        line  = The line number that the $(LREF DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(LREF DateTimeException) if $(D valid!\"days\"(year, month, day)) is false.\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "units == \"days\"",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "monthsToMonth",
				"line": 32394,
				"comment": "    Returns the number of months from the current months of the year to the\n    given month of the year. If they are the same, then the result is 0.\n\n    Params:\n        currMonth = The current month of the year.\n        month     = The month of the year to get the number of months to.\n",
				"deco": "FNaNfiiZi",
				"parameters": [
					{
						"name": "currMonth",
						"deco": "i"
					},
					{
						"name": "month",
						"deco": "i"
					}
				],
				"endline": 32406,
				"char": 12,
				"kind": "function",
				"storageClass": [
					"static"
				]
			},
			{
				"endchar": 1,
				"name": "daysToDayOfWeek",
				"line": 32472,
				"comment": "    Returns the number of days from the current day of the week to the given\n    day of the week. If they are the same, then the result is 0.\n\n    Params:\n        currDoW = The current day of the week.\n        dow     = The day of the week to get the number of days to.\n",
				"deco": "FNaNbNfE3std8datetime9DayOfWeekE3std8datetime9DayOfWeekZi",
				"parameters": [
					{
						"name": "currDoW",
						"deco": "E3std8datetime9DayOfWeek"
					},
					{
						"name": "dow",
						"deco": "E3std8datetime9DayOfWeek"
					}
				],
				"endline": 32481,
				"char": 12,
				"kind": "function",
				"storageClass": [
					"static"
				]
			},
			{
				"members": [
					{
						"name": "measureTime",
						"line": 32579,
						"type": "()",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "measureTime",
				"line": 32579,
				"comment": "        Function for starting to a stop watch time when the function is called\n        and stopping it when its return value goes out of scope and is destroyed.\n\n        When the value that is returned by this function is destroyed,\n        $(D func) will run. $(D func) is a unary function that takes a\n        $(CXREF time, TickDuration).\n\n        Example:\n--------------------\n{\n    auto mt = measureTime!((TickDuration a)\n        { /+ do something when the scope is exited +/ });\n    // do something that needs to be timed\n}\n--------------------\n\n        which is functionally equivalent to\n\n--------------------\n{\n    auto sw = StopWatch(AutoStart.yes);\n    scope(exit)\n    {\n        TickDuration a = sw.peek();\n        /+ do something when the scope is exited +/\n    }\n    // do something that needs to be timed\n}\n--------------------\n\n        See_Also:\n            $(LREF benchmark)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "alias"
					}
				],
				"char": 10,
				"kind": "template"
			}
		],
		"comment": "    Module containing Date/Time functionality.\n\n    This module provides:\n    $(UL\n        $(LI Types to represent points in time: $(LREF SysTime), $(LREF Date),\n             $(LREF TimeOfDay), and $(LREF2 .DateTime, DateTime).)\n        $(LI Types to represent intervals of time.)\n        $(LI Types to represent ranges over intervals of time.)\n        $(LI Types to represent time zones (used by $(LREF SysTime)).)\n        $(LI A platform-independent, high precision stopwatch type:\n             $(LREF StopWatch))\n        $(LI Benchmarking functions.)\n        $(LI Various helper functions.)\n    )\n\n    Closely related to std.datetime is <a href=\"core_time.html\">$(D core.time)</a>,\n    and some of the time types used in std.datetime come from there - such as\n    $(CXREF time, Duration), $(CXREF time, TickDuration), and\n    $(CXREF time, FracSec).\n    core.time is publically imported into std.datetime, it isn't necessary\n    to import it separately.\n\n    Three of the main concepts used in this module are time points, time\n    durations, and time intervals.\n\n    A time point is a specific point in time. e.g. January 5th, 2010\n    or 5:00.\n\n    A time duration is a length of time with units. e.g. 5 days or 231 seconds.\n\n    A time interval indicates a period of time associated with a fixed point in\n    time. It is either two time points associated with each other,\n    indicating the time starting at the first point up to, but not including,\n    the second point - e.g. [January 5th, 2010 - March 10th, 2010$(RPAREN) - or\n    it is a time point and a time duration associated with one another. e.g.\n    January 5th, 2010 and 5 days, indicating [January 5th, 2010 -\n    January 10th, 2010$(RPAREN).\n\n    Various arithmetic operations are supported between time points and\n    durations (e.g. the difference between two time points is a time duration),\n    and ranges can be gotten from time intervals, so range-based operations may\n    be done on a series of time points.\n\n    The types that the typical user is most likely to be interested in are\n    $(LREF Date) (if they want dates but don't care about time), $(LREF DateTime)\n    (if they want dates and times but don't care about time zones), $(LREF SysTime)\n    (if they want the date and time from the OS and/or do care about time\n    zones), and StopWatch (a platform-independent, high precision stop watch).\n    $(LREF Date) and $(LREF DateTime) are optimized for calendar-based operations,\n    while $(LREF SysTime) is designed for dealing with time from the OS. Check out\n    their specific documentation for more details.\n\n    To get the current time, use $(LREF2 .Clock.currTime, Clock.currTime).\n    It will return the current\n    time as a $(LREF SysTime). To print it, $(D toString) is\n    sufficient, but if using $(D toISOString), $(D toISOExtString), or\n    $(D toSimpleString), use the corresponding $(D fromISOString),\n    $(D fromISOExtString), or $(D fromSimpleString) to create a\n    $(LREF SysTime) from the string.\n\n--------------------\nauto currentTime = Clock.currTime();\nauto timeString = currentTime.toISOExtString();\nauto restoredTime = SysTime.fromISOExtString(timeString);\n--------------------\n\n    Various functions take a string (or strings) to represent a unit of time\n    (e.g. $(D convert!(\"days\", \"hours\")(numDays))). The valid strings to use\n    with such functions are $(D \"years\"), $(D \"months\"), $(D \"weeks\"),\n    $(D \"days\"), $(D \"hours\"), $(D \"minutes\"), $(D \"seconds\"),\n    $(D \"msecs\") (milliseconds), $(D \"usecs\") (microseconds),\n    $(D \"hnsecs\") (hecto-nanoseconds - i.e. 100 ns), or some subset thereof.\n    There are a few functions in core.time which take $(D \"nsecs\"), but because\n    nothing in std.datetime has precision greater than hnsecs, and very little\n    in core.time does, no functions in std.datetime accept $(D \"nsecs\").\n    To remember which units are abbreviated and which aren't,\n    all units seconds and greater use their full names, and all\n    sub-second units are abbreviated (since they'd be rather long if they\n    weren't).\n\n    Note:\n        $(LREF DateTimeException) is an alias for $(CXREF time, TimeException),\n        so you don't need to worry about core.time functions and std.datetime\n        functions throwing different exception types (except in the rare case\n        that they throw something other than $(CXREF time, TimeException) or\n        $(LREF DateTimeException)).\n\n    See_Also:\n        $(DDLINK intro-to-_datetime, Introduction to std.datetime,\n                 Introduction to std&#46;_datetime)<br>\n        $(WEB en.wikipedia.org/wiki/ISO_8601, ISO 8601)<br>\n        $(WEB en.wikipedia.org/wiki/Tz_database,\n              Wikipedia entry on TZ Database)<br>\n        $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones,\n              List of Time Zones)<br>\n\n    Copyright: Copyright 2010 - 2015\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   Jonathan M Davis and Kato Shoichi\n    Source:    $(PHOBOSSRC std/_datetime.d)\n    Macros:\n        LREF2=<a href=\"#$1\">$(D $2)</a>\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/socket.d",
		"name": "std.socket",
		"members": [
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 149,
						"comment": "\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std6socket15SocketException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 152,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 155,
						"comment": "\n",
						"deco": "FNaNbNfAyaC6object9ThrowableAyamZC3std6socket15SocketException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 158,
						"originalType": "pure nothrow @safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "SocketException",
				"line": 146,
				"comment": "Base exception thrown by $(D std.socket).\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "lastSocketError",
				"line": 229,
				"comment": "Retrieve the error message for the most recently encountered network error.\n",
				"deco": "FNdNfZAya",
				"endline": 232,
				"char": 18,
				"kind": "function"
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "errorCode",
						"line": 238,
						"comment": "Platform-specific error code.\n",
						"deco": "i",
						"char": 9,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 241,
						"comment": "\n",
						"deco": "FNfAyaAyamC6object9ThrowableiPFNeiZAyaZC3std6socket17SocketOSException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							},
							{
								"name": "errorFormatter",
								"deco": "PFNeiZAya",
								"default": "& formatSocketError"
							}
						],
						"endline": 254,
						"originalType": "@safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr(), string function(int) @trusted errorFormatter = &formatSocketError)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 257,
						"comment": "\n",
						"deco": "FNfAyaC6object9ThrowableAyamiPFNeiZAyaZC3std6socket17SocketOSException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							},
							{
								"name": "errorFormatter",
								"deco": "PFNeiZAya",
								"default": "& formatSocketError"
							}
						],
						"endline": 265,
						"originalType": "@safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr(), string function(int) @trusted errorFormatter = &formatSocketError)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 268,
						"comment": "\n",
						"deco": "FNfAyaiPFNeiZAyaAyamC6object9ThrowableZC3std6socket17SocketOSException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "err",
								"deco": "i"
							},
							{
								"name": "errorFormatter",
								"deco": "PFNeiZAya",
								"default": "& formatSocketError"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 276,
						"originalType": "@safe (string msg, int err, string function(int) @trusted errorFormatter = &formatSocketError, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "SocketOSException",
				"line": 236,
				"comment": "Socket exceptions representing network errors reported by the operating\n\nsystem.\n",
				"base": "std.socket.SocketException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 283,
						"comment": "\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std6socket24SocketParameterException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 286,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 289,
						"comment": "\n",
						"deco": "FNaNbNfAyaC6object9ThrowableAyamZC3std6socket24SocketParameterException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 292,
						"originalType": "pure nothrow @safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "SocketParameterException",
				"line": 280,
				"comment": "Socket exceptions representing invalid parameters specified by user code.\n",
				"base": "std.socket.SocketException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 300,
						"comment": "\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std6socket22SocketFeatureException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 303,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 306,
						"comment": "\n",
						"deco": "FNaNbNfAyaC6object9ThrowableAyamZC3std6socket22SocketFeatureException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 309,
						"originalType": "pure nothrow @safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "SocketFeatureException",
				"line": 297,
				"comment": "Socket exceptions representing attempts to use network capabilities not\n\navailable on the current system.\n",
				"base": "std.socket.SocketException",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "wouldHaveBlocked",
				"line": 315,
				"comment": "Return $(D true) if the last socket operation failed because the socket\n\nwas in non-blocking mode and the operation would have blocked.\n",
				"deco": "FNbNiNfZb",
				"endline": 323,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "UNSPEC",
						"line": 381,
						"value": "0",
						"comment": "Unspecified address family\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "UNIX",
						"line": 382,
						"value": "1",
						"comment": "Local communication\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "INET",
						"line": 383,
						"value": "2",
						"comment": "Internet Protocol version 4\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPX",
						"line": 384,
						"value": "4",
						"comment": "Novell IPX\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "APPLETALK",
						"line": 385,
						"value": "5",
						"comment": "AppleTalk\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "INET6",
						"line": 386,
						"value": "10",
						"comment": "Internet Protocol version 6\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "AddressFamily",
				"line": 379,
				"comment": " The communication domain used to resolve an address.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "STREAM",
						"line": 395,
						"value": "1",
						"comment": "Sequenced, reliable, two-way communication-based byte streams\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "DGRAM",
						"line": 396,
						"value": "2",
						"comment": "Connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RAW",
						"line": 397,
						"value": "3",
						"comment": "Raw protocol access\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RDM",
						"line": 398,
						"value": "4",
						"comment": "Reliably-delivered message datagrams\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "SEQPACKET",
						"line": 399,
						"value": "5",
						"comment": "Sequenced, reliable, two-way connection-based datagrams with a fixed maximum length\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SocketType",
				"line": 393,
				"comment": " Communication semantics\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "IP",
						"line": 408,
						"value": "0",
						"comment": "Internet Protocol version 4\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ICMP",
						"line": 409,
						"value": "1",
						"comment": "Internet Control Message Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IGMP",
						"line": 410,
						"value": "2",
						"comment": "Internet Group Management Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "GGP",
						"line": 411,
						"value": "3",
						"comment": "Gateway to Gateway Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "TCP",
						"line": 412,
						"value": "6",
						"comment": "Transmission Control Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "PUP",
						"line": 413,
						"value": "12",
						"comment": "PARC Universal Packet Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "UDP",
						"line": 414,
						"value": "17",
						"comment": "User Datagram Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IDP",
						"line": 415,
						"value": "22",
						"comment": "Xerox NS protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RAW",
						"line": 416,
						"value": "255",
						"comment": "Raw IP packets\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6",
						"line": 417,
						"value": "41",
						"comment": "Internet Protocol version 6\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "ProtocolType",
				"line": 406,
				"comment": " Protocol\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Protocol",
				"line": 438,
				"comment": " $(D Protocol) is a class for retrieving protocol information.\n\n Example:\n ---\n auto proto = new Protocol;\n writeln(\"About protocol TCP:\");\n if (proto.getProtocolByType(ProtocolType.TCP))\n {\n     writefln(\"  Name: %s\", proto.name);\n     foreach(string s; proto.aliases)\n          writefln(\"  Alias: %s\", s);\n }\n else\n     writeln(\"  No information found\");\n ---\n",
				"members": [
					{
						"offset": 16,
						"name": "type",
						"line": 441,
						"comment": "These members are populated when one of the following functions are called successfully:\n",
						"deco": "E3std6socket12ProtocolType",
						"char": 18,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 24,
						"name": "name",
						"line": 442,
						"comment": "ditto\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 40,
						"name": "aliases",
						"line": 443,
						"comment": "ditto\n",
						"deco": "AAya",
						"char": 14,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "getProtocolByName",
						"line": 474,
						"comment": " Returns: false on failure\n",
						"deco": "FNbNexAaZb",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							}
						],
						"endline": 482,
						"originalType": "nothrow @trusted bool(in char[] name)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getProtocolByType",
						"line": 487,
						"comment": " Returns: false on failure\n",
						"deco": "FNbNeE3std6socket12ProtocolTypeZb",
						"parameters": [
							{
								"name": "type",
								"deco": "E3std6socket12ProtocolType"
							}
						],
						"endline": 495,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Service",
				"line": 536,
				"comment": " $(D Service) is a class for retrieving service information.\n\n Example:\n ---\n auto serv = new Service;\n writeln(\"About service epmap:\");\n if (serv.getServiceByName(\"epmap\", \"tcp\"))\n {\n     writefln(\"  Service: %s\", serv.name);\n     writefln(\"  Port: %d\", serv.port);\n     writefln(\"  Protocol: %s\", serv.protocolName);\n     foreach (string s; serv.aliases)\n          writefln(\"  Alias: %s\", s);\n }\n else\n     writefln(\"  No service for epmap.\");\n ---\n",
				"members": [
					{
						"offset": 16,
						"name": "name",
						"line": 539,
						"comment": "These members are populated when one of the following functions are called successfully:\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 32,
						"name": "aliases",
						"line": 540,
						"comment": "ditto\n",
						"deco": "AAya",
						"char": 14,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 48,
						"name": "port",
						"line": 541,
						"comment": "ditto\n",
						"deco": "t",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 56,
						"name": "protocolName",
						"line": 542,
						"comment": "ditto\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "getServiceByName",
						"line": 577,
						"comment": " If a protocol name is omitted, any protocol will be matched.\n Returns: false on failure.\n",
						"deco": "FNbNexAaxAaZb",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							},
							{
								"name": "protocolName",
								"deco": "xAa",
								"default": "null"
							}
						],
						"endline": 585,
						"originalType": "nothrow @trusted bool(in char[] name, in char[] protocolName = null)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getServiceByPort",
						"line": 589,
						"comment": "ditto\n",
						"deco": "FNbNetxAaZb",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							},
							{
								"name": "protocolName",
								"deco": "xAa",
								"default": "null"
							}
						],
						"endline": 597,
						"originalType": "nothrow @trusted bool(ushort port, in char[] protocolName = null)",
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 634,
						"comment": "\n",
						"deco": "FNfAyaAyamC6object9ThrowableiZC3std6socket13HostException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 637,
						"originalType": "@safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 640,
						"comment": "\n",
						"deco": "FNfAyaC6object9ThrowableAyamiZC3std6socket13HostException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 643,
						"originalType": "@safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 646,
						"comment": "\n",
						"deco": "FNfAyaiAyamC6object9ThrowableZC3std6socket13HostException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "err",
								"deco": "i"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 649,
						"originalType": "@safe (string msg, int err, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "HostException",
				"line": 631,
				"comment": " Class for exceptions thrown from an $(D InternetHost).\n",
				"base": "std.socket.SocketOSException",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "InternetHost",
				"line": 688,
				"comment": " $(D InternetHost) is a class for resolving IPv4 addresses.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n\n Example:\n ---\n auto ih = new InternetHost;\n\n // Forward lookup\n writeln(\"About www.digitalmars.com:\");\n if (ih.getHostByName(\"www.digitalmars.com\"))\n {\n     writefln(\"  Name: %s\", ih.name);\n     auto ip = InternetAddress.addrToString(ih.addrList[0]);\n     writefln(\"  IP address: %s\", ip);\n     foreach (string s; ih.aliases)\n          writefln(\"  Alias: %s\", s);\n     writeln(\"---\");\n\n     // Reverse lookup\n     writefln(\"About IP %s:\", ip);\n     if (ih.getHostByAddr(ih.addrList[0]))\n     {\n         writefln(\"  Name: %s\", ih.name);\n         foreach (string s; ih.aliases)\n              writefln(\"  Alias: %s\", s);\n     }\n     else\n         writeln(\"  Reverse lookup failed\");\n }\n else\n     writeln(\"  Can't resolve www.digitalmars.com\");\n ---\n",
				"members": [
					{
						"offset": 16,
						"name": "name",
						"line": 691,
						"comment": "These members are populated when one of the following functions are called successfully:\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 32,
						"name": "aliases",
						"line": 692,
						"comment": "ditto\n",
						"deco": "AAya",
						"char": 14,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 48,
						"name": "addrList",
						"line": 693,
						"comment": "ditto\n",
						"deco": "Ak",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "getHostByName",
						"line": 779,
						"comment": " Resolve host name.\n Returns: false if unable to resolve.\n",
						"deco": "FNexAaZb",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							}
						],
						"endline": 806,
						"originalType": "@trusted bool(in char[] name)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getHostByAddr",
						"line": 816,
						"comment": " Resolve IPv4 address number.\n\n Params:\n   addr = The IPv4 address to resolve, in host byte order.\n Returns:\n   false if unable to resolve.\n",
						"deco": "FNekZb",
						"parameters": [
							{
								"name": "addr",
								"deco": "k"
							}
						],
						"endline": 822,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getHostByAddr",
						"line": 829,
						"comment": " Same as previous, but addr is an IPv4 address string in the\n dotted-decimal form $(I a.b.c.d).\n Returns: false if unable to resolve.\n",
						"deco": "FNexAaZb",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							}
						],
						"endline": 837,
						"originalType": "@trusted bool(in char[] addr)",
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"name": "AddressInfo",
				"line": 877,
				"comment": "Holds information about a socket _address retrieved by $(D getAddressInfo).\n",
				"members": [
					{
						"offset": 0,
						"name": "family",
						"line": 879,
						"comment": "Address _family\n",
						"deco": "E3std6socket13AddressFamily",
						"char": 19,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 4,
						"name": "type",
						"line": 880,
						"comment": "Socket _type\n",
						"deco": "E3std6socket10SocketType",
						"char": 16,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 8,
						"name": "protocol",
						"line": 881,
						"comment": "Protocol\n",
						"deco": "E3std6socket12ProtocolType",
						"char": 18,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 16,
						"name": "address",
						"line": 882,
						"comment": "Socket _address\n",
						"deco": "C3std6socket7Address",
						"originalType": "Address",
						"char": 13,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 24,
						"name": "canonicalName",
						"line": 883,
						"comment": "Canonical name, when $(D AddressInfoFlags.CANONNAME) is used.\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "PASSIVE",
						"line": 891,
						"value": "1",
						"comment": "The resulting addresses will be used in a call to $(D Socket.bind).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "CANONNAME",
						"line": 894,
						"value": "2",
						"comment": "The canonical name is returned in $(D canonicalName) member in the first $(D AddressInfo).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "NUMERICHOST",
						"line": 898,
						"value": "4",
						"comment": "The $(D node) parameter passed to $(D getAddressInfo) must be a numeric string.\n\nThis will suppress any potentially lengthy network host address lookups.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "AddressInfoFlags",
				"line": 888,
				"comment": "Specifies option flags for $(D getAddressInfo).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "getAddressInfo",
						"line": 969,
						"type": "@trusted AddressInfo[](in char[] node, T options)",
						"parameters": [
							{
								"name": "node",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "options",
								"type": "T"
							}
						],
						"endline": 996,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "getAddressInfo",
				"line": 969,
				"comment": " Provides _protocol-independent translation from host names to socket\n addresses. If advanced functionality is not required, consider using\n $(D getAddress) for compatibility with older systems.\n\n Returns: Array with one $(D AddressInfo) per socket address.\n\n Throws: $(D SocketOSException) on failure, or $(D SocketFeatureException)\n if this functionality is not available on the current system.\n\n Params:\n  node     = string containing host name or numeric address\n  options  = optional additional parameters, identified by type:\n             $(UL $(LI $(D string) - service name or port number)\n                  $(LI $(D AddressInfoFlags) - option flags)\n                  $(LI $(D AddressFamily) - address family to filter by)\n                  $(LI $(D SocketType) - socket type to filter by)\n                  $(LI $(D ProtocolType) - protocol to filter by))\n\n Example:\n ---\n // Roundtrip DNS resolution\n auto results = getAddressInfo(\"www.digitalmars.com\");\n assert(results[0].address.toHostNameString() ==\n     \"digitalmars.com\");\n\n // Canonical name\n results = getAddressInfo(\"www.digitalmars.com\",\n     AddressInfoFlags.CANONNAME);\n assert(results[0].canonicalName == \"digitalmars.com\");\n\n // IPv6 resolution\n results = getAddressInfo(\"ipv6.google.com\");\n assert(results[0].family == AddressFamily.INET6);\n\n // Multihomed resolution\n results = getAddressInfo(\"google.com\");\n assert(results.length > 1);\n\n // Parsing IPv4\n results = getAddressInfo(\"127.0.0.1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET);\n\n // Parsing IPv6\n results = getAddressInfo(\"::1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET6);\n ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "getAddress",
				"line": 1110,
				"comment": " Provides _protocol-independent translation from host names to socket\n addresses. Uses $(D getAddressInfo) if the current system supports it,\n and $(D InternetHost) otherwise.\n\n Returns: Array with one $(D Address) instance per socket address.\n\n Throws: $(D SocketOSException) on failure.\n\n Example:\n ---\n writeln(\"Resolving www.digitalmars.com:\");\n try\n {\n     auto addresses = getAddress(\"www.digitalmars.com\");\n     foreach (address; addresses)\n         writefln(\"  IP: %s\", address.toAddrString());\n }\n catch (SocketException e)\n     writefln(\"  Lookup failed: %s\", e.msg);\n ---\n",
				"deco": "FNfxAaxAaZAC3std6socket7Address",
				"parameters": [
					{
						"name": "hostname",
						"deco": "xAa"
					},
					{
						"name": "service",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 1124,
				"originalType": "@safe Address[](in char[] hostname, in char[] service = null)",
				"char": 11,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "getAddress",
				"line": 1127,
				"comment": "ditto\n",
				"deco": "FNfxAatZAC3std6socket7Address",
				"parameters": [
					{
						"name": "hostname",
						"deco": "xAa"
					},
					{
						"name": "port",
						"deco": "t"
					}
				],
				"endline": 1144,
				"originalType": "@safe Address[](in char[] hostname, ushort port)",
				"char": 11,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "parseAddress",
				"line": 1204,
				"comment": " Provides _protocol-independent parsing of network addresses. Does not\n attempt name resolution. Uses $(D getAddressInfo) with\n $(D AddressInfoFlags.NUMERICHOST) if the current system supports it, and\n $(D InternetAddress) otherwise.\n\n Returns: An $(D Address) instance representing specified address.\n\n Throws: $(D SocketException) on failure.\n\n Example:\n ---\n writeln(\"Enter IP address:\");\n string ip = readln().chomp();\n try\n {\n     Address address = parseAddress(ip);\n     writefln(\"Looking up reverse of %s:\",\n         address.toAddrString());\n     try\n     {\n         string reverse = address.toHostNameString();\n         if (reverse)\n             writefln(\"  Reverse name: %s\", reverse);\n         else\n             writeln(\"  Reverse hostname not found.\");\n     }\n     catch (SocketException e)\n         writefln(\"  Lookup error: %s\", e.msg);\n }\n catch (SocketException e)\n {\n     writefln(\"  %s is not a valid IP address: %s\",\n         ip, e.msg);\n }\n ---\n",
				"deco": "FNfxAaxAaZC3std6socket7Address",
				"parameters": [
					{
						"name": "hostaddr",
						"deco": "xAa"
					},
					{
						"name": "service",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 1210,
				"originalType": "@safe Address(in char[] hostaddr, in char[] service = null)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "parseAddress",
				"line": 1213,
				"comment": "ditto\n",
				"deco": "FNfxAatZC3std6socket7Address",
				"parameters": [
					{
						"name": "hostaddr",
						"deco": "xAa"
					},
					{
						"name": "port",
						"deco": "t"
					}
				],
				"endline": 1224,
				"originalType": "@safe Address(in char[] hostaddr, ushort port)",
				"char": 9,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1255,
						"comment": "\n",
						"deco": "FNfAyaAyamC6object9ThrowableiZC3std6socket16AddressException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 1258,
						"originalType": "@safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1261,
						"comment": "\n",
						"deco": "FNfAyaC6object9ThrowableAyamiZC3std6socket16AddressException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 1264,
						"originalType": "@safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1267,
						"comment": "\n",
						"deco": "FNfAyaiAyamC6object9ThrowableZC3std6socket16AddressException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "err",
								"deco": "i"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 1270,
						"originalType": "@safe (string msg, int err, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "AddressException",
				"line": 1252,
				"comment": " Class for exceptions thrown from an $(D Address).\n",
				"base": "std.socket.SocketOSException",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Address",
				"line": 1298,
				"comment": " $(D Address) is an abstract class for representing a socket addresses.\n\n Example:\n ---\n writeln(\"About www.google.com port 80:\");\n try\n {\n     Address[] addresses = getAddress(\"www.google.com\", 80);\n     writefln(\"  %d addresses found.\", addresses.length);\n     foreach (int i, Address a; addresses)\n     {\n         writefln(\"  Address %d:\", i+1);\n         writefln(\"    IP address: %s\", a.toAddrString());\n         writefln(\"    Hostname: %s\", a.toHostNameString());\n         writefln(\"    Port: %s\", a.toPortString());\n         writefln(\"    Service name: %s\",\n             a.toServiceNameString());\n     }\n }\n catch (SocketException e)\n     writefln(\"  Lookup error: %s\", e.msg);\n ---\n",
				"members": [
					{
						"name": "name",
						"line": 1301,
						"comment": "Returns pointer to underlying $(D sockaddr) structure.\n",
						"deco": "FNaNbNdNiNfZPS4core3sys5posix3sys6socket8sockaddr",
						"char": 34,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "name",
						"line": 1302,
						"comment": "ditto\n",
						"deco": "xFNaNbNdNiNfZPxS4core3sys5posix3sys6socket8sockaddr",
						"char": 41,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "nameLen",
						"line": 1305,
						"comment": "Returns actual size of underlying $(D sockaddr) structure.\n",
						"deco": "xFNaNbNdNiNfZk",
						"originalType": "const pure nothrow @nogc @property @safe socklen_t()",
						"char": 34,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"endchar": 5,
						"name": "addressFamily",
						"line": 1308,
						"comment": "Family of this address.\n",
						"deco": "xFNaNbNdNiNfZE3std6socket13AddressFamily",
						"endline": 1311,
						"char": 29,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toAddrString",
						"line": 1381,
						"comment": " Attempts to retrieve the host address as a human-readable string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if address retrieval for this address family is not available on the\n current system.\n",
						"deco": "xFNfZAya",
						"endline": 1384,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toHostNameString",
						"line": 1396,
						"comment": " Attempts to retrieve the host name as a fully qualified domain name.\n\n Returns: The FQDN corresponding to this $(D Address), or $(D null) if\n the host name did not resolve.\n\n Throws: $(D AddressException) on error, or $(D SocketFeatureException)\n if host name lookup for this address family is not available on the\n current system.\n",
						"deco": "xFNfZAya",
						"endline": 1399,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toPortString",
						"line": 1408,
						"comment": " Attempts to retrieve the numeric port number as a string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if port number retrieval for this address family is not available on the\n current system.\n",
						"deco": "xFNfZAya",
						"endline": 1411,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toServiceNameString",
						"line": 1420,
						"comment": " Attempts to retrieve the service name as a string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if service name lookup for this address family is not available on the\n current system.\n",
						"deco": "xFNfZAya",
						"endline": 1423,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1426,
						"comment": "Human readable string representing this address.\n",
						"deco": "xFNfZAya",
						"endline": 1439,
						"char": 21,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"char": 10,
				"kind": "class"
			},
			{
				"members": [],
				"name": "UnknownAddress",
				"line": 1445,
				"comment": " $(D UnknownAddress) encapsulates an unknown socket address.\n",
				"base": "std.socket.Address",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1483,
						"comment": "Constructs an $(D Address) with a reference to the specified $(D sockaddr).\n",
						"deco": "FNaNbNiNfPS4core3sys5posix3sys6socket8sockaddrkZC3std6socket23UnknownAddressReference",
						"parameters": [
							{
								"name": "sa",
								"deco": "PS4core3sys5posix3sys6socket8sockaddr"
							},
							{
								"name": "len",
								"deco": "k"
							}
						],
						"endline": 1487,
						"originalType": "pure nothrow @nogc @safe (sockaddr* sa, socklen_t len)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1490,
						"comment": "Constructs an $(D Address) with a copy of the specified $(D sockaddr).\n",
						"deco": "FNaNbPxS4core3sys5posix3sys6socket8sockaddrkZC3std6socket23UnknownAddressReference",
						"parameters": [
							{
								"name": "sa",
								"deco": "PxS4core3sys5posix3sys6socket8sockaddr"
							},
							{
								"name": "len",
								"deco": "k"
							}
						],
						"endline": 1494,
						"originalType": "pure nothrow @system (const(sockaddr)* sa, socklen_t len)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "UnknownAddressReference",
				"line": 1475,
				"comment": " $(D UnknownAddressReference) encapsulates a reference to an arbitrary\n socket address.\n",
				"base": "std.socket.Address",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "ADDR_ANY",
						"line": 1550,
						"comment": "Any IPv4 host address.\n",
						"deco": "k",
						"init": "0u",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum",
							"@safe"
						]
					},
					{
						"name": "ADDR_NONE",
						"line": 1551,
						"comment": "An invalid IPv4 host address.\n",
						"deco": "k",
						"init": "4294967295u",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum",
							"@safe"
						]
					},
					{
						"name": "PORT_ANY",
						"line": 1552,
						"comment": "Any IPv4 port number.\n",
						"deco": "t",
						"init": "cast(ushort)0u",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum",
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "port",
						"line": 1555,
						"comment": "Returns the IPv4 _port number (in host byte order).\n",
						"deco": "xFNaNbNdNiNfZt",
						"endline": 1558,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "addr",
						"line": 1561,
						"comment": "Returns the IPv4 address number (in host byte order).\n",
						"deco": "xFNaNbNdNiNfZk",
						"endline": 1564,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1574,
						"comment": " Construct a new $(D InternetAddress).\n Params:\n   addr = an IPv4 address string in the dotted-decimal form a.b.c.d,\n          or a host name which will be resolved using an $(D InternetHost)\n          object.\n   port = port number, may be $(D PORT_ANY).\n",
						"deco": "FNfxAatZC3std6socket15InternetAddress",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							},
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1589,
						"originalType": "@safe (in char[] addr, ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1597,
						"comment": " Construct a new $(D InternetAddress).\n Params:\n   addr = (optional) an IPv4 address in host byte order, may be $(D ADDR_ANY).\n   port = port number, may be $(D PORT_ANY).\n",
						"deco": "FNaNbNiNfktZC3std6socket15InternetAddress",
						"parameters": [
							{
								"name": "addr",
								"deco": "k"
							},
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1602,
						"originalType": "pure nothrow @nogc @safe (uint addr, ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1605,
						"comment": "ditto\n",
						"deco": "FNaNbNiNftZC3std6socket15InternetAddress",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1610,
						"originalType": "pure nothrow @nogc @safe (ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1617,
						"comment": " Construct a new $(D InternetAddress).\n Params:\n   addr = A sockaddr_in as obtained from lower-level API calls such as getifaddrs.\n",
						"deco": "FNaNbNiNfS4core3sys5posix7netinet3in_11sockaddr_inZC3std6socket15InternetAddress",
						"parameters": [
							{
								"name": "addr",
								"deco": "S4core3sys5posix7netinet3in_11sockaddr_in"
							}
						],
						"endline": 1621,
						"originalType": "pure nothrow @nogc @safe (sockaddr_in addr)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "toAddrString",
						"line": 1624,
						"comment": "Human readable string representing the IPv4 address in dotted-decimal form.\n",
						"deco": "xFNeZAya",
						"endline": 1627,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.socket.Address.toAddrString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "toPortString",
						"line": 1630,
						"comment": "Human readable string representing the IPv4 port.\n",
						"deco": "xFNfZAya",
						"endline": 1633,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.socket.Address.toPortString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "toHostNameString",
						"line": 1643,
						"comment": " Attempts to retrieve the host name as a fully qualified domain name.\n\n Returns: The FQDN corresponding to this $(D InternetAddress), or\n $(D null) if the host name did not resolve.\n\n Throws: $(D AddressException) on error.\n",
						"deco": "xFNfZAya",
						"endline": 1662,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.socket.Address.toHostNameString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1669,
						"comment": " Compares with another InternetAddress of same type for equality\n Returns: true if the InternetAddresses share the same address and\n port number.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1677_1171)\n---\nauto addr1 = new InternetAddress(\"127.0.0.1\", 80);\nauto addr2 = new InternetAddress(\"127.0.0.2\", 80);\n\nassert(addr1 == addr1);\nassert(addr1 != addr2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1677_1171)\n",
						"deco": "xFNfC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1674,
						"char": 19,
						"kind": "function",
						"overrides": [
							"object.Object.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "parse",
						"line": 1692,
						"comment": " Parse an IPv4 address string in the dotted-decimal form $(I a.b.c.d)\n and return the number.\n Returns: If the string is not a legitimate IPv4 address,\n $(D ADDR_NONE) is returned.\n",
						"deco": "FNbNexAaZk",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							}
						],
						"endline": 1695,
						"originalType": "nothrow @trusted uint(in char[] addr)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "addrToString",
						"line": 1701,
						"comment": " Convert an IPv4 address number in host byte order to a human readable\n string representing the IPv4 address in dotted-decimal form.\n",
						"deco": "FNbNekZAya",
						"parameters": [
							{
								"name": "addr",
								"deco": "k"
							}
						],
						"endline": 1706,
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"name": "InternetAddress",
				"line": 1521,
				"comment": " $(D InternetAddress) encapsulates an IPv4 (Internet Protocol version 4)\n socket address.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n",
				"base": "std.socket.Address",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "ADDR_ANY",
						"line": 1805,
						"comment": "Any IPv6 host address.\n",
						"deco": "FNaNbNcNdNiNfZxG16h",
						"endline": 1820,
						"originalType": "pure nothrow @nogc @property ref @safe const(ubyte)[16]()",
						"char": 43,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"name": "PORT_ANY",
						"line": 1823,
						"comment": "Any IPv6 port number.\n",
						"deco": "t",
						"init": "cast(ushort)0u",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum",
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "port",
						"line": 1826,
						"comment": "Returns the IPv6 port number.\n",
						"deco": "xFNaNbNdNiNfZt",
						"endline": 1829,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "addr",
						"line": 1832,
						"comment": "Returns the IPv6 address.\n",
						"deco": "xFNaNbNdNiNfZG16h",
						"endline": 1835,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1844,
						"comment": " Construct a new $(D Internet6Address).\n Params:\n   addr    = an IPv6 host address string in the form described in RFC 2373,\n             or a host name which will be resolved using $(D getAddressInfo).\n   service = (optional) service name.\n",
						"deco": "FNexAaxAaZC3std6socket16Internet6Address",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							},
							{
								"name": "service",
								"deco": "xAa",
								"default": "null"
							}
						],
						"endline": 1849,
						"originalType": "@trusted (in char[] addr, in char[] service = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1858,
						"comment": " Construct a new $(D Internet6Address).\n Params:\n   addr = an IPv6 host address string in the form described in RFC 2373,\n          or a host name which will be resolved using $(D getAddressInfo).\n   port = port number, may be $(D PORT_ANY).\n",
						"deco": "FNfxAatZC3std6socket16Internet6Address",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							},
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1864,
						"originalType": "@safe (in char[] addr, ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1873,
						"comment": " Construct a new $(D Internet6Address).\n Params:\n   addr = (optional) an IPv6 host address in host byte order, or\n          $(D ADDR_ANY).\n   port = port number, may be $(D PORT_ANY).\n",
						"deco": "FNaNbNiNfG16htZC3std6socket16Internet6Address",
						"parameters": [
							{
								"name": "addr",
								"deco": "G16h"
							},
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1878,
						"originalType": "pure nothrow @nogc @safe (ubyte[16] addr, ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1881,
						"comment": "ditto\n",
						"deco": "FNaNbNiNftZC3std6socket16Internet6Address",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1886,
						"originalType": "pure nothrow @nogc @safe (ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1893,
						"comment": " Construct a new $(D Internet6Address).\n Params:\n   addr = A sockaddr_in6 as obtained from lower-level API calls such as getifaddrs.\n",
						"deco": "FNaNbNiNfS4core3sys5posix7netinet3in_12sockaddr_in6ZC3std6socket16Internet6Address",
						"parameters": [
							{
								"name": "addr",
								"deco": "S4core3sys5posix7netinet3in_12sockaddr_in6"
							}
						],
						"endline": 1897,
						"originalType": "pure nothrow @nogc @safe (sockaddr_in6 addr)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "parse",
						"line": 1904,
						"comment": " Parse an IPv6 host address string as described in RFC 2373, and return the\n address.\n Throws: $(D SocketException) on error.\n",
						"deco": "FNexAaZG16h",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							}
						],
						"endline": 1913,
						"originalType": "@trusted ubyte[16](in char[] addr)",
						"char": 22,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"name": "Internet6Address",
				"line": 1775,
				"comment": " $(D Internet6Address) encapsulates an IPv6 (Internet Protocol version 6)\n socket address.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n",
				"base": "std.socket.Address",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 32,
						"name": "this",
						"line": 1959,
						"comment": "Construct a new $(D UnixAddress) from the specified path.\n",
						"deco": "FNfxAaZC3std6socket11UnixAddress",
						"parameters": [
							{
								"name": "path",
								"deco": "xAa"
							}
						],
						"endline": 1959,
						"originalType": "@safe (in char[] path)",
						"char": 9,
						"kind": "constructor"
					},
					{
						"endchar": 53,
						"name": "this",
						"line": 1966,
						"comment": " Construct a new $(D UnixAddress).\n Params:\n   addr = A sockaddr_un as obtained from lower-level API calls.\n",
						"deco": "FNaNbNiNfS4core3sys5posix3sys2un11sockaddr_unZC3std6socket11UnixAddress",
						"parameters": [
							{
								"name": "addr",
								"deco": "S4core3sys5posix3sys2un11sockaddr_un"
							}
						],
						"endline": 1966,
						"originalType": "pure nothrow @nogc @safe (sockaddr_un addr)",
						"char": 9,
						"kind": "constructor"
					},
					{
						"endchar": 54,
						"name": "path",
						"line": 1969,
						"comment": "Get the underlying _path.\n",
						"deco": "xFNdNfZAya",
						"endline": 1969,
						"char": 26,
						"kind": "function"
					},
					{
						"endchar": 57,
						"name": "toString",
						"line": 1972,
						"comment": "ditto\n",
						"deco": "xFNfZAya",
						"endline": 1972,
						"char": 25,
						"kind": "function",
						"overrides": [
							"std.socket.Address.toString"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "UnixAddress",
				"line": 1954,
				"comment": " $(D UnixAddress) encapsulates an address for a Unix domain socket\n ($(D AF_UNIX)). Available only on supported systems.\n",
				"base": "std.socket.Address",
				"char": 5,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 2084,
						"comment": "\n",
						"deco": "FNfAyaAyamC6object9ThrowableiZC3std6socket21SocketAcceptException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 2087,
						"originalType": "@safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2090,
						"comment": "\n",
						"deco": "FNfAyaC6object9ThrowableAyamiZC3std6socket21SocketAcceptException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 2093,
						"originalType": "@safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2096,
						"comment": "\n",
						"deco": "FNfAyaiAyamC6object9ThrowableZC3std6socket21SocketAcceptException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "err",
								"deco": "i"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 2099,
						"originalType": "@safe (string msg, int err, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "SocketAcceptException",
				"line": 2081,
				"comment": " Class for exceptions thrown by $(D Socket.accept).\n",
				"base": "std.socket.SocketOSException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "RECEIVE",
						"line": 2105,
						"value": "0",
						"comment": "socket receives are disallowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "SEND",
						"line": 2106,
						"value": "1",
						"comment": "socket sends are disallowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "BOTH",
						"line": 2107,
						"value": "2",
						"comment": "both RECEIVE and SEND\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SocketShutdown",
				"line": 2103,
				"comment": "How a socket is shutdown:\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "NONE",
						"line": 2114,
						"value": "0",
						"comment": "no flags specified\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "OOB",
						"line": 2116,
						"value": "1",
						"comment": "out-of-band stream data\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "PEEK",
						"line": 2117,
						"value": "2",
						"comment": "peek at incoming data without removing it from the queue, only for receiving\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "DONTROUTE",
						"line": 2118,
						"value": "4",
						"comment": "data should not be subject to routing; this flag may be ignored. Only for sending\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SocketFlags",
				"line": 2112,
				"comment": "Flags may be OR'ed together:\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "TimeVal",
				"line": 2140,
				"comment": "Duration timeout value.\n",
				"members": [
					{
						"offset": 16,
						"name": "seconds",
						"line": 2148,
						"comment": "Number of _seconds.\n",
						"deco": "l",
						"originalType": "tv_sec_t",
						"char": 18,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 24,
						"name": "microseconds",
						"line": 2149,
						"comment": "Number of additional _microseconds.\n",
						"deco": "l",
						"originalType": "tv_usec_t",
						"char": 19,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "SocketSet",
				"line": 2167,
				"comment": " A collection of sockets for use with $(D Socket.select).\n\n $(D SocketSet) wraps the platform $(D fd_set) type. However, unlike\n $(D fd_set), $(D SocketSet) is not statically limited to $(D FD_SETSIZE)\n or any other limit, and grows as needed.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 2274,
						"comment": " Create a SocketSet with a specific initial capacity (defaults to\n $(D FD_SETSIZE), the system's default capacity).\n",
						"deco": "FNaNbNfmZC3std6socket9SocketSet",
						"parameters": [
							{
								"name": "size",
								"deco": "m",
								"default": "1024LU"
							}
						],
						"endline": 2278,
						"originalType": "pure nothrow @safe (size_t size = FD_SETSIZE)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "reset",
						"line": 2281,
						"comment": "Reset the $(D SocketSet) so that there are 0 $(D Socket)s in the collection.\n",
						"deco": "FNaNbNiNfZv",
						"endline": 2290,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "add",
						"line": 2324,
						"comment": "Add a $(D Socket) to the collection.\n\nThe socket must not already be in the collection.\n",
						"deco": "FNaNbNfC3std6socket6SocketZv",
						"parameters": [
							{
								"name": "s",
								"deco": "C3std6socket6Socket"
							}
						],
						"endline": 2327,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "remove",
						"line": 2352,
						"comment": "Remove this $(D Socket) from the collection.\n\nDoes nothing if the socket is not in the collection already.\n",
						"deco": "FNaNbNfC3std6socket6SocketZv",
						"parameters": [
							{
								"name": "s",
								"deco": "C3std6socket6Socket"
							}
						],
						"endline": 2355,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isSet",
						"line": 2375,
						"comment": "Return nonzero if this $(D Socket) is in the collection.\n",
						"deco": "xFNaNbNiNfC3std6socket6SocketZi",
						"parameters": [
							{
								"name": "s",
								"deco": "C3std6socket6Socket"
							}
						],
						"endline": 2378,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "max",
						"line": 2387,
						"comment": "Return the current capacity of this $(D SocketSet). The exact\n\nmeaning of the return value varies from platform to platform.\n\n\n\nNote that since D 2.065, this value does not indicate a\n\nrestriction, and $(D SocketSet) will grow its capacity as\n\nneeded automatically.\n",
						"deco": "xFNaNbNdNiNfZk",
						"endline": 2390,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "SOCKET",
						"line": 2523,
						"value": "1",
						"comment": "Socket level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IP",
						"line": 2524,
						"value": "0",
						"comment": "Internet Protocol version 4 level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ICMP",
						"line": 2525,
						"value": "1",
						"comment": "Internet Control Message Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IGMP",
						"line": 2526,
						"value": "2",
						"comment": "Internet Group Management Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "GGP",
						"line": 2527,
						"value": "3",
						"comment": "Gateway to Gateway Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "TCP",
						"line": 2528,
						"value": "6",
						"comment": "Transmission Control Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "PUP",
						"line": 2529,
						"value": "12",
						"comment": "PARC Universal Packet Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "UDP",
						"line": 2530,
						"value": "17",
						"comment": "User Datagram Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IDP",
						"line": 2531,
						"value": "22",
						"comment": "Xerox NS protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RAW",
						"line": 2532,
						"value": "255",
						"comment": "Raw IP packet level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6",
						"line": 2533,
						"value": "41",
						"comment": "Internet Protocol version 6 level\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SocketOptionLevel",
				"line": 2521,
				"comment": "The level at which a socket option is defined:\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Linger",
				"line": 2537,
				"comment": "_Linger information for use with SocketOption.LINGER.\n",
				"members": [
					{
						"offset": 8,
						"name": "on",
						"line": 2545,
						"comment": "Nonzero for _on.\n",
						"deco": "i",
						"originalType": "l_onoff_t",
						"char": 20,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 12,
						"name": "time",
						"line": 2546,
						"comment": "Linger _time.\n",
						"deco": "i",
						"originalType": "l_linger_t",
						"char": 20,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "DEBUG",
						"line": 2559,
						"value": "1",
						"comment": "Record debugging information\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "BROADCAST",
						"line": 2560,
						"value": "6",
						"comment": "Allow transmission of broadcast messages\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "REUSEADDR",
						"line": 2561,
						"value": "2",
						"comment": "Allow local reuse of address\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "LINGER",
						"line": 2562,
						"value": "13",
						"comment": "Linger on close if unsent data is present\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "OOBINLINE",
						"line": 2563,
						"value": "10",
						"comment": "Receive out-of-band data in band\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "SNDBUF",
						"line": 2564,
						"value": "7",
						"comment": "Send buffer size\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RCVBUF",
						"line": 2565,
						"value": "8",
						"comment": "Receive buffer size\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "DONTROUTE",
						"line": 2566,
						"value": "5",
						"comment": "Do not route\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "SNDTIMEO",
						"line": 2567,
						"value": "21",
						"comment": "Send timeout\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RCVTIMEO",
						"line": 2568,
						"value": "20",
						"comment": "Receive timeout\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ERROR",
						"line": 2569,
						"value": "4",
						"comment": "Retrieve and clear error status\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "KEEPALIVE",
						"line": 2570,
						"value": "9",
						"comment": "Enable keep-alive packets\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ACCEPTCONN",
						"line": 2571,
						"value": "30",
						"comment": "Listen\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RCVLOWAT",
						"line": 2572,
						"value": "18",
						"comment": "Minimum number of input bytes to process\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "SNDLOWAT",
						"line": 2573,
						"value": "19",
						"comment": "Minimum number of output bytes to process\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "TYPE",
						"line": 2574,
						"value": "3",
						"comment": "Socket type\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "TCP_NODELAY",
						"line": 2577,
						"value": "1",
						"comment": "Disable the Nagle algorithm for send coalescing\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_UNICAST_HOPS",
						"line": 2580,
						"value": "16",
						"comment": "IP unicast hop limit\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_MULTICAST_IF",
						"line": 2581,
						"value": "17",
						"comment": "IP multicast interface\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_MULTICAST_LOOP",
						"line": 2582,
						"value": "19",
						"comment": "IP multicast loopback\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_MULTICAST_HOPS",
						"line": 2583,
						"value": "18",
						"comment": "IP multicast hops\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_JOIN_GROUP",
						"line": 2584,
						"value": "20",
						"comment": "Add an IP group membership\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_LEAVE_GROUP",
						"line": 2585,
						"value": "21",
						"comment": "Drop an IP group membership\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_V6ONLY",
						"line": 2586,
						"value": "26",
						"comment": "Treat wildcard bind as AF_INET6-only\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SocketOption",
				"line": 2557,
				"comment": "Specifies a socket option:\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Socket",
				"line": 2594,
				"comment": " $(D Socket) is a class that creates a network communication endpoint using\n the Berkeley sockets interface.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 2662,
						"comment": " Create a blocking socket. If a single protocol type exists to support\n this socket type within the address family, the $(D ProtocolType) may be\n omitted.\n",
						"deco": "FNeE3std6socket13AddressFamilyE3std6socket10SocketTypeE3std6socket12ProtocolTypeZC3std6socket6Socket",
						"parameters": [
							{
								"name": "af",
								"deco": "E3std6socket13AddressFamily"
							},
							{
								"name": "type",
								"deco": "E3std6socket10SocketType"
							},
							{
								"name": "protocol",
								"deco": "E3std6socket12ProtocolType"
							}
						],
						"endline": 2669,
						"originalType": "@trusted (AddressFamily af, SocketType type, ProtocolType protocol)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2675,
						"comment": "ditto\n",
						"deco": "FNfE3std6socket13AddressFamilyE3std6socket10SocketTypeZC3std6socket6Socket",
						"parameters": [
							{
								"name": "af",
								"deco": "E3std6socket13AddressFamily"
							},
							{
								"name": "type",
								"deco": "E3std6socket10SocketType"
							}
						],
						"endline": 2678,
						"originalType": "@safe (AddressFamily af, SocketType type)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2682,
						"comment": "ditto\n",
						"deco": "FNeE3std6socket13AddressFamilyE3std6socket10SocketTypexAaZC3std6socket6Socket",
						"parameters": [
							{
								"name": "af",
								"deco": "E3std6socket13AddressFamily"
							},
							{
								"name": "type",
								"deco": "E3std6socket10SocketType"
							},
							{
								"name": "protocolName",
								"deco": "xAa"
							}
						],
						"endline": 2689,
						"originalType": "@trusted (AddressFamily af, SocketType type, in char[] protocolName)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2696,
						"comment": " Create a blocking socket using the parameters from the specified\n $(D AddressInfo) structure.\n",
						"deco": "FNfxS3std6socket11AddressInfoZC3std6socket6Socket",
						"parameters": [
							{
								"name": "info",
								"deco": "xS3std6socket11AddressInfo"
							}
						],
						"endline": 2699,
						"originalType": "@safe (in AddressInfo info)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2702,
						"comment": "Use an existing socket handle.\n",
						"deco": "FNaNbNiNfE3std6socket8socket_tE3std6socket13AddressFamilyZC3std6socket6Socket",
						"parameters": [
							{
								"name": "sock",
								"deco": "E3std6socket8socket_t"
							},
							{
								"name": "af",
								"deco": "E3std6socket13AddressFamily"
							}
						],
						"endline": 2707,
						"originalType": "pure nothrow @nogc @safe (socket_t sock, AddressFamily af)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "handle",
						"line": 2717,
						"comment": "Get underlying socket handle.\n",
						"deco": "xFNaNbNdNiNfZE3std6socket8socket_t",
						"endline": 2720,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "blocking",
						"line": 2729,
						"comment": " Get/set socket's blocking flag.\n\n When a socket is blocking, calls to receive(), accept(), and send()\n will block and wait for data/action.\n A non-blocking socket will immediately return instead of blocking.\n",
						"deco": "xFNbNdNiNeZb",
						"endline": 2739,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "blocking",
						"line": 2742,
						"comment": "ditto\n",
						"deco": "FNdNebZv",
						"parameters": [
							{
								"name": "byes",
								"deco": "b"
							}
						],
						"endline": 2767,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "addressFamily",
						"line": 2771,
						"comment": "Get the socket's address family.\n",
						"deco": "FNdNfZE3std6socket13AddressFamily",
						"endline": 2774,
						"char": 29,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isAlive",
						"line": 2777,
						"comment": "Property that indicates if this is a valid, alive socket.\n",
						"deco": "xFNdNeZb",
						"endline": 2782,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "bind",
						"line": 2785,
						"comment": "Associate a local address with this socket.\n",
						"deco": "FNeC3std6socket7AddressZv",
						"parameters": [
							{
								"name": "addr",
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 2789,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "connect",
						"line": 2796,
						"comment": " Establish a connection. If the socket is blocking, connect waits for\n the connection to be made. If the socket is nonblocking, connect\n returns immediately and the connection attempt is still in progress.\n",
						"deco": "FNeC3std6socket7AddressZv",
						"parameters": [
							{
								"name": "to",
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 2822,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "listen",
						"line": 2829,
						"comment": " Listen for an incoming connection. $(D bind) must be called before you\n can $(D listen). The $(D backlog) is a request of how many pending\n incoming connections are queued until $(D accept)ed.\n",
						"deco": "FNeiZv",
						"parameters": [
							{
								"name": "backlog",
								"deco": "i"
							}
						],
						"endline": 2833,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "accepting",
						"line": 2844,
						"protection": "protected",
						"comment": " Called by $(D accept) when a new $(D Socket) must be created for a new\n connection. To use a derived class, override this method and return an\n instance of your class. The returned $(D Socket)'s handle must not be\n set; $(D Socket) has a protected constructor $(D this()) to use in this\n situation.\n",
						"deco": "FNaNbNfZC3std6socket6Socket",
						"endline": 2847,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "accept",
						"line": 2854,
						"comment": " Accept an incoming connection. If the socket is blocking, $(D accept)\n waits for a connection request. Throws $(D SocketAcceptException) if\n unable to _accept. See $(D accepting) for use with derived classes.\n",
						"deco": "FNeZC3std6socket6Socket",
						"endline": 2878,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "shutdown",
						"line": 2881,
						"comment": "Disables sends and/or receives.\n",
						"deco": "FNbNiNeE3std6socket14SocketShutdownZv",
						"parameters": [
							{
								"name": "how",
								"deco": "E3std6socket14SocketShutdown"
							}
						],
						"endline": 2884,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "close",
						"line": 2908,
						"comment": " Immediately drop any connections and release socket resources.\n Calling $(D shutdown) before $(D close) is recommended for\n connection-oriented sockets. The $(D Socket) object is no longer\n usable after $(D close).\n",
						"deco": "FNbNiNeZv",
						"endline": 2912,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hostName",
						"line": 2917,
						"comment": "Returns the local machine's host name.\n",
						"deco": "FNdNeZAya",
						"endline": 2923,
						"char": 29,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "remoteAddress",
						"line": 2926,
						"comment": "Remote endpoint $(D Address).\n",
						"deco": "FNdNeZC3std6socket7Address",
						"endline": 2936,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "localAddress",
						"line": 2939,
						"comment": "Local endpoint $(D Address).\n",
						"deco": "FNdNeZC3std6socket7Address",
						"endline": 2949,
						"char": 23,
						"kind": "function"
					},
					{
						"name": "ERROR",
						"line": 2956,
						"comment": " Send or receive error code. See $(D wouldHaveBlocked),\n $(D lastSocketError) and $(D Socket.getErrorText) for obtaining more\n information about the error.\n",
						"deco": "i",
						"init": "-1",
						"char": 14,
						"kind": "variable",
						"storageClass": [
							"enum",
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "send",
						"line": 2965,
						"comment": " Send data on the connection. If the socket is blocking and there is no\n buffer space left, $(D send) waits.\n Returns: The number of bytes actually sent, or $(D Socket.ERROR) on\n failure.\n",
						"deco": "FNeAxvE3std6socket11SocketFlagsZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							}
						],
						"endline": 2976,
						"originalType": "@trusted ptrdiff_t(const(void)[] buf, SocketFlags flags)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "send",
						"line": 2979,
						"comment": "ditto\n",
						"deco": "FNfAxvZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							}
						],
						"endline": 2982,
						"originalType": "@safe ptrdiff_t(const(void)[] buf)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sendTo",
						"line": 2991,
						"comment": " Send data to a specific destination Address. If the destination address is\n not specified, a connection must have been made and that address is used.\n If the socket is blocking and there is no buffer space left, $(D sendTo) waits.\n Returns: The number of bytes actually sent, or $(D Socket.ERROR) on\n failure.\n",
						"deco": "FNeAxvE3std6socket11SocketFlagsC3std6socket7AddressZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							},
							{
								"name": "to",
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 3004,
						"originalType": "@trusted ptrdiff_t(const(void)[] buf, SocketFlags flags, Address to)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sendTo",
						"line": 3007,
						"comment": "ditto\n",
						"deco": "FNfAxvC3std6socket7AddressZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							},
							{
								"name": "to",
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 3010,
						"originalType": "@safe ptrdiff_t(const(void)[] buf, Address to)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sendTo",
						"line": 3015,
						"comment": "ditto\n",
						"deco": "FNeAxvE3std6socket11SocketFlagsZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							}
						],
						"endline": 3025,
						"originalType": "@trusted ptrdiff_t(const(void)[] buf, SocketFlags flags)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sendTo",
						"line": 3030,
						"comment": "ditto\n",
						"deco": "FNfAxvZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							}
						],
						"endline": 3033,
						"originalType": "@safe ptrdiff_t(const(void)[] buf)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receive",
						"line": 3043,
						"comment": " Receive data on the connection. If the socket is blocking, $(D receive)\n waits until there is data to be received.\n Returns: The number of bytes actually received, $(D 0) if the remote side\n has closed the connection, or $(D Socket.ERROR) on failure.\n",
						"deco": "FNeAvE3std6socket11SocketFlagsZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							}
						],
						"endline": 3055,
						"originalType": "@trusted ptrdiff_t(void[] buf, SocketFlags flags)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receive",
						"line": 3058,
						"comment": "ditto\n",
						"deco": "FNfAvZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							}
						],
						"endline": 3061,
						"originalType": "@safe ptrdiff_t(void[] buf)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receiveFrom",
						"line": 3070,
						"comment": " Receive data and get the remote endpoint $(D Address).\n If the socket is blocking, $(D receiveFrom) waits until there is data to\n be received.\n Returns: The number of bytes actually received, $(D 0) if the remote side\n has closed the connection, or $(D Socket.ERROR) on failure.\n",
						"deco": "FNeAvE3std6socket11SocketFlagsKC3std6socket7AddressZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							},
							{
								"name": "from",
								"storageClass": [
									"ref"
								],
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 3089,
						"originalType": "@trusted ptrdiff_t(void[] buf, SocketFlags flags, ref Address from)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receiveFrom",
						"line": 3093,
						"comment": "ditto\n",
						"deco": "FNfAvKC3std6socket7AddressZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							},
							{
								"name": "from",
								"storageClass": [
									"ref"
								],
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 3096,
						"originalType": "@safe ptrdiff_t(void[] buf, ref Address from)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receiveFrom",
						"line": 3101,
						"comment": "ditto\n",
						"deco": "FNeAvE3std6socket11SocketFlagsZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							}
						],
						"endline": 3115,
						"originalType": "@trusted ptrdiff_t(void[] buf, SocketFlags flags)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receiveFrom",
						"line": 3120,
						"comment": "ditto\n",
						"deco": "FNfAvZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							}
						],
						"endline": 3123,
						"originalType": "@safe ptrdiff_t(void[] buf)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getOption",
						"line": 3129,
						"comment": "Get a socket option.\n\nReturns: The number of bytes written to $(D result).\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionAvZi",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "result",
								"deco": "Av"
							}
						],
						"endline": 3135,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getOption",
						"line": 3139,
						"comment": "Common case of getting integer and boolean options.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionJiZi",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "result",
								"storageClass": [
									"out"
								],
								"deco": "i"
							}
						],
						"endline": 3142,
						"originalType": "@trusted int(SocketOptionLevel level, SocketOption option, out int32_t result)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getOption",
						"line": 3146,
						"comment": "Get the linger option.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionJS3std6socket6LingerZi",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "result",
								"storageClass": [
									"out"
								],
								"deco": "S3std6socket6Linger"
							}
						],
						"endline": 3150,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getOption",
						"line": 3153,
						"comment": "Get a timeout (duration) option.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionJS4core4time8DurationZv",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "result",
								"storageClass": [
									"out"
								],
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 3174,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setOption",
						"line": 3177,
						"comment": "Set a socket option.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionAvZv",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "value",
								"deco": "Av"
							}
						],
						"endline": 3182,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setOption",
						"line": 3186,
						"comment": "Common case for setting integer and boolean options.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptioniZv",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "value",
								"deco": "i"
							}
						],
						"endline": 3189,
						"originalType": "@trusted void(SocketOptionLevel level, SocketOption option, int32_t value)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setOption",
						"line": 3193,
						"comment": "Set the linger option.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionS3std6socket6LingerZv",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "value",
								"deco": "S3std6socket6Linger"
							}
						],
						"endline": 3197,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setOption",
						"line": 3240,
						"comment": " Sets a timeout (duration) option, i.e. $(D SocketOption.SNDTIMEO) or\n $(D RCVTIMEO). Zero indicates no timeout.\n\n In a typical application, you might also want to consider using\n a non-blocking socket instead of setting a timeout on a blocking one.\n\n Note: While the receive timeout setting is generally quite accurate\n on *nix systems even for smaller durations, there are two issues to\n be aware of on Windows: First, although undocumented, the effective\n timeout duration seems to be the one set on the socket plus half\n a second. $(D setOption()) tries to compensate for that, but still,\n timeouts under 500ms are not possible on Windows. Second, be aware\n that the actual amount of time spent until a blocking call returns\n randomly varies on the order of 10ms.\n\n Params:\n   level  = The level at which a socket option is defined.\n   option = Either $(D SocketOption.SNDTIMEO) or $(D SocketOption.RCVTIMEO).\n   value  = The timeout duration to set. Must not be negative.\n\n Throws: $(D SocketException) if setting the options fails.\n\n Example:\n ---\n import std.datetime;\n auto pair = socketPair();\n scope(exit) foreach (s; pair) s.close();\n\n // Set a receive timeout, and then wait at one end of\n // the socket pair, knowing that no data will arrive.\n pair[0].setOption(SocketOptionLevel.SOCKET,\n     SocketOption.RCVTIMEO, dur!\"seconds\"(1));\n\n auto sw = StopWatch(AutoStart.yes);\n ubyte[1] buffer;\n pair[0].receive(buffer);\n writefln(\"Waited %s ms until the socket timed out.\",\n     sw.peek.msecs);\n ---\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionS4core4time8DurationZv",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "value",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 3264,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getErrorText",
						"line": 3268,
						"comment": "Get a text description of this socket's error status, and clear the\n\nsocket's error status.\n",
						"deco": "FNfZAya",
						"endline": 3273,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setKeepAlive",
						"line": 3288,
						"comment": " Enables TCP keep-alive with the specified parameters.\n\n Params:\n   time     = Number of seconds with no activity until the first\n              keep-alive packet is sent.\n   interval = Number of seconds between when successive keep-alive\n              packets are sent if no acknowledgement is received.\n\n Throws: $(D SocketOSException) if setting the options fails, or\n $(D SocketFeatureException) if setting keep-alive parameters is\n unsupported on the current platform.\n",
						"deco": "FNeiiZv",
						"parameters": [
							{
								"name": "time",
								"deco": "i"
							},
							{
								"name": "interval",
								"deco": "i"
							}
						],
						"endline": 3313,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "select",
						"line": 3333,
						"comment": " Wait for a socket to change status. A wait timeout of $(Duration) or\n $(D TimeVal), may be specified; if a timeout is not specified or the\n $(D TimeVal) is $(D null), the maximum timeout is used. The $(D TimeVal)\n timeout has an unspecified value when $(D select) returns.\n Returns: The number of sockets with status changes, $(D 0) on timeout,\n or $(D -1) on interruption. If the return value is greater than $(D 0),\n the $(D SocketSets) are updated to only contain the sockets having status\n changes. For a connecting socket, a write status change means the\n connection is established and it's able to send. For a listening socket,\n a read status change means there is an incoming connection request and\n it's able to accept.\n",
						"deco": "FNeC3std6socket9SocketSetC3std6socket9SocketSetC3std6socket9SocketSetS4core4time8DurationZi",
						"parameters": [
							{
								"name": "checkRead",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkWrite",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkError",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "timeout",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 3340,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "select",
						"line": 3344,
						"comment": "ditto\n",
						"deco": "FNfC3std6socket9SocketSetC3std6socket9SocketSetC3std6socket9SocketSetZi",
						"parameters": [
							{
								"name": "checkRead",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkWrite",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkError",
								"deco": "C3std6socket9SocketSet"
							}
						],
						"endline": 3347,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "select",
						"line": 3350,
						"comment": "Ditto\n",
						"deco": "FNeC3std6socket9SocketSetC3std6socket9SocketSetC3std6socket9SocketSetPS3std6socket7TimeValZi",
						"parameters": [
							{
								"name": "checkRead",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkWrite",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkError",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "timeout",
								"deco": "PS3std6socket7TimeVal"
							}
						],
						"endline": 3442,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "createAddress",
						"line": 3447,
						"protection": "protected",
						"comment": "Returns a new Address object for the current address family.\n\nCan be overridden to support other addresses.\n",
						"deco": "FNaNbNfZC3std6socket7Address",
						"endline": 3471,
						"char": 23,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3480,
						"comment": "Constructs a blocking TCP Socket.\n",
						"deco": "FNfE3std6socket13AddressFamilyZC3std6socket9TcpSocket",
						"parameters": [
							{
								"name": "family",
								"deco": "E3std6socket13AddressFamily"
							}
						],
						"endline": 3483,
						"originalType": "@safe (AddressFamily family)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3486,
						"comment": "Constructs a blocking IPv4 TCP Socket.\n",
						"deco": "FNfZC3std6socket9TcpSocket",
						"endline": 3489,
						"originalType": "@safe ()",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3494,
						"comment": "Constructs a blocking TCP Socket and connects to an $(D Address).\n",
						"deco": "FNfC3std6socket7AddressZC3std6socket9TcpSocket",
						"parameters": [
							{
								"name": "connectTo",
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 3498,
						"originalType": "@safe (Address connectTo)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "TcpSocket",
				"line": 3477,
				"comment": "$(D TcpSocket) is a shortcut class for a TCP Socket.\n",
				"base": "std.socket.Socket",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3506,
						"comment": "Constructs a blocking UDP Socket.\n",
						"deco": "FNfE3std6socket13AddressFamilyZC3std6socket9UdpSocket",
						"parameters": [
							{
								"name": "family",
								"deco": "E3std6socket13AddressFamily"
							}
						],
						"endline": 3509,
						"originalType": "@safe (AddressFamily family)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3513,
						"comment": "Constructs a blocking IPv4 UDP Socket.\n",
						"deco": "FNfZC3std6socket9UdpSocket",
						"endline": 3516,
						"originalType": "@safe ()",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "UdpSocket",
				"line": 3503,
				"comment": "$(D UdpSocket) is a shortcut class for a UDP Socket.\n",
				"base": "std.socket.Socket",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "socketPair",
				"line": 3539,
				"comment": " Creates a pair of connected sockets.\n\n The two sockets are indistinguishable.\n\n Throws: $(D SocketException) if creation of the sockets fails.\n\n Example:\n ---\n immutable ubyte[] data = [1, 2, 3, 4];\n auto pair = socketPair();\n scope(exit) foreach (s; pair) s.close();\n\n pair[0].send(data);\n\n auto buf = new ubyte[data.length];\n pair[1].receive(buf);\n assert(buf == data);\n ---\n",
				"deco": "FNeZG2C3std6socket6Socket",
				"endline": 3577,
				"char": 11,
				"kind": "function"
			}
		],
		"comment": " Socket primitives.\n Example: See $(SAMPLESRC listener.d) and $(SAMPLESRC htmlget.d)\n License: $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors: Christopher E. Miller, $(WEB klickverbot.at, David Nadlinger),\n      $(WEB thecybershadow.net, Vladimir Panteleev)\n Source:  $(PHOBOSSRC std/_socket.d)\n Macros:\n      WIKI=Phobos/StdSocket\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/typecons.d",
		"name": "std.typecons",
		"members": [
			{
				"members": [
					{
						"name": "Unique",
						"line": 59,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 100,
								"comment": "    Constructor that takes an rvalue.\n    It will ensure uniqueness, as long as the rvalue\n    isn't just a view on an lvalue (e.g., a cast).\n    Typical usage:\n    ----\n    Unique!Foo f = new Foo;\n    ----\n",
								"type": "(RefT p)",
								"parameters": [
									{
										"name": "p",
										"type": "RefT"
									}
								],
								"endline": 104,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 110,
								"comment": "    Constructor that takes an lvalue. It nulls its source.\n    The nulling will ensure uniqueness as long as there\n    are no previous aliases to the source.\n",
								"type": "(ref RefT p)",
								"parameters": [
									{
										"name": "p",
										"type": "RefT",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 116,
								"char": 5,
								"kind": "constructor"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 130,
										"type": "(Unique!U u)",
										"parameters": [
											{
												"name": "u",
												"type": "Unique!U"
											}
										],
										"endline": 136,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 130,
								"comment": "    Constructor that takes a $(D Unique) of a type that is convertible to our type.\n\n    Typically used to transfer a $(D Unique) rvalue of derived type to\n    a $(D Unique) of base type.\n    Example:\n    ---\n    class C : Object {}\n\n    Unique!C uc = new C;\n    Unique!Object uo = uc.release;\n    ---\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "is(u.RefT : RefT)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 139,
										"type": "void(Unique!U u)",
										"parameters": [
											{
												"name": "u",
												"type": "Unique!U"
											}
										],
										"endline": 147,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 139,
								"comment": "Transfer ownership from a $(D Unique) of a type that is convertible to our type.\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "is(u.RefT : RefT)",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "isEmpty",
								"line": 156,
								"comment": " Returns whether the resource exists.\n",
								"type": "const @property bool()",
								"endline": 159,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "release",
								"line": 161,
								"comment": " Transfer ownership to a $(D Unique) rvalue. Nullifies the current contents.\n",
								"type": "Unique()",
								"endline": 168,
								"char": 12,
								"kind": "function"
							},
							{
								"endchar": 31,
								"name": "opDot",
								"line": 170,
								"comment": " Forwards member access to contents.\n",
								"type": "RefT()",
								"endline": 170,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Unique",
				"line": 59,
				"comment": "Encapsulates unique ownership of a resource.  Resource of type $(D T) is\ndeleted at the end of the scope, unless it is transferred.  The\ntransfer can be explicit, by calling $(D release), or implicit, when\nreturning Unique from a function. The resource can be a polymorphic\nclass object, in which case Unique behaves polymorphically too.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL182_1180)\n---\nstatic struct S\n{\n    int i;\n    this(int i){this.i = i;}\n}\nUnique!S produce()\n{\n    // Construct a unique instance of S on the heap\n    Unique!S ut = new S(5);\n    // Implicit transfer of ownership\n    return ut;\n}\n// Borrow a unique resource by ref\nvoid increment(ref Unique!S ur)\n{\n    ur.i++;\n}\nvoid consume(Unique!S u2)\n{\n    assert(u2.i == 6);\n    // Resource automatically deleted here\n}\nUnique!S u1;\nassert(u1.isEmpty);\nu1 = produce();\nincrement(u1);\nassert(u1.i == 6);\n//consume(u1); // Error: u1 is not copyable\n// Transfer ownership of the resource\nconsume(u1.release);\nassert(u1.isEmpty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL182_1180)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Tuple",
						"line": 430,
						"members": [
							{
								"name": "Types",
								"line": 435,
								"comment": " The types of the `Tuple`'s components.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL438_1184)\n---\nalias Fields = Tuple!(int, \"id\", string, float);\nstatic assert(is(Fields.Types == AliasSeq!(int, string, float)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL438_1184)\n",
								"type": "staticMap!(extractType, fieldSpecs)",
								"char": 9,
								"kind": "alias"
							},
							{
								"name": "fieldNames",
								"line": 447,
								"comment": " The names of the `Tuple`'s components. Unnamed fields have empty names.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL450_1185)\n---\nalias Fields = Tuple!(int, \"id\", string, float);\nstatic assert(Fields.fieldNames == AliasSeq!(\"id\", \"\", \"\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL450_1185)\n",
								"type": "staticMap!(extractName, fieldSpecs)",
								"char": 9,
								"kind": "alias"
							},
							{
								"name": "expand",
								"line": 462,
								"comment": " Use $(D t.expand) for a `Tuple` $(D t) to expand it into its\n components. The result of $(D expand) acts as if the `Tuple`'s components\n were listed as a list of values. (Ordinarily, a $(D Tuple) acts as a\n single value.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL466_1186)\n---\nauto t1 = tuple(1, \" hello \", 2.3);\nassert(t1.toString() == `Tuple!(int, string, double)(1, \" hello \", 2.3)`);\n\nvoid takeSeveralTypes(int n, string s, bool b)\n{\n    assert(n == 4 && s == \"test\" && b == false);\n}\n\nauto t2 = tuple(4, \"test\", false);\n//t.expand acting as a list of values\ntakeSeveralTypes(t2.expand);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL466_1186)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL524_1187)\n---\nalias ISD = Tuple!(int, string, double);\nauto tup = ISD(1, \"test\", 3.2);\nassert(tup.toString() == `Tuple!(int, string, double)(1, \"test\", 3.2)`);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL524_1187)\n",
								"type": "Types",
								"char": 15,
								"kind": "variable"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "this",
										"line": 538,
										"type": "(U[n] values)",
										"parameters": [
											{
												"name": "values",
												"type": "U[n]"
											}
										],
										"endline": 545,
										"char": 9,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 538,
								"comment": " Constructor taking a compatible array.\n\n Params:\n     values = A compatible static array to build the `Tuple` from.\n              Array slices are not supported.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL548_1188)\n---\nint[2] ints;\nTuple!(int, int) t = ints;\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL548_1188)\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									},
									{
										"name": "n",
										"type": "size_t",
										"kind": "value"
									}
								],
								"constraint": "n == Types.length && allSatisfy!(isBuildableFrom!U, Types)",
								"char": 9,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "this",
										"line": 564,
										"type": "(U another)",
										"parameters": [
											{
												"name": "another",
												"type": "U"
											}
										],
										"endline": 568,
										"char": 9,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 564,
								"comment": " Constructor taking a compatible `Tuple`. Two `Tuple`s are compatible\n $(B iff) they are both of the same length, and, for each type `T` on the\n left-hand side, the corresponding type `U` on the right-hand side can\n implicitly convert to `T`.\n\n Params:\n     another = A compatible `Tuple` to build from. Its type must be\n               compatible with the target `Tuple`'s type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL571_1189)\n---\nalias IntVec = Tuple!(int, int, int);\nalias DubVec = Tuple!(double, double, double);\n\nIntVec iv = tuple(1, 1, 1);\n\n//Ok, int can implicitly convert to double\nDubVec dv = iv;\n//Error: double cannot implicitly convert to int\n//IntVec iv2 = dv;\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL571_1189)\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "areBuildCompatibleTuples!(typeof(this), U)",
								"char": 9,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "opEquals",
										"line": 604,
										"type": "bool(R rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "R"
											}
										],
										"endline": 608,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opEquals",
								"line": 604,
								"comment": " Comparison for equality. Two `Tuple`s are considered equal\n $(B iff) they fulfill the following criteria:\n\n $(UL\n   $(LI Each `Tuple` is the same length.)\n   $(LI For each type `T` on the left-hand side and each type\n        `U` on the right-hand side, values of type `T` can be\n        compared with values of type `U`.)\n   $(LI For each value `v1` on the left-hand side and each value\n        `v2` on the right-hand side, the expression `v1 == v2` is\n        true.))\n\n Params:\n     rhs = The `Tuple` to compare against. It must meeting the criteria\n           for comparison between `Tuple`s.\n\n Returns:\n     true if both `Tuple`s are equal, otherwise false.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL618_1190)\n---\nTuple!(int, string) t1 = tuple(1, \"test\");\nTuple!(double, string) t2 =  tuple(1.0, \"test\");\n//Ok, int can be compared with double and\n//both have a value of 1\nassert(t1 == t2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL618_1190)\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "areCompatibleTuples!(typeof(this), R, \"==\")",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "opEquals",
										"line": 611,
										"type": "const bool(R rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "R"
											}
										],
										"endline": 615,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opEquals",
								"line": 611,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "areCompatibleTuples!(typeof(this), R, \"==\")",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "opCmp",
										"line": 643,
										"type": "int(R rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "R"
											}
										],
										"endline": 654,
										"char": 13,
										"kind": "function"
									}
								],
								"name": "opCmp",
								"line": 643,
								"comment": " Comparison for ordering.\n\n Params:\n     rhs = The `Tuple` to compare against. It must meet the criteria\n           for comparison between `Tuple`s.\n\n Returns:\n For any values `v1` on the right-hand side and `v2` on the\n left-hand side:\n\n $(UL\n   $(LI A negative integer if the expression `v1 < v2` is true.)\n   $(LI A positive integer if the expression `v1 > v2` is true.)\n   $(LI 0 if the expression `v1 == v2` is true.))\nExample:\nThe first `v1` for which `v1 > v2` is true determines\n            the result. This could lead to unexpected behaviour.$(DDOX_UNITTEST_HEADER __unittestL674_1191)\n---\nauto tup1 = tuple(1, 1, 1);\nauto tup2 = tuple(1, 100, 100);\nassert(tup1 < tup2);\n\n//Only the first result matters for comparison\ntup1[0] = 2;\nassert(tup1 > tup2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL674_1191)\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "areCompatibleTuples!(typeof(this), R, \"<\")",
								"char": 13,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "opCmp",
										"line": 657,
										"type": "const int(R rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "R"
											}
										],
										"endline": 668,
										"char": 13,
										"kind": "function"
									}
								],
								"name": "opCmp",
								"line": 657,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "areCompatibleTuples!(typeof(this), R, \"<\")",
								"char": 13,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "opAssign",
										"line": 693,
										"type": "void(auto ref R rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "R",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 716,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 693,
								"comment": " Assignment from another `Tuple`.\n\n Params:\n     rhs = The source `Tuple` to assign from. Each element of the\n           source `Tuple` must be implicitly assignable to each\n           respective element of the target `Tuple`.\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "areCompatibleTuples!(typeof(this), R, \"=\")",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "slice",
										"line": 731,
										"type": "@property ref @trusted Tuple!(sliceSpecs!(from, to))()",
										"endline": 735,
										"char": 43,
										"kind": "function"
									}
								],
								"name": "slice",
								"line": 731,
								"comment": " Takes a slice of this `Tuple`.\n\n Params:\n     from = A `size_t` designating the starting position of the slice.\n     to = A `size_t` designating the ending position (exclusive) of the slice.\n\n Returns:\n     A new `Tuple` that is a slice from `[from, to$(RPAREN)` of the original.\n     It has the same types and values as the range `[from, to$(RPAREN)` in\n     the original.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL738_1192)\n---\nTuple!(int, string, float, double) a;\na[1] = \"abc\";\na[2] = 4.5;\nauto s = a.slice!(1, 3);\nstatic assert(is(typeof(s) == Tuple!(string, float)));\nassert(s[0] == \"abc\" && s[1] == 4.5);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL738_1192)\n",
								"parameters": [
									{
										"name": "from",
										"type": "size_t",
										"kind": "value"
									},
									{
										"name": "to",
										"type": "size_t",
										"kind": "value"
									}
								],
								"constraint": "from <= to && to <= Types.length",
								"char": 43,
								"kind": "template"
							},
							{
								"endchar": 9,
								"name": "toHash",
								"line": 754,
								"comment": "            Creates a hash of this `Tuple`.\n\n            Returns:\n                A `size_t` representing the hash of this `Tuple`.\n",
								"type": "const nothrow @trusted size_t()",
								"endline": 760,
								"char": 16,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "toString",
										"line": 795,
										"type": "string()",
										"endline": 799,
										"char": 16,
										"kind": "function"
									}
								],
								"name": "toString",
								"line": 795,
								"comment": " Converts to string.\n\n Returns:\n     The string representation of this `Tuple`.\n",
								"parameters": [],
								"char": 16,
								"kind": "template"
							}
						],
						"char": 5,
						"kind": "struct"
					}
				],
				"name": "Tuple",
				"line": 311,
				"comment": "Tuple of values, for example $(D Tuple!(int, string)) is a record that\nstores an $(D int) and a $(D string). $(D Tuple) can be used to bundle\nvalues together, notably when returning multiple values from a\nfunction. If $(D obj) is a `Tuple`, the individual members are\naccessible with the syntax $(D obj[0]) for the first field, $(D obj[1])\nfor the second, and so on.\n\nThe choice of zero-based indexing instead of one-base indexing was\nmotivated by the ability to use value `Tuple`s with various compile-time\nloop constructs (e.g. $(XREF meta, AliasSeq) iteration), all of which use\nzero-based indexing.\n\nParams:\n    Specs = A list of types (and optionally, member names) that the `Tuple` contains.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL804_1193)\n---\nTuple!(int, int) point;\n// assign coordinates\npoint[0] = 5;\npoint[1] = 6;\n// read coordinates\nauto x = point[0];\nauto y = point[1];\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL804_1193)\nExample:\n`Tuple` members can be named. It is legal to mix named and unnamed\n    members. The method above is still applicable to all fields.$(DDOX_UNITTEST_HEADER __unittestL819_1194)\n---\nalias Entry = Tuple!(int, \"index\", string, \"value\");\nEntry e;\ne.index = 4;\ne.value = \"Hello\";\nassert(e[1] == \"Hello\");\nassert(e[0] == 4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL819_1194)\nExample:\nA `Tuple` with named fields is a distinct type from a `Tuple` with unnamed\n    fields, i.e. each naming imparts a separate type for the `Tuple`. Two\n    `Tuple`s differing in naming only are still distinct, even though they\n    might have the same structure.$(DDOX_UNITTEST_HEADER __unittestL835_1195)\n---\nTuple!(int, \"x\", int, \"y\") point1;\nTuple!(int, int) point2;\nassert(!is(typeof(point1) == typeof(point2)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL835_1195)\n",
				"parameters": [
					{
						"name": "Specs",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reverse",
						"line": 851,
						"type": "ReverseTupleType!T(T t)",
						"parameters": [
							{
								"name": "t",
								"type": "T"
							}
						],
						"endline": 864,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "reverse",
				"line": 851,
				"comment": "    Create a copy of a `Tuple` with its fields in reverse order.\n\n    Params:\n        t = The `Tuple` to copy.\n\n    Returns:\n        A copy of `t` with its fields in reverse order.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL867_1196)\n---\nauto tup = tuple(1, \"2\");\nassert(tup.reverse == tuple(\"2\", 1));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL867_1196)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isTuple!T",
				"char": 20,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "tuple",
								"line": 1316,
								"type": "(Args args)",
								"parameters": [
									{
										"name": "args",
										"type": "Args"
									}
								],
								"endline": 1352,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "tuple",
						"line": 1316,
						"parameters": [
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "tuple",
				"line": 1314,
				"comment": "    Constructs a $(D Tuple) object instantiated and initialized according to\n    the given arguments.\n\n    Params:\n        Names = A list of strings naming each successive field of the `Tuple`.\n                Each name matches up with the corresponding field given by `Args`.\n                A name does not have to be provided for every field, but as\n                the names must proceed in order, it is not possible to skip\n                one field and name the next after it.\n\n        args = Values to initialize the `Tuple` with. The `Tuple`'s type will\n               be inferred from the types of the values given.\n\n    Returns:\n        A new `Tuple` with its type inferred from the arguments given.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1356_1208)\n---\nauto value = tuple(5, 6.7, \"hello\");\nassert(value[0] == 5);\nassert(value[1] == 6.7);\nassert(value[2] == \"hello\");\n\n// Field names can be provided.\nauto entry = tuple!(\"index\", \"value\")(4, \"Hello\");\nassert(entry.index == 4);\nassert(entry.value == \"Hello\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1356_1208)\n",
				"parameters": [
					{
						"name": "Names",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isTuple",
						"line": 1378,
						"init": "__traits(compiles, ()\n{\ntemplate f(Specs...)f(T.init);\n}\n)",
						"char": 6,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isTuple",
				"line": 1378,
				"comment": "    Returns $(D true) if and only if $(D T) is an instance of $(D std.typecons.Tuple).\n\n    Params:\n        T = The type to check.\n\n    Returns:\n        true if `T` is a `Tuple` type, false otherwise.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1385_1209)\n---\nstatic assert(isTuple!(Tuple!()));\nstatic assert(isTuple!(Tuple!(int)));\nstatic assert(isTuple!(Tuple!(int, real, string)));\nstatic assert(isTuple!(Tuple!(int, \"x\", real, \"y\")));\nstatic assert(isTuple!(Tuple!(int, Tuple!(real), string)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1385_1209)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Rebindable",
				"line": 1466,
				"comment": "$(D Rebindable!(T)) is a simple, efficient wrapper that behaves just\nlike an object of type $(D T), except that you can reassign it to\nrefer to another object. For completeness, $(D Rebindable!(T)) aliases\nitself away to $(D T) if $(D T) is a non-const object type.\n\nYou may want to use $(D Rebindable) when you want to have mutable\nstorage referring to $(D const) objects, for example an array of\nreferences that must be sorted in place. $(D Rebindable) does not\nbreak the soundness of D's type system and does not incur any of the\nrisks usually associated with $(D cast).\n\nParams:\n    T = An object, interface, array slice type, or associative array type.\nExample:\nRegular $(D const) object references cannot be reassigned.$(DDOX_UNITTEST_HEADER __unittestL1491_1211)\n---\nclass Widget { int x; int y() const { return x; } }\nconst a = new Widget;\n// Fine\na.y();\n// error! can't modify const a\n// a.x = 5;\n// error! can't modify const a\n// a = new Widget;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1491_1211)\nExample:\nHowever, $(D Rebindable!(Widget)) does allow reassignment,\n    while otherwise behaving exactly like a $(D const Widget).$(DDOX_UNITTEST_HEADER __unittestL1507_1212)\n---\nclass Widget { int x; int y() const { return x; } }\nauto a = Rebindable!(const Widget)(new Widget);\n// Fine\na.y();\n// error! can't modify const a\n// a.x = 5;\n// Fine\na = new Widget;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1507_1212)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) || is(T == interface) || isDynamicArray!T || isAssociativeArray!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rebindable",
						"line": 1530,
						"type": "Rebindable!T(T obj)",
						"parameters": [
							{
								"name": "obj",
								"type": "T"
							}
						],
						"endline": 1536,
						"char": 14,
						"kind": "function"
					}
				],
				"name": "rebindable",
				"line": 1530,
				"comment": "Convenience function for creating a $(D Rebindable) using automatic type\ninference.\n\nParams:\n    obj = A reference to an object, interface, associative array, or an array slice\n          to initialize the `Rebindable` with.\n\nReturns:\n    A newly constructed `Rebindable` initialized with the given reference.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) || is(T == interface) || isDynamicArray!T || isAssociativeArray!T",
				"char": 14,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rebindable",
						"line": 1549,
						"type": "Rebindable!T(Rebindable!T obj)",
						"parameters": [
							{
								"name": "obj",
								"type": "Rebindable!T"
							}
						],
						"endline": 1552,
						"char": 14,
						"kind": "function"
					}
				],
				"name": "rebindable",
				"line": 1549,
				"comment": "This function simply returns the $(D Rebindable) object passed in.  It's useful\nin generic programming cases when a given object may be either a regular\n$(D class) or a $(D Rebindable).\n\nParams:\n    obj = An instance of Rebindable!T.\n\nReturns:\n    `obj` without any modification.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 14,
				"kind": "template"
			},
			{
				"members": [],
				"name": "UnqualRef",
				"line": 1653,
				"comment": "    Similar to $(D Rebindable!(T)) but strips all qualifiers from the reference as\n    opposed to just constness / immutability. Primary intended use case is with\n    shared (having thread-local reference to shared class data)\n\n    Params:\n        T = A class or interface type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1673_1214)\n---\nclass Data {}\n\nstatic shared(Data) a;\nstatic UnqualRef!(shared Data) b;\n\nimport core.thread;\n\nauto thread = new core.thread.Thread({\n    a = new shared Data();\n    b = new shared Data();\n});\n\nthread.start();\nthread.join();\n\nassert(a !is null);\nassert(b is null);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1673_1214)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) || is(T == interface)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "alignForSize",
						"line": 1717,
						"type": "string(string[] names...)",
						"parameters": [
							{
								"name": "names",
								"type": "string[]"
							}
						],
						"endline": 1743,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "alignForSize",
				"line": 1717,
				"comment": "  Order the provided members to minimize size while preserving alignment.\n  Alignment is not always optimal for 80-bit reals, nor for structs declared\n  as align(1).\n\n  Params:\n      E = A list of the types to be aligned, representing fields\n          of an aggregate such as a `struct` or `class`.\n\n      names = The names of the fields that are to be aligned.\n\n  Returns:\n      A string to be mixed in to an aggregate, such as a `struct` or `class`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1746_1216)\n---\nstruct Banner {\n    mixin(alignForSize!(byte[6], double)([\"name\", \"height\"]));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1746_1216)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "tuple"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Nullable",
						"line": 1778,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 1789,
								"comment": "Constructor initializing $(D this) with $(D value).\n\nParams:\n    value = The value to initialize this `Nullable` with.\n",
								"type": "inout (inout T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 1793,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "isNull",
								"line": 1831,
								"comment": "Check if `this` is in the null state.\n\nReturns:\n    true $(B iff) `this` is in the null state, otherwise false.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1837_1218)\n---\nNullable!int ni;\nassert(ni.isNull);\n\nni = 0;\nassert(!ni.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1837_1218)\n",
								"type": "const pure nothrow @property @safe bool()",
								"endline": 1834,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "nullify",
										"line": 1861,
										"type": "void()",
										"endline": 1865,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "nullify",
								"line": 1861,
								"comment": "Forces $(D this) to the null state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1868_1220)\n---\nNullable!int ni = 0;\nassert(!ni.isNull);\n\nni.nullify();\nassert(ni.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1868_1220)\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 1884,
										"type": "void(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 1888,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 1884,
								"comment": "Assigns $(D value) to the internally-held state. If the assignment\nsucceeds, $(D this) becomes non-null.\n\nParams:\n    value = A value of type `T` to assign to this `Nullable`.\nExample:\nIf this `Nullable` wraps a type that already has a null value\n    (such as a pointer), then assigning the null value to this\n    `Nullable` is no different than assigning any other value of\n    type `T`, and the resulting code will look very strange. It\n    is strongly recommended that this be avoided by instead using\n    the version of `Nullable` that takes an additional `nullValue`\n    template argument.$(DDOX_UNITTEST_HEADER __unittestL1899_1221)\n---\n//Passes\nNullable!(int*) npi;\nassert(npi.isNull);\n\n//Passes?!\nnpi = null;\nassert(!npi.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1899_1221)\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "get",
								"line": 1917,
								"comment": "Gets the value. $(D this) must not be in the null state.\nThis function is also called for the implicit conversion to $(D T).\n\nReturns:\n    The value held internally by this `Nullable`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1925_1222)\n---\nimport std.exception: assertThrown, assertNotThrown;\n\nNullable!int ni;\n//`get` is implicitly called. Will throw\n//an AssertError in non-release mode\nassertThrown!Throwable(ni == 0);\n\nni = 0;\nassertNotThrown!Throwable(ni == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1925_1222)\n",
								"type": "inout pure nothrow @property ref @safe inout(T)()",
								"endline": 1922,
								"char": 28,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Nullable",
				"line": 1778,
				"comment": "Defines a value paired with a distinctive \"null\" state that denotes\nthe absence of a value. If default constructed, a $(D\nNullable!T) object starts in the null state. Assigning it renders it\nnon-null. Calling $(D nullify) can nullify it again.\n\nPractically $(D Nullable!T) stores a $(D T) and a $(D bool).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1946_1223)\n---\nstruct CustomerRecord\n{\n    string name;\n    string address;\n    int customerNum;\n}\n\nNullable!CustomerRecord getByName(string name)\n{\n    //A bunch of hairy stuff\n\n    return Nullable!CustomerRecord.init;\n}\n\nauto queryResult = getByName(\"Doe, John\");\nif (!queryResult.isNull)\n{\n    //Process Mr. Doe's customer record\n    auto address = queryResult.address;\n    auto customerNum = queryResult.customerNum;\n\n    //Do some things with this customer's info\n}\nelse\n{\n    //Add the customer to the database\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1946_1223)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Nullable",
						"line": 2272,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 2282,
								"comment": "Constructor initializing $(D this) with $(D value).\n\nParams:\n    value = The value to initialize this `Nullable` with.\n",
								"type": "(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 2285,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "isNull",
								"line": 2310,
								"comment": "Check if `this` is in the null state.\n\nReturns:\n    true $(B iff) `this` is in the null state, otherwise false.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2325_1237)\n---\nNullable!(int, -1) ni;\n//Initialized to \"null\" state\nassert(ni.isNull);\n\nni = 0;\nassert(!ni.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2325_1237)\n",
								"type": "const @property bool()",
								"endline": 2322,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "nullify",
										"line": 2338,
										"type": "void()",
										"endline": 2341,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "nullify",
								"line": 2338,
								"comment": "Forces $(D this) to the null state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2344_1238)\n---\nNullable!(int, -1) ni = 0;\nassert(!ni.isNull);\n\nni = -1;\nassert(ni.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2344_1238)\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 2363,
										"type": "void(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 2366,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 2363,
								"comment": "Assigns $(D value) to the internally-held state. If the assignment\nsucceeds, $(D this) becomes non-null. No null checks are made. Note\nthat the assignment may leave $(D this) in the null state.\n\nParams:\n    value = A value of type `T` to assign to this `Nullable`.\n            If it is `nullvalue`, then the internal state of\n            this `Nullable` will be set to null.\nExample:\nIf this `Nullable` wraps a type that already has a null value\n    (such as a pointer), and that null value is not given for\n    `nullValue`, then assigning the null value to this `Nullable`\n    is no different than assigning any other value of type `T`,\n    and the resulting code will look very strange. It is strongly\n    recommended that this be avoided by using `T`'s \"built in\"\n    null value for `nullValue`.$(DDOX_UNITTEST_HEADER __unittestL2377_1239)\n---\n//Passes\nenum nullVal = cast(int*)0xCAFEBABE;\nNullable!(int*, nullVal) npi;\nassert(npi.isNull);\n\n//Passes?!\nnpi = null;\nassert(!npi.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2377_1239)\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "get",
								"line": 2396,
								"comment": "Gets the value. $(D this) must not be in the null state.\nThis function is also called for the implicit conversion to $(D T).\n\nReturns:\n    The value held internally by this `Nullable`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2406_1240)\n---\nimport std.exception: assertThrown, assertNotThrown;\n\nNullable!(int, -1) ni;\n//`get` is implicitly called. Will throw\n//an error in non-release mode\nassertThrown!Throwable(ni == 0);\n\nni = 0;\nassertNotThrown!Throwable(ni == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2406_1240)\n",
								"type": "inout @property ref inout(T)()",
								"endline": 2403,
								"char": 28,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Nullable",
				"line": 2272,
				"comment": "Just like $(D Nullable!T), except that the null state is defined as a\nparticular value. For example, $(D Nullable!(uint, uint.max)) is an\n$(D uint) that sets aside the value $(D uint.max) to denote a null\nstate. $(D Nullable!(T, nullValue)) is more storage-efficient than $(D\nNullable!T) because it does not need to store an extra $(D bool).\n\nParams:\n    T = The wrapped type for which Nullable provides a null value.\n\n    nullValue = The null value which denotes the null state of this\n                `Nullable`. Must be of type `T`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2427_1241)\n---\nNullable!(size_t, size_t.max) indexOf(string[] haystack, string needle)\n{\n    //Find the needle, returning -1 if not found\n\n    return Nullable!(size_t, size_t.max).init;\n}\n\nvoid sendLunchInvite(string name)\n{\n}\n\n//It's safer than C...\nauto coworkers = [\"Jane\", \"Jim\", \"Marry\", \"Fred\"];\nauto pos = indexOf(coworkers, \"Bob\");\nif (!pos.isNull)\n{\n    //Send Bob an invitation to lunch\n    sendLunchInvite(coworkers[pos]);\n}\nelse\n{\n    //Bob not found; report the error\n}\n\n//And there's no overhead\nstatic assert(Nullable!(size_t, size_t.max).sizeof == size_t.sizeof);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2427_1241)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "nullValue",
						"type": "T",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "NullableRef",
						"line": 2589,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 2599,
								"comment": "Constructor binding $(D this) to $(D value).\n\nParams:\n    value = The value to bind to.\n",
								"type": "pure nothrow @safe (T* value)",
								"parameters": [
									{
										"name": "value",
										"type": "T*"
									}
								],
								"endline": 2602,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "bind",
								"line": 2627,
								"comment": "Binds the internal state to $(D value).\n\nParams:\n    value = A pointer to a value of type `T` to bind this `NullableRef` to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2633_1249)\n---\nNullableRef!int nr = new int(42);\nassert(nr == 42);\n\nint* n = new int(1);\nnr.bind(n);\nassert(nr == 1);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2633_1249)\n",
								"type": "pure nothrow @safe void(T* value)",
								"parameters": [
									{
										"name": "value",
										"type": "T*"
									}
								],
								"endline": 2630,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isNull",
								"line": 2649,
								"comment": "Returns $(D true) if and only if $(D this) is in the null state.\n\nReturns:\n    true if `this` is in the null state, otherwise false.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2655_1250)\n---\nNullableRef!int nr;\nassert(nr.isNull);\n\nint* n = new int(42);\nnr.bind(n);\nassert(!nr.isNull && nr == 42);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2655_1250)\n",
								"type": "const pure nothrow @property @safe bool()",
								"endline": 2652,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "nullify",
								"line": 2668,
								"comment": "Forces $(D this) to the null state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2674_1251)\n---\nNullableRef!int nr = new int(42);\nassert(!nr.isNull);\n\nnr.nullify();\nassert(nr.isNull);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2674_1251)\n",
								"type": "pure nothrow @safe void()",
								"endline": 2671,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 2692,
										"type": "void(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 2698,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 2692,
								"comment": "Assigns $(D value) to the internally-held state.\n\nParams:\n    value = A value of type `T` to assign to this `NullableRef`.\n            If the internal state of this `NullableRef` has not\n            been initialized, an error will be thrown in\n            non-release mode.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2701_1252)\n---\nimport std.exception: assertThrown, assertNotThrown;\n\nNullableRef!int nr;\nassert(nr.isNull);\nassertThrown!Throwable(nr = 42);\n\nnr.bind(new int(0));\nassert(!nr.isNull);\nassertNotThrown!Throwable(nr = 42);\nassert(nr == 42);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2701_1252)\n",
								"parameters": [],
								"constraint": "isAssignable!T",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "get",
								"line": 2719,
								"comment": "Gets the value. $(D this) must not be in the null state.\nThis function is also called for the implicit conversion to $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2727_1253)\n---\nimport std.exception: assertThrown, assertNotThrown;\n\nNullableRef!int nr;\n//`get` is implicitly called. Will throw\n//an error in non-release mode\nassertThrown!Throwable(nr == 0);\n\nnr.bind(new int(0));\nassertNotThrown!Throwable(nr == 0);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2727_1253)\n",
								"type": "inout pure nothrow @property ref @safe inout(T)()",
								"endline": 2724,
								"char": 28,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "NullableRef",
				"line": 2589,
				"comment": "Just like $(D Nullable!T), except that the object refers to a value\nsitting elsewhere in memory. This makes assignments overwrite the\ninitially assigned value. Internally $(D NullableRef!T) only stores a\npointer to $(D T) (i.e., $(D Nullable!T.sizeof == (T*).sizeof)).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "BlackHole",
						"line": 2898,
						"type": "AutoImplement!(Base, generateEmptyFunction, isAbstractFunction)",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "BlackHole",
				"line": 2898,
				"comment": "$(D BlackHole!Base) is a subclass of $(D Base) which automatically implements\nall abstract member functions in $(D Base) as do-nothing functions.  Each\nauto-implemented function just returns the default value of the return type\nwithout doing anything.\n\nThe name came from\n$(WEB search.cpan.org/~sburke/Class-_BlackHole-0.04/lib/Class/_BlackHole.pm, Class::_BlackHole)\nPerl module by Sean M. Burke.\n\nParams:\n    Base = A non-final class for `BlackHole` to inherit from.\n\nSee_Also:\n  $(LREF AutoImplement), $(LREF generateEmptyFunction)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2901_1260)\n---\nimport std.math: isNaN;\n\nstatic abstract class C\n{\n    int m_value;\n    this(int v) { m_value = v; }\n    int value() @property { return m_value; }\n\n    abstract real realValue() @property;\n    abstract void doSomething();\n}\n\nauto c = new BlackHole!C(42);\nassert(c.value == 42);\n\n// Returns real.init which is NaN\nassert(c.realValue.isNaN);\n// Abstract functions are implemented as do-nothing\nc.doSomething();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2901_1260)\n",
				"parameters": [
					{
						"name": "Base",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "WhiteHole",
						"line": 2978,
						"type": "AutoImplement!(Base, generateAssertTrap, isAbstractFunction)",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "WhiteHole",
				"line": 2978,
				"comment": "$(D WhiteHole!Base) is a subclass of $(D Base) which automatically implements\nall abstract member functions as functions that always fail. These functions\nsimply throw an $(D Error) and never return. `Whitehole` is useful for\ntrapping the use of class member functions that haven't been implemented.\n\nThe name came from\n$(WEB search.cpan.org/~mschwern/Class-_WhiteHole-0.04/lib/Class/_WhiteHole.pm, Class::_WhiteHole)\nPerl module by Michael G Schwern.\n\nParams:\n    Base = A non-final class for `WhiteHole` to inherit from.\n\nSee_Also:\n  $(LREF AutoImplement), $(LREF generateAssertTrap)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2981_1262)\n---\nimport std.exception: assertThrown;\n\nstatic class C\n{\n    abstract void notYetImplemented();\n}\n\nauto c = new WhiteHole!C;\nassertThrown!NotImplementedError(c.notYetImplemented()); // throws an Error\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2981_1262)\n",
				"parameters": [
					{
						"name": "Base",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "AutoImplement",
						"line": 3118,
						"members": [],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "AutoImplement",
				"line": 3118,
				"comment": "$(D AutoImplement) automatically implements (by default) all abstract member\nfunctions in the class or interface $(D Base) in specified way.\n\nParams:\n  how  = template which specifies _how functions will be implemented/overridden.\n\n         Two arguments are passed to $(D how): the type $(D Base) and an alias\n         to an implemented function.  Then $(D how) must return an implemented\n         function body as a string.\n\n         The generated function body can use these keywords:\n         $(UL\n            $(LI $(D a0), $(D a1), &hellip;: arguments passed to the function;)\n            $(LI $(D args): a tuple of the arguments;)\n            $(LI $(D self): an alias to the function itself;)\n            $(LI $(D parent): an alias to the overridden function (if any).)\n         )\n\n        You may want to use templated property functions (instead of Implicit\n        Template Properties) to generate complex functions:\n--------------------\n// Prints log messages for each call to overridden functions.\nstring generateLogger(C, alias fun)() @property\n{\n    import std.traits;\n    enum qname = C.stringof ~ \".\" ~ __traits(identifier, fun);\n    string stmt;\n\n    stmt ~= q{ struct Importer { import std.stdio; } };\n    stmt ~= `Importer.writeln(\"Log: ` ~ qname ~ `(\", args, \")\");`;\n    static if (!__traits(isAbstractFunction, fun))\n    {\n        static if (is(ReturnType!fun == void))\n            stmt ~= q{ parent(args); };\n        else\n            stmt ~= q{\n                auto r = parent(args);\n                Importer.writeln(\"--> \", r);\n                return r;\n            };\n    }\n    return stmt;\n}\n--------------------\n\n  what = template which determines _what functions should be\n         implemented/overridden.\n\n         An argument is passed to $(D what): an alias to a non-final member\n         function in $(D Base).  Then $(D what) must return a boolean value.\n         Return $(D true) to indicate that the passed function should be\n         implemented/overridden.\n\n--------------------\n// Sees if fun returns something.\nenum bool hasValue(alias fun) = !is(ReturnType!(fun) == void);\n--------------------\n\n\nNote:\n\nGenerated code is inserted in the scope of $(D std.typecons) module.  Thus,\nany useful functions outside $(D std.typecons) cannot be used in the generated\ncode.  To workaround this problem, you may $(D import) necessary things in a\nlocal struct, as done in the $(D generateLogger()) template in the above\nexample.\n\n\nBUGS:\n\n$(UL\n $(LI Variadic arguments to constructors are not forwarded to super.)\n $(LI Deep interface inheritance causes compile error with messages like\n      \"Error: function std.typecons._AutoImplement!(Foo)._AutoImplement.bar\n      does not override any function\".  [$(BUGZILLA 2525), $(BUGZILLA 3525)] )\n $(LI The $(D parent) keyword is actually a delegate to the super class'\n      corresponding member function.  [$(BUGZILLA 2540)] )\n $(LI Using alias template parameter in $(D how) and/or $(D what) may cause\n     strange compile error.  Use template tuple parameter instead to workaround\n     this problem.  [$(BUGZILLA 4217)] )\n)\n",
				"parameters": [
					{
						"name": "Base",
						"kind": "type"
					},
					{
						"name": "how",
						"kind": "alias"
					},
					{
						"name": "what",
						"defaultAlias": "isAbstractFunction",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "generateEmptyFunction",
				"line": 3746,
				"comment": "Predefined how-policies for $(D AutoImplement).  These templates are also used by\n$(D BlackHole) and $(D WhiteHole), respectively.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "generateAssertTrap",
						"line": 3765,
						"type": "string",
						"init": "\"throw new NotImplementedError(\\\"\" ~ C.stringof ~ \".\" ~ __traits(identifier, func) ~ \"\\\");\"",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "generateAssertTrap",
				"line": 3763,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "wrap",
								"line": 3831,
								"type": "pure nothrow @trusted (inout Source src)",
								"parameters": [
									{
										"name": "src",
										"type": "Source",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 3836,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "wrap",
						"line": 3831,
						"parameters": [
							{
								"name": "Source",
								"kind": "type"
							}
						],
						"constraint": "Targets.length == 1 && is(Source : Targets[0])",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 9,
								"name": "wrap",
								"line": 3841,
								"type": "(inout Source src)",
								"parameters": [
									{
										"name": "src",
										"type": "Source",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 3850,
								"char": 14,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "wrap",
						"line": 3838,
						"parameters": [
							{
								"name": "Source",
								"kind": "type"
							}
						],
						"constraint": "!allSatisfy!(Bind!(isImplicitlyConvertible, Source), Targets)",
						"char": 5,
						"kind": "template"
					}
				],
				"name": "wrap",
				"line": 3825,
				"comment": " Supports structural based typesafe conversion.\n\n If $(D Source) has structural conformance with the $(D interface) $(D Targets),\n wrap creates internal wrapper class which inherits $(D Targets) and\n wrap $(D src) object, then return it.\n",
				"parameters": [
					{
						"name": "Targets",
						"kind": "tuple"
					}
				],
				"constraint": "Targets.length >= 1 && allSatisfy!(isMutable, Targets)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "wrap",
						"line": 4003,
						"type": ".wrap!(staticMap!(Unqual, Targets))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "wrap",
				"line": 3998,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Targets",
						"kind": "tuple"
					}
				],
				"constraint": "Targets.length >= 1 && !allSatisfy!(isMutable, Targets)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "unwrap",
								"line": 4019,
								"type": "pure nothrow @trusted (inout Source src)",
								"parameters": [
									{
										"name": "src",
										"type": "Source",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 4024,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "unwrap",
						"line": 4019,
						"parameters": [
							{
								"name": "Source",
								"kind": "type"
							}
						],
						"constraint": "is(Target : Source)",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "unwrap",
								"line": 4026,
								"type": "pure nothrow @trusted (inout Source src)",
								"parameters": [
									{
										"name": "src",
										"type": "Source",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 4044,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "unwrap",
						"line": 4026,
						"parameters": [
							{
								"name": "Source",
								"kind": "type"
							}
						],
						"constraint": "!is(Target : Source)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "unwrap",
				"line": 4015,
				"comment": " Extract object which wrapped by $(D wrap).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4054_1267)\n---\ninterface Quack\n{\n    int quack();\n    @property int height();\n}\ninterface Flyer\n{\n    @property int height();\n}\nclass Duck : Quack\n{\n    int quack() { return 1; }\n    @property int height() { return 10; }\n}\nclass Human\n{\n    int quack() { return 2; }\n    @property int height() { return 20; }\n}\n\nDuck d1 = new Duck();\nHuman h1 = new Human();\n\ninterface Refleshable\n{\n    int reflesh();\n}\n// does not have structural conformance\nstatic assert(!__traits(compiles, d1.wrap!Refleshable));\nstatic assert(!__traits(compiles, h1.wrap!Refleshable));\n\n// strict upcast\nQuack qd = d1.wrap!Quack;\nassert(qd is d1);\nassert(qd.quack() == 1);    // calls Duck.quack\n// strict downcast\nDuck d2 = qd.unwrap!Duck;\nassert(d2 is d1);\n\n// structural upcast\nQuack qh = h1.wrap!Quack;\nassert(qh.quack() == 2);    // calls Human.quack\n// structural downcast\nHuman h2 = qh.unwrap!Human;\nassert(h2 is h1);\n\n// structural upcast (two steps)\nQuack qx = h1.wrap!Quack;   // Human -> Quack\nFlyer fx = qx.wrap!Flyer;   // Quack -> Flyer\nassert(fx.height == 20);    // calls Human.height\n// strucural downcast (two steps)\nQuack qy = fx.unwrap!Quack; // Flyer -> Quack\nHuman hy = qy.unwrap!Human; // Quack -> Human\nassert(hy is h1);\n// strucural downcast (one step)\nHuman hz = fx.unwrap!Human; // Flyer -> Human\nassert(hz is h1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4054_1267)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4115_1268)\n---\ninterface A { int run(); }\ninterface B { int stop(); @property int status(); }\nclass X\n{\n    int run() { return 1; }\n    int stop() { return 2; }\n    @property int status() { return 3; }\n}\n\nauto x = new X();\nauto ab = x.wrap!(A, B);\nA a = ab;\nB b = ab;\nassert(a.run() == 1);\nassert(b.stop() == 2);\nassert(b.status == 3);\nstatic assert(functionAttributes!(typeof(ab).status) & FunctionAttribute.property);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4115_1268)\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					}
				],
				"constraint": "isMutable!Target",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "unwrap",
						"line": 4050,
						"type": ".unwrap!(Unqual!Target)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "unwrap",
				"line": 4047,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					}
				],
				"constraint": "!isMutable!Target",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 4534,
						"value": "0",
						"comment": "Do not auto-initialize the object\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 4536,
						"value": "1",
						"comment": "Auto-initialize the object\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "RefCountedAutoInitialize",
				"line": 4531,
				"comment": "Options regarding auto-initialization of a $(D RefCounted) object (see\nthe definition of $(D RefCounted) below).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "RefCounted",
						"line": 4557,
						"members": [
							{
								"name": "RefCountedStore",
								"line": 4562,
								"comment": "$(D RefCounted) storage implementation.\n",
								"members": [
									{
										"endchar": 9,
										"name": "isInitialized",
										"line": 4636,
										"comment": "           Returns $(D true) if and only if the underlying store has been\n           allocated and initialized.\n",
										"type": "const pure nothrow @nogc @property @safe bool()",
										"endline": 4639,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "refCount",
										"line": 4646,
										"comment": "           Returns underlying reference count if it is allocated and initialized\n           (a positive integer), and $(D 0) otherwise.\n",
										"type": "const pure nothrow @nogc @property @safe size_t()",
										"endline": 4649,
										"char": 16,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "ensureInitialized",
										"line": 4655,
										"comment": "           Makes sure the payload was properly initialized. Such a\n           call is typically inserted before using the payload.\n",
										"type": "void()",
										"endline": 4658,
										"char": 14,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							},
							{
								"endchar": 5,
								"name": "refCountedStore",
								"line": 4665,
								"comment": "Returns storage implementation struct.\n",
								"type": "inout nothrow @property ref @safe inout(RefCountedStore)()",
								"endline": 4668,
								"char": 32,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 4675,
										"type": "(auto ref A args)",
										"parameters": [
											{
												"name": "args",
												"type": "A",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 4678,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 4675,
								"comment": "Constructor that initializes the payload.\n\nPostcondition: $(D refCountedStore.isInitialized)\n",
								"parameters": [
									{
										"name": "A",
										"kind": "tuple"
									}
								],
								"constraint": "A.length > 0",
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 4681,
								"comment": "Ditto\n",
								"type": "(T val)",
								"parameters": [
									{
										"name": "val",
										"type": "T"
									}
								],
								"endline": 4684,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "~this",
								"line": 4702,
								"comment": "Destructor that tracks the reference count appropriately. If $(D\n!refCountedStore.isInitialized), does nothing. When the reference count goes\ndown to zero, calls $(D destroy) agaist the payload and calls $(D free)\nto deallocate the corresponding resource.\n",
								"endline": 4718,
								"char": 5,
								"kind": "destructor"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 4723,
								"comment": "Assignment operators\n",
								"type": "void(typeof(this) rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "typeof(this)"
									}
								],
								"endline": 4728,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 4731,
								"comment": "Ditto\n",
								"type": "void(T rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "T"
									}
								],
								"endline": 4744,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "refCountedPayload",
								"line": 4764,
								"comment": "        Returns a reference to the payload. If (autoInit ==\n        RefCountedAutoInitialize.yes), calls $(D\n        refCountedStore.ensureInitialized). Otherwise, just issues $(D\n        assert(refCountedStore.isInitialized)). Used with $(D alias\n        refCountedPayload this;), so callers can just use the $(D RefCounted)\n        object as a $(D T).\n\n        $(BLUE The first overload exists only if $(D autoInit == RefCountedAutoInitialize.yes).)\n        So if $(D autoInit == RefCountedAutoInitialize.no)\n        or called for a constant or immutable object, then\n        $(D refCountedPayload) will also be qualified as safe and nothrow\n        (but will still assert if not initialized).\n",
								"type": "@property ref return T()",
								"char": 15,
								"kind": "function"
							},
							{
								"name": "refCountedPayload",
								"line": 4768,
								"comment": "ditto\n",
								"type": "inout pure nothrow @nogc @property ref return @safe inout(T)()",
								"char": 22,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "RefCounted",
				"line": 4557,
				"comment": "Defines a reference-counted object containing a $(D T) value as\npayload. $(D RefCounted) keeps track of all references of an object,\nand when the reference count goes down to zero, frees the underlying\nstore. $(D RefCounted) uses $(D malloc) and $(D free) for operation.\n\n$(D RefCounted) is unsafe and should be used with care. No references\nto the payload should be escaped outside the $(D RefCounted) object.\n\nThe $(D autoInit) option makes the object ensure the store is\nautomatically initialized. Leaving $(D autoInit ==\nRefCountedAutoInitialize.yes) (the default option) is convenient but\nhas the cost of a test whenever the payload is accessed. If $(D\nautoInit == RefCountedAutoInitialize.no), user code must call either\n$(D refCountedStore.isInitialized) or $(D refCountedStore.ensureInitialized)\nbefore attempting to access the payload. Not doing so results in null\npointer dereference.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4801_1275)\n---\n// A pair of an $(D int) and a $(D size_t) - the latter being the\n// reference count - will be dynamically allocated\nauto rc1 = RefCounted!int(5);\nassert(rc1 == 5);\n// No more allocation, add just one extra reference count\nauto rc2 = rc1;\n// Reference semantics\nrc2 = 42;\nassert(rc1 == 42);\n// the pair will be freed when rc1 and rc2 go out of scope\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4801_1275)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "autoInit",
						"defaultValue": "RefCountedAutoInitialize.yes",
						"deco": "E3std8typecons24RefCountedAutoInitialize",
						"kind": "value"
					}
				],
				"constraint": "!is(T == class) && !is(T == interface)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "refCounted",
						"line": 4911,
						"type": "RefCounted!(T, RefCountedAutoInitialize.no)(T val)",
						"parameters": [
							{
								"name": "val",
								"type": "T"
							}
						],
						"endline": 4916,
						"char": 45,
						"kind": "function"
					}
				],
				"name": "refCounted",
				"line": 4911,
				"comment": " Initializes a `RefCounted` with `val`. The template parameter\n `T` of `RefCounted` is inferred from `val`.\n This function can be used to move non-copyable values to the heap.\n It also disables the `autoInit` option of `RefCounted`.\n\n Params:\n   val = The value to be reference counted\n Returns:\n   An initialized $(D RefCounted) containing $(D val).\n See_Also:\n   $(WEB http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared, C++'s make_shared)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4919_1281)\n---\nstatic struct File\n{\n    string name;\n    @disable this(this); // not copyable\n    ~this() { name = null; }\n}\n\nauto file = File(\"name\");\nassert(file.name == \"name\");\n// file cannot be copied and has unique ownership\nstatic assert(!__traits(compiles, {auto file2 = file;}));\n\n// make the file refcounted to share ownership\nimport std.algorithm.mutation : move;\nauto rcFile = refCounted(move(file));\nassert(rcFile.name == \"name\");\nassert(file.name == null);\nauto rcFile2 = rcFile;\nassert(rcFile.refCountedStore.refCount == 2);\n// file gets properly closed when last reference is dropped\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4919_1281)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 45,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Proxy",
				"line": 4958,
				"comment": "    Creates a proxy for the value `a` that will forward all operations\n    while disabling implicit conversions. The aliased item `a` must be\n    an $(B lvalue). This is useful for creating a new type from the\n    \"base\" type (though this is $(B not) a subtype-supertype\n    relationship; the new type is not related to the old type in any way,\n    by design).\n\n    The new type supports all operations that the underlying type does,\n    including all operators such as `+`, `--`, `<`, `[]`, etc.\n\n    Params:\n        a = The value to act as a proxy for all operations. It must\n            be an lvalue.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5161_1282)\n---\nstruct MyInt\n{\n    private int value;\n    mixin Proxy!value;\n\n    this(int n){ value = n; }\n}\n\nMyInt n = 10;\n\n// Enable operations that original type has.\n++n;\nassert(n == 11);\nassert(n * 2 == 22);\n\nvoid func(int n) { }\n\n// Disable implicit conversions to original type.\n//int x = n;\n//func(n);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5161_1282)\nExample:\nThe proxied value must be an $(B lvalue).$(DDOX_UNITTEST_HEADER __unittestL5186_1283)\n---\nstruct NewIntType\n{\n    //Won't work; the literal '1' is\n    //is an rvalue, not an lvalue\n    //mixin Proxy!1;\n\n    //Okay, n is an lvalue\n    int n;\n    mixin Proxy!n;\n\n    this(int n) { this.n = n; }\n}\n\nNewIntType nit = 0;\nnit++;\nassert(nit == 1);\n\n\nstruct NewObjectType\n{\n    Object obj;\n    //Ok, obj is an lvalue\n    mixin Proxy!obj;\n\n    this (Object o) { obj = o; }\n}\n\nNewObjectType not = new Object();\nassert(__traits(compiles, not.toHash()));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5186_1283)\nExample:\nThere is one exception to the fact that the new type is not related to the\n    old type. $(DDSUBLINK spec/function,pseudo-member, Pseudo-member)\n    functions are usable with the new type; they will be forwarded on to the\n    proxied value.$(DDOX_UNITTEST_HEADER __unittestL5225_1284)\n---\nimport std.math;\n\nfloat f = 1.0;\nassert(!f.isInfinity);\n\nstruct NewFloat\n{\n    float _;\n    mixin Proxy!_;\n\n    this(float f) { _ = f; }\n}\n\nNewFloat nf = 1.0f;\nassert(!nf.isInfinity);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5225_1284)\n",
				"parameters": [
					{
						"name": "a",
						"kind": "alias"
					}
				],
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Typedef",
						"line": 5642,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Typedef",
				"line": 5642,
				"comment": "$(B Typedef) allows the creation of a unique type which is\nbased on an existing type. Unlike the $(D alias) feature,\n$(B Typedef) ensures the two types are not considered as equals.\n\nExample:\n----\nalias MyInt = Typedef!int;\nstatic void takeInt(int) { }\nstatic void takeMyInt(MyInt) { }\n\nint i;\ntakeInt(i);    // ok\ntakeMyInt(i);  // fails\n\nMyInt myInt;\ntakeInt(myInt);    // fails\ntakeMyInt(myInt);  // ok\n----\n\nParams:\n\ninit = Optional initial value for the new type. For example:\n\n----\nalias MyInt = Typedef!(int, 10);\nMyInt myInt;\nassert(myInt == 10);  // default-initialized to 10\n----\n\ncookie = Optional, used to create multiple unique types which are\nbased on the same origin type $(D T). For example:\n\n----\nalias TypeInt1 = Typedef!int;\nalias TypeInt2 = Typedef!int;\n\n// The two Typedefs are the same type.\nstatic assert(is(TypeInt1 == TypeInt2));\n\nalias MoneyEuros = Typedef!(float, float.init, \"euros\");\nalias MoneyDollars = Typedef!(float, float.init, \"dollars\");\n\n// The two Typedefs are _not_ the same type.\nstatic assert(!is(MoneyEuros == MoneyDollars));\n----\n\nNote: If a library routine cannot handle the Typedef type,\nyou can use the $(D TypedefType) template to extract the\ntype which the Typedef wraps.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "init",
						"type": "T",
						"defaultValue": "T.init",
						"kind": "value"
					},
					{
						"name": "cookie",
						"defaultValue": "null",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "TypedefType",
				"line": 5675,
				"comment": "Get the underlying type which a $(D Typedef) wraps.\nIf $(D T) is not a $(D Typedef) it will alias itself to $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5684_1292)\n---\nimport std.typecons: Typedef, TypedefType;\nimport std.conv: to;\n\nalias MyInt = Typedef!int;\nstatic assert(is(TypedefType!MyInt == int));\n\n/// Instantiating with a non-Typedef will return that type\nstatic assert(is(TypedefType!int == int));\n\nstring num = \"5\";\n\n// extract the needed type\nMyInt myInt = MyInt( num.to!(TypedefType!MyInt) );\nassert(myInt == 5);\n\n// cast to the underlying type to get the value that's being wrapped\nint x = cast(TypedefType!MyInt)myInt;\n\nalias MyIntInit = Typedef!(int, 42);\nstatic assert(is(TypedefType!MyIntInit == int));\nstatic assert(MyIntInit() == 42);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5684_1292)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "scoped",
								"line": 5918,
								"type": "@system (auto ref Args args)",
								"parameters": [
									{
										"name": "args",
										"type": "Args",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 5928,
								"char": 18,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "scoped",
						"line": 5918,
						"comment": "Returns the scoped object\n",
						"parameters": [
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"char": 18,
						"kind": "template"
					}
				],
				"name": "scoped",
				"line": 5877,
				"comment": "Allocates a $(D class) object right inside the current scope,\ntherefore avoiding the overhead of $(D new). This facility is unsafe;\nit is the responsibility of the user to not escape a reference to the\nobject outside the scope.\n\nNote: it's illegal to move a class reference even if you are sure there\nare no pointers to it. As such, it is illegal to move a scoped object.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5931_1298)\n---\nclass A\n{\n    int x;\n    this()     {x = 0;}\n    this(int i){x = i;}\n}\n\n// Standard usage\nauto a1 = scoped!A();\nauto a2 = scoped!A(1);\na1.x = 42;\nassert(a1.x == 42);\nassert(a2.x ==  1);\n\n// Restrictions\nstatic assert(!is(typeof({\n    auto e1 = a1; // illegal, scoped objects can't be copied\n    assert([a2][0].x == 42); // ditto\n    alias ScopedObject = typeof(a1);\n    auto e2 = ScopedObject();  //Illegal, must be built via scoped!A\n    auto e3 = ScopedObject(1); //Illegal, must be built via scoped!A\n})));\n\n// Use as member variable\nstruct B\n{\n    typeof(scoped!A()) a; // note the trailing parentheses\n}\n\n// Use with alias\nalias makeScopedA = scoped!A;\nauto a6 = makeScopedA();\nauto a7 = makeScopedA();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5931_1298)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"name": "no",
								"line": 6292,
								"value": "false",
								"comment": "         When creating a value of type $(D Flag!\"Name\"), use $(D\n         Flag!\"Name\".no) for the negative option. When using a value\n         of type $(D Flag!\"Name\"), compare it against $(D\n         Flag!\"Name\".no) or just $(D false) or $(D 0).\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "yes",
								"line": 6299,
								"value": "true",
								"comment": " When creating a value of type $(D Flag!\"Name\"), use $(D\n         Flag!\"Name\".yes) for the affirmative option. When using a\n         value of type $(D Flag!\"Name\"), compare it against $(D\n         Flag!\"Name\".yes).\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "Flag",
						"line": 6285,
						"comment": "\n",
						"baseDeco": "b",
						"char": 5,
						"kind": "enum"
					}
				],
				"name": "Flag",
				"line": 6283,
				"comment": "Defines a simple, self-documenting yes/no flag. This makes it easy for\nAPIs to define functions accepting flags without resorting to $(D\nbool), which is opaque in calls, and without needing to define an\nenumerated type separately. Using $(D Flag!\"Name\") instead of $(D\nbool) makes the flag's meaning visible in calls. Each yes/no flag has\nits own type, which makes confusions and mix-ups impossible.\n\nExample:\n\nCode calling $(D getLine) (usually far away from its definition) can't be\nunderstood without looking at the documentation, even by users familiar with\nthe API:\n----\nstring getLine(bool keepTerminator)\n{\n    ...\n    if (keepTerminator) ...\n    ...\n}\n...\nauto line = getLine(false);\n----\n\nAssuming the reverse meaning (i.e. \"ignoreTerminator\") and inserting the wrong\ncode compiles and runs with erroneous results.\n\nAfter replacing the boolean parameter with an instantiation of $(D Flag), code\ncalling $(D getLine) can be easily read and understood even by people not\nfluent with the API:\n\n----\nstring getLine(Flag!\"keepTerminator\" keepTerminator)\n{\n    ...\n    if (keepTerminator) ...\n    ...\n}\n...\nauto line = getLine(Flag!\"keepTerminator\".yes);\n----\n\nPassing categorical data by means of unstructured $(D bool)\nparameters is classified under \"simple-data coupling\" by Steve\nMcConnell in the $(LUCKY Code Complete) book, along with three other\nkinds of coupling. The author argues citing several studies that\ncoupling has a negative effect on code quality. $(D Flag) offers a\nsimple structuring method for passing yes/no flags to APIs.\n\nAn alias can be used to reduce the verbosity of the flag's type:\n----\nalias KeepTerminator = Flag!\"keepTerminator\";\nstring getline(KeepTerminator keepTerminator)\n{\n    ...\n    if (keepTerminator) ...\n    ...\n}\n...\n// Code calling getLine can now refer to flag values using the shorter name:\nauto line = getLine(KeepTerminator.yes);\n----\n",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "Yes",
				"line": 6308,
				"comment": "Convenience names that allow using e.g. $(D Yes.encryption) instead of\n$(D Flag!\"encryption\".yes) and $(D No.encryption) instead of $(D\nFlag!\"encryption\".no).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6327_1312)\n---\nFlag!\"abc\" flag1;\nassert(flag1 == Flag!\"abc\".no);\nassert(flag1 == No.abc);\nassert(!flag1);\nif (flag1) assert(false);\nflag1 = Yes.abc;\nassert(flag1);\nif (!flag1) assert(false);\nif (flag1) {} else assert(false);\nassert(flag1 == Yes.abc);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6327_1312)\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "No",
				"line": 6318,
				"comment": "Ditto\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [],
				"name": "isBitFlagEnum",
				"line": 6347,
				"comment": "Detect whether an enum is of integral type and has only \"flag\" values\n(i.e. values with a bit count of exactly 1).\nAdditionally, a zero value is allowed for compatibility with enums including\na \"None\" value.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6369_1313)\n---\nenum A\n{\n    None,\n    A = 1<<0,\n    B = 1<<1,\n    C = 1<<2,\n    D = 1<<3,\n}\n\nstatic assert(isBitFlagEnum!A);\n\nenum B\n{\n    A,\n    B,\n    C,\n    D // D == 3\n}\n\nstatic assert(!isBitFlagEnum!B);\n\nenum C: double\n{\n    A = 1<<0,\n    B = 1<<1\n}\n\nstatic assert(!isBitFlagEnum!C);\n}\n\n/**\nA typesafe structure for storing combinations of enum values.\n\nThis template defines a simple struct to represent bitwise OR combinations of\nenum values. It can be used if all the enum values are integral constants with\na bit count of at most 1, or if the $(D unsafe) parameter is explicitly set to\nYes.\nThis is much safer than using the enum itself to store\nthe OR combination, which can produce surprising effects like this:\n----\nenum E\n{\nA = 1<<0,\nB = 1<<1\n}\nE e = E.A | E.B;\n// will throw SwitchError\nfinal switch(e)\n{\ncase E.A:\n    return;\ncase E.B:\n    return;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6369_1313)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "BitFlags",
						"line": 6427,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "BitFlags",
				"line": 6427,
				"comment": "A typesafe structure for storing combinations of enum values.\n\nThis template defines a simple struct to represent bitwise OR combinations of\nenum values. It can be used if all the enum values are integral constants with\na bit count of at most 1, or if the $(D unsafe) parameter is explicitly set to\nYes.\nThis is much safer than using the enum itself to store\nthe OR combination, which can produce surprising effects like this:\n----\nenum E\n{\n    A = 1<<0,\n    B = 1<<1\n}\nE e = E.A | E.B;\n// will throw SwitchError\nfinal switch(e)\n{\n    case E.A:\n        return;\n    case E.B:\n        return;\n}\n----\nExample:\nBitFlags can be manipulated with the usual operators$(DDOX_UNITTEST_HEADER __unittestL6555_1314)\n---\n// You can use such an enum with BitFlags straight away\nenum Enum\n{\n    None,\n    A = 1<<0,\n    B = 1<<1,\n    C = 1<<2\n}\nBitFlags!Enum flags1;\nassert(!(flags1 & (Enum.A | Enum.B | Enum.C)));\n\n// You need to specify the $(D unsafe) parameter for enum with custom values\nenum UnsafeEnum\n{\n    A,\n    B,\n    C,\n    D = B|C\n}\nstatic assert(!__traits(compiles, { BitFlags!UnsafeEnum flags2; }));\nBitFlags!(UnsafeEnum, Yes.unsafe) flags3;\n\nimmutable BitFlags!Enum flags_empty;\n// A default constructed BitFlags has no value set\nassert(!(flags_empty & Enum.A) && !(flags_empty & Enum.B) && !(flags_empty & Enum.C));\n\n// Value can be set with the | operator\nimmutable BitFlags!Enum flags_A = flags_empty | Enum.A;\n\n// And tested with the & operator\nassert(flags_A & Enum.A);\n\n// Which commutes\nassert(Enum.A & flags_A);\n\n// BitFlags can be variadically initialized\nimmutable BitFlags!Enum flags_AB = BitFlags!Enum(Enum.A, Enum.B);\nassert((flags_AB & Enum.A) && (flags_AB & Enum.B) && !(flags_AB & Enum.C));\n\n// Use the ~ operator for subtracting flags\nimmutable BitFlags!Enum flags_B = flags_AB & ~BitFlags!Enum(Enum.A);\nassert(!(flags_B & Enum.A) && (flags_B & Enum.B) && !(flags_B & Enum.C));\n\n// You can use the EnumMembers template to set all flags\nimmutable BitFlags!Enum flags_all = EnumMembers!Enum;\n\n// use & between BitFlags for intersection\nimmutable BitFlags!Enum flags_BC = BitFlags!Enum(Enum.B, Enum.C);\nassert (flags_B == (flags_BC & flags_AB));\n\n// All the binary operators work in their assignment version\nBitFlags!Enum temp = flags_empty;\ntemp |= flags_AB;\nassert(temp == (flags_empty | flags_AB));\ntemp = flags_empty;\ntemp |= Enum.B;\nassert(temp == (flags_empty | Enum.B));\ntemp = flags_empty;\ntemp &= flags_AB;\nassert(temp == (flags_empty & flags_AB));\ntemp = flags_empty;\ntemp &= Enum.A;\nassert(temp == (flags_empty & Enum.A));\n\n// BitFlags with no value set evaluate to false\nassert(!flags_empty);\n\n// BitFlags with at least one value set evaluate to true\nassert(flags_A);\n\n// This can be useful to check intersection between BitFlags\nassert(flags_A & flags_AB);\nassert(flags_AB & Enum.A);\n\n// Finally, you can of course get you raw value out of flags\nauto value = cast(int)flags_A;\nassert(value == Enum.A);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6555_1314)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "unsafe",
						"defaultValue": "No.unsafe",
						"deco": "E3std8typecons28__T4FlagVAyaa6_756e73616665Z4Flag",
						"kind": "value"
					}
				],
				"constraint": "unsafe || isBitFlagEnum!E",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "ReplaceType",
				"line": 6653,
				"comment": "Replaces all occurrences of `From` into `To`, in one or more types `T`. For\nexample, $(D ReplaceType!(int, uint, Tuple!(int, float)[string])) yields\n$(D Tuple!(uint, float)[string]). The types in which replacement is performed\nmay be arbitrarily complex, including qualifiers, built-in type constructors\n(pointers, arrays, associative arrays, functions, and delegates), and template\ninstantiations; replacement proceeds transitively through the type definition.\nHowever, member types in `struct`s or `class`es are not replaced because there\nare no ways to express the types resulting after replacement.\n\nThis is an advanced type manipulation necessary e.g. for replacing the\nplaceholder type `This` in $(XREF variant, Algebraic).\n\nReturns: `ReplaceType` aliases itself to the type(s) that result after\nreplacement.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6717_1315)\n---\nstatic assert(\n    is(ReplaceType!(int, string, int[]) == string[]) &&\n    is(ReplaceType!(int, string, int[int]) == string[string]) &&\n    is(ReplaceType!(int, string, const(int)[]) == const(string)[]) &&\n    is(ReplaceType!(int, string, Tuple!(int[], float))\n        == Tuple!(string[], float))\n);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6717_1315)\n",
				"parameters": [
					{
						"name": "From",
						"kind": "type"
					},
					{
						"name": "To",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module implements a variety of type constructors, i.e., templates\nthat allow construction of new, useful general-purpose types.\n\nSource:    $(PHOBOSSRC std/_typecons.d)\n\nMacros:\n\nWIKI = Phobos/StdVariant\n\nSynopsis:\n\n----\n// value tuples\nalias Coord = Tuple!(float, \"x\", float, \"y\", float, \"z\");\nCoord c;\nc[1] = 1;       // access by index\nc.z = 1;        // access by given name\nalias DicEntry = Tuple!(string, string); // names can be omitted\n\n// Rebindable references to const and immutable objects\nvoid bar()\n{\n    const w1 = new Widget, w2 = new Widget;\n    w1.foo();\n    // w1 = w2 would not work; can't rebind const object\n    auto r = Rebindable!(const Widget)(w1);\n    // invoke method as if r were a Widget object\n    r.foo();\n    // rebind r to refer to another object\n    r = w2;\n}\n----\n\nCopyright: Copyright the respective authors, 2008-\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu),\n           $(WEB bartoszmilewski.wordpress.com, Bartosz Milewski),\n           Don Clugston,\n           Shin Fujishiro,\n           Kenji Hara\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/conv.d",
		"name": "std.conv",
		"members": [
			{
				"members": [],
				"name": "ConvException",
				"line": 44,
				"comment": " Thrown on conversion errors.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "ConvOverflowException",
				"line": 159,
				"comment": " Thrown on conversion overflow errors.\n",
				"base": "std.conv.ConvException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "to",
								"line": 295,
								"type": "T(A args)",
								"parameters": [
									{
										"name": "args",
										"type": "A"
									}
								],
								"endline": 299,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "to",
						"line": 295,
						"parameters": [
							{
								"name": "A",
								"kind": "tuple"
							}
						],
						"constraint": "!isRawStaticArray!A",
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "to",
								"line": 302,
								"type": "T(ref S arg)",
								"parameters": [
									{
										"name": "arg",
										"type": "S",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 306,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "to",
						"line": 302,
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isRawStaticArray!S",
						"char": 7,
						"kind": "template"
					}
				],
				"name": "to",
				"line": 293,
				"comment": "\nThe $(D_PARAM to) family of functions converts a value from type\n$(D_PARAM Source) to type $(D_PARAM Target). The source type is\ndeduced and the target type must be specified, for example the\nexpression $(D_PARAM to!int(42.0)) converts the number 42 from\n$(D_PARAM double) to $(D_PARAM int). The conversion is \"safe\", i.e.,\nit checks for overflow; $(D_PARAM to!int(4.2e10)) would throw the\n$(D_PARAM ConvOverflowException) exception. Overflow checks are only\ninserted when necessary, e.g., $(D_PARAM to!double(42)) does not do\nany checking because any int fits in a double.\n\nConverting a value to its own type (useful mostly for generic code)\nsimply returns its argument.\n\nExample:\n-------------------------\nint a = 42;\nauto b = to!int(a); // b is int with value 42\nauto c = to!double(3.14); // c is double with value 3.14\n-------------------------\n\nConverting among numeric types is a safe way to cast them around.\n\nConversions from floating-point types to integral types allow loss of\nprecision (the fractional part of a floating-point number). The\nconversion is truncating towards zero, the same way a cast would\ntruncate. (To round a floating point value when casting to an\nintegral, use $(D_PARAM roundTo).)\n\nExample:\n-------------------------\nint a = 420;\nauto b = to!long(a); // same as long b = a;\nauto c = to!byte(a / 10); // fine, c = 42\nauto d = to!byte(a); // throw ConvOverflowException\ndouble e = 4.2e6;\nauto f = to!int(e); // f == 4200000\ne = -3.14;\nauto g = to!uint(e); // fails: floating-to-integral negative overflow\ne = 3.14;\nauto h = to!uint(e); // h = 3\ne = 3.99;\nh = to!uint(a); // h = 3\ne = -3.99;\nf = to!int(a); // f = -3\n-------------------------\n\nConversions from integral types to floating-point types always\nsucceed, but might lose accuracy. The largest integers with a\npredecessor representable in floating-point format are 2^24-1 for\nfloat, 2^53-1 for double, and 2^64-1 for $(D_PARAM real) (when\n$(D_PARAM real) is 80-bit, e.g. on Intel machines).\n\nExample:\n-------------------------\nint a = 16_777_215; // 2^24 - 1, largest proper integer representable as float\nassert(to!int(to!float(a)) == a);\nassert(to!int(to!float(-a)) == -a);\na += 2;\nassert(to!int(to!float(a)) == a); // fails!\n-------------------------\n\nConversions from string to numeric types differ from the C equivalents\n$(D_PARAM atoi()) and $(D_PARAM atol()) by checking for overflow and\nnot allowing whitespace.\n\nFor conversion of strings to signed types, the grammar recognized is:\n<pre>\n$(I Integer): $(I Sign UnsignedInteger)\n$(I UnsignedInteger)\n$(I Sign):\n    $(B +)\n    $(B -)\n</pre>\n\nFor conversion to unsigned types, the grammar recognized is:\n<pre>\n$(I UnsignedInteger):\n    $(I DecimalDigit)\n    $(I DecimalDigit) $(I UnsignedInteger)\n</pre>\n\nConverting an array to another array type works by converting each\nelement in turn. Associative arrays can be converted to associative\narrays as long as keys and values can in turn be converted.\n\nExample:\n-------------------------\nint[] a = [1, 2, 3];\nauto b = to!(float[])(a);\nassert(b == [1.0f, 2, 3]);\nstring str = \"1 2 3 4 5 6\";\nauto numbers = to!(double[])(split(str));\nassert(numbers == [1.0, 2, 3, 4, 5, 6]);\nint[string] c;\nc[\"a\"] = 1;\nc[\"b\"] = 2;\nauto d = to!(double[wstring])(c);\nassert(d[\"a\"w] == 1 && d[\"b\"w] == 2);\n-------------------------\n\nConversions operate transitively, meaning that they work on arrays and\nassociative arrays of any complexity:\n\n-------------------------\nint[string][double[int[]]] a;\n...\nauto b = to!(short[wstring][string[double[]]])(a);\n-------------------------\n\nThis conversion works because $(D_PARAM to!short) applies to an\n$(D_PARAM int), $(D_PARAM to!wstring) applies to a $(D_PARAM\nstring), $(D_PARAM to!string) applies to a $(D_PARAM double), and\n$(D_PARAM to!(double[])) applies to an $(D_PARAM int[]). The\nconversion might throw an exception because $(D_PARAM to!short)\nmight fail the range check.\n\n\n   Entry point that dispatches to the appropriate conversion\n   primitive. Client code normally calls $(D _to!TargetType(value))\n   (and not some variant of $(D toImpl)).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 364,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 389,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 364,
				"comment": "If the source type is implicitly convertible to the target type, $(D\nto) simply performs the implicit conversion.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isImplicitlyConvertible!(S, T) && !isEnumStrToStr!(S, T) && !isNullToStr!(S, T)",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 494,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 501,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 494,
				"comment": "When source type supports member template function opCast, it is used.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && is(typeof(S.init.opCast!T()) : T) && !isExactSomeString!T && !is(typeof(T(value)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 545,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 550,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 545,
				"comment": "When target type supports 'converting construction', it is used.\n$(UL $(LI If target type is struct, $(D T(value)) is used.)\n     $(LI If target type is class, $(D new T(value)) is used.))\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && is(T == struct) && is(typeof(T(value)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 594,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 599,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 594,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && is(T == class) && is(typeof(new T(value)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 667,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 716,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 667,
				"comment": "Object-to-object conversions by dynamic casting throw exception when the source is\nnon-null and the target is null.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && (is(S == class) || is(S == interface)) && !is(typeof(value.opCast!T()) : T) && (is(T == class) || is(T == interface)) && !is(typeof(new T(value)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 830,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 925,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 830,
				"comment": "Stringize conversion from all types is supported.\n$(UL\n  $(LI String _to string conversion works for any two string types having\n       ($(D char), $(D wchar), $(D dchar)) character widths and any\n       combination of qualifiers (mutable, $(D const), or $(D immutable)).)\n  $(LI Converts array (other than strings) to string.\n       Each element is converted by calling $(D to!T).)\n  $(LI Associative array to string conversion.\n       Each element is printed by calling $(D to!T).)\n  $(LI Object to string conversion calls $(D toString) against the object or\n       returns $(D \"null\") if the object is null.)\n  $(LI Struct to string conversion calls $(D toString) against the struct if\n       it is defined.)\n  $(LI For structs that do not define $(D toString), the conversion to string\n       produces the list of fields.)\n  $(LI Enumerated types are converted to strings as their symbolic names.)\n  $(LI Boolean values are printed as $(D \"true\") or $(D \"false\").)\n  $(LI $(D char), $(D wchar), $(D dchar) to a string type.)\n  $(LI Unsigned or signed integers to strings.\n       $(DL $(DT [special case])\n            $(DD Convert integral value to string in $(D_PARAM radix) radix.\n            radix must be a value from 2 to 36.\n            value is treated as a signed value only if radix is 10.\n            The characters A through Z are used to represent values 10 through 36\n            and their case is determined by the $(D_PARAM letterCase) parameter.)))\n  $(LI All floating point types to all string types.)\n  $(LI Pointer to string conversions prints the pointer as a $(D size_t) value.\n       If pointer is $(D char*), treat it as C-style strings.\n       In that case, this function is $(D @system).))\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!(isImplicitlyConvertible!(S, T) && !isEnumStrToStr!(S, T) && !isNullToStr!(S, T)) && !isInfinite!S && isExactSomeString!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1222,
						"type": "pure @trusted T(S value, uint radix, LetterCase letterCase = LetterCase.upper)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							},
							{
								"name": "radix",
								"deco": "k"
							},
							{
								"name": "letterCase",
								"type": "LetterCase",
								"default": "LetterCase.upper"
							}
						],
						"endline": 1274,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1222,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!S && isExactSomeString!T",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1302,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 1331,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1302,
				"comment": "Narrowing numeric-numeric conversions throw when the value does not\nfit in the narrower type.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && (isNumeric!S || isSomeChar!S || isBoolean!S) && (isNumeric!T || isSomeChar!T || isBoolean!T) && !is(T == enum)",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1395,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 1421,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1395,
				"comment": "Array-to-array conversion (except when target is a string type)\nconverts each element in turn by using $(D to).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && !isSomeString!S && isDynamicArray!S && !isExactSomeString!T && isArray!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1479,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 1498,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1479,
				"comment": "Associative array to associative array conversion converts each key\nand each value in turn.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isAssociativeArray!S && isAssociativeArray!T && !is(T == enum)",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1712,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 1724,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1712,
				"comment": "String to non-string conversion runs parsing.\n$(UL\n  $(LI When the source is a wide string, it is first converted to a narrow\n       string and then parsed.)\n  $(LI When the source is a narrow string, normal text parsing occurs.))\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!S && isDynamicArray!S && !isExactSomeString!T && is(typeof(parse!T(value)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1727,
						"type": "T(S value, uint radix)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							},
							{
								"name": "radix",
								"deco": "k"
							}
						],
						"endline": 1739,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1727,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!S && isDynamicArray!S && !isExactSomeString!T && is(typeof(parse!T(value, radix)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1768,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 1779,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1768,
				"comment": "Convert a value that is implicitly convertible to the enum base type\ninto an Enum value. If the value does not match any enum member values\na ConvException is thrown.\nEnums with floating-point or string base types are not supported.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(T == enum) && !is(S == enum) && is(typeof(value == OriginalType!T.init)) && !isFloatingPoint!(OriginalType!T) && !isSomeString!(OriginalType!T)",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "roundTo",
								"line": 1803,
								"type": "Target(Source value)",
								"parameters": [
									{
										"name": "value",
										"type": "Source"
									}
								],
								"endline": 1810,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "roundTo",
						"line": 1803,
						"parameters": [
							{
								"name": "Source",
								"kind": "type"
							}
						],
						"char": 12,
						"kind": "template"
					}
				],
				"name": "roundTo",
				"line": 1801,
				"comment": " Rounded conversion from floating point to integral.\n\nRounded conversions do not work with non-integral target types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1814_1362)\n---\nassert(roundTo!int(3.14) == 3);\nassert(roundTo!int(3.49) == 3);\nassert(roundTo!int(3.5) == 4);\nassert(roundTo!int(3.999) == 4);\nassert(roundTo!int(-3.14) == -3);\nassert(roundTo!int(-3.49) == -3);\nassert(roundTo!int(-3.5) == -4);\nassert(roundTo!int(-3.999) == -4);\nassert(roundTo!(const int)(to!(const double)(-3.999)) == -4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1814_1362)\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 1853,
						"type": "Target(ref Source s)",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1877,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 1853,
				"comment": "The $(D parse) family of functions works quite like the $(D to)\nfamily, except that:\n$(OL\n    $(LI It only works with character ranges as input.)\n    $(LI It takes the input by reference. (This means that rvalues - such\n    as string literals - are not accepted: use $(D to) instead.))\n    $(LI It advances the input to the position following the conversion.)\n    $(LI It does not throw if it could not convert the entire input.))\n\nIt still throws if an overflow occurred during conversion or if no character\nof the input was meaningfully converted.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1880_1364)\n---\nimport std.string : munch;\nstring test = \"123 \\t  76.14\";\nauto a = parse!uint(test);\nassert(a == 123);\nassert(test == \" \\t  76.14\"); // parse bumps string\nmunch(test, \" \\t\\n\\r\"); // skip ws\nassert(test == \"76.14\");\nauto b = parse!double(test);\nassert(b == 76.14);\nassert(test == \"\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1880_1364)\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Source && isSomeChar!(ElementType!Source) && is(Unqual!Target == bool)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 2215,
						"type": "Target(ref Source s, uint radix)",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "radix",
								"deco": "k"
							}
						],
						"endline": 2270,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 2215,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!(ElementType!Source) && isIntegral!Target && !is(Target == enum)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 3028,
						"type": "Target(ref Source s)",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 3047,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 3028,
				"comment": "Parsing one character off a string returns the character and bumps the\nstring up one position.\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!Source && staticIndexOf!(Unqual!Target, dchar, Unqual!(ElementEncodingType!Source)) >= 0",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 3173,
						"type": "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar comma = ',')",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "lbracket",
								"deco": "w",
								"default": "'['"
							},
							{
								"name": "rbracket",
								"deco": "w",
								"default": "']'"
							},
							{
								"name": "comma",
								"deco": "w",
								"default": "','"
							}
						],
						"endline": 3200,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 3173,
				"comment": " Parses an array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), and element separator (by\n default $(D ',')).\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!Source && isDynamicArray!Target && !is(Target == enum)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 3281,
						"type": "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar comma = ',')",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "lbracket",
								"deco": "w",
								"default": "'['"
							},
							{
								"name": "rbracket",
								"deco": "w",
								"default": "']'"
							},
							{
								"name": "comma",
								"deco": "w",
								"default": "','"
							}
						],
						"endline": 3328,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 3281,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!Source && isStaticArray!Target && !is(Target == enum)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 3354,
						"type": "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar keyval = ':', dchar comma = ',')",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "lbracket",
								"deco": "w",
								"default": "'['"
							},
							{
								"name": "rbracket",
								"deco": "w",
								"default": "']'"
							},
							{
								"name": "keyval",
								"deco": "w",
								"default": "':'"
							},
							{
								"name": "comma",
								"deco": "w",
								"default": "','"
							}
						],
						"endline": 3389,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 3354,
				"comment": " Parses an associative array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), key-value separator (default $(D\n ':')), and element seprator (by default $(D ',')).\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!Source && isAssociativeArray!Target && !is(Target == enum)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 59,
						"name": "text",
						"line": 3612,
						"type": "string(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3612,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "text",
				"line": 3612,
				"comment": " Convenience functions for converting any number and types of\n arguments into _text (the three character widths).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3633_1395)\n---\nassert( text(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"c);\nassert(wtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"w);\nassert(dtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"d);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3633_1395)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 62,
						"name": "wtext",
						"line": 3614,
						"type": "wstring(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3614,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "wtext",
				"line": 3614,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 62,
						"name": "dtext",
						"line": 3616,
						"type": "dstring(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3616,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "dtext",
				"line": 3616,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 9,
				"kind": "template"
			},
			{
				"members": [],
				"name": "octal",
				"line": 3662,
				"comment": "The $(D octal) facility provides a means to declare a number in base 8.\nUsing $(D octal!177) or $(D octal!\"177\") for 127 represented in octal\n(same as 0177 in C).\n\nThe rules for strings are the usual for literals: If it can fit in an\n$(D int), it is an $(D int). Otherwise, it is a $(D long). But, if the\nuser specifically asks for a $(D long) with the $(D L) suffix, always\ngive the $(D long). Give an unsigned iff it is asked for with the $(D\nU) or $(D u) suffix. _Octals created from integers preserve the type\nof the passed-in integral.\n\nSee_Also:\n    $(LREF parse) for parsing octal strings at runtime.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3685_1397)\n---\n// same as 0177\nauto x = octal!177;\n// octal is a compile-time device\nenum y = octal!160;\n// Create an unsigned octal\nauto z = octal!\"1_000_000u\";\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3685_1397)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3722_1398)\n---\nint a = octal!int(\"10\");\nassert(a == 8);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3722_1398)\n",
				"parameters": [
					{
						"name": "num",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "isOctalLiteral(num)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "octal",
						"line": 3681,
						"init": "octal!(typeof(decimalInteger))(to!string(decimalInteger))",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "octal",
				"line": 3678,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "decimalInteger",
						"kind": "alias"
					}
				],
				"constraint": "isIntegral!(typeof(decimalInteger))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emplace",
						"line": 3984,
						"type": "pure nothrow @safe T*(T* chunk)",
						"parameters": [
							{
								"name": "chunk",
								"type": "T*"
							}
						],
						"endline": 3988,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "emplace",
				"line": 3984,
				"comment": "Given a pointer $(D chunk) to uninitialized memory (but already typed\nas $(D T)), constructs an object of non-$(D class) type $(D T) at that\naddress.\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3991_1400)\n---\nstatic struct S\n{\n    int i = 42;\n}\nS[2] s2 = void;\nemplace(&s2);\nassert(s2[0].i == 42 && s2[1].i == 42);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3991_1400)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emplace",
						"line": 4013,
						"type": "T*(T* chunk, auto ref Args args)",
						"parameters": [
							{
								"name": "chunk",
								"type": "T*"
							},
							{
								"name": "args",
								"type": "Args",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 4018,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "emplace",
				"line": 4013,
				"comment": "Given a pointer $(D chunk) to uninitialized memory (but already typed\nas a non-class type $(D T)), constructs an object of type $(D T) at\nthat address from arguments $(D args).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4021_1401)\n---\nint a;\nint b = 42;\nassert(*emplace!int(&a, b) == 42);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4021_1401)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(T == struct) || Args.length == 1",
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emplace",
						"line": 4047,
						"type": "T(void[] chunk, auto ref Args args)",
						"parameters": [
							{
								"name": "chunk",
								"type": "void[]"
							},
							{
								"name": "args",
								"type": "Args",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 4071,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "emplace",
				"line": 4047,
				"comment": "Given a raw memory area $(D chunk), constructs an object of $(D class)\ntype $(D T) at that address. The constructor is passed the arguments\n$(D Args). The $(D chunk) must be as least as large as $(D T) needs\nand should have an alignment multiple of $(D T)'s alignment. (The size\nof a $(D class) instance is obtained by using $(D\n__traits(classInstanceSize, T))).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4074_1402)\n---\ninterface I {}\nclass K : I {}\n\nK k = void;\nemplace(&k);\nassert(k is null);\n\nI i = void;\nemplace(&i);\nassert(i is null);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4074_1402)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(T == class)",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emplace",
						"line": 4109,
						"type": "T*(void[] chunk, auto ref Args args)",
						"parameters": [
							{
								"name": "chunk",
								"type": "void[]"
							},
							{
								"name": "args",
								"type": "Args",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 4115,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "emplace",
				"line": 4109,
				"comment": "Given a raw memory area $(D chunk), constructs an object of non-$(D\nclass) type $(D T) at that address. The constructor is passed the\narguments $(D args), if any. The $(D chunk) must be as least as large\nas $(D T) needs and should have an alignment multiple of $(D T)'s\nalignment.\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4118_1404)\n---\nstruct S\n{\n    int a, b;\n}\nauto p = new void[S.sizeof];\nS s;\ns.a = 42;\ns.b = 43;\nauto s1 = emplace!S(p, s);\nassert(s1.a == 42 && s1.b == 43);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4118_1404)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "!is(T == class)",
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "unsigned",
						"line": 5093,
						"type": "(T x)",
						"parameters": [
							{
								"name": "x",
								"type": "T"
							}
						],
						"endline": 5096,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "unsigned",
				"line": 5093,
				"comment": "    Returns the corresponding _unsigned value for $(D x) (e.g. if $(D x) has type\n    $(D int), it returns $(D cast(uint) x)). The advantage compared to the cast\n    is that you do not need to rewrite the cast if $(D x) later changes type\n    (e.g from $(D int) to $(D long)).\n\n    Note that the result is always mutable even if the original type was const\n    or immutable. In order to retain the constness, use $(XREF traits, Unsigned).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5099_1449)\n---\nimmutable int s = 42;\nauto u1 = unsigned(s); //not qualified\nstatic assert(is(typeof(u1) == uint));\nUnsigned!(typeof(s)) u2 = unsigned(s); //same qualification\nstatic assert(is(typeof(u2) == immutable uint));\nimmutable u3 = unsigned(s); //explicitly qualified\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5099_1449)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!T",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "signed",
						"line": 5167,
						"type": "(T x)",
						"parameters": [
							{
								"name": "x",
								"type": "T"
							}
						],
						"endline": 5170,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "signed",
				"line": 5167,
				"comment": "    Returns the corresponding _signed value for $(D x) (e.g. if $(D x) has type\n    $(D uint), it returns $(D cast(int) x)). The advantage compared to the cast\n    is that you do not need to rewrite the cast if $(D x) later changes type\n    (e.g from $(D uint) to $(D ulong)).\n\n    Note that the result is always mutable even if the original type was const\n    or immutable. In order to retain the constness, use $(XREF traits, Signed).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5173_1452)\n---\nimmutable uint u = 42;\nauto s1 = signed(u); //not qualified\nstatic assert(is(typeof(s1) == int));\nSigned!(typeof(u)) s2 = signed(u); //same qualification\nstatic assert(is(typeof(s2) == immutable int));\nimmutable s3 = signed(u); //explicitly qualified\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5173_1452)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!T",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "to",
								"line": 5245,
								"type": "ref @system (auto ref T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 5259,
								"char": 14,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "to",
						"line": 5245,
						"comment": "        Params:\n            To    = The type _to cast _to.\n            value = The value _to cast. It must be of type $(D From),\n                    otherwise a compile-time error is emitted.\n\n        Returns:\n            the value after the cast, returned by reference if possible.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5262_1455)\n---\n// Regular cast, which has been verified to be legal by the programmer:\n{\n    long x;\n    auto y = cast(int) x;\n}\n\n// However this will still compile if 'x' is changed to be a pointer:\n{\n    long* x;\n    auto y = cast(int) x;\n}\n\n// castFrom provides a more reliable alternative to casting:\n{\n    long x;\n    auto y = castFrom!long.to!int(x);\n}\n\n// Changing the type of 'x' will now issue a compiler error,\n// allowing bad casts to be caught before it's too late:\n{\n    long* x;\n    static assert (\n        !__traits(compiles, castFrom!long.to!int(x))\n    );\n\n    // if cast is still needed, must be changed to:\n    auto y = castFrom!(long*).to!int(x);\n}\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5262_1455)\n",
						"parameters": [
							{
								"name": "To",
								"kind": "type"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 14,
						"kind": "template"
					}
				],
				"name": "castFrom",
				"line": 5234,
				"comment": "    A wrapper on top of the built-in cast operator that allows one to restrict\n    casting of the original type of the value.\n\n    A common issue with using a raw cast is that it may silently continue to\n    compile even if the value's type has changed during refactoring,\n    which breaks the initial assumption about the cast.\n\n    Params:\n        From  = The type to cast from. The programmer must ensure it is legal\n                to make this cast.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5334_1456)\n---\n// test all the hex digits\nstatic assert( (\"0123456789abcdefABCDEF\").isHexLiteral);\n// empty or white strings are not valid\nstatic assert( \"\\r\\n\\t\".isHexLiteral);\n// but are accepted if the count of hex digits is even\nstatic assert( \"A\\r\\n\\tB\".isHexLiteral);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5334_1456)\n",
				"parameters": [
					{
						"name": "From",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hexString",
						"line": 5412,
						"init": "hexStrImpl(hexData)",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"immutable"
						]
					}
				],
				"name": "hexString",
				"line": 5409,
				"comment": "Converts a hex literal to a string at compile time.\n\nTakes a string made of hexadecimal digits and returns\nthe matching string by converting each pair of digits to a character.\nThe input string can also include white characters, which can be used\nto keep the literal string readable in the source code.\n\nThe function is intended to replace the hexadecimal literal strings\nstarting with $(D 'x'), which could be removed to simplify the core language.\n\nParams:\n    hexData = string to be converted.\n\nReturns:\n    a $(D string), a $(D wstring) or a $(D dstring), according to the type of hexData.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5430_1458)\n---\n// conversion at compile time\nauto string1 = hexString!\"304A314B\";\nassert(string1 == \"0J1K\");\nauto string2 = hexString!\"304A314B\"w;\nassert(string2 == \"0J1K\"w);\nauto string3 = hexString!\"304A314B\"d;\nassert(string3 == \"0J1K\"d);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5430_1458)\n",
				"parameters": [
					{
						"name": "hexData",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "hexData.isHexLiteral",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hexString",
						"line": 5419,
						"init": "hexStrImpl(hexData)",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"immutable"
						]
					}
				],
				"name": "hexString",
				"line": 5416,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "hexData",
						"deco": "Ayu",
						"kind": "value"
					}
				],
				"constraint": "hexData.isHexLiteral",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hexString",
						"line": 5426,
						"init": "hexStrImpl(hexData)",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"immutable"
						]
					}
				],
				"name": "hexString",
				"line": 5423,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "hexData",
						"deco": "Ayw",
						"kind": "value"
					}
				],
				"constraint": "hexData.isHexLiteral",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toChars",
						"line": 5503,
						"type": "pure nothrow @nogc @safe (T value)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							}
						],
						"endline": 5635,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toChars",
				"line": 5503,
				"comment": " Convert integer to a range of characters.\n Intended to be lightweight and fast.\n\n Params:\n      radix = 2, 8, 10, 16\n      Char = character type for output\n      letterCase = lower for deadbeef, upper for DEADBEEF\n      value = integer to convert. Can be uint or ulong. If radix is 10, can also be\n              int or long.\n Returns:\n      Random access range with slicing and everything\n",
				"parameters": [
					{
						"name": "radix",
						"defaultValue": "10",
						"deco": "h",
						"kind": "value"
					},
					{
						"defaultDeco": "a",
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "letterCase",
						"defaultValue": "LetterCase.lower",
						"deco": "E3std5ascii10LetterCase",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "(radix == 2 || radix == 8 || radix == 10 || radix == 16) && (is(Unqual!T == uint) || is(Unqual!T == ulong) || radix == 10 && (is(Unqual!T == int) || is(Unqual!T == long)))",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "A one-stop shop for converting values from one type to another.\n\nCopyright: Copyright Digital Mars 2007-.\n\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Shin Fujishiro,\n           Adam D. Ruppe,\n           Kenji Hara\n\nSource:    $(PHOBOSSRC std/_conv.d)\n\nMacros:\nWIKI = Phobos/StdConv\n\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/numeric.d",
		"name": "std.numeric",
		"members": [
			{
				"members": [
					{
						"name": "signed",
						"line": 41,
						"value": "1",
						"comment": "Adds a sign bit to allow for signed numbers.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "storeNormalized",
						"line": 49,
						"value": "2",
						"comment": " Store values in normalized form by default. The actual precision of the\n significand is extended by 1 bit by assuming an implicit leading bit of 1\n instead of 0. i.e. $(D 1.nnnn) instead of $(D 0.nnnn).\n True for all $(LUCKY IEE754) types\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "allowDenorm",
						"line": 55,
						"value": "4",
						"comment": " Stores the significand in $(LUCKY IEEE754 denormalized) form when the\n exponent is 0. Required to express the value 0.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "infinity",
						"line": 58,
						"value": "8",
						"comment": "Allows the storage of $(LUCKY IEEE754 _infinity) values.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "nan",
						"line": 61,
						"value": "16",
						"comment": "Allows the storage of $(LUCKY IEEE754 Not a Number) values.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "probability",
						"line": 68,
						"value": "32",
						"comment": " If set, select an exponent bias such that max_exp = 1.\n i.e. so that the maximum value is >= 1.0 and < 2.0.\n Ignored if the exponent bias is manually specified.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "negativeUnsigned",
						"line": 71,
						"value": "64",
						"comment": "If set, unsigned custom floats are assumed to be negative.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "allowDenormZeroOnly",
						"line": 76,
						"value": "134",
						"comment": "If set, 0 is the only allowed $(LUCKY IEEE754 denormalized) number.\n Requires allowDenorm and storeNormalized.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ieee",
						"line": 79,
						"value": "31",
						"comment": "Include _all of the $(LUCKY IEEE754) options.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "none",
						"line": 82,
						"value": "0",
						"comment": "Include none of the above options.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CustomFloatFlags",
				"line": 38,
				"comment": "Format flags for CustomFloat.\n",
				"baseDeco": "i",
				"char": 8,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "CustomFloat",
						"line": 137,
						"type": "CustomFloat!(CustomFloatParams!bits)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CustomFloat",
				"line": 134,
				"comment": " Allows user code to define custom floating-point formats. These formats are\n for storage only; all operations on them are performed by first implicitly\n extracting them to $(D real) first. After the operation is completed the\n result can be stored in a custom floating-point value via assignment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL148_1461)\n---\n// Define a 16-bit floating point values\nCustomFloat!16                                x;     // Using the number of bits\nCustomFloat!(10, 5)                           y;     // Using the precision and exponent width\nCustomFloat!(10, 5,CustomFloatFlags.ieee)     z;     // Using the precision, exponent width and format flags\nCustomFloat!(10, 5,CustomFloatFlags.ieee, 15) w;     // Using the precision, exponent width, format flags and exponent offset bias\n\n// Use the 16-bit floats mostly like normal numbers\nw = x*y - 1;\n\n// Functions calls require conversion\nz = sin(+x)           + cos(+y);                     // Use unary plus to concisely convert to a real\nz = sin(x.get!float)  + cos(y.get!float);            // Or use get!T\nz = sin(cast(float)x) + cos(cast(float)y);           // Or use cast(T) to explicitly convert\n\n// Define a 8-bit custom float for storing probabilities\nalias Probability = CustomFloat!(4, 4, CustomFloatFlags.ieee^CustomFloatFlags.probability^CustomFloatFlags.signed );\nauto p = Probability(0.5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL148_1461)\n",
				"parameters": [
					{
						"name": "bits",
						"deco": "k",
						"kind": "value"
					}
				],
				"constraint": "bits == 8 || bits == 16 || bits == 32 || bits == 64 || bits == 80",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CustomFloat",
						"line": 144,
						"type": "CustomFloat!(CustomFloatParams!(precision, exponentWidth, flags))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CustomFloat",
				"line": 141,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "precision",
						"deco": "k",
						"kind": "value"
					},
					{
						"name": "exponentWidth",
						"deco": "k",
						"kind": "value"
					},
					{
						"name": "flags",
						"defaultValue": "CustomFloatFlags.ieee",
						"deco": "E3std7numeric16CustomFloatFlags",
						"kind": "value"
					}
				],
				"constraint": "((flags & flags.signed) + precision + exponentWidth) % 8 == 0 && precision + exponentWidth > 0",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CustomFloat",
						"line": 170,
						"members": [
							{
								"endchar": 5,
								"name": "dig",
								"line": 424,
								"comment": "Returns: number of decimal digits of precision\n",
								"type": "@property size_t()",
								"endline": 429,
								"char": 29,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"endchar": 5,
								"name": "epsilon",
								"line": 432,
								"comment": "Returns: smallest increment to the value 1\n",
								"type": "@property CustomFloat()",
								"endline": 452,
								"char": 34,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"name": "mant_dig",
								"line": 455,
								"comment": "the number of bits in mantissa\n",
								"init": "precision + ((flags & Flags.storeNormalized) != 0)",
								"char": 10,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 72,
								"name": "max_10_exp",
								"line": 458,
								"comment": "Returns: maximum int value such that 10<sup>max_10_exp</sup> is representable\n",
								"type": "@property int()",
								"endline": 458,
								"char": 26,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"name": "max_exp",
								"line": 461,
								"comment": "maximum int value such that 2<sup>max_exp-1</sup> is representable\n",
								"init": "exponent_max - bias + ((~flags & (Flags.infinity | flags.nan)) != 0)",
								"char": 10,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 79,
								"name": "min_10_exp",
								"line": 464,
								"comment": "Returns: minimum int value such that 10<sup>min_10_exp</sup> is representable\n",
								"type": "@property int()",
								"endline": 464,
								"char": 26,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"name": "min_exp",
								"line": 467,
								"comment": "minimum int value such that 2<sup>min_exp-1</sup> is representable as a normalized value\n",
								"init": "cast(T_signed_exp)-bias + 1 + ((flags & Flags.allowDenorm) != 0)",
								"char": 10,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "max",
								"line": 470,
								"comment": "Returns: largest representable value that's not infinity\n",
								"type": "@property CustomFloat()",
								"endline": 478,
								"char": 34,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"endchar": 5,
								"name": "min_normal",
								"line": 481,
								"comment": "Returns: smallest representable normalized value that's not 0\n",
								"type": "@property CustomFloat()",
								"endline": 491,
								"char": 34,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"endchar": 47,
								"name": "re",
								"line": 494,
								"comment": "Returns: real part\n",
								"type": "@property CustomFloat()",
								"endline": 494,
								"char": 27,
								"kind": "function"
							},
							{
								"endchar": 67,
								"name": "im",
								"line": 497,
								"comment": "Returns: imaginary part\n",
								"type": "@property CustomFloat()",
								"endline": 497,
								"char": 34,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 500,
										"type": "(F input)",
										"parameters": [
											{
												"name": "input",
												"type": "F"
											}
										],
										"endline": 503,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 500,
								"comment": "Initialize from any $(D real) compatible type.\n",
								"parameters": [
									{
										"name": "F",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, cast(real)input)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 506,
										"type": "void(F input)",
										"parameters": [
											{
												"name": "input",
												"type": "F"
											}
										],
										"endline": 512,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 506,
								"comment": "Self assignment\n",
								"parameters": [
									{
										"name": "F",
										"type": "CustomFloat",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 515,
										"type": "void(F input)",
										"parameters": [
											{
												"name": "input",
												"type": "F"
											}
										],
										"endline": 545,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 515,
								"comment": "Assigns from any $(D real) compatible type.\n",
								"parameters": [
									{
										"name": "F",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, cast(real)input)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "get",
										"line": 548,
										"type": "@property F()",
										"endline": 570,
										"char": 17,
										"kind": "function"
									}
								],
								"name": "get",
								"line": 548,
								"comment": "Fetches the stored value either as a $(D float), $(D double) or $(D real).\n",
								"parameters": [
									{
										"name": "F",
										"kind": "type"
									}
								],
								"constraint": "staticIndexOf!(Unqual!F, float, double, real) >= 0",
								"char": 17,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opCast",
										"line": 573,
										"type": "T()",
										"endline": 573,
										"char": 7,
										"kind": "function"
									}
								],
								"name": "opCast",
								"line": 573,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, get!T)",
								"char": 7,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opUnary",
										"line": 576,
										"type": "real()",
										"endline": 587,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opUnary",
								"line": 576,
								"comment": "Convert the CustomFloat to a real and perform the relavent operator on the result\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "__traits(compiles, mixin(op ~ \"(get!real)\")) || op == \"++\" || op == \"--\"",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 590,
										"type": "real(T b)",
										"parameters": [
											{
												"name": "b",
												"type": "T"
											}
										],
										"endline": 594,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 590,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, mixin(\"get!real\" ~ op ~ \"b\"))",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinaryRight",
										"line": 597,
										"type": "real(T a)",
										"parameters": [
											{
												"name": "a",
												"type": "T"
											}
										],
										"endline": 602,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opBinaryRight",
								"line": 597,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, mixin(\"a\" ~ op ~ \"get!real\")) && !__traits(compiles, mixin(\"get!real\" ~ op ~ \"b\"))",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opCmp",
										"line": 605,
										"type": "int(auto ref T b)",
										"parameters": [
											{
												"name": "b",
												"type": "T",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 611,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "opCmp",
								"line": 605,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, cast(real)b)",
								"char": 9,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 614,
										"type": "void(auto ref T b)",
										"parameters": [
											{
												"name": "b",
												"type": "T",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 618,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 614,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, mixin(\"get!real\" ~ op ~ \"cast(real)b\"))",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"members": [
											{
												"endchar": 9,
												"name": "toString",
												"line": 625,
												"type": "void(scope void delegate(const(char)[]) sink, FormatSpec!char fmt)",
												"parameters": [
													{
														"name": "sink",
														"type": "void delegate(const(char)[])",
														"storageClass": [
															"scope"
														]
													},
													{
														"name": "fmt",
														"type": "FormatSpec!char"
													}
												],
												"endline": 628,
												"char": 14,
												"kind": "function"
											}
										],
										"name": "toString",
										"line": 625,
										"parameters": [],
										"char": 14,
										"kind": "template"
									}
								],
								"name": "toString",
								"line": 621,
								"comment": "ditto\n",
								"parameters": [],
								"char": 5,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "CustomFloat",
				"line": 170,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "precision",
						"deco": "k",
						"kind": "value"
					},
					{
						"name": "exponentWidth",
						"deco": "k",
						"kind": "value"
					},
					{
						"name": "flags",
						"deco": "E3std7numeric16CustomFloatFlags",
						"kind": "value"
					},
					{
						"name": "bias",
						"deco": "k",
						"kind": "value"
					}
				],
				"constraint": "((flags & flags.signed) + precision + exponentWidth) % 8 == 0 && precision + exponentWidth > 0",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "FPTemporary",
						"line": 701,
						"deco": "e",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "FPTemporary",
				"line": 698,
				"comment": "Defines the fastest type to use when storing temporaries of a\ncalculation intended to ultimately yield a result of type $(D F)\n(where $(D F) must be one of $(D float), $(D double), or $(D\nreal)). When doing a multi-step computation, you may want to store\nintermediate results as $(D FPTemporary!F).\n\nThe necessity of $(D FPTemporary) stems from the optimized\nfloating-point operations and registers present in virtually all\nprocessors. When adding numbers in the example above, the addition may\nin fact be done in $(D real) precision internally. In that case,\nstoring the intermediate $(D result) in $(D double format) is not only\nless precise, it is also (surprisingly) slower, because a conversion\nfrom $(D real) to $(D double) is performed every pass through the\nloop. This being a lose-lose situation, $(D FPTemporary!F) has been\ndefined as the $(I fastest) type to use for calculations at precision\n$(D F). There is no need to define a type for the $(I most accurate)\ncalculations, as that is always $(D real).\n\nFinally, there is no guarantee that using $(D FPTemporary!F) will\nalways be fastest, as the speed of floating-point calculations depends\non very many factors.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL705_1464)\n---\n// Average numbers in an array\ndouble avg(in double[] a)\n{\n    if (a.length == 0) return 0;\n    FPTemporary!double result = 0;\n    foreach (e; a) result += e;\n    return result / a.length;\n}\n\nauto a = [1.0, 2.0, 3.0];\nassert(approxEqual(avg(a), 2));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL705_1464)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!F",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "secantMethod",
								"line": 729,
								"type": "Num(Num xn_1, Num xn)",
								"parameters": [
									{
										"name": "xn_1",
										"type": "Num"
									},
									{
										"name": "xn",
										"type": "Num"
									}
								],
								"endline": 744,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "secantMethod",
						"line": 729,
						"parameters": [
							{
								"name": "Num",
								"kind": "type"
							}
						],
						"char": 9,
						"kind": "template"
					}
				],
				"name": "secantMethod",
				"line": 726,
				"comment": "Implements the $(WEB tinyurl.com/2zb9yr, secant method) for finding a\nroot of the function $(D fun) starting from points $(D [xn_1, x_n])\n(ideally close to the root). $(D Num) may be $(D float), $(D double),\nor $(D real).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL748_1465)\n---\nfloat f(float x)\n{\n    return cos(x) - x*x*x;\n}\nauto x = secantMethod!(f)(0f, 1f);\nassert(approxEqual(x, 0.865474));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL748_1465)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findRoot",
						"line": 808,
						"type": "T(scope DF f, in T a, in T b, scope DT tolerance)",
						"parameters": [
							{
								"name": "f",
								"type": "DF",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "a",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "b",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "tolerance",
								"type": "DT",
								"storageClass": [
									"scope"
								]
							}
						],
						"endline": 825,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "findRoot",
				"line": 808,
				"comment": "  Find a real root of a real function f(x) via bracketing.\n\n Given a function $(D f) and a range $(D [a..b]) such that $(D f(a))\n and $(D f(b)) have opposite signs or at least one of them equals ±0,\n returns the value of $(D x) in\n the range which is closest to a root of $(D f(x)).  If $(D f(x))\n has more than one root in the range, one will be chosen\n arbitrarily.  If $(D f(x)) returns NaN, NaN will be returned;\n otherwise, this algorithm is guaranteed to succeed.\n\n Uses an algorithm based on TOMS748, which uses inverse cubic\n interpolation whenever possible, otherwise reverting to parabolic\n or secant interpolation. Compared to TOMS748, this implementation\n improves worst-case performance by a factor of more than 100, and\n typical performance by a factor of 2. For 80-bit reals, most\n problems require 8 to 15 calls to $(D f(x)) to achieve full machine\n precision. The worst-case performance (pathological cases) is\n approximately twice the number of bits.\n\n References: \"On Enclosing Simple Roots of Nonlinear Equations\",\n G. Alefeld, F.A. Potra, Yixun Shi, Mathematics of Computation 61,\n pp733-744 (1993).  Fortran code available from $(WEB\n www.netlib.org,www.netlib.org) as algorithm TOMS478.\n\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "DF",
						"kind": "type"
					},
					{
						"name": "DT",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T && is(typeof(tolerance(T.init, T.init)) : bool) && is(typeof(f(T.init)) == R, R) && isFloatingPoint!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findRoot",
						"line": 828,
						"type": "T(scope DF f, in T a, in T b)",
						"parameters": [
							{
								"name": "f",
								"type": "DF",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "a",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "b",
								"type": "T",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 831,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "findRoot",
				"line": 828,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "DF",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findRoot",
						"line": 866,
						"type": "Tuple!(T, T, R, R)(scope DF f, in T ax, in T bx, in R fax, in R fbx, scope DT tolerance)",
						"parameters": [
							{
								"name": "f",
								"type": "DF",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "ax",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "bx",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "fax",
								"type": "R",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "fbx",
								"type": "R",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "tolerance",
								"type": "DT",
								"storageClass": [
									"scope"
								]
							}
						],
						"endline": 1170,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "findRoot",
				"line": 866,
				"comment": " Find root of a real function f(x) by bracketing, allowing the\n termination condition to be specified.\n\n Params:\n\n f = Function to be analyzed\n\n ax = Left bound of initial range of $(D f) known to contain the\n root.\n\n bx = Right bound of initial range of $(D f) known to contain the\n root.\n\n fax = Value of $(D f(ax)).\n\n fbx = Value of $(D f(bx)). $(D fax) and $(D fbx) should have opposite signs.\n ($(D f(ax)) and $(D f(bx)) are commonly known in advance.)\n\n\n tolerance = Defines an early termination condition. Receives the\n             current upper and lower bounds on the root. The\n             delegate must return $(D true) when these bounds are\n             acceptable. If this function always returns $(D false),\n             full machine precision will be achieved.\n\n Returns:\n\n A tuple consisting of two ranges. The first two elements are the\n range (in $(D x)) of the root, while the second pair of elements\n are the corresponding function values at those points. If an exact\n root was found, both of the first two elements will contain the\n root, and the second pair of elements will be 0.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "DF",
						"kind": "type"
					},
					{
						"name": "DT",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T && is(typeof(tolerance(T.init, T.init)) : bool) && is(typeof(f(T.init)) == R) && isFloatingPoint!R",
				"char": 20,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findRoot",
						"line": 1173,
						"type": "Tuple!(T, T, R, R)(scope DF f, in T ax, in T bx, in R fax, in R fbx)",
						"parameters": [
							{
								"name": "f",
								"type": "DF",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "ax",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "bx",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "fax",
								"type": "R",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "fbx",
								"type": "R",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1176,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "findRoot",
				"line": 1173,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "DF",
						"kind": "type"
					}
				],
				"char": 20,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findRoot",
						"line": 1179,
						"type": "T(scope R delegate(T) f, in T a, in T b, scope bool delegate(T lo, T hi) tolerance = (T a, T b) => false)",
						"parameters": [
							{
								"name": "f",
								"type": "R delegate(T)",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "a",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "b",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "tolerance",
								"type": "bool delegate(T lo, T hi)",
								"storageClass": [
									"scope"
								],
								"default": ""
							}
						],
						"endline": 1183,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "findRoot",
				"line": 1179,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "euclideanDistance",
						"line": 1411,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							}
						],
						"endline": 1424,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "euclideanDistance",
				"line": 1411,
				"comment": "Computes $(LUCKY Euclidean distance) between input ranges $(D a) and\n$(D b). The two ranges must have the same length. The three-parameter\nversion stops computation as soon as the distance is greater than or\nequal to $(D limit) (this is useful to save computation if a small\ndistance is sought).\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "euclideanDistance",
						"line": 1428,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b, F limit)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							},
							{
								"name": "limit",
								"type": "F"
							}
						],
						"endline": 1447,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "euclideanDistance",
				"line": 1428,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dotProduct",
						"line": 1470,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							}
						],
						"endline": 1483,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "dotProduct",
				"line": 1470,
				"comment": "Computes the $(LUCKY dot product) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration.\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && !(isArray!Range1 && isArray!Range2)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dotProduct",
						"line": 1487,
						"type": "CommonType!(F1, F2)(in F1[] avector, in F2[] bvector)",
						"parameters": [
							{
								"name": "avector",
								"type": "F1[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "bvector",
								"type": "F2[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1537,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "dotProduct",
				"line": 1487,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "F1",
						"kind": "type"
					},
					{
						"name": "F2",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cosineSimilarity",
						"line": 1565,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							}
						],
						"endline": 1581,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "cosineSimilarity",
				"line": 1565,
				"comment": "Computes the $(LUCKY cosine similarity) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration. If either range has all-zero elements, return 0.\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "normalize",
						"line": 1606,
						"type": "bool(R range, ElementType!R sum = 1)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "sum",
								"type": "ElementType!R",
								"default": "1"
							}
						],
						"endline": 1644,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "normalize",
				"line": 1606,
				"comment": "Normalizes values in $(D range) by multiplying each element with a\nnumber chosen such that values sum up to $(D sum). If elements in $(D\nrange) sum to zero, assigns $(D sum / range.length) to\nall. Normalization makes sense only if all elements in $(D range) are\npositive. $(D normalize) assumes that is the case without checking it.\n\nReturns: $(D true) if normalization completed normally, $(D false) if\nall elements in $(D range) were zero or if $(D range) is empty.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1647_1473)\n---\ndouble[] a = [];\nassert(!normalize(a));\na = [ 1.0, 3.0 ];\nassert(normalize(a));\nassert(a == [ 0.25, 0.75 ]);\na = [ 0.0, 0.0 ];\nassert(!normalize(a));\nassert(a == [ 0.5, 0.5 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1647_1473)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sumOfLog2s",
						"line": 1663,
						"type": "ElementType!Range(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1682,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "sumOfLog2s",
				"line": 1663,
				"comment": "Compute the sum of binary logarithms of the input range $(D r).\nThe error of this method is much smaller than with a naive sum of log2.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1685_1474)\n---\nassert(sumOfLog2s(new double[0]) == 0);\nassert(sumOfLog2s([0.0L]) == -real.infinity);\nassert(sumOfLog2s([-0.0L]) == -real.infinity);\nassert(sumOfLog2s([2.0L]) == 1);\nassert(sumOfLog2s([-2.0L]).isNaN());\nassert(sumOfLog2s([real.nan]).isNaN());\nassert(sumOfLog2s([-real.nan]).isNaN());\nassert(sumOfLog2s([real.infinity]) == real.infinity);\nassert(sumOfLog2s([-real.infinity]).isNaN());\nassert(sumOfLog2s([ 0.25, 0.25, 0.25, 0.125 ]) == -9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1685_1474)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isFloatingPoint!(ElementType!Range)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "entropy",
						"line": 1707,
						"type": "ElementType!Range(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1716,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "entropy",
				"line": 1707,
				"comment": "Computes $(LUCKY _entropy) of input range $(D r) in bits. This\nfunction assumes (without checking) that the values in $(D r) are all\nin $(D [0, 1]). For the entropy to be meaningful, often $(D r) should\nbe normalized too (i.e., its values should sum to 1). The\ntwo-parameter version stops evaluating as soon as the intermediate\nresult is greater than or equal to $(D max).\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "entropy",
						"line": 1719,
						"type": "ElementType!Range(Range r, F max)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "max",
								"type": "F"
							}
						],
						"endline": 1731,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "entropy",
				"line": 1719,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && !is(CommonType!(ElementType!Range, F) == void)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "kullbackLeiblerDivergence",
						"line": 1759,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							}
						],
						"endline": 1776,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "kullbackLeiblerDivergence",
				"line": 1759,
				"comment": "Computes the $(LUCKY Kullback-Leibler divergence) between input ranges\n$(D a) and $(D b), which is the sum $(D ai * log(ai / bi)). The base\nof logarithm is 2. The ranges are assumed to contain elements in $(D\n[0, 1]). Usually the ranges are normalized probability distributions,\nbut this is not required or checked by $(D\nkullbackLeiblerDivergence). If any element $(D bi) is zero and the\ncorresponding element $(D ai) nonzero, returns infinity. (Otherwise,\nif $(D ai == 0 && bi == 0), the term $(D ai * log(ai / bi)) is\nconsidered zero.) If the inputs are normalized, the result is\npositive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1779_1476)\n---\ndouble[] p = [ 0.0, 0, 0, 1 ];\nassert(kullbackLeiblerDivergence(p, p) == 0);\ndouble[] p1 = [ 0.25, 0.25, 0.25, 0.25 ];\nassert(kullbackLeiblerDivergence(p1, p1) == 0);\nassert(kullbackLeiblerDivergence(p, p1) == 2);\nassert(kullbackLeiblerDivergence(p1, p) == double.infinity);\ndouble[] p2 = [ 0.2, 0.2, 0.2, 0.4 ];\nassert(approxEqual(kullbackLeiblerDivergence(p1, p2), 0.0719281));\nassert(approxEqual(kullbackLeiblerDivergence(p2, p1), 0.0780719));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1779_1476)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "jensenShannonDivergence",
						"line": 1804,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							}
						],
						"endline": 1827,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "jensenShannonDivergence",
				"line": 1804,
				"comment": "Computes the $(LUCKY Jensen-Shannon divergence) between $(D a) and $(D\nb), which is the sum $(D (ai * log(2 * ai / (ai + bi)) + bi * log(2 *\nbi / (ai + bi))) / 2). The base of logarithm is 2. The ranges are\nassumed to contain elements in $(D [0, 1]). Usually the ranges are\nnormalized probability distributions, but this is not required or\nchecked by $(D jensenShannonDivergence). If the inputs are normalized,\nthe result is bounded within $(D [0, 1]). The three-parameter version\nstops evaluations as soon as the intermediate result is greater than\nor equal to $(D limit).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1860_1477)\n---\ndouble[] p = [ 0.0, 0, 0, 1 ];\nassert(jensenShannonDivergence(p, p) == 0);\ndouble[] p1 = [ 0.25, 0.25, 0.25, 0.25 ];\nassert(jensenShannonDivergence(p1, p1) == 0);\nassert(approxEqual(jensenShannonDivergence(p1, p), 0.548795));\ndouble[] p2 = [ 0.2, 0.2, 0.2, 0.4 ];\nassert(approxEqual(jensenShannonDivergence(p1, p2), 0.0186218));\nassert(approxEqual(jensenShannonDivergence(p2, p1), 0.0186218));\nassert(approxEqual(jensenShannonDivergence(p2, p1, 0.005), 0.00602366));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1860_1477)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(CommonType!(ElementType!Range1, ElementType!Range2))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "jensenShannonDivergence",
						"line": 1831,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b, F limit)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							},
							{
								"name": "limit",
								"type": "F"
							}
						],
						"endline": 1857,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "jensenShannonDivergence",
				"line": 1831,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(typeof(CommonType!(ElementType!Range1, ElementType!Range2).init >= F.init) : bool)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "gapWeightedSimilarity",
						"line": 1944,
						"type": "F(R1 s, R2 t, F lambda)",
						"parameters": [
							{
								"name": "s",
								"type": "R1"
							},
							{
								"name": "t",
								"type": "R2"
							},
							{
								"name": "lambda",
								"type": "F"
							}
						],
						"endline": 1988,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "gapWeightedSimilarity",
				"line": 1944,
				"comment": "The so-called \"all-lengths gap-weighted string kernel\" computes a\nsimilarity measure between $(D s) and $(D t) based on all of their\ncommon subsequences of all lengths. Gapped subsequences are also\nincluded.\n\nTo understand what $(D gapWeightedSimilarity(s, t, lambda)) computes,\nconsider first the case $(D lambda = 1) and the strings $(D s =\n[\"Hello\", \"brave\", \"new\", \"world\"]) and $(D t = [\"Hello\", \"new\",\n\"world\"]). In that case, $(D gapWeightedSimilarity) counts the\nfollowing matches:\n\n$(OL $(LI three matches of length 1, namely $(D \"Hello\"), $(D \"new\"),\nand $(D \"world\");) $(LI three matches of length 2, namely ($(D\n\"Hello\", \"new\")), ($(D \"Hello\", \"world\")), and ($(D \"new\", \"world\"));)\n$(LI one match of length 3, namely ($(D \"Hello\", \"new\", \"world\")).))\n\nThe call $(D gapWeightedSimilarity(s, t, 1)) simply counts all of\nthese matches and adds them up, returning 7.\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 1) == 7);\n----\n\nNote how the gaps in matching are simply ignored, for example ($(D\n\"Hello\", \"new\")) is deemed as good a match as ($(D \"new\",\n\"world\")). This may be too permissive for some applications. To\neliminate gapped matches entirely, use $(D lambda = 0):\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0) == 4);\n----\n\nThe call above eliminated the gapped matches ($(D \"Hello\", \"new\")),\n($(D \"Hello\", \"world\")), and ($(D \"Hello\", \"new\", \"world\")) from the\ntally. That leaves only 4 matches.\n\nThe most interesting case is when gapped matches still participate in\nthe result, but not as strongly as ungapped matches. The result will\nbe a smooth, fine-grained similarity measure between the input\nstrings. This is where values of $(D lambda) between 0 and 1 enter\ninto play: gapped matches are $(I exponentially penalized with the\nnumber of gaps) with base $(D lambda). This means that an ungapped\nmatch adds 1 to the return value; a match with one gap in either\nstring adds $(D lambda) to the return value; ...; a match with a total\nof $(D n) gaps in both strings adds $(D pow(lambda, n)) to the return\nvalue. In the example above, we have 4 matches without gaps, 2 matches\nwith one gap, and 1 match with three gaps. The latter match is ($(D\n\"Hello\", \"world\")), which has two gaps in the first string and one gap\nin the second string, totaling to three gaps. Summing these up we get\n$(D 4 + 2 * lambda + pow(lambda, 3)).\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0.5) == 4 + 0.5 * 2 + 0.125);\n----\n\n$(D gapWeightedSimilarity) is useful wherever a smooth similarity\nmeasure between sequences allowing for approximate matches is\nneeded. The examples above are given with words, but any sequences\nwith elements comparable for equality are allowed, e.g. characters or\nnumbers. $(D gapWeightedSimilarity) uses a highly optimized dynamic\nprogramming implementation that needs $(D 16 * min(s.length,\nt.length)) extra bytes of memory and $(BIGOH s.length * t.length) time\nto complete.\n",
				"parameters": [
					{
						"name": "comp",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R1 && hasLength!R1 && isRandomAccessRange!R2 && hasLength!R2",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "gapWeightedSimilarityNormalized",
						"line": 2021,
						"type": "Select!(isFloatingPoint!F, F, double)(R1 s, R2 t, F lambda, F sSelfSim = F.init, F tSelfSim = F.init)",
						"parameters": [
							{
								"name": "s",
								"type": "R1"
							},
							{
								"name": "t",
								"type": "R2"
							},
							{
								"name": "lambda",
								"type": "F"
							},
							{
								"name": "sSelfSim",
								"type": "F",
								"default": "F.init"
							},
							{
								"name": "tSelfSim",
								"type": "F",
								"default": "F.init"
							}
						],
						"endline": 2042,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "gapWeightedSimilarityNormalized",
				"line": 2021,
				"comment": "The similarity per $(D gapWeightedSimilarity) has an issue in that it\ngrows with the lengths of the two strings, even though the strings are\nnot actually very similar. For example, the range $(D [\"Hello\",\n\"world\"]) is increasingly similar with the range $(D [\"Hello\",\n\"world\", \"world\", \"world\",...]) as more instances of $(D \"world\") are\nappended. To prevent that, $(D gapWeightedSimilarityNormalized)\ncomputes a normalized version of the similarity that is computed as\n$(D gapWeightedSimilarity(s, t, lambda) /\nsqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t,\nlambda))). The function $(D gapWeightedSimilarityNormalized) (a\nso-called normalized kernel) is bounded in $(D [0, 1]), reaches $(D 0)\nonly for ranges that don't match in any position, and $(D 1) only for\nidentical ranges.\n\nThe optional parameters $(D sSelfSim) and $(D tSelfSim) are meant for\navoiding duplicate computation. Many applications may have already\ncomputed $(D gapWeightedSimilarity(s, s, lambda)) and/or $(D\ngapWeightedSimilarity(t, t, lambda)). In that case, they can be passed\nas $(D sSelfSim) and $(D tSelfSim), respectively.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2045_1479)\n---\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, s, 1) == 15);\nassert(gapWeightedSimilarity(t, t, 1) == 7);\nassert(gapWeightedSimilarity(s, t, 1) == 7);\nassert(approxEqual(gapWeightedSimilarityNormalized(s, t, 1),\n                7.0 / sqrt(15.0 * 7), 0.01));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2045_1479)\n",
				"parameters": [
					{
						"name": "comp",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R1 && hasLength!R1 && isRandomAccessRange!R2 && hasLength!R2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "GapWeightedSimilarityIncremental",
						"line": 2069,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 2087,
								"comment": "Constructs an object given two ranges $(D s) and $(D t) and a penalty\n$(D lambda). Constructor completes in $(BIGOH s.length * t.length)\ntime and computes all matches of length 1.\n",
								"type": "(Range s, Range t, F lambda)",
								"parameters": [
									{
										"name": "s",
										"type": "Range"
									},
									{
										"name": "t",
										"type": "Range"
									},
									{
										"name": "lambda",
										"type": "F"
									}
								],
								"endline": 2141,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 2146,
								"comment": "    Returns: $(D this).\n",
								"type": "ref GapWeightedSimilarityIncremental()",
								"endline": 2149,
								"char": 42,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 2155,
								"comment": "    Computes the match of the popFront length. Completes in $(BIGOH s.length *\n    t.length) time.\n",
								"type": "void()",
								"endline": 2233,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 48,
								"name": "front",
								"line": 2239,
								"comment": "    Returns: The gapped similarity at the current match length (initially\n    1, grows with each call to $(D popFront)).\n",
								"type": "@property F()",
								"endline": 2239,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 2244,
								"comment": "    Returns: Whether there are more matches.\n",
								"type": "@property bool()",
								"endline": 2253,
								"char": 20,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "GapWeightedSimilarityIncremental",
				"line": 2069,
				"comment": "Similar to $(D gapWeightedSimilarity), just works in an incremental\nmanner by first revealing the matches of length 1, then gapped matches\nof length 2, and so on. The memory requirement is $(BIGOH s.length *\nt.length). The time complexity is $(BIGOH s.length * t.length) time\nfor computing each step. Continuing on the previous example:\n\nThe implementation is based on the pseudocode in Fig. 4 of the paper\n$(WEB jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf,\n\"Efﬁcient Computation of Gapped Substring Kernels on Large Alphabets\")\nby Rousu et al., with additional algorithmic and systems-level\noptimizations.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2266_1480)\n---\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nauto simIter = gapWeightedSimilarityIncremental(s, t, 1.0);\nassert(simIter.front == 3); // three 1-length matches\nsimIter.popFront();\nassert(simIter.front == 3); // three 2-length matches\nsimIter.popFront();\nassert(simIter.front == 1); // one 3-length match\nsimIter.popFront();\nassert(simIter.empty);     // no more match\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2266_1480)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"defaultDeco": "d",
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && hasLength!Range",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "gapWeightedSimilarityIncremental",
						"line": 2259,
						"type": "GapWeightedSimilarityIncremental!(R, F)(R r1, R r2, F penalty)",
						"parameters": [
							{
								"name": "r1",
								"type": "R"
							},
							{
								"name": "r2",
								"type": "R"
							},
							{
								"name": "penalty",
								"type": "F"
							}
						],
						"endline": 2263,
						"char": 41,
						"kind": "function"
					}
				],
				"name": "gapWeightedSimilarityIncremental",
				"line": 2259,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"char": 41,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "gcd",
						"line": 2354,
						"type": "T(T a, T b)",
						"parameters": [
							{
								"name": "a",
								"type": "T"
							},
							{
								"name": "b",
								"type": "T"
							}
						],
						"endline": 2374,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "gcd",
				"line": 2354,
				"comment": "Computes the greatest common divisor of $(D a) and $(D b) by using\nEuclid's algorithm.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2377_1483)\n---\nassert(gcd(2 * 5 * 7 * 7, 5 * 7 * 11) == 5 * 7);\nconst int a = 5 * 13 * 23 * 23, b = 13 * 59;\nassert(gcd(a, b) == 13);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2377_1483)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"name": "Fft",
				"line": 2401,
				"comment": "A class for performing fast Fourier transforms of power of two sizes.\n This class encapsulates a large amount of state that is reusable when\n performing multiple FFTs of sizes smaller than or equal to that specified\n in the constructor.  This results in substantial speedups when performing\n multiple FFTs with a known maximum size.  However,\n a free function API is provided for convenience if you need to perform a\n one-off FFT.\n\n References:\n $(WEB en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm)\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 2697,
						"comment": "Create an $(D Fft) object for computing fast Fourier transforms of\n power of two sizes of $(D size) or smaller.  $(D size) must be a\n power of two.\n",
						"deco": "FmZC3std7numeric3Fft",
						"parameters": [
							{
								"name": "size",
								"deco": "m"
							}
						],
						"endline": 2703,
						"originalType": "(size_t size)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fft",
								"line": 2726,
								"type": "const Complex!F[](R range)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									}
								],
								"endline": 2741,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "fft",
						"line": 2726,
						"comment": "Compute the Fourier transform of range using the $(BIGOH N log N)\n Cooley-Tukey Algorithm.  $(D range) must be a random-access range with\n slicing and a length equal to $(D size) as provided at the construction of\n this object.  The contents of range can be either  numeric types,\n which will be interpreted as pure real values, or complex types with\n properties or members $(D .re) and $(D .im) that can be read.\n\n Note:  Pure real FFTs are automatically detected and the relevant\n        optimizations are performed.\n\n Returns:  An array of complex numbers representing the transformed data in\n           the frequency domain.\n\n Conventions: The exponent is negative and the factor is one,\n              i.e., output[j] := sum[ exp(-2 PI i j k / N) input[k] ].\n",
						"parameters": [
							{
								"defaultDeco": "d",
								"name": "F",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isFloatingPoint!F && isRandomAccessRange!R",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fft",
								"line": 2749,
								"type": "const void(R range, Ret buf)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									},
									{
										"name": "buf",
										"type": "Ret"
									}
								],
								"endline": 2784,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "fft",
						"line": 2749,
						"comment": "Same as the overload, but allows for the results to be stored in a user-\n provided buffer.  The buffer must be of the same length as range, must be\n a random-access range, must have slicing, and must contain elements that are\n complex-like.  This means that they must have a .re and a .im member or\n property that can be both read and written and are floating point numbers.\n",
						"parameters": [
							{
								"name": "Ret",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Ret && isComplexLike!(ElementType!Ret) && hasSlicing!Ret",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "inverseFft",
								"line": 2798,
								"type": "const Complex!F[](R range)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									}
								],
								"endline": 2813,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "inverseFft",
						"line": 2798,
						"comment": " Computes the inverse Fourier transform of a range.  The range must be a\n random access range with slicing, have a length equal to the size\n provided at construction of this object, and contain elements that are\n either of type std.complex.Complex or have essentially\n the same compile-time interface.\n\n Returns:  The time-domain signal.\n\n Conventions: The exponent is positive and the factor is 1/N, i.e.,\n              output[j] := (1 / N) sum[ exp(+2 PI i j k / N) input[k] ].\n",
						"parameters": [
							{
								"defaultDeco": "d",
								"name": "F",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!R && isComplexLike!(ElementType!R) && isFloatingPoint!F",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "inverseFft",
								"line": 2820,
								"type": "const void(R range, Ret buf)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									},
									{
										"name": "buf",
										"type": "Ret"
									}
								],
								"endline": 2835,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "inverseFft",
						"line": 2820,
						"comment": " Inverse FFT that allows a user-supplied buffer to be provided.  The buffer\n must be a random access range with slicing, and its elements\n must be some complex-like type.\n",
						"parameters": [
							{
								"name": "Ret",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Ret && isComplexLike!(ElementType!Ret) && hasSlicing!Ret",
						"char": 10,
						"kind": "template"
					}
				],
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "fft",
						"line": 2862,
						"type": "Complex!F[](R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2866,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "fft",
				"line": 2862,
				"comment": "Convenience functions that create an $(D Fft) object, run the FFT or inverse\n FFT and return the result.  Useful for one-off FFTs.\n\n Note:  In addition to convenience, these functions are slightly more\n        efficient than manually creating an Fft object for a single use,\n        as the Fft object is deterministically destroyed before these\n        functions return.\n",
				"parameters": [
					{
						"defaultDeco": "d",
						"name": "F",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "fft",
						"line": 2869,
						"type": "void(R range, Ret buf)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "buf",
								"type": "Ret"
							}
						],
						"endline": 2873,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "fft",
				"line": 2869,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Ret",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "inverseFft",
						"line": 2876,
						"type": "Complex!F[](R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2880,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "inverseFft",
				"line": 2876,
				"comment": "ditto\n",
				"parameters": [
					{
						"defaultDeco": "d",
						"name": "F",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "inverseFft",
						"line": 2883,
						"type": "void(R range, Ret buf)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "buf",
								"type": "Ret"
							}
						],
						"endline": 2887,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "inverseFft",
				"line": 2883,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Ret",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This module is a port of a growing fragment of the $(D_PARAM numeric)\nheader in Alexander Stepanov's $(LINK2 http://sgi.com/tech/stl,\nStandard Template Library), with a few additions.\n\nMacros:\n\nWIKI = Phobos/StdNumeric\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu),\n                   Don Clugston, Robert Jacques\nSource:    $(PHOBOSSRC std/_numeric.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/path.d",
		"name": "std.path",
		"members": [
			{
				"name": "dirSeparator",
				"line": 83,
				"comment": " String used to separate directory names in a path.  Under\n    POSIX this is a slash, under Windows a backslash.\n",
				"deco": "Aya",
				"init": "\"/\"",
				"char": 37,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "pathSeparator",
				"line": 93,
				"comment": " Path separator string.  A colon under POSIX, a semicolon\n    under Windows.\n",
				"deco": "Aya",
				"init": "\":\"",
				"char": 37,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"endchar": 1,
				"name": "isDirSeparator",
				"line": 105,
				"comment": " Determines whether the given character is a directory separator.\n\n    On Windows, this includes both $(D `\\`) and $(D `/`).\n    On POSIX, it's just $(D `/`).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 110,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 286,
						"value": "false",
						"comment": "File names are case insensitive\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 289,
						"value": "true",
						"comment": "File names are case sensitive\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "osDefault",
						"line": 295,
						"value": "true",
						"comment": " The default (or most common) setting for the current platform.\n        That is, $(D no) on Windows and Mac OS X, and $(D yes) on all\n        POSIX systems except OS X (Linux, *BSD, etc.).\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CaseSensitive",
				"line": 283,
				"comment": " This $(D enum) is used as a template argument to functions which\n    compare file names, and determines whether the comparison is\n    case sensitive or not.\n",
				"baseDeco": "b",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "baseName",
						"line": 352,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 373,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "baseName",
				"line": 352,
				"comment": "    Params:\n        cs = Whether or not suffix matching is case-sensitive.\n        path = A path name. It can be a string, or any random-access range of\n            characters.\n        suffix = An optional suffix to be removed from the file name.\n    Returns: The name of the file in the path name, without any leading\n        directory and with an optional suffix chopped off.\n\n    If $(D suffix) is specified, it will be compared to $(D path)\n    using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    Example:\n    ---\n    assert (baseName(\"dir/file.ext\")         == \"file.ext\");\n    assert (baseName(\"dir/file.ext\", \".ext\") == \"file\");\n    assert (baseName(\"dir/file.ext\", \".xyz\") == \"file.ext\");\n    assert (baseName(\"dir/filename\", \"name\") == \"file\");\n    assert (baseName(\"dir/subdir/\")          == \"subdir\");\n\n    version (Windows)\n    {\n        assert (baseName(`d:file.ext`)      == \"file.ext\");\n        assert (baseName(`d:\\dir\\file.ext`) == \"file.ext\");\n    }\n    ---\n\n    Note:\n    This function $(I only) strips away the specified suffix, which\n    doesn't necessarily have to represent an extension.\n    To remove the extension from a path, regardless of what the extension\n    is, use $(LREF stripExtension).\n    To obtain the filename without leading directories and without\n    an extension, combine the functions like this:\n    ---\n    assert (baseName(stripExtension(\"dir/file.ext\")) == \"file\");\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html,\n    the POSIX requirements for the 'basename' shell utility)\n    (with suitable adaptations for Windows paths).\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "baseName",
						"line": 376,
						"type": "pure @safe inout(C)[](inout(C)[] path, in C1[] suffix)",
						"parameters": [
							{
								"name": "path",
								"type": "inout(C)[]"
							},
							{
								"name": "suffix",
								"type": "C1[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 388,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "baseName",
				"line": 376,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "C1",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C && isSomeChar!C1",
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dirName",
						"line": 470,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 517,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "dirName",
				"line": 470,
				"comment": " Returns the directory part of a path.  On Windows, this\n    includes the drive letter if present.\n\n    Params:\n        path = A path name.\n\n    Returns:\n        A slice of $(D path) or \".\".\n\n    Standards:\n    This function complies with\n    $(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html,\n    the POSIX requirements for the 'dirname' shell utility)\n    (with suitable adaptations for Windows paths).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL520_1491)\n---\nassert (dirName(\"\") == \".\");\nassert (dirName(\"file\"w) == \".\");\nassert (dirName(\"dir/\"d) == \".\");\nassert (dirName(\"dir///\") == \".\");\nassert (dirName(\"dir/file\"w.dup) == \"dir\");\nassert (dirName(\"dir///file\"d.dup) == \"dir\");\nassert (dirName(\"dir/subdir/\") == \"dir\");\nassert (dirName(\"/dir/file\"w) == \"/dir\");\nassert (dirName(\"/file\"d) == \"/\");\nassert (dirName(\"/\") == \"/\");\nassert (dirName(\"///\") == \"/\");\n\nversion (Windows)\n{\n    assert (dirName(`dir\\`) == `.`);\n    assert (dirName(`dir\\\\\\`) == `.`);\n    assert (dirName(`dir\\file`) == `dir`);\n    assert (dirName(`dir\\\\\\file`) == `dir`);\n    assert (dirName(`dir\\subdir\\`) == `dir`);\n    assert (dirName(`\\dir\\file`) == `\\dir`);\n    assert (dirName(`\\file`) == `\\`);\n    assert (dirName(`\\`) == `\\`);\n    assert (dirName(`\\\\\\`) == `\\`);\n    assert (dirName(`d:`) == `d:`);\n    assert (dirName(`d:file`) == `d:`);\n    assert (dirName(`d:\\`) == `d:\\`);\n    assert (dirName(`d:\\file`) == `d:\\`);\n    assert (dirName(`d:\\dir\\file`) == `d:\\dir`);\n    assert (dirName(`\\\\server\\share\\dir\\file`) == `\\\\server\\share\\dir`);\n    assert (dirName(`\\\\server\\share\\file`) == `\\\\server\\share`);\n    assert (dirName(`\\\\server\\share\\`) == `\\\\server\\share`);\n    assert (dirName(`\\\\server\\share`) == `\\\\server\\share`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL520_1491)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || isNarrowString!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rootName",
						"line": 622,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 655,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "rootName",
				"line": 622,
				"comment": " Returns the root directory of the specified path, or $(D null) if the\n    path is not rooted.\n\n    Params:\n        path = A path name.\n\n    Returns:\n        A slice of $(D path).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL658_1494)\n---\nassert (rootName(\"\") is null);\nassert (rootName(\"foo\") is null);\nassert (rootName(\"/\") == \"/\");\nassert (rootName(\"/foo/bar\") == \"/\");\n\nversion (Windows)\n{\n    assert (rootName(\"d:foo\") is null);\n    assert (rootName(`d:\\foo`) == `d:\\`);\n    assert (rootName(`\\\\server\\share\\foo`) == `\\\\server\\share`);\n    assert (rootName(`\\\\server\\share`) == `\\\\server\\share`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL658_1494)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || isNarrowString!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "driveName",
						"line": 718,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 734,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "driveName",
				"line": 718,
				"comment": "    Get the drive portion of a path.\n\n    Params:\n        path = string or range of characters\n\n    Returns:\n        A slice of $(D _path) that is the drive, or an empty range if the drive\n        is not specified.  In the case of UNC paths, the network share\n        is returned.\n\n        Always returns an empty range on POSIX.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL737_1497)\n---\nversion (Posix)  assert (driveName(\"c:/foo\").empty);\nversion (Windows)\n{\n    assert (driveName(`dir\\file`).empty);\n    assert (driveName(`d:file`) == \"d:\");\n    assert (driveName(`d:\\file`) == \"d:\");\n    assert (driveName(\"d:\") == \"d:\");\n    assert (driveName(`\\\\server\\share\\file`) == `\\\\server\\share`);\n    assert (driveName(`\\\\server\\share\\`) == `\\\\server\\share`);\n    assert (driveName(`\\\\server\\share`) == `\\\\server\\share`);\n\n    static assert (driveName(`d:\\file`) == \"d:\");\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL737_1497)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || isNarrowString!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripDrive",
						"line": 794,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 805,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "stripDrive",
				"line": 794,
				"comment": " Strips the drive from a Windows path.  On POSIX, the path is returned\n    unaltered.\n\n    Params:\n        path = A pathname\n\n    Returns: A slice of path without the drive component.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL808_1500)\n---\nversion (Windows)\n{\n    assert (stripDrive(`d:\\dir\\file`) == `\\dir\\file`);\n    assert (stripDrive(`\\\\server\\share\\dir\\file`) == `\\dir\\file`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL808_1500)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && hasSlicing!R && isSomeChar!(ElementType!R) || isNarrowString!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "extension",
						"line": 916,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 929,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "extension",
				"line": 916,
				"comment": "    Params: path = A path name.\n    Returns: The _extension part of a file name, including the dot.\n\n    If there is no _extension, $(D null) is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL932_1505)\n---\nassert (extension(\"file\").empty);\nassert (extension(\"file.\") == \".\");\nassert (extension(\"file.ext\"w) == \".ext\");\nassert (extension(\"file.ext1.ext2\"d) == \".ext2\");\nassert (extension(\".foo\".dup).empty);\nassert (extension(\".foo.ext\"w.dup) == \".ext\");\n\nstatic assert (extension(\"file\").empty);\nstatic assert (extension(\"file.ext\") == \".ext\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL932_1505)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripExtension",
						"line": 967,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 974,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "stripExtension",
				"line": 967,
				"comment": " Remove extension from path.\n\n    Params:\n        path = string or range to be sliced\n\n    Returns:\n        slice of path with the extension (if any) stripped off\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL977_1507)\n---\nassert (stripExtension(\"file\")           == \"file\");\nassert (stripExtension(\"file.ext\")       == \"file\");\nassert (stripExtension(\"file.ext1.ext2\") == \"file.ext1\");\nassert (stripExtension(\"file.\")          == \"file\");\nassert (stripExtension(\".file\")          == \".file\");\nassert (stripExtension(\".file.ext\")      == \".file\");\nassert (stripExtension(\"dir/file.ext\")   == \"dir/file\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL977_1507)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || isNarrowString!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setExtension",
						"line": 1034,
						"type": "immutable(Unqual!C1)[](in C1[] path, in C2[] ext)",
						"parameters": [
							{
								"name": "path",
								"type": "C1[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "ext",
								"type": "C2[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1046,
						"char": 24,
						"kind": "function"
					}
				],
				"name": "setExtension",
				"line": 1034,
				"comment": " Params:\n        path = A path name\n        ext = The new extension\n\n    Returns: A string containing the _path given by $(D path), but where\n    the extension has been set to $(D ext).\n\n    If the filename already has an extension, it is replaced.   If not, the\n    extension is simply appended to the filename.  Including a leading dot\n    in $(D ext) is optional.\n\n    If the extension is empty, this function is equivalent to\n    $(LREF stripExtension).\n\n    This function normally allocates a new string (the possible exception\n    being the case when path is immutable and doesn't already have an\n    extension).\n\n    See_Also:\n        $(LREF withExtension) which does not allocate and returns a lazy range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1067_1510)\n---\nassert (setExtension(\"file\", \"ext\") == \"file.ext\");\nassert (setExtension(\"file\"w, \".ext\"w) == \"file.ext\");\nassert (setExtension(\"file.\"d, \"ext\"d) == \"file.ext\");\nassert (setExtension(\"file.\", \".ext\") == \"file.ext\");\nassert (setExtension(\"file.old\"w, \"new\"w) == \"file.new\");\nassert (setExtension(\"file.old\"d, \".new\"d) == \"file.new\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1067_1510)\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && !is(C1 == immutable) && is(Unqual!C1 == Unqual!C2)",
				"char": 24,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setExtension",
						"line": 1049,
						"type": "immutable(C1)[](immutable(C1)[] path, const(C2)[] ext)",
						"parameters": [
							{
								"name": "path",
								"type": "immutable(C1)[]"
							},
							{
								"name": "ext",
								"type": "const(C2)[]"
							}
						],
						"endline": 1064,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "setExtension",
				"line": 1049,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && is(Unqual!C1 == Unqual!C2)",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "withExtension",
						"line": 1109,
						"type": "(R path, C[] ext)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							},
							{
								"name": "ext",
								"type": "C[]"
							}
						],
						"endline": 1123,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "withExtension",
				"line": 1109,
				"comment": " Replace existing extension on filespec with new one.\n\n Params:\n      path = string or random access range representing a filespec\n      ext = the new extension\n Returns:\n      Range with $(D path)'s extension (if any) replaced with $(D ext).\n      The element encoding type of the returned range will be the same as $(D path)'s.\n See_Also:\n      $(LREF setExtension)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1126_1512)\n---\nimport std.array;\nassert (withExtension(\"file\", \"ext\").array == \"file.ext\");\nassert (withExtension(\"file\"w, \".ext\"w).array == \"file.ext\");\nassert (withExtension(\"file.ext\"w, \".\").array == \"file.\");\n\nimport std.utf : byChar, byWchar;\nassert (withExtension(\"file\".byChar, \"ext\").array == \"file.ext\");\nassert (withExtension(\"file\"w.byWchar, \".ext\"w).array == \"file.ext\"w);\nassert (withExtension(\"file.ext\"w.byWchar, \".\").array == \"file.\"w);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1126_1512)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || isNarrowString!R) && !isConvertibleToString!R && isSomeChar!C",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "defaultExtension",
						"line": 1162,
						"type": "immutable(Unqual!C1)[](in C1[] path, in C2[] ext)",
						"parameters": [
							{
								"name": "path",
								"type": "C1[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "ext",
								"type": "C2[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1167,
						"char": 24,
						"kind": "function"
					}
				],
				"name": "defaultExtension",
				"line": 1162,
				"comment": " Params:\n        path = A path name.\n        ext = The default extension to use.\n\n    Returns: The _path given by $(D path), with the extension given by $(D ext)\n    appended if the path doesn't already have one.\n\n    Including the dot in the extension is optional.\n\n    This function always allocates a new string, except in the case when\n    path is immutable and already has an extension.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1170_1514)\n---\nassert (defaultExtension(\"file\", \"ext\") == \"file.ext\");\nassert (defaultExtension(\"file\", \".ext\") == \"file.ext\");\nassert (defaultExtension(\"file.\", \"ext\")     == \"file.\");\nassert (defaultExtension(\"file.old\", \"new\") == \"file.old\");\nassert (defaultExtension(\"file.old\", \".new\") == \"file.old\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1170_1514)\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && is(Unqual!C1 == Unqual!C2)",
				"char": 24,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "withDefaultExtension",
						"line": 1201,
						"type": "(R path, C[] ext)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							},
							{
								"name": "ext",
								"type": "C[]"
							}
						],
						"endline": 1225,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "withDefaultExtension",
				"line": 1201,
				"comment": " Set the extension of $(D path) to $(D ext) if $(D path) doesn't have one.\n\n Params:\n      path = filespec as string or range\n      ext = extension, may have leading '.'\n Returns:\n      range with the result\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1228_1516)\n---\nimport std.array;\nassert (withDefaultExtension(\"file\", \"ext\").array == \"file.ext\");\nassert (withDefaultExtension(\"file\"w, \".ext\").array == \"file.ext\"w);\nassert (withDefaultExtension(\"file.\", \"ext\").array == \"file.\");\nassert (withDefaultExtension(\"file\", \"\").array == \"file.\");\n\nimport std.utf : byChar, byWchar;\nassert (withDefaultExtension(\"file\".byChar, \"ext\").array == \"file.ext\");\nassert (withDefaultExtension(\"file\"w.byWchar, \".ext\").array == \"file.ext\"w);\nassert (withDefaultExtension(\"file.\".byChar, \"ext\"d).array == \"file.\");\nassert (withDefaultExtension(\"file\".byChar, \"\").array == \"file.\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1228_1516)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || isNarrowString!R) && !isConvertibleToString!R && isSomeChar!C",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "buildPath",
						"line": 1277,
						"type": "immutable(ElementEncodingType!(ElementType!Range))[](Range segments)",
						"parameters": [
							{
								"name": "segments",
								"type": "Range"
							}
						],
						"endline": 1314,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "buildPath",
				"line": 1277,
				"comment": " Combines one or more path segments.\n\n    This function takes a set of path segments, given as an input\n    range of string elements or as a set of string arguments,\n    and concatenates them with each other.  Directory separators\n    are inserted between segments if necessary.  If any of the\n    path segments are absolute (as defined by $(LREF isAbsolute)), the\n    preceding segments will be dropped.\n\n    On Windows, if one of the path segments are rooted, but not absolute\n    (e.g. $(D `\\foo`)), all preceding path segments down to the previous\n    root will be dropped.  (See below for an example.)\n\n    This function always allocates memory to hold the resulting path.\n    The variadic overload is guaranteed to only perform a single\n    allocation, as is the range version if $(D paths) is a forward\n    range.\n\n    Params:\n        segments = An input range of segments to assemble the path from.\n    Returns: The assembled path.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1325_1518)\n---\nversion (Posix)\n{\n    assert (buildPath(\"foo\", \"bar\", \"baz\") == \"foo/bar/baz\");\n    assert (buildPath(\"/foo/\", \"bar/baz\")  == \"/foo/bar/baz\");\n    assert (buildPath(\"/foo\", \"/bar\")      == \"/bar\");\n}\n\nversion (Windows)\n{\n    assert (buildPath(\"foo\", \"bar\", \"baz\") == `foo\\bar\\baz`);\n    assert (buildPath(`c:\\foo`, `bar\\baz`) == `c:\\foo\\bar\\baz`);\n    assert (buildPath(\"foo\", `d:\\bar`)     == `d:\\bar`);\n    assert (buildPath(\"foo\", `\\bar`)       == `\\bar`);\n    assert (buildPath(`c:\\foo`, `\\bar`)    == `c:\\bar`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1325_1518)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeString!(ElementType!Range)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "buildPath",
						"line": 1317,
						"type": "pure nothrow @safe immutable(C)[](const(C)[][] paths...)",
						"parameters": [
							{
								"name": "paths",
								"type": "const(C)[][]"
							}
						],
						"endline": 1322,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "buildPath",
				"line": 1317,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chainPath",
						"line": 1451,
						"type": "(R1 r1, R2 r2, Ranges ranges)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							},
							{
								"name": "ranges",
								"type": "Ranges"
							}
						],
						"endline": 1506,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "chainPath",
				"line": 1451,
				"comment": " Concatenate path segments together to form one path.\n\n Params:\n      r1 = first segment\n      r2 = second segment\n      ranges = 0 or more segments\n Returns:\n      Lazy range which is the concatenation of r1, r2 and ranges with path separators.\n      The resulting element type is that of r1.\n See_Also:\n      $(LREF buildPath)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1509_1521)\n---\nimport std.array;\nversion (Posix)\n{\n    assert (chainPath(\"foo\", \"bar\", \"baz\").array == \"foo/bar/baz\");\n    assert (chainPath(\"/foo/\", \"bar/baz\").array  == \"/foo/bar/baz\");\n    assert (chainPath(\"/foo\", \"/bar\").array      == \"/bar\");\n}\n\nversion (Windows)\n{\n    assert (chainPath(\"foo\", \"bar\", \"baz\").array == `foo\\bar\\baz`);\n    assert (chainPath(`c:\\foo`, `bar\\baz`).array == `c:\\foo\\bar\\baz`);\n    assert (chainPath(\"foo\", `d:\\bar`).array     == `d:\\bar`);\n    assert (chainPath(\"foo\", `\\bar`).array       == `\\bar`);\n    assert (chainPath(`c:\\foo`, `\\bar`).array    == `c:\\bar`);\n}\n\nimport std.utf : byChar;\nversion (Posix)\n{\n    assert (chainPath(\"foo\", \"bar\", \"baz\").array == \"foo/bar/baz\");\n    assert (chainPath(\"/foo/\".byChar, \"bar/baz\").array  == \"/foo/bar/baz\");\n    assert (chainPath(\"/foo\", \"/bar\".byChar).array      == \"/bar\");\n}\n\nversion (Windows)\n{\n    assert (chainPath(\"foo\", \"bar\", \"baz\").array == `foo\\bar\\baz`);\n    assert (chainPath(`c:\\foo`.byChar, `bar\\baz`).array == `c:\\foo\\bar\\baz`);\n    assert (chainPath(\"foo\", `d:\\bar`).array     == `d:\\bar`);\n    assert (chainPath(\"foo\", `\\bar`.byChar).array       == `\\bar`);\n    assert (chainPath(`c:\\foo`, `\\bar`w).array    == `c:\\bar`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1509_1521)\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					},
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "(isRandomAccessRange!R1 && hasSlicing!R1 && hasLength!R1 && isSomeChar!(ElementType!R1) || isNarrowString!R1 && !isConvertibleToString!R1) && (isRandomAccessRange!R2 && hasSlicing!R2 && hasLength!R2 && isSomeChar!(ElementType!R2) || isNarrowString!R2 && !isConvertibleToString!R2) && (Ranges.length == 0 || is(typeof(chainPath(r2, ranges))))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "buildNormalizedPath",
						"line": 1583,
						"type": "pure nothrow @trusted immutable(C)[](const(C[])[] paths...)",
						"parameters": [
							{
								"name": "paths",
								"type": "const(C[])[]"
							}
						],
						"endline": 1599,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "buildNormalizedPath",
				"line": 1583,
				"comment": " Performs the same task as $(LREF buildPath),\n    while at the same time resolving current/parent directory\n    symbols ($(D \".\") and $(D \"..\")) and removing superfluous\n    directory separators.\n    It will return \".\" if the path leads to the starting directory.\n    On Windows, slashes are replaced with backslashes.\n\n    Using buildNormalizedPath on null paths will always return null.\n\n    Note that this function does not resolve symbolic links.\n\n    This function always allocates memory to hold the resulting path.\n    Use $(LREF asNormalizedPath) to not allocate memory.\n\n    Params:\n        paths = An array of paths to assemble.\n\n    Returns: The assembled path.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1602_1523)\n---\nassert (buildNormalizedPath(\"foo\", \"..\") == \".\");\n\nversion (Posix)\n{\n    assert (buildNormalizedPath(\"/foo/./bar/..//baz/\") == \"/foo/baz\");\n    assert (buildNormalizedPath(\"../foo/.\") == \"../foo\");\n    assert (buildNormalizedPath(\"/foo\", \"bar/baz/\") == \"/foo/bar/baz\");\n    assert (buildNormalizedPath(\"/foo\", \"/bar/..\", \"baz\") == \"/baz\");\n    assert (buildNormalizedPath(\"foo/./bar\", \"../../\", \"../baz\") == \"../baz\");\n    assert (buildNormalizedPath(\"/foo/./bar\", \"../../baz\") == \"/baz\");\n}\n\nversion (Windows)\n{\n    assert (buildNormalizedPath(`c:\\foo\\.\\bar/..\\\\baz\\`) == `c:\\foo\\baz`);\n    assert (buildNormalizedPath(`..\\foo\\.`) == `..\\foo`);\n    assert (buildNormalizedPath(`c:\\foo`, `bar\\baz\\`) == `c:\\foo\\bar\\baz`);\n    assert (buildNormalizedPath(`c:\\foo`, `bar/..`) == `c:\\foo`);\n    assert (buildNormalizedPath(`\\\\server\\share\\foo`, `..\\bar`) ==\n            `\\\\server\\share\\bar`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1602_1523)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asNormalizedPath",
						"line": 1737,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 1877,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asNormalizedPath",
				"line": 1737,
				"comment": " Normalize a path by resolving current/parent directory\n    symbols ($(D \".\") and $(D \"..\")) and removing superfluous\n    directory separators.\n    It will return \".\" if the path leads to the starting directory.\n    On Windows, slashes are replaced with backslashes.\n\n    Using asNormalizedPath on empty paths will always return an empty path.\n\n    Does not resolve symbolic links.\n\n    This function always allocates memory to hold the resulting path.\n    Use $(LREF buildNormalizedPath) to allocate memory and return a string.\n\n    Params:\n        path = string or random access range representing the _path to normalize\n\n    Returns:\n        normalized path as a forward range\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1880_1526)\n---\nimport std.array;\nassert (asNormalizedPath(\"foo/..\").array == \".\");\n\nversion (Posix)\n{\n    assert (asNormalizedPath(\"/foo/./bar/..//baz/\").array == \"/foo/baz\");\n    assert (asNormalizedPath(\"../foo/.\").array == \"../foo\");\n    assert (asNormalizedPath(\"/foo/bar/baz/\").array == \"/foo/bar/baz\");\n    assert (asNormalizedPath(\"/foo/./bar/../../baz\").array == \"/baz\");\n}\n\nversion (Windows)\n{\n    assert (asNormalizedPath(`c:\\foo\\.\\bar/..\\\\baz\\`).array == `c:\\foo\\baz`);\n    assert (asNormalizedPath(`..\\foo\\.`).array == `..\\foo`);\n    assert (asNormalizedPath(`c:\\foo\\bar\\baz\\`).array == `c:\\foo\\bar\\baz`);\n    assert (asNormalizedPath(`c:\\foo\\bar/..`).array == `c:\\foo`);\n    assert (asNormalizedPath(`\\\\server\\share\\foo\\..\\bar`).array ==\n            `\\\\server\\share\\bar`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1880_1526)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!(ElementEncodingType!R) && (isRandomAccessRange!R && hasSlicing!R && hasLength!R || isNarrowString!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "pathSplitter",
						"line": 2119,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 2281,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "pathSplitter",
				"line": 2119,
				"comment": " Slice up a path into its elements.\n\n    Params:\n        path = string or slicable random access range\n\n    Returns:\n        bidirectional range of slices of `path`\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2284_1530)\n---\nimport std.algorithm.comparison : equal;\nimport std.conv : to;\n\nassert (equal(pathSplitter(\"/\"), [\"/\"]));\nassert (equal(pathSplitter(\"/foo/bar\"), [\"/\", \"foo\", \"bar\"]));\nassert (equal(pathSplitter(\"foo/../bar//./\"), [\"foo\", \"..\", \"bar\", \".\"]));\n\nversion (Posix)\n{\n    assert (equal(pathSplitter(\"//foo/bar\"), [\"/\", \"foo\", \"bar\"]));\n}\n\nversion (Windows)\n{\n    assert (equal(pathSplitter(`foo\\..\\bar\\/.\\`), [\"foo\", \"..\", \"bar\", \".\"]));\n    assert (equal(pathSplitter(\"c:\"), [\"c:\"]));\n    assert (equal(pathSplitter(`c:\\foo\\bar`), [`c:\\`, \"foo\", \"bar\"]));\n    assert (equal(pathSplitter(`c:foo\\bar`), [\"c:foo\", \"bar\"]));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2284_1530)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && hasSlicing!R || isNarrowString!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isRooted",
						"line": 2418,
						"type": "bool(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 2425,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isRooted",
				"line": 2418,
				"comment": " Determines whether a path starts at a root directory.\n\n    Params: path = A path name.\n    Returns: Whether a path starts at a root directory.\n\n    On POSIX, this function returns true if and only if the path starts\n    with a slash (/).\n    ---\n    version (Posix)\n    {\n        assert (isRooted(\"/\"));\n        assert (isRooted(\"/foo\"));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"../foo\"));\n    }\n    ---\n\n    On Windows, this function returns true if the path starts at\n    the root directory of the current drive, of some other drive,\n    or of a network drive.\n    ---\n    version (Windows)\n    {\n        assert (isRooted(`\\`));\n        assert (isRooted(`\\foo`));\n        assert (isRooted(`d:\\foo`));\n        assert (isRooted(`\\\\foo\\bar`));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"d:foo\"));\n    }\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAbsolute",
						"line": 2492,
						"type": "pure nothrow @safe bool(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"char": 10,
						"kind": "function"
					}
				],
				"name": "isAbsolute",
				"line": 2492,
				"comment": " Determines whether a path is absolute or not.\n\n    Params: path = A path name.\n\n    Returns: Whether a path is absolute or not.\n\n    Example:\n    On POSIX, an absolute path starts at the root directory.\n    (In fact, $(D _isAbsolute) is just an alias for $(LREF isRooted).)\n    ---\n    version (Posix)\n    {\n        assert (isAbsolute(\"/\"));\n        assert (isAbsolute(\"/foo\"));\n        assert (!isAbsolute(\"foo\"));\n        assert (!isAbsolute(\"../foo\"));\n    }\n    ---\n\n    On Windows, an absolute path starts at the root directory of\n    a specific drive.  Hence, it must start with $(D `d:\\`) or $(D `d:/`),\n    where $(D d) is the drive letter.  Alternatively, it may be a\n    network path, i.e. a path starting with a double (back)slash.\n    ---\n    version (Windows)\n    {\n        assert (isAbsolute(`d:\\`));\n        assert (isAbsolute(`d:\\foo`));\n        assert (isAbsolute(`\\\\foo\\bar`));\n        assert (!isAbsolute(`\\`));\n        assert (!isAbsolute(`\\foo`));\n        assert (!isAbsolute(\"d:foo\"));\n    }\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 10,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "absolutePath",
				"line": 2574,
				"comment": " Tranforms $(D path) into an absolute _path.\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is empty, return $(D null).)\n        $(LI If $(D path) is already absolute, return it.)\n        $(LI Otherwise, append $(D path) to $(D base) and return\n            the result. If $(D base) is not specified, the current\n            working directory is used.)\n    )\n    The function allocates memory if and only if it gets to the third stage\n    of this algorithm.\n\n    Params:\n        path = the relative path to transform\n        base = the base directory of the relative path\n\n    Returns:\n        string of transformed path\n\n    Throws:\n    $(D Exception) if the specified _base directory is not absolute.\n\n    See_Also:\n        $(LREF asAbsolutePath) which does not allocate\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2586_1535)\n---\nversion (Posix)\n{\n    assert (absolutePath(\"some/file\", \"/foo/bar\")  == \"/foo/bar/some/file\");\n    assert (absolutePath(\"../file\", \"/foo/bar\")    == \"/foo/bar/../file\");\n    assert (absolutePath(\"/some/file\", \"/foo/bar\") == \"/some/file\");\n}\n\nversion (Windows)\n{\n    assert (absolutePath(`some\\file`, `c:\\foo\\bar`)    == `c:\\foo\\bar\\some\\file`);\n    assert (absolutePath(`..\\file`, `c:\\foo\\bar`)      == `c:\\foo\\bar\\..\\file`);\n    assert (absolutePath(`c:\\some\\file`, `c:\\foo\\bar`) == `c:\\some\\file`);\n    assert (absolutePath(`\\`, `c:\\`)                   == `c:\\`);\n    assert (absolutePath(`\\some\\file`, `c:\\foo\\bar`)   == `c:\\some\\file`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2586_1535)\n",
				"deco": "FNaNfAyaLAyaZAya",
				"parameters": [
					{
						"name": "path",
						"deco": "Aya"
					},
					{
						"name": "base",
						"storageClass": [
							"lazy"
						],
						"deco": "Aya",
						"default": "getcwd()"
					}
				],
				"endline": 2583,
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asAbsolutePath",
						"line": 2640,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 2650,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asAbsolutePath",
				"line": 2640,
				"comment": " Tranforms $(D path) into an absolute _path.\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is empty, return $(D null).)\n        $(LI If $(D path) is already absolute, return it.)\n        $(LI Otherwise, append $(D path) to the current working directory,\n        which allocates memory.)\n    )\n\n    Params:\n        path = the relative path to transform\n\n    Returns:\n        the transformed path as a lazy range\n\n    See_Also:\n        $(LREF absolutePath) which returns an allocated string\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2653_1537)\n---\nimport std.array;\nassert(asAbsolutePath(cast(string)null).array == \"\");\nversion (Posix)\n{\n    assert(asAbsolutePath(\"/foo\").array == \"/foo\");\n}\nversion (Windows)\n{\n    assert(asAbsolutePath(\"c:/foo\").array == \"c:/foo\");\n}\nasAbsolutePath(\"foo\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2653_1537)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && isSomeChar!(ElementType!R) || isNarrowString!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "relativePath",
						"line": 2719,
						"type": "string(string path, lazy string base = getcwd())",
						"parameters": [
							{
								"name": "path",
								"type": "string"
							},
							{
								"name": "base",
								"type": "string",
								"storageClass": [
									"lazy"
								],
								"default": "getcwd()"
							}
						],
						"endline": 2730,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "relativePath",
				"line": 2719,
				"comment": " Translates $(D path) into a relative _path.\n\n    The returned _path is relative to $(D base), which is by default\n    taken to be the current working directory.  If specified,\n    $(D base) must be an absolute _path, and it is always assumed\n    to refer to a directory.  If $(D path) and $(D base) refer to\n    the same directory, the function returns $(D `.`).\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is a relative directory, return it unaltered.)\n        $(LI Find a common root between $(D path) and $(D base).\n            If there is no common root, return $(D path) unaltered.)\n        $(LI Prepare a string with as many $(D `../`) or $(D `..\\`) as\n            necessary to reach the common root from base path.)\n        $(LI Append the remaining segments of $(D path) to the string\n            and return.)\n    )\n\n    In the second step, path components are compared using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    This function allocates memory.\n\n    Params:\n        cs = Whether matching path name components against the base path should\n            be case-sensitive or not.\n        path = A path name.\n        base = The base path to construct the relative path from.\n\n    Returns: The relative path.\n\n    See_Also:\n        $(LREF asRelativePath) which does not allocate memory\n\n    Throws:\n    $(D Exception) if the specified _base directory is not absolute.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2733_1539)\n---\nassert (relativePath(\"foo\") == \"foo\");\n\nversion (Posix)\n{\n    assert (relativePath(\"foo\", \"/bar\") == \"foo\");\n    assert (relativePath(\"/foo/bar\", \"/foo/bar\") == \".\");\n    assert (relativePath(\"/foo/bar\", \"/foo/baz\") == \"../bar\");\n    assert (relativePath(\"/foo/bar/baz\", \"/foo/woo/wee\") == \"../../bar/baz\");\n    assert (relativePath(\"/foo/bar/baz\", \"/foo/bar\") == \"baz\");\n}\nversion (Windows)\n{\n    assert (relativePath(\"foo\", `c:\\bar`) == \"foo\");\n    assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\bar`) == \".\");\n    assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\baz`) == `..\\bar`);\n    assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\woo\\wee`) == `..\\..\\bar\\baz`);\n    assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\bar`) == \"baz\");\n    assert (relativePath(`c:\\foo\\bar`, `d:\\foo`) == `c:\\foo\\bar`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2733_1539)\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asRelativePath",
						"line": 2811,
						"type": "(R1 path, R2 base)",
						"parameters": [
							{
								"name": "path",
								"type": "R1"
							},
							{
								"name": "base",
								"type": "R2"
							}
						],
						"endline": 2860,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asRelativePath",
				"line": 2811,
				"comment": " Transforms `path` into a _path relative to `base`.\n\n    The returned _path is relative to `base`, which is usually\n    the current working directory.\n    `base` must be an absolute _path, and it is always assumed\n    to refer to a directory.  If `path` and `base` refer to\n    the same directory, the function returns `'.'`.\n\n    The following algorithm is used:\n    $(OL\n        $(LI If `path` is a relative directory, return it unaltered.)\n        $(LI Find a common root between `path` and `base`.\n            If there is no common root, return `path` unaltered.)\n        $(LI Prepare a string with as many `../` or `..\\` as\n            necessary to reach the common root from base path.)\n        $(LI Append the remaining segments of `path` to the string\n            and return.)\n    )\n\n    In the second step, path components are compared using `filenameCmp!cs`,\n    where `cs` is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    Params:\n        path = _path to transform\n        base = absolute path\n        cs = whether filespec comparisons are sensitive or not; defaults to\n         `CaseSensitive.osDefault`\n\n    Returns:\n        a random access range of the transformed _path\n\n    See_Also:\n        $(LREF relativePath)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2863_1543)\n---\nimport std.array;\nversion (Posix)\n{\n    assert (asRelativePath(\"foo\", \"/bar\").array == \"foo\");\n    assert (asRelativePath(\"/foo/bar\", \"/foo/bar\").array == \".\");\n    assert (asRelativePath(\"/foo/bar\", \"/foo/baz\").array == \"../bar\");\n    assert (asRelativePath(\"/foo/bar/baz\", \"/foo/woo/wee\").array == \"../../bar/baz\");\n    assert (asRelativePath(\"/foo/bar/baz\", \"/foo/bar\").array == \"baz\");\n}\nelse version (Windows)\n{\n    assert (asRelativePath(\"foo\", `c:\\bar`).array == \"foo\");\n    assert (asRelativePath(`c:\\foo\\bar`, `c:\\foo\\bar`).array == \".\");\n    assert (asRelativePath(`c:\\foo\\bar`, `c:\\foo\\baz`).array == `..\\bar`);\n    assert (asRelativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\woo\\wee`).array == `..\\..\\bar\\baz`);\n    assert (asRelativePath(`c:/foo/bar/baz`, `c:\\foo\\woo\\wee`).array == `..\\..\\bar\\baz`);\n    assert (asRelativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\bar`).array == \"baz\");\n    assert (asRelativePath(`c:\\foo\\bar`, `d:\\foo`).array == `c:\\foo\\bar`);\n    assert (asRelativePath(`\\\\foo\\bar`, `c:\\foo`).array == `\\\\foo\\bar`);\n}\nelse\n    static assert(0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2863_1543)\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "(isNarrowString!R1 || isRandomAccessRange!R1 && hasSlicing!R1 && isSomeChar!(ElementType!R1) && !isConvertibleToString!R1) && (isNarrowString!R2 || isRandomAccessRange!R2 && hasSlicing!R2 && isSomeChar!(ElementType!R2) && !isConvertibleToString!R2)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "filenameCharCmp",
						"line": 2948,
						"type": "pure nothrow @safe int(dchar a, dchar b)",
						"parameters": [
							{
								"name": "a",
								"deco": "w"
							},
							{
								"name": "b",
								"deco": "w"
							}
						],
						"endline": 2959,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "filenameCharCmp",
				"line": 2948,
				"comment": " Compares filename characters.\n\n    This function can perform a case-sensitive or a case-insensitive\n    comparison.  This is controlled through the $(D cs) template parameter\n    which, if not specified, is given by $(LREF CaseSensitive)$(D .osDefault).\n\n    On Windows, the backslash and slash characters ($(D `\\`) and $(D `/`))\n    are considered equal.\n\n    Params:\n        cs = Case-sensitivity of the comparison.\n        a = A filename character.\n        b = A filename character.\n\n    Returns:\n        $(D < 0) if $(D a < b),\n        $(D 0) if $(D a == b), and\n        $(D > 0) if $(D a > b).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2962_1546)\n---\nassert (filenameCharCmp('a', 'a') == 0);\nassert (filenameCharCmp('a', 'b') < 0);\nassert (filenameCharCmp('b', 'a') > 0);\n\nversion (linux)\n{\n    // Same as calling filenameCharCmp!(CaseSensitive.yes)(a, b)\n    assert (filenameCharCmp('A', 'a') < 0);\n    assert (filenameCharCmp('a', 'A') > 0);\n}\nversion (Windows)\n{\n    // Same as calling filenameCharCmp!(CaseSensitive.no)(a, b)\n    assert (filenameCharCmp('a', 'A') == 0);\n    assert (filenameCharCmp('a', 'B') < 0);\n    assert (filenameCharCmp('A', 'b') < 0);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2962_1546)\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					}
				],
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "filenameCmp",
						"line": 3024,
						"type": "int(Range1 filename1, Range2 filename2)",
						"parameters": [
							{
								"name": "filename1",
								"type": "Range1"
							},
							{
								"name": "filename2",
								"type": "Range2"
							}
						],
						"endline": 3059,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "filenameCmp",
				"line": 3024,
				"comment": " Compares file names and returns\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.\n\n    Treatment of invalid UTF encodings is implementation defined.\n\n    Params:\n        cs = case sensitivity\n        filename1 = range for first file name\n        filename2 = range for second file name\n\n    Returns:\n        $(D < 0) if $(D filename1 < filename2),\n        $(D 0) if $(D filename1 == filename2) and\n        $(D > 0) if $(D filename1 > filename2).\n\n    See_Also:\n        $(LREF filenameCharCmp)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3062_1548)\n---\nassert (filenameCmp(\"abc\", \"abc\") == 0);\nassert (filenameCmp(\"abc\", \"abd\") < 0);\nassert (filenameCmp(\"abc\", \"abb\") > 0);\nassert (filenameCmp(\"abc\", \"abcd\") < 0);\nassert (filenameCmp(\"abcd\", \"abc\") > 0);\n\nversion (linux)\n{\n    // Same as calling filenameCmp!(CaseSensitive.yes)(filename1, filename2)\n    assert (filenameCmp(\"Abc\", \"abc\") < 0);\n    assert (filenameCmp(\"abc\", \"Abc\") > 0);\n}\nversion (Windows)\n{\n    // Same as calling filenameCmp!(CaseSensitive.no)(filename1, filename2)\n    assert (filenameCmp(\"Abc\", \"abc\") == 0);\n    assert (filenameCmp(\"abc\", \"Abc\") == 0);\n    assert (filenameCmp(\"Abc\", \"abD\") < 0);\n    assert (filenameCmp(\"abc\", \"AbB\") > 0);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3062_1548)\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isSomeChar!(ElementEncodingType!Range1) && !isConvertibleToString!Range1 && isInputRange!Range2 && isSomeChar!(ElementEncodingType!Range2) && !isConvertibleToString!Range2",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "globMatch",
						"line": 3161,
						"type": "pure nothrow @safe bool(Range path, const(C)[] pattern)",
						"parameters": [
							{
								"name": "path",
								"type": "Range"
							},
							{
								"name": "pattern",
								"type": "const(C)[]"
							}
						],
						"endline": 3308,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "globMatch",
				"line": 3161,
				"comment": " Matches a pattern against a path.\n\n    Some characters of pattern have a special meaning (they are\n    $(I meta-characters)) and can't be escaped. These are:\n\n    $(BOOKTABLE,\n    $(TR $(TD $(D *))\n         $(TD Matches 0 or more instances of any character.))\n    $(TR $(TD $(D ?))\n         $(TD Matches exactly one instance of any character.))\n    $(TR $(TD $(D [)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that appears\n              between the brackets.))\n    $(TR $(TD $(D [!)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that does not\n              appear between the brackets after the exclamation mark.))\n    $(TR $(TD $(D {)$(I string1)$(D ,)$(I string2)$(D ,)&hellip;$(D }))\n         $(TD Matches either of the specified strings.))\n    )\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCharCmp) documentation for details.\n\n    Note that directory\n    separators and dots don't stop a meta-character from matching\n    further portions of the path.\n\n    Params:\n        cs = Whether the matching should be case-sensitive\n        path = The path to be matched against\n        pattern = The glob pattern\n\n    Returns:\n    $(D true) if pattern matches path, $(D false) otherwise.\n\n    See_also:\n    $(LINK2 http://en.wikipedia.org/wiki/Glob_%28programming%29,Wikipedia: _glob (programming))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3311_1551)\n---\nassert (globMatch(\"foo.bar\", \"*\"));\nassert (globMatch(\"foo.bar\", \"*.*\"));\nassert (globMatch(`foo/foo\\bar`, \"f*b*r\"));\nassert (globMatch(\"foo.bar\", \"f???bar\"));\nassert (globMatch(\"foo.bar\", \"[fg]???bar\"));\nassert (globMatch(\"foo.bar\", \"[!gh]*bar\"));\nassert (globMatch(\"bar.fooz\", \"bar.{foo,bif}z\"));\nassert (globMatch(\"bar.bifz\", \"bar.{foo,bif}z\"));\n\nversion (Windows)\n{\n    // Same as calling globMatch!(CaseSensitive.no)(path, pattern)\n    assert (globMatch(\"foo\", \"Foo\"));\n    assert (globMatch(\"Goo.bar\", \"[fg]???bar\"));\n}\nversion (linux)\n{\n    // Same as calling globMatch!(CaseSensitive.yes)(path, pattern)\n    assert (!globMatch(\"foo\", \"Foo\"));\n    assert (!globMatch(\"Goo.bar\", \"[fg]???bar\"));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3311_1551)\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range && isSomeChar!C && is(Unqual!C == Unqual!(ElementEncodingType!Range))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isValidFilename",
						"line": 3433,
						"type": "bool(Range filename)",
						"parameters": [
							{
								"name": "filename",
								"type": "Range"
							}
						],
						"endline": 3478,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isValidFilename",
				"line": 3433,
				"comment": " Checks that the given file or directory name is valid.\n\n    The maximum length of $(D filename) is given by the constant\n    $(D core.stdc.stdio.FILENAME_MAX).  (On Windows, this number is\n    defined as the maximum number of UTF-16 code points, and the\n    test will therefore only yield strictly correct results when\n    $(D filename) is a string of $(D wchar)s.)\n\n    On Windows, the following criteria must be satisfied\n    ($(LINK2 http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx,source)):\n    $(UL\n        $(LI $(D filename) must not contain any characters whose integer\n            representation is in the range 0-31.)\n        $(LI $(D filename) must not contain any of the following $(I reserved\n            characters): <>:\"/\\|?*)\n        $(LI $(D filename) may not end with a space ($(D ' ')) or a period\n            ($(D '.')).)\n    )\n\n    On POSIX, $(D filename) may not contain a forward slash ($(D '/')) or\n    the null character ($(D '\\0')).\n\n    Params:\n        filename = string to check\n\n    Returns:\n        $(D true) if and only if $(D filename) is not\n        empty, not too long, and does not contain invalid characters.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3482_1554)\n---\nimport std.utf : byCodeUnit;\n\nassert(isValidFilename(\"hello.exe\".byCodeUnit));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3482_1554)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range && isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isValidPath",
						"line": 3575,
						"type": "bool(Range path)",
						"parameters": [
							{
								"name": "path",
								"type": "Range"
							}
						],
						"endline": 3670,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isValidPath",
				"line": 3575,
				"comment": " Checks whether $(D path) is a valid _path.\n\n    Generally, this function checks that $(D path) is not empty, and that\n    each component of the path either satisfies $(LREF isValidFilename)\n    or is equal to $(D \".\") or $(D \"..\").\n    It does $(I not) check whether the _path points to an existing file\n    or directory; use $(XREF file,exists) for this purpose.\n\n    On Windows, some special rules apply:\n    $(UL\n        $(LI If the second character of $(D path) is a colon ($(D ':')),\n            the first character is interpreted as a drive letter, and\n            must be in the range A-Z (case insensitive).)\n        $(LI If $(D path) is on the form $(D `\\\\$(I server)\\$(I share)\\...`)\n            (UNC path), $(LREF isValidFilename) is applied to $(I server)\n            and $(I share) as well.)\n        $(LI If $(D path) starts with $(D `\\\\?\\`) (long UNC path), the\n            only requirement for the rest of the string is that it does\n            not contain the null character.)\n        $(LI If $(D path) starts with $(D `\\\\.\\`) (Win32 device namespace)\n            this function returns $(D false); such paths are beyond the scope\n            of this module.)\n    )\n\n    Params:\n        path = string or Range of characters to check\n\n    Returns:\n        true if $(D path) is a valid _path.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3674_1557)\n---\nassert (isValidPath(\"/foo/bar\"));\nassert (!isValidPath(\"/foo\\0/bar\"));\nassert (isValidPath(\"/\"));\nassert (isValidPath(\"a\"));\n\nversion (Windows)\n{\n    assert (isValidPath(`c:\\`));\n    assert (isValidPath(`c:\\foo`));\n    assert (isValidPath(`c:\\foo\\.\\bar\\\\\\..\\`));\n    assert (!isValidPath(`!:\\foo`));\n    assert (!isValidPath(`c::\\foo`));\n    assert (!isValidPath(`c:\\foo?`));\n    assert (!isValidPath(`c:\\foo.`));\n\n    assert (isValidPath(`\\\\server\\share`));\n    assert (isValidPath(`\\\\server\\share\\foo`));\n    assert (isValidPath(`\\\\server\\share\\\\foo`));\n    assert (!isValidPath(`\\\\\\server\\share\\foo`));\n    assert (!isValidPath(`\\\\server\\\\share\\foo`));\n    assert (!isValidPath(`\\\\ser*er\\share\\foo`));\n    assert (!isValidPath(`\\\\server\\sha?e\\foo`));\n    assert (!isValidPath(`\\\\server\\share\\|oo`));\n\n    assert (isValidPath(`\\\\?\\<>:\"?*|/\\..\\.`));\n    assert (!isValidPath(\"\\\\\\\\?\\\\foo\\0bar\"));\n\n    assert (!isValidPath(`\\\\.\\PhysicalDisk1`));\n    assert (!isValidPath(`\\\\`));\n}\n\nimport std.utf : byCodeUnit;\nassert (isValidPath(\"/foo/bar\".byCodeUnit));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3674_1557)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range && isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "expandTilde",
				"line": 3766,
				"comment": " Performs tilde expansion in paths on POSIX systems.\n    On Windows, this function does nothing.\n\n    There are two ways of using tilde expansion in a path. One\n    involves using the tilde alone or followed by a path separator. In\n    this case, the tilde will be expanded with the value of the\n    environment variable $(D HOME).  The second way is putting\n    a username after the tilde (i.e. $(D ~john/Mail)). Here,\n    the username will be searched for in the user database\n    (i.e. $(D /etc/passwd) on Unix systems) and will expand to\n    whatever path is stored there.  The username is considered the\n    string after the tilde ending at the first instance of a path\n    separator.\n\n    Note that using the $(D ~user) syntax may give different\n    values from just $(D ~) if the environment variable doesn't\n    match the value stored in the user database.\n\n    When the environment variable version is used, the path won't\n    be modified if the environment variable doesn't exist or it\n    is empty. When the database version is used, the path won't be\n    modified if the user doesn't exist in the database or there is\n    not enough memory to perform the query.\n\n    This function performs several memory allocations.\n\n    Params:\n        inputPath = The path name to expand.\n\n    Returns:\n    $(D inputPath) with the tilde expanded, or just $(D inputPath)\n    if it could not be expanded.\n    For Windows, $(D expandTilde) merely returns its argument $(D inputPath).\n\n    Example:\n    -----\n    void processFile(string path)\n    {\n        // Allow calling this function with paths such as ~/foo\n        auto fullPath = expandTilde(path);\n        ...\n    }\n    -----\n",
				"deco": "FNbAyaZAya",
				"parameters": [
					{
						"name": "inputPath",
						"deco": "Aya"
					}
				],
				"endline": 3912,
				"char": 8,
				"kind": "function"
			}
		],
		"comment": " This module is used to manipulate _path strings.\n\n    All functions, with the exception of $(LREF expandTilde) (and in some\n    cases $(LREF absolutePath) and $(LREF relativePath)), are pure\n    string manipulation functions; they don't depend on any state outside\n    the program, nor do they perform any actual file system actions.\n    This has the consequence that the module does not make any distinction\n    between a _path that points to a directory and a _path that points to a\n    file, and it does not know whether or not the object pointed to by the\n    _path actually exists in the file system.\n    To differentiate between these cases, use $(XREF file,isDir) and\n    $(XREF file,exists).\n\n    Note that on Windows, both the backslash ($(D `\\`)) and the slash ($(D `/`))\n    are in principle valid directory separators.  This module treats them\n    both on equal footing, but in cases where a $(I new) separator is\n    added, a backslash will be used.  Furthermore, the $(LREF buildNormalizedPath)\n    function will replace all slashes with backslashes on that platform.\n\n    In general, the functions in this module assume that the input paths\n    are well-formed.  (That is, they should not contain invalid characters,\n    they should follow the file system's _path format, etc.)  The result\n    of calling a function on an ill-formed _path is undefined.  When there\n    is a chance that a _path or a file name is invalid (for instance, when it\n    has been input by the user), it may sometimes be desirable to use the\n    $(LREF isValidFilename) and $(LREF isValidPath) functions to check\n    this.\n\n    Most functions do not perform any memory allocations, and if a string is\n    returned, it is usually a slice of an input string.  If a function\n    allocates, this is explicitly mentioned in the documentation.\n\n    Upgrading:\n        $(WEB digitalmars.com/d/1.0/phobos/std_path.html#fnmatch) can\n        be replaced with $(D globMatch).\n\n    Authors:\n        Lars Tandle Kyllingstad,\n        $(WEB digitalmars.com, Walter Bright),\n        Grzegorz Adam Hankiewicz,\n        Thomas K$(UUML)hne,\n        $(WEB erdani.org, Andrei Alexandrescu)\n    Copyright:\n        Copyright (c) 2000-2014, the authors. All rights reserved.\n    License:\n        $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n    Source:\n        $(PHOBOSSRC std/_path.d)\n    Macros:\n        WIKI = Phobos/StdPath\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/file.d",
		"name": "std.file",
		"members": [
			{
				"members": [
					{
						"offset": 72,
						"name": "errno",
						"line": 105,
						"comment": "        OS error code.\n",
						"deco": "yk",
						"originalType": "uint",
						"char": 20,
						"kind": "variable",
						"storageClass": [
							"immutable"
						]
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 116,
						"comment": "        Constructor which takes an error message.\n\n        Params:\n            name = Name of file for which the error occurred.\n            msg  = Message describing the error.\n            file = The file where the error occurred.\n            line = The line where the error occurred.\n",
						"deco": "FNaNfxAaxAaAyamZC3std4file13FileException",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							},
							{
								"name": "msg",
								"deco": "xAa"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 124,
						"originalType": "pure @safe (in char[] name, in char[] msg, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 146,
						"comment": "        Constructor which takes the error number ($(LUCKY GetLastError)\n        in Windows, $(D_PARAM errno) in Posix).\n\n        Params:\n            name  = Name of file for which the error occurred.\n            errno = The error number.\n            file  = The file where the error occurred.\n                    Defaults to $(D __FILE__).\n            line  = The line where the error occurred.\n                    Defaults to $(D __LINE__).\n",
						"deco": "FNexAakAyamZC3std4file13FileException",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							},
							{
								"name": "errno",
								"deco": "k",
								"default": "cast(uint)errno()"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 154,
						"originalType": "@trusted (in char[] name, uint errno = .errno, string file = __FILE__, size_t line = __LINE__)",
						"char": 25,
						"kind": "constructor"
					}
				],
				"name": "FileException",
				"line": 100,
				"comment": "    Exception thrown for file I/O errors.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "read",
						"line": 222,
						"type": "void[](R name, size_t upTo = size_t.max)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							},
							{
								"name": "upTo",
								"type": "size_t",
								"default": "size_t.max"
							}
						],
						"endline": 230,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "read",
				"line": 222,
				"comment": "Read entire contents of file $(D name) and returns it as an untyped\narray. If the file size is larger than $(D upTo), only $(D upTo)\nbytes are read.\n\nParams:\n    name = string or range of characters representing the file _name\n    upTo = if present, the maximum number of bytes to read\n\nReturns: Untyped array of bytes _read.\n\nThrows: $(LREF FileException) on error.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL233_1560)\n---\nimport std.utf : byChar;\nscope(exit)\n{\n    assert(exists(\"someUniqueFilename\"));\n    remove(\"someUniqueFilename\");\n}\n\nwrite(\"someUniqueFilename\", \"1234\");\nassert(read(\"someUniqueFilename\", 2) == \"12\");\nassert(read(\"someUniqueFilename\".byChar) == \"1234\");\nassert((cast(ubyte[])read(\"someUniqueFilename\")).length == 4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL233_1560)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "readText",
						"line": 400,
						"type": "S(R name)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							}
						],
						"endline": 410,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "readText",
				"line": 400,
				"comment": "Read and validates (using $(XREF utf, validate)) a text file. $(D S)\ncan be a type of array of characters of any width and constancy. No\nwidth conversion is performed; if the width of the characters in file\n$(D name) is different from the width of elements of $(D S),\nvalidation will fail.\n\nParams:\n    name = string or range of characters representing the file _name\n\nReturns: Array of characters read.\n\nThrows: $(D FileException) on file error, $(D UTFException) on UTF\ndecoding error.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL413_1564)\n---\nimport std.string;\nwrite(\"someUniqueFilename\", \"abc\\n\");\nscope(exit)\n{\n    assert(exists(\"someUniqueFilename\"));\n    remove(\"someUniqueFilename\");\n}\nenforce(chomp(readText(\"someUniqueFilename\")) == \"abc\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL413_1564)\n",
				"parameters": [
					{
						"name": "S",
						"default": "string",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S && (isInputRange!R && isSomeChar!(ElementEncodingType!R) || isSomeString!R) && !isConvertibleToString!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "write",
						"line": 445,
						"type": "void(R name, const void[] buffer)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							},
							{
								"name": "buffer",
								"type": "void[]",
								"storageClass": [
									"const"
								]
							}
						],
						"endline": 453,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "write",
				"line": 445,
				"comment": "Write $(D buffer) to file $(D name).\n\nParams:\n    name = string or range of characters representing the file _name\n    buffer = data to be written to file\n\nThrows: $(D FileException) on error.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL456_1566)\n---\nscope(exit)\n{\n    assert(exists(\"someUniqueFilename\"));\n    remove(\"someUniqueFilename\");\n}\n\nint[] a = [ 0, 1, 1, 2, 3, 5, 8 ];\nwrite(\"someUniqueFilename\", a);\nassert(cast(int[]) read(\"someUniqueFilename\") == a);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL456_1566)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "(isInputRange!R && isSomeChar!(ElementEncodingType!R) || isSomeString!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "append",
						"line": 489,
						"type": "void(R name, const void[] buffer)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							},
							{
								"name": "buffer",
								"type": "void[]",
								"storageClass": [
									"const"
								]
							}
						],
						"endline": 497,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "append",
				"line": 489,
				"comment": "Appends $(D buffer) to file $(D name).\n\nParams:\n    name = string or range of characters representing the file _name\n    buffer = data to be appended to file\n\nThrows: $(D FileException) on error.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL500_1568)\n---\nscope(exit)\n{\n    assert(exists(\"someUniqueFilename\"));\n    remove(\"someUniqueFilename\");\n}\n\nint[] a = [ 0, 1, 1, 2, 3, 5, 8 ];\nwrite(\"someUniqueFilename\", a);\nint[] b = [ 13, 21 ];\nappend(\"someUniqueFilename\", b);\nassert(cast(int[]) read(\"someUniqueFilename\") == a ~ b);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL500_1568)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "(isInputRange!R && isSomeChar!(ElementEncodingType!R) || isSomeString!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rename",
						"line": 595,
						"type": "void(RF from, RT to)",
						"parameters": [
							{
								"name": "from",
								"type": "RF"
							},
							{
								"name": "to",
								"type": "RT"
							}
						],
						"endline": 614,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "rename",
				"line": 595,
				"comment": " Rename file $(D from) to $(D to).\n If the target file exists, it is overwritten.\n Params:\n    from = string or range of characters representing the existing file name\n    to = string or range of characters representing the target file name\n Throws: $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "RF",
						"kind": "type"
					},
					{
						"name": "RT",
						"kind": "type"
					}
				],
				"constraint": "(isInputRange!RF && isSomeChar!(ElementEncodingType!RF) || isSomeString!RF) && !isConvertibleToString!RF && (isInputRange!RT && isSomeChar!(ElementEncodingType!RT) || isSomeString!RT) && !isConvertibleToString!RT",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "remove",
						"line": 685,
						"type": "void(R name)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							}
						],
						"endline": 693,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "remove",
				"line": 685,
				"comment": "Delete file $(D name).\n\nParams:\n    name = string or range of characters representing the file name\n\nThrows: $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "getSize",
						"line": 774,
						"type": "ulong(R name)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							}
						],
						"endline": 799,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "getSize",
				"line": 774,
				"comment": "Get size of file $(D name) in bytes.\n\nParams:\n    name = string or range of characters representing the file name\n\nThrows: $(D FileException) on error (e.g., file not found).\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "getTimes",
						"line": 836,
						"type": "void(R name, out SysTime accessTime, out SysTime modificationTime)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							},
							{
								"name": "accessTime",
								"type": "SysTime",
								"storageClass": [
									"out"
								]
							},
							{
								"name": "modificationTime",
								"type": "SysTime",
								"storageClass": [
									"out"
								]
							}
						],
						"endline": 869,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "getTimes",
				"line": 836,
				"comment": "    Get the access and modified times of file or folder $(D name).\n\n    Params:\n        name             = File/Folder name to get times for.\n        accessTime       = Time the file/folder was last accessed.\n        modificationTime = Time the file/folder was last modified.\n\n    Throws:\n        $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "getTimesWin",
						"line": 959,
						"type": "void(R name, out SysTime fileCreationTime, out SysTime fileAccessTime, out SysTime fileModificationTime)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							},
							{
								"name": "fileCreationTime",
								"type": "SysTime",
								"storageClass": [
									"out"
								]
							},
							{
								"name": "fileAccessTime",
								"type": "SysTime",
								"storageClass": [
									"out"
								]
							},
							{
								"name": "fileModificationTime",
								"type": "SysTime",
								"storageClass": [
									"out"
								]
							}
						],
						"char": 10,
						"kind": "function"
					}
				],
				"name": "getTimesWin",
				"line": 959,
				"comment": "     $(BLUE This function is Windows-Only.)\n\n     Get creation/access/modified times of file $(D name).\n\n     This is the same as $(D getTimes) except that it also gives you the file\n     creation time - which isn't possible on Posix systems.\n\n     Params:\n     name                 = File name to get times for.\n     fileCreationTime     = Time the file was created.\n     fileAccessTime       = Time the file was last accessed.\n     fileModificationTime = Time the file was last modified.\n\n     Throws:\n     $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setTimes",
						"line": 1075,
						"type": "@safe void(R name, SysTime accessTime, SysTime modificationTime)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							},
							{
								"name": "accessTime",
								"type": "SysTime"
							},
							{
								"name": "modificationTime",
								"type": "SysTime"
							}
						],
						"endline": 1145,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "setTimes",
				"line": 1075,
				"comment": "    Set access/modified times of file or folder $(D name).\n\n    Params:\n        name             = File/Folder name to get times for.\n        accessTime       = Time the file/folder was last accessed.\n        modificationTime = Time the file/folder was last modified.\n\n    Throws:\n        $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "timeLastModified",
						"line": 1192,
						"type": "SysTime(R name)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							}
						],
						"endline": 1222,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "timeLastModified",
				"line": 1192,
				"comment": "    Returns the time that the given file was last modified.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "timeLastModified",
						"line": 1265,
						"type": "SysTime(R name, SysTime returnIfMissing)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							},
							{
								"name": "returnIfMissing",
								"type": "SysTime"
							}
						],
						"endline": 1293,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "timeLastModified",
				"line": 1265,
				"comment": "    Returns the time that the given file was last modified. If the\n    file does not exist, returns $(D returnIfMissing).\n\n    A frequent usage pattern occurs in build automation tools such as\n    $(WEB gnu.org/software/make, make) or $(WEB\n    en.wikipedia.org/wiki/Apache_Ant, ant). To check whether file $(D\n    target) must be rebuilt from file $(D source) (i.e., $(D target) is\n    older than $(D source) or does not exist), use the comparison\n    below. The code throws a $(D FileException) if $(D source) does not\n    exist (as it should). On the other hand, the $(D SysTime.min) default\n    makes a non-existing $(D target) seem infinitely old so the test\n    correctly prompts building it.\n\n    Params:\n        name            = The name of the file to get the modification time for.\n        returnIfMissing = The time to return if the given file does not exist.\n\nExample:\n--------------------\nif(timeLastModified(source) >= timeLastModified(target, SysTime.min))\n{\n    // must (re)build\n}\nelse\n{\n    // target is up-to-date\n}\n--------------------\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R)",
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "exists",
						"line": 1322,
						"type": "bool(R name)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							}
						],
						"endline": 1327,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "exists",
				"line": 1322,
				"comment": " Determine whether the given file (or directory) exists.\n Params:\n    name = string or range of characters representing the file name\n Returns:\n    true if it exists\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "getAttributes",
						"line": 1402,
						"type": "uint(R name)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							}
						],
						"endline": 1440,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "getAttributes",
				"line": 1402,
				"comment": " Returns the attributes of the given file.\n\n Note that the file attributes on Windows and Posix systems are\n completely different. On Windows, they're what is returned by $(WEB\n msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx,\n GetFileAttributes), whereas on Posix systems, they're the $(LUCKY\n st_mode) value which is part of the $(D stat struct) gotten by\n calling the $(WEB en.wikipedia.org/wiki/Stat_%28Unix%29, $(D stat))\n function.\n\n On Posix systems, if the given file is a symbolic link, then\n attributes are the attributes of the file pointed to by the symbolic\n link.\n\n Params:\n name = The file to get the attributes of.\n\n Throws: $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "getLinkAttributes",
						"line": 1472,
						"type": "uint(R name)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							}
						],
						"endline": 1495,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "getLinkAttributes",
				"line": 1472,
				"comment": "    If the given file is a symbolic link, then this returns the attributes of the\n    symbolic link itself rather than file that it points to. If the given file\n    is $(I not) a symbolic link, then this function returns the same result\n    as getAttributes.\n\n    On Windows, getLinkAttributes is identical to getAttributes. It exists on\n    Windows so that you don't have to special-case code for Windows when dealing\n    with symbolic links.\n\n    Params:\n        name = The file to get the symbolic link attributes of.\n\n    Returns:\n        the attributes\n\n    Throws:\n        $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setAttributes",
						"line": 1518,
						"type": "void(R name, uint attributes)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							},
							{
								"name": "attributes",
								"deco": "k"
							}
						],
						"endline": 1549,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "setAttributes",
				"line": 1518,
				"comment": "    Set the attributes of the given file.\n\n    Params:\n        name = the file name\n        attributes = the attributes to set the file to\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isDir",
						"line": 1580,
						"type": "@property bool(R name)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							}
						],
						"endline": 1592,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "isDir",
				"line": 1580,
				"comment": "    Returns whether the given file is a directory.\n\n    Params:\n        name = The path to the file.\n\n    Returns:\n        true if the name specifies a directory\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n\nExample:\n--------------------\nassert(!\"/etc/fonts/fonts.conf\".isDir);\nassert(\"/usr/share/include\".isDir);\n--------------------\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 16,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "attrIsDir",
				"line": 1655,
				"comment": "    Returns whether the given file attributes are for a directory.\n\n    Params:\n        attributes = The file attributes.\n\n    Returns:\n        true if attibutes specifies a directory\n\nExample:\n--------------------\nassert(!attrIsDir(getAttributes(\"/etc/fonts/fonts.conf\")));\nassert(!attrIsDir(getLinkAttributes(\"/etc/fonts/fonts.conf\")));\n--------------------\n",
				"deco": "FNaNbNiNfkZb",
				"parameters": [
					{
						"name": "attributes",
						"deco": "k"
					}
				],
				"endline": 1665,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isFile",
						"line": 1730,
						"type": "@property bool(R name)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							}
						],
						"endline": 1738,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "isFile",
				"line": 1730,
				"comment": "    Returns whether the given file (or directory) is a file.\n\n    On Windows, if a file is not a directory, then it's a file. So,\n    either $(D isFile) or $(D isDir) will return true for any given file.\n\n    On Posix systems, if $(D isFile) is $(D true), that indicates that the file\n    is a regular file (e.g. not a block not device). So, on Posix systems, it's\n    possible for both $(D isFile) and $(D isDir) to be $(D false) for a\n    particular file (in which case, it's a special file). You can use\n    $(D getAttributes) to get the attributes to figure out what type of special\n    it is, or you can use $(D DirEntry) to get at its $(D statBuf), which is the\n    result from $(D stat). In either case, see the man page for $(D stat) for\n    more information.\n\n    Params:\n        name = The path to the file.\n\n    Returns:\n        true if name specifies a file\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n\nExample:\n--------------------\nassert(\"/etc/fonts/fonts.conf\".isFile);\nassert(!\"/usr/share/include\".isFile);\n--------------------\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 16,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "attrIsFile",
				"line": 1798,
				"comment": "    Returns whether the given file attributes are for a file.\n\n    On Windows, if a file is not a directory, it's a file. So, either\n    $(D attrIsFile) or $(D attrIsDir) will return $(D true) for the\n    attributes of any given file.\n\n    On Posix systems, if $(D attrIsFile) is $(D true), that indicates that the\n    file is a regular file (e.g. not a block not device). So, on Posix systems,\n    it's possible for both $(D attrIsFile) and $(D attrIsDir) to be $(D false)\n    for a particular file (in which case, it's a special file). If a file is a\n    special file, you can use the attributes to check what type of special file\n    it is (see the man page for $(D stat) for more information).\n\n    Params:\n        attributes = The file attributes.\n\n    Returns:\n        true if the given file attributes are for a file\n\nExample:\n--------------------\nassert(attrIsFile(getAttributes(\"/etc/fonts/fonts.conf\")));\nassert(attrIsFile(getLinkAttributes(\"/etc/fonts/fonts.conf\")));\n--------------------\n",
				"deco": "FNaNbNiNfkZb",
				"parameters": [
					{
						"name": "attributes",
						"deco": "k"
					}
				],
				"endline": 1808,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isSymlink",
						"line": 1858,
						"type": "@property bool(R name)",
						"parameters": [
							{
								"name": "name",
								"type": "R"
							}
						],
						"endline": 1866,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "isSymlink",
				"line": 1858,
				"comment": "    Returns whether the given file is a symbolic link.\n\n    On Windows, returns $(D true) when the file is either a symbolic link or a\n    junction point.\n\n    Params:\n        name = The path to the file.\n\n    Returns:\n        true if name is a symbolic link\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 16,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "attrIsSymlink",
				"line": 1973,
				"comment": "    Returns whether the given file attributes are for a symbolic link.\n\n    On Windows, return $(D true) when the file is either a symbolic link or a\n    junction point.\n\n    Params:\n        attributes = The file attributes.\n\n    Returns:\n        true if attributes are for a symbolic link\n\nExample:\n--------------------\ncore.sys.posix.unistd.symlink(\"/etc/fonts/fonts.conf\", \"/tmp/alink\");\n\nassert(!getAttributes(\"/tmp/alink\").isSymlink);\nassert(getLinkAttributes(\"/tmp/alink\").isSymlink);\n--------------------\n",
				"deco": "FNaNbNiNfkZb",
				"parameters": [
					{
						"name": "attributes",
						"deco": "k"
					}
				],
				"endline": 1979,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chdir",
						"line": 1986,
						"type": "void(R pathname)",
						"parameters": [
							{
								"name": "pathname",
								"type": "R"
							}
						],
						"endline": 2012,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "chdir",
				"line": 1986,
				"comment": " Change directory to $(D pathname).\n Throws: $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "mkdir",
						"line": 2031,
						"type": "void(R pathname)",
						"parameters": [
							{
								"name": "pathname",
								"type": "R"
							}
						],
						"endline": 2062,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "mkdir",
				"line": 2031,
				"comment": "Make directory $(D pathname).\n\nThrows: $(D FileException) on Posix or $(D WindowsException) on Windows\n        if an error occured.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "mkdirRecurse",
				"line": 2102,
				"comment": " Make directory and all parent directories as needed.\n\n Throws: $(D FileException) on error.\n",
				"deco": "FxAaZv",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAa"
					}
				],
				"endline": 2113,
				"originalType": "void(in char[] pathname)",
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rmdir",
						"line": 2167,
						"type": "void(R pathname)",
						"parameters": [
							{
								"name": "pathname",
								"type": "R"
							}
						],
						"endline": 2193,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "rmdir",
				"line": 2167,
				"comment": "Remove directory $(D pathname).\n\nParams:\n    pathname = Range or string specifying the directory name\n\nThrows: $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && isSomeChar!(ElementEncodingType!R) && !isConvertibleToString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "symlink",
						"line": 2223,
						"type": "@safe void(const(C1)[] original, const(C2)[] link)",
						"parameters": [
							{
								"name": "original",
								"type": "const(C1)[]"
							},
							{
								"name": "link",
								"type": "const(C2)[]"
							}
						],
						"char": 23,
						"kind": "function"
					}
				],
				"name": "symlink",
				"line": 2223,
				"comment": "    $(BLUE This function is Posix-Only.)\n\n    Creates a symlink.\n\n    Params:\n        original = The file to link from.\n        link     = The symlink to create.\n\n    Note:\n        Relative paths are relative to the current working directory,\n        not the files being linked to or from.\n\n    Throws:\n        $(D FileException) on error (which includes if the symlink already\n        exists).\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"char": 23,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "readLink",
						"line": 2289,
						"type": "@safe string(const(C)[] link)",
						"parameters": [
							{
								"name": "link",
								"type": "const(C)[]"
							}
						],
						"char": 25,
						"kind": "function"
					}
				],
				"name": "readLink",
				"line": 2289,
				"comment": "    $(BLUE This function is Posix-Only.)\n\n    Returns the path to the file pointed to by a symlink. Note that the\n    path could be either relative or absolute depending on the symlink.\n    If the path is relative, it's relative to the symlink, not the current\n    working directory.\n\n    Throws:\n        $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"char": 25,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "getcwd",
				"line": 2379,
				"comment": " Get the current working directory.\n Throws: $(D FileException) on error.\n",
				"deco": "FZAya",
				"endline": 2385,
				"char": 29,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thisExePath",
				"line": 2405,
				"comment": " Returns the full path of the current executable.\n\n Throws:\n $(XREF object, Exception)\n",
				"deco": "FNeZAya",
				"endline": 2477,
				"char": 17,
				"kind": "function"
			},
			{
				"name": "DirEntry",
				"line": 2493,
				"comment": "        Info on a file, similar to what you'd get from stat on a Posix system.\n",
				"members": [
					{
						"name": "this",
						"line": 2504,
						"comment": "            Constructs a DirEntry for the given file (or directory).\n\n            Params:\n                path = The file (or directory) to get a DirEntry for.\n\n            Throws:\n                $(D FileException) if the file does not exist.\n",
						"deco": "FNcAyaZS3std4file8DirEntry",
						"parameters": [
							{
								"name": "path",
								"deco": "Aya"
							}
						],
						"originalType": "ref (string path)",
						"char": 9,
						"kind": "constructor"
					},
					{
						"name": "name",
						"line": 2527,
						"comment": "            Returns the path to the file represented by this $(D DirEntry).\n\nExample:\n--------------------\nauto de1 = DirEntry(\"/etc/fonts/fonts.conf\");\nassert(de1.name == \"/etc/fonts/fonts.conf\");\n\nauto de2 = DirEntry(\"/usr/share/include\");\nassert(de2.name == \"/usr/share/include\");\n--------------------\n",
						"deco": "xFNdZAya",
						"char": 26,
						"kind": "function"
					},
					{
						"name": "isDir",
						"line": 2543,
						"comment": "            Returns whether the file represented by this $(D DirEntry) is a\n            directory.\n\nExample:\n--------------------\nauto de1 = DirEntry(\"/etc/fonts/fonts.conf\");\nassert(!de1.isDir);\n\nauto de2 = DirEntry(\"/usr/share/include\");\nassert(de2.isDir);\n--------------------\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "isFile",
						"line": 2569,
						"comment": "            Returns whether the file represented by this $(D DirEntry) is a file.\n\n            On Windows, if a file is not a directory, then it's a file. So,\n            either $(D isFile) or $(D isDir) will return $(D true).\n\n            On Posix systems, if $(D isFile) is $(D true), that indicates that\n            the file is a regular file (e.g. not a block not device). So, on\n            Posix systems, it's possible for both $(D isFile) and $(D isDir) to\n            be $(D false) for a particular file (in which case, it's a special\n            file). You can use $(D attributes) or $(D statBuf) to get more\n            information about a special file (see the stat man page for more\n            details).\n\nExample:\n--------------------\nauto de1 = DirEntry(\"/etc/fonts/fonts.conf\");\nassert(de1.isFile);\n\nauto de2 = DirEntry(\"/usr/share/include\");\nassert(!de2.isFile);\n--------------------\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "isSymlink",
						"line": 2578,
						"comment": "            Returns whether the file represented by this $(D DirEntry) is a\n            symbolic link.\n\n            On Windows, return $(D true) when the file is either a symbolic\n            link or a junction point.\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "size",
						"line": 2584,
						"comment": "            Returns the size of the the file represented by this $(D DirEntry)\n            in bytes.\n",
						"deco": "FNdZm",
						"char": 25,
						"kind": "function"
					},
					{
						"name": "timeCreated",
						"line": 2592,
						"comment": "            $(BLUE This function is Windows-Only.)\n\n            Returns the creation time of the file represented by this\n            $(D DirEntry).\n",
						"deco": "xFNdZS3std8datetime7SysTime",
						"char": 27,
						"kind": "function"
					},
					{
						"name": "timeLastAccessed",
						"line": 2603,
						"comment": "            Returns the time that the file represented by this $(D DirEntry) was\n            last accessed.\n\n            Note that many file systems do not update the access time for files\n            (generally for performance reasons), so there's a good chance that\n            $(D timeLastAccessed) will return the same value as\n            $(D timeLastModified).\n",
						"deco": "FNdZS3std8datetime7SysTime",
						"char": 27,
						"kind": "function"
					},
					{
						"name": "timeLastModified",
						"line": 2609,
						"comment": "            Returns the time that the file represented by this $(D DirEntry) was\n            last modified.\n",
						"deco": "FNdZS3std8datetime7SysTime",
						"char": 27,
						"kind": "function"
					},
					{
						"name": "attributes",
						"line": 2625,
						"comment": "            Returns the attributes of the file represented by this $(D DirEntry).\n\n            Note that the file attributes on Windows and Posix systems are\n            completely different. On, Windows, they're what is returned by\n            $(D GetFileAttributes)\n            $(WEB msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx, GetFileAttributes)\n            Whereas, an Posix systems, they're the $(D st_mode) value which is\n            part of the $(D stat) struct gotten by calling $(D stat).\n\n            On Posix systems, if the file represented by this $(D DirEntry) is a\n            symbolic link, then attributes are the attributes of the file\n            pointed to by the symbolic link.\n",
						"deco": "FNdZk",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "linkAttributes",
						"line": 2637,
						"comment": "            On Posix systems, if the file represented by this $(D DirEntry) is a\n            symbolic link, then $(D linkAttributes) are the attributes of the\n            symbolic link itself. Otherwise, $(D linkAttributes) is identical to\n            $(D attributes).\n\n            On Windows, $(D linkAttributes) is identical to $(D attributes). It\n            exists on Windows so that you don't have to special-case code for\n            Windows when dealing with symbolic links.\n",
						"deco": "FNdZk",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "statBuf",
						"line": 2647,
						"comment": "            $(BLUE This function is Posix-Only.)\n\n            The $(D stat) struct gotten from calling $(D stat).\n",
						"deco": "FNdZS4core3sys5posix3sys4stat6stat_t",
						"char": 26,
						"kind": "function"
					}
				],
				"char": 5,
				"kind": "struct"
			},
			{
				"name": "preserveAttributesDefault",
				"line": 3041,
				"comment": "Defaults to PreserveAttributes.yes on Windows, and the opposite on all other platforms.\n",
				"deco": "E3std8typecons53__T4FlagVAyaa18_707265736572766541747472696275746573Z4Flag",
				"originalType": "PreserveAttributes",
				"char": 24,
				"kind": "variable"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "copy",
						"line": 3065,
						"type": "void(RF from, RT to, PreserveAttributes preserve = preserveAttributesDefault)",
						"parameters": [
							{
								"name": "from",
								"type": "RF"
							},
							{
								"name": "to",
								"type": "RT"
							},
							{
								"name": "preserve",
								"type": "PreserveAttributes",
								"default": "preserveAttributesDefault"
							}
						],
						"endline": 3084,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "copy",
				"line": 3065,
				"comment": "Copy file $(D from) to file $(D to). File timestamps are preserved.\nFile attributes are preserved, if $(D preserve) equals $(D PreserveAttributes.yes).\nOn Windows only $(D PreserveAttributes.yes) (the default on Windows) is supported.\nIf the target file exists, it is overwritten.\n\nParams:\n    from = string or range of characters representing the existing file name\n    to = string or range of characters representing the target file name\n    preserve = whether to preserve the file attributes\n\nThrows: $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "RF",
						"kind": "type"
					},
					{
						"name": "RT",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RF && isSomeChar!(ElementEncodingType!RF) && !isConvertibleToString!RF && isInputRange!RT && isSomeChar!(ElementEncodingType!RT) && !isConvertibleToString!RT",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "rmdirRecurse",
				"line": 3211,
				"comment": "    Remove directory and all of its content and subdirectories,\n    recursively.\n\n    Throws:\n        $(D FileException) if there is an error (including if the given\n        file is not a directory).\n",
				"deco": "FxAaZv",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAa"
					}
				],
				"endline": 3216,
				"originalType": "void(in char[] pathname)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "rmdirRecurse",
				"line": 3226,
				"comment": "    Remove directory and all of its content and subdirectories,\n    recursively.\n\n    Throws:\n        $(D FileException) if there is an error (including if the given\n        file is not a directory).\n",
				"deco": "FKS3std4file8DirEntryZv",
				"parameters": [
					{
						"name": "de",
						"storageClass": [
							"ref"
						],
						"deco": "S3std4file8DirEntry"
					}
				],
				"endline": 3249,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "rmdirRecurse",
				"line": 3256,
				"comment": "ditto\n",
				"deco": "FS3std4file8DirEntryZv",
				"parameters": [
					{
						"name": "de",
						"deco": "S3std4file8DirEntry"
					}
				],
				"endline": 3259,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "shallow",
						"line": 3320,
						"value": "0",
						"comment": " Only spans one directory.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "depth",
						"line": 3324,
						"value": "1",
						"comment": " Spans the directory depth-first, i.e. the content of any\n     subdirectory is spanned before that subdirectory itself. Useful\n     e.g. when recursively deleting files.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "breadth",
						"line": 3327,
						"value": "2",
						"comment": " Spans the directory breadth-first, i.e. the content of any\n     subdirectory is spanned right after that subdirectory itself.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SpanMode",
				"line": 3317,
				"comment": " Dictates directory spanning policy for $(D_PARAM dirEntries) (see below).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"endchar": 1,
				"name": "dirEntries",
				"line": 3614,
				"comment": "    Returns an input range of DirEntry that lazily iterates a given directory,\n    also provides two ways of foreach iteration. The iteration variable can be of\n    type $(D_PARAM string) if only the name is needed, or $(D_PARAM DirEntry)\n    if additional details are needed. The span mode dictates the how the\n    directory is traversed. The name of the each directory entry iterated\n    contains the absolute path.\n\n    Params:\n        path = The directory to iterate over.\n               If empty, the current directory will be iterated.\n        mode = Whether the directory's sub-directories should be iterated\n               over depth-first ($(D_PARAM depth)), breadth-first\n               ($(D_PARAM breadth)), or not at all ($(D_PARAM shallow)).\n        followSymlink = Whether symbolic links which point to directories\n                         should be treated as directories and their contents\n                         iterated over.\n\n    Throws:\n        $(D FileException) if the directory does not exist.\n\nExample:\n--------------------\n// Iterate a directory in depth\nforeach (string name; dirEntries(\"destroy/me\", SpanMode.depth))\n{\n remove(name);\n}\n// Iterate the current directory in breadth\nforeach (string name; dirEntries(\"\", SpanMode.breadth))\n{\n writeln(name);\n}\n// Iterate a directory and get detailed info about it\nforeach (DirEntry e; dirEntries(\"dmd-testing\", SpanMode.breadth))\n{\n writeln(e.name, \"\\t\", e.size);\n}\n// Iterate over all *.d files in current directory and all its subdirectories\nauto dFiles = dirEntries(\"\", SpanMode.depth).filter!(f => f.name.endsWith(\".d\"));\nforeach(d; dFiles)\n    writeln(d.name);\n// Hook it up with std.parallelism to compile them all in parallel:\nforeach(d; parallel(dFiles, 1)) //passes by 1 file to each thread\n{\n    string cmd = \"dmd -c \"  ~ d.name;\n    writeln(cmd);\n    std.process.system(cmd);\n}\n--------------------\nExample:\nDuplicate functionality of D1's $(D std.file.listdir()):$(DDOX_UNITTEST_HEADER __unittestL3620_1612)\n---\nstring[] listdir(string pathname)\n{\n    import std.file;\n    import std.path;\n    import std.algorithm;\n    import std.array;\n\n    return std.file.dirEntries(pathname, SpanMode.shallow)\n        .filter!(a => a.isFile)\n        .map!(a => std.path.baseName(a.name))\n        .array;\n}\n\nvoid main(string[] args)\n{\n    import std.stdio;\n\n    string[] files = listdir(args[1]);\n    writefln(\"%s\", files);\n }\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3620_1612)\n",
				"deco": "FAyaE3std4file8SpanModebZS3std4file11DirIterator",
				"parameters": [
					{
						"name": "path",
						"deco": "Aya"
					},
					{
						"name": "mode",
						"deco": "E3std4file8SpanMode"
					},
					{
						"name": "followSymlink",
						"deco": "b",
						"default": "true"
					}
				],
				"endline": 3617,
				"originalType": "(string path, SpanMode mode, bool followSymlink = true)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"endchar": 1,
				"name": "dirEntries",
				"line": 3734,
				"comment": "    Convenience wrapper for filtering file names with a glob pattern.\n\n    Params:\n        path = The directory to iterate over.\n        pattern  = String with wildcards, such as $(RED \"*.d\"). The supported\n                   wildcard strings are described under\n                   $(XREF _path, globMatch).\n        mode = Whether the directory's sub-directories should be iterated\n               over depth-first ($(D_PARAM depth)), breadth-first\n               ($(D_PARAM breadth)), or not at all ($(D_PARAM shallow)).\n        followSymlink = Whether symbolic links which point to directories\n                         should be treated as directories and their contents\n                         iterated over.\n\n    Throws:\n        $(D FileException) if the directory does not exist.\n\nExample:\n--------------------\n// Iterate over all D source files in current directory and all its\n// subdirectories\nauto dFiles = dirEntries(\"\",\"*.{d,di}\",SpanMode.depth);\nforeach(d; dFiles)\n    writeln(d.name);\n--------------------\n",
				"deco": "FAyaAyaE3std4file8SpanModebZS3std9algorithm9iteration121__T12FilterResultS76_D3std4file10dirEntriesFAyaAyaE3std4file8SpanModebZ1fMFS3std4file8DirEntryZbTS3std4file11DirIteratorZ12FilterResult",
				"parameters": [
					{
						"name": "path",
						"deco": "Aya"
					},
					{
						"name": "pattern",
						"deco": "Aya"
					},
					{
						"name": "mode",
						"deco": "E3std4file8SpanMode"
					},
					{
						"name": "followSymlink",
						"deco": "b",
						"default": "true"
					}
				],
				"endline": 3740,
				"originalType": "(string path, string pattern, SpanMode mode, bool followSymlink = true)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "slurp",
						"line": 3823,
						"type": "Select!(Types.length == 1, Types[0][], Tuple!Types[])(string filename, in char[] format)",
						"parameters": [
							{
								"name": "filename",
								"type": "string"
							},
							{
								"name": "format",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 3842,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "slurp",
				"line": 3823,
				"comment": "Reads an entire file into an array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3845_1617)\n---\nscope(exit)\n{\n    assert(exists(\"someUniqueFilename\"));\n    remove(\"someUniqueFilename\");\n}\n\nwrite(\"someUniqueFilename\", \"12 12.25\\n345 1.125\");\n\n// Load file; each line is an int followed by comma, whitespace and a\n// double.\nauto a = slurp!(int, double)(\"someUniqueFilename\", \"%s %s\");\nassert(a.length == 2);\nassert(a[0] == tuple(12, 12.25));\nassert(a[1] == tuple(345, 1.125));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3845_1617)\n",
				"parameters": [
					{
						"name": "Types",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "tempDir",
				"line": 3893,
				"comment": "Returns the path to a directory for temporary files.\n\nOn Windows, this function returns the result of calling the Windows API function\n$(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/aa364992.aspx, $(D GetTempPath)).\n\nOn POSIX platforms, it searches through the following list of directories\nand returns the first one which is found to exist:\n$(OL\n    $(LI The directory given by the $(D TMPDIR) environment variable.)\n    $(LI The directory given by the $(D TEMP) environment variable.)\n    $(LI The directory given by the $(D TMP) environment variable.)\n    $(LI $(D /tmp))\n    $(LI $(D /var/tmp))\n    $(LI $(D /usr/tmp))\n)\n\nOn all platforms, $(D tempDir) returns $(D \".\") on failure, representing\nthe current working directory.\n\nThe return value of the function is cached, so the procedures described\nabove will only be performed the first time the function is called.  All\nsubsequent runs will return the same string, regardless of whether\nenvironment variables and directory structures have changed in the\nmeantime.\n\nThe POSIX $(D tempDir) algorithm is inspired by Python's\n$(LINK2 http://docs.python.org/library/tempfile.html#tempfile.tempdir, $(D tempfile.tempdir)).\n",
				"deco": "FNeZAya",
				"endline": 3930,
				"char": 8,
				"kind": "function"
			}
		],
		"comment": "Utilities for manipulating files and scanning directories. Functions\nin this module handle files as a unit, e.g., read or write one _file\nat a time. For opening files and manipulating them via handles refer\nto module $(LINK2 std_stdio.html,$(D std.stdio)).\n\nMacros:\nWIKI = Phobos/StdFile\n\nCopyright: Copyright Digital Mars 2007 - 2011.\nSee_Also:  The $(WEB ddili.org/ders/d.en/files.html, official tutorial) for an\nintroduction to working with files in D, module\n$(LINK2 std_stdio.html,$(D std.stdio)) for opening files and manipulating them\nvia handles, and module $(LINK2 std_path.html,$(D std.path)) for manipulating\npath strings.\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Jonathan M Davis\nSource:    $(PHOBOSSRC std/_file.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/bigint.d",
		"name": "std.bigint",
		"members": [
			{
				"name": "BigInt",
				"line": 43,
				"comment": " A struct representing an arbitrary precision integer.\n\n All arithmetic operations are supported, except unsigned shift right (>>>).\n Bitwise operations (|, &, ^, ~) are supported, and behave as if BigInt was\n an infinite length 2's complement number.\n\n BigInt implements value semantics using copy-on-write. This means that\n assignment is cheap, but operations such as x++ will cause heap\n allocation. (But note that for most bigint operations, heap allocation is\n inevitable anyway.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL916_1639)\n---\nBigInt a = \"9588669891916142\";\nBigInt b = \"7452469135154800\";\nauto c = a * b;\nassert(c == BigInt(\"71459266416693160362545788781600\"));\nauto d = b * a;\nassert(d == BigInt(\"71459266416693160362545788781600\"));\nassert(d == c);\nd = c * BigInt(\"794628672112\");\nassert(d == BigInt(\"56783581982794522489042432639320434378739200\"));\nauto e = c + d;\nassert(e == BigInt(\"56783581982865981755459125799682980167520800\"));\nauto f = d + c;\nassert(f == e);\nauto g = f - c;\nassert(g == d);\ng = f - d;\nassert(g == c);\ne = 12345678;\ng = c + e;\nauto h = g / b;\nauto i = g % b;\nassert(h == a);\nassert(i == e);\nBigInt j = \"-0x9A56_57f4_7B83_AB78\";\nj ^^= 11;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL916_1639)\n",
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 54,
								"type": "pure (T s)",
								"parameters": [
									{
										"name": "s",
										"type": "T"
									}
								],
								"endline": 78,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 54,
						"comment": "Construct a BigInt from a decimal or hexadecimal string.\n\nThe number must be in the form of a D decimal or hex literal:\n\nIt may have a leading + or - sign; followed by \"0x\" if hexadecimal.\n\nUnderscores are permitted.\n\nBUG: Should throw a IllegalArgumentException/ConvError if invalid character found\n",
						"parameters": [
							{
								"name": "T",
								"deco": "Axa",
								"kind": "type"
							}
						],
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 81,
								"type": "pure nothrow (T x)",
								"parameters": [
									{
										"name": "x",
										"type": "T"
									}
								],
								"endline": 85,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 81,
						"comment": "Construct a BigInt from a built-in integral type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL88_1618)\n---\nulong data = 1_000_000_000_000;\nauto bigData = BigInt(data);\nassert(data == BigInt(\"1_000_000_000_000\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL88_1618)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isIntegral!T",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 96,
								"type": "pure nothrow (T x)",
								"parameters": [
									{
										"name": "x",
										"type": "T"
									}
								],
								"endline": 99,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 96,
						"comment": "Construct a BigInt from another BigInt.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL102_1619)\n---\nconst(BigInt) b1 = BigInt(\"1_234_567_890\");\nBigInt b2 = BigInt(b1);\nassert(b2 == BigInt(\"1_234_567_890\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL102_1619)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!T == BigInt)",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 110,
								"type": "pure nothrow BigInt(T x)",
								"parameters": [
									{
										"name": "x",
										"type": "T"
									}
								],
								"endline": 115,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opAssign",
						"line": 110,
						"comment": "Assignment from built-in integer types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL118_1620)\n---\nauto b = BigInt(\"123\");\nb = 456;\nassert(b == BigInt(\"456\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL118_1620)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isIntegral!T",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 126,
								"type": "pure @nogc BigInt(T x)",
								"parameters": [
									{
										"name": "x",
										"type": "T"
									}
								],
								"endline": 131,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opAssign",
						"line": 126,
						"comment": "Assignment from another BigInt.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL134_1621)\n---\nauto b1 = BigInt(\"123\");\nauto b2 = BigInt(\"456\");\nb2 = b1;\nassert(b2 == BigInt(\"123\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL134_1621)\n",
						"parameters": [
							{
								"name": "T",
								"deco": "S3std6bigint6BigInt",
								"kind": "type"
							}
						],
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 146,
								"type": "pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 228,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 146,
						"comment": " Implements assignment operators from built-in integers of the form\n $(D BigInt op= integer).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL231_1622)\n---\nauto b = BigInt(\"1_000_000_000\");\n\nb += 12345;\nassert(b == BigInt(\"1_000_012_345\"));\n\nb /= 5;\nassert(b == BigInt(\"200_002_469\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL231_1622)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\" || op == \"*\" || op == \"/\" || op == \"%\" || op == \">>\" || op == \"<<\" || op == \"^^\" || op == \"|\" || op == \"&\" || op == \"^\") && isIntegral!T",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 245,
								"type": "pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 289,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 245,
						"comment": " Implements assignment operators of the form $(D BigInt op= BigInt).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL292_1623)\n---\nauto x = BigInt(\"123\");\nauto y = BigInt(\"321\");\nx += y;\nassert(x == BigInt(\"444\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL292_1623)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\" || op == \"*\" || op == \"|\" || op == \"&\" || op == \"^\" || op == \"/\" || op == \"%\") && is(T : BigInt)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 303,
								"type": "const pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 310,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 303,
						"comment": " Implements binary operators between BigInts.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL313_1624)\n---\nauto x = BigInt(\"123\");\nauto y = BigInt(\"456\");\nBigInt z = x * y;\nassert(z == BigInt(\"56088\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL313_1624)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"*\" || op == \"-\" || op == \"|\" || op == \"&\" || op == \"^\" || op == \"/\" || op == \"%\") && is(T : BigInt)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 324,
								"type": "const pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 331,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 324,
						"comment": " Implements binary operators between BigInt's and built-in integers.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL334_1625)\n---\nauto x = BigInt(\"123\");\nx *= 300;\nassert(x == BigInt(\"36900\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL334_1625)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"*\" || op == \"-\" || op == \"/\" || op == \"|\" || op == \"&\" || op == \"^\" || op == \">>\" || op == \"<<\" || op == \"^^\") && isIntegral!T",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 353,
								"type": "const pure nothrow (T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 383,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "opBinary",
						"line": 353,
						"comment": "        Implements a narrowing remainder operation with built-in integer types.\n\n        This binary operator returns a narrower, built-in integer type\n        where applicable, according to the following table.\n\n        $(TABLE ,\n        $(TR $(TD `BigInt`) $(TD $(CODE_PERCENT)) $(TD `long`) $(TD $(RARR)) $(TD `long`))\n        $(TR $(TD `BigInt`) $(TD $(CODE_PERCENT)) $(TD `ulong`) $(TD $(RARR)) $(TD `BigInt`))\n        $(TR $(TD `BigInt`) $(TD $(CODE_PERCENT)) $(TD other type) $(TD $(RARR)) $(TD `int`))\n        )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL386_1626)\n---\nauto  x  = BigInt(\"1_000_000_500\");\nlong  l  = 1_000_000L;\nulong ul = 2_000_000UL;\nint   i  = 500_000;\nshort s  = 30_000;\n\nassert(is(typeof(x % l)  == long)   && x % l  == 500L);\nassert(is(typeof(x % ul) == BigInt) && x % ul == BigInt(500));\nassert(is(typeof(x % i)  == int)    && x % i  == 500);\nassert(is(typeof(x % s)  == int)    && x % s  == 10500);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL386_1626)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"%\" && isIntegral!T",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 404,
								"type": "const pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 408,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opBinaryRight",
						"line": 404,
						"comment": "        Implements operators with built-in integers on the left-hand side and\n        BigInt on the right-hand side.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL411_1627)\n---\nauto x = BigInt(\"100\");\nBigInt y = 123 + x;\nassert(y == BigInt(\"223\"));\n\nBigInt z = 123 - x;\nassert(z == BigInt(\"23\"));\n\n// Dividing a built-in integer type by BigInt always results in\n// something that fits in a built-in type, so the built-in type is\n// returned, not BigInt.\nassert(is(typeof(1000 / x) == int));\nassert(1000 / x == 10);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL411_1627)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"*\" || op == \"|\" || op == \"&\" || op == \"^\") && isIntegral!T",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 429,
								"type": "const pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 441,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opBinaryRight",
						"line": 429,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"-\" && isIntegral!T",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 445,
								"type": "const pure nothrow T(T x)",
								"parameters": [
									{
										"name": "x",
										"type": "T"
									}
								],
								"endline": 466,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "opBinaryRight",
						"line": 445,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"%\" || op == \"/\") && isIntegral!T",
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 472,
								"type": "const pure nothrow BigInt()",
								"endline": 486,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 472,
						"comment": "        Implements BigInt unary operators.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL505_1628)\n---\nauto x = BigInt(\"1234\");\nassert(-x == BigInt(\"-1234\"));\n\n++x;\nassert(x == BigInt(\"1235\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL505_1628)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\" || op == \"~\"",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 490,
								"type": "pure nothrow BigInt()",
								"endline": 502,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 490,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"++\" || op == \"--\"",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 518,
								"type": "const pure @nogc bool(auto ref const BigInt y)",
								"parameters": [
									{
										"name": "y",
										"type": "BigInt",
										"storageClass": [
											"auto",
											"const",
											"ref"
										]
									}
								],
								"endline": 521,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opEquals",
						"line": 518,
						"comment": "        Implements BigInt equality test with other BigInt's and built-in\n        integer types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL532_1629)\n---\nauto x = BigInt(\"12345\");\nauto y = BigInt(\"12340\");\nint z = 12345;\nint w = 54321;\n\nassert(x == x);\nassert(x != y);\nassert(x == y + 5);\nassert(x == z);\nassert(x != w);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL532_1629)\n",
						"parameters": [],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 524,
								"type": "const pure nothrow @nogc bool(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 529,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opEquals",
						"line": 524,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isIntegral!T",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 549,
								"type": "const pure nothrow @nogc T()",
								"endline": 552,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 549,
						"comment": "        Implements casting to bool.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL555_1630)\n---\n// Non-zero values are regarded as true\nauto x = BigInt(\"1\");\nauto y = BigInt(\"10\");\nassert(x);\nassert(y);\n\n// Zero value is regarded as false\nauto z = BigInt(\"0\");\nassert(!z);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL555_1630)\n",
						"parameters": [
							{
								"name": "T",
								"deco": "b",
								"kind": "type"
							}
						],
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 574,
								"type": "const T()",
								"endline": 599,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 574,
						"comment": "        Implements casting to integer types.\n\n        Throws: $(XREF conv,ConvOverflowException) if the number exceeds\n        the target type's range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL602_1631)\n---\nimport std.conv : to, ConvOverflowException;\nimport std.exception : assertThrown;\n\nassert(BigInt(\"0\").to!int == 0);\n\nassert(BigInt(\"0\").to!ubyte == 0);\nassert(BigInt(\"255\").to!ubyte == 255);\nassertThrown!ConvOverflowException(BigInt(\"256\").to!ubyte);\nassertThrown!ConvOverflowException(BigInt(\"-1\").to!ubyte);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL602_1631)\n",
						"parameters": [
							{
								"name": "T",
								"deco": "m",
								"kind": "type"
							}
						],
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 655,
								"type": "const pure nothrow @nogc T()",
								"endline": 657,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 655,
						"comment": "        Implements casting to/from qualified BigInt's.\n\n        Warning: Casting to/from $(D const) or $(D immutable) may break type\n        system guarantees. Use with care.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL660_1633)\n---\nconst(BigInt) x = BigInt(\"123\");\nBigInt y = cast() x;    // cast away const\nassert(y == x);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL660_1633)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!T == BigInt)",
						"char": 7,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 674,
						"comment": "        Implements 3-way comparisons of BigInt with BigInt or BigInt with\n        built-in integers.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL698_1634)\n---\nauto x = BigInt(\"100\");\nauto y = BigInt(\"10\");\nint z = 50;\nconst int w = 200;\n\nassert(y < x);\nassert(x > z);\nassert(z > y);\nassert(x < w);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL698_1634)\n",
						"deco": "xFNaNbNiKxS3std6bigint6BigIntZi",
						"parameters": [
							{
								"name": "y",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std6bigint6BigInt"
							}
						],
						"endline": 678,
						"originalType": "const pure nothrow @nogc int(ref const BigInt y)",
						"char": 9,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCmp",
								"line": 681,
								"type": "const pure nothrow @nogc int(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 687,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "opCmp",
						"line": 681,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isIntegral!T",
						"char": 9,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCmp",
								"line": 689,
								"type": "const pure nothrow @nogc int(const T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T",
										"storageClass": [
											"const"
										]
									}
								],
								"endline": 695,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "opCmp",
						"line": 689,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "T",
								"deco": "S3std6bigint6BigInt",
								"kind": "type"
							}
						],
						"char": 9,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "toLong",
						"line": 715,
						"comment": "        Returns: The value of this BigInt as a long, or +/- long.max if outside\n        the representable range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL724_1635)\n---\nauto b = BigInt(\"12345\");\nlong l = b.toLong();\nassert(l == 12345);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL724_1635)\n",
						"deco": "xFNaNbNiNfZl",
						"endline": 721,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toInt",
						"line": 735,
						"comment": "        Returns: The value of this BigInt as an int, or +/- int.max if outside\n        the representable range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL744_1636)\n---\nauto big = BigInt(\"5_000_000\");\nauto i = big.toInt();\nassert(i == 5_000_000);\n\n// Numbers that are too big to fit into an int will be clamped to int.max.\nauto tooBig = BigInt(\"5_000_000_000\");\ni = tooBig.toInt();\nassert(i == int.max);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL744_1636)\n",
						"deco": "xFNaNbNiNfZi",
						"endline": 741,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "uintLength",
						"line": 758,
						"comment": "Number of significant uints which are used in storing this number.\n\nThe absolute value of this BigInt is always &lt; 2$(SUPERSCRIPT 32*uintLength)\n",
						"deco": "xFNaNbNdNiNfZm",
						"endline": 761,
						"originalType": "const pure nothrow @nogc @property @safe size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "ulongLength",
						"line": 765,
						"comment": "Number of significant ulongs which are used in storing this number.\n\nThe absolute value of this BigInt is always &lt; 2$(SUPERSCRIPT 64*ulongLength)\n",
						"deco": "xFNaNbNdNiNfZm",
						"endline": 768,
						"originalType": "const pure nothrow @nogc @property @safe size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 785,
						"comment": " Convert the BigInt to string, passing it to the given sink.\n\n Params:\n  sink = A delegate for accepting possibly piecewise segments of the\n      formatted string.\n  formatString = A format string specifying the output format.\n\n $(TABLE  Available output formats:,\n $(TR $(TD \"d\") $(TD  Decimal))\n $(TR $(TD \"x\") $(TD  Hexadecimal, lower case))\n $(TR $(TD \"X\") $(TD  Hexadecimal, upper case))\n $(TR $(TD \"s\") $(TD  Default formatting (same as \"d\") ))\n $(TR $(TD null) $(TD Default formatting (same as \"d\") ))\n )\nExample:\n$(D toString) is rarely directly invoked; the usual way of using it is via\n        $(LINK2 std_format.html#format, std.format.format):$(DDOX_UNITTEST_HEADER __unittestL856_1637)\n---\nimport std.format : format;\n\nauto x = BigInt(\"1_000_000\");\nx *= 12345;\n\nassert(format(\"%d\", x) == \"12345000000\");\nassert(format(\"%x\", x) == \"2_dfd1c040\");\nassert(format(\"%X\", x) == \"2_DFD1C040\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL856_1637)\n",
						"deco": "xFMDFAxaZvAyaZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFAxaZv"
							},
							{
								"name": "formatString",
								"deco": "Aya"
							}
						],
						"endline": 790,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 793,
						"comment": "ditto\n",
						"deco": "xFMDFAxaZvKS3std6format18__T10FormatSpecTaZ10FormatSpecZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFAxaZv"
							},
							{
								"name": "f",
								"storageClass": [
									"ref"
								],
								"deco": "S3std6format18__T10FormatSpecTaZ10FormatSpec"
							}
						],
						"endline": 850,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toHash",
						"line": 873,
						"comment": "        Returns: A unique hash of the BigInt's value suitable for use in a hash\n        table.\nExample:\n$(D toHash) is rarely directly invoked; it is implicitly used when\n        BigInt is used as the key of an associative array.$(DDOX_UNITTEST_HEADER __unittestL882_1638)\n---\nstring[BigInt] aa;\naa[BigInt(123)] = \"abc\";\naa[BigInt(456)] = \"def\";\n\nassert(aa[BigInt(123)] == \"abc\");\nassert(aa[BigInt(456)] == \"def\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL882_1638)\n",
						"deco": "xFNbNfZm",
						"endline": 876,
						"originalType": "const nothrow @safe size_t()",
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "toDecimalString",
				"line": 953,
				"comment": "Params:\n    x = The $(D BigInt) to convert to a decimal $(D string).\n\nReturns:\n    A $(D string) that represents the $(D BigInt) as a decimal number.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL962_1640)\n---\nauto x = BigInt(\"123\");\nx *= 1000;\nx += 456;\n\nauto xstr = x.toDecimalString();\nassert(xstr == \"123456\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL962_1640)\n",
				"deco": "FxS3std6bigint6BigIntZAya",
				"parameters": [
					{
						"name": "x",
						"deco": "xS3std6bigint6BigInt"
					}
				],
				"endline": 959,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toHex",
				"line": 981,
				"comment": "Params:\n    x = The $(D BigInt) to convert to a hexadecimal $(D string).\n\nReturns:\n    A $(D string) that represents the $(D BigInt) as a hexadecimal (base 16)\n    number in upper case.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL990_1641)\n---\nauto x = BigInt(\"123\");\nx *= 1000;\nx += 456;\n\nauto xstr = x.toHex();\nassert(xstr == \"1E240\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL990_1641)\n",
				"deco": "FxS3std6bigint6BigIntZAya",
				"parameters": [
					{
						"name": "x",
						"deco": "xS3std6bigint6BigInt"
					}
				],
				"endline": 987,
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "absUnsign",
						"line": 1010,
						"type": "Unsigned!T(T x)",
						"parameters": [
							{
								"name": "x",
								"type": "T"
							}
						],
						"endline": 1025,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "absUnsign",
				"line": 1010,
				"comment": " Returns the absolute value of x converted to the corresponding unsigned\ntype.\n\nParams:\n    x = The integral value to return the absolute value of.\n\nReturns:\n    The absolute value of x.\n\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!T",
				"char": 12,
				"kind": "template"
			}
		],
		"comment": " Arbitrary-precision ('bignum') arithmetic.\n\n Performance is optimized for numbers below ~1000 decimal digits.\n For X86 machines, highly optimised assembly routines are used.\n\n The following algorithms are currently implemented:\n $(UL\n $(LI Karatsuba multiplication)\n $(LI Squaring is optimized independently of multiplication)\n $(LI Divide-and-conquer division)\n $(LI Binary exponentiation)\n )\n\n For very large numbers, consider using the $(WEB gmplib.org, GMP library) instead.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Don Clugston\n Source: $(PHOBOSSRC std/_bigint.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/regex/package.d",
		"name": "std.regex",
		"members": [
			{
				"members": [
					{
						"name": "Regex",
						"line": 289,
						"type": "std.regex.internal.ir.Regex!Char",
						"char": 8,
						"kind": "alias"
					}
				],
				"name": "Regex",
				"line": 289,
				"comment": "    $(D Regex) object holds regular expression pattern in compiled form.\n\n    Instances of this object are constructed via calls to $(D regex).\n    This is an intended form for caching and storage of frequently\n    used regular expressions.\n\n    Example:\n\n    Test if this object doesn't contain any compiled pattern.\n    ---\n    Regex!char r;\n    assert(r.empty);\n    r = regex(\"\"); // Note: \"\" is a valid regex pattern.\n    assert(!r.empty);\n    ---\n\n    Getting a range of all the named captures in the regex.\n    ----\n    import std.range;\n    import std.algorithm;\n\n    auto re = regex(`(?P<name>\\w+) = (?P<var>\\d+)`);\n    auto nc = re.namedCaptures;\n    static assert(isRandomAccessRange!(typeof(nc)));\n    assert(!nc.empty);\n    assert(nc.length == 2);\n    assert(nc.equal([\"name\", \"var\"]));\n    assert(nc[0] == \"name\");\n    assert(nc[1..$].equal([\"var\"]));\n    ----\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "StaticRegex",
						"line": 298,
						"type": "std.regex.internal.ir.StaticRegex!Char",
						"char": 8,
						"kind": "alias"
					}
				],
				"name": "StaticRegex",
				"line": 298,
				"comment": "    A $(D StaticRegex) is $(D Regex) object that contains D code specially\n    generated at compile-time to speed up matching.\n\n    Implicitly convertible to normal $(D Regex),\n    however doing so will result in losing this additional capability.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "regex",
						"line": 311,
						"type": "@trusted (S pattern, const(char)[] flags = \"\")",
						"parameters": [
							{
								"name": "pattern",
								"type": "S"
							},
							{
								"name": "flags",
								"type": "const(char)[]",
								"default": "\"\""
							}
						],
						"endline": 319,
						"char": 22,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "regex",
				"line": 311,
				"comment": "    Compile regular expression pattern for the later execution.\n    Returns: $(D Regex) object that works on inputs having\n    the same character width as $(D pattern).\n\n    Params:\n    pattern = Regular expression\n    flags = The _attributes (g, i, m and x accepted)\n\n    Throws: $(D RegexException) if there were any errors during compilation.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ctRegex",
						"line": 356,
						"init": "ctRegexImpl!(pattern, flags).nr",
						"char": 13,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "ctRegex",
				"line": 356,
				"comment": "    Compile regular expression using CTFE\n    and generate optimized native machine code for matching it.\n\n    Returns: StaticRegex object for faster matching.\n\n    Params:\n    pattern = Regular expression\n    flags = The _attributes (g, i, m and x accepted)\n",
				"parameters": [
					{
						"name": "pattern",
						"kind": "alias"
					},
					{
						"name": "flags",
						"defaultAlias": "[]",
						"kind": "alias"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Captures",
						"line": 368,
						"members": [
							{
								"endchar": 5,
								"name": "pre",
								"line": 420,
								"comment": "Slice of input prior to the match.\n",
								"type": "@property R()",
								"endline": 423,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "post",
								"line": 426,
								"comment": "Slice of input immediately after the match.\n",
								"type": "@property R()",
								"endline": 429,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "hit",
								"line": 432,
								"comment": "Slice of matched portion of input.\n",
								"type": "@property R()",
								"endline": 436,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 439,
								"comment": "Range interface.\n",
								"type": "@property R()",
								"endline": 443,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 446,
								"comment": "ditto\n",
								"type": "@property R()",
								"endline": 450,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 453,
								"comment": "ditto\n",
								"type": "void()",
								"endline": 457,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popBack",
								"line": 460,
								"comment": "ditto\n",
								"type": "void()",
								"endline": 464,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 63,
								"name": "empty",
								"line": 467,
								"comment": "ditto\n",
								"type": "const @property bool()",
								"endline": 467,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndex",
										"line": 470,
										"type": "R(size_t i)",
										"parameters": [
											{
												"name": "i",
												"type": "size_t"
											}
										],
										"endline": 476,
										"char": 7,
										"kind": "function"
									}
								],
								"name": "opIndex",
								"line": 470,
								"comment": "ditto\n",
								"parameters": [],
								"char": 7,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 64,
										"name": "opCast",
										"line": 489,
										"type": "const nothrow @safe bool()",
										"endline": 489,
										"char": 16,
										"kind": "function"
									}
								],
								"name": "opCast",
								"line": 489,
								"comment": "        Explicit cast to bool.\n        Useful as a shorthand for !(x.empty) in if and assert statements.\n\n        ---\n        import std.regex;\n\n        assert(!matchFirst(\"nothing\", \"something\"));\n        ---\n",
								"parameters": [
									{
										"name": "T",
										"deco": "b",
										"kind": "type"
									}
								],
								"char": 16,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndex",
										"line": 507,
										"type": "R(String i)",
										"parameters": [
											{
												"name": "i",
												"type": "String"
											}
										],
										"endline": 512,
										"char": 7,
										"kind": "function"
									}
								],
								"name": "opIndex",
								"line": 507,
								"comment": "        Lookup named submatch.\n\n        ---\n        import std.regex;\n        import std.range;\n\n        auto c = matchFirst(\"a = 42;\", regex(`(?P<var>\\w+)\\s*=\\s*(?P<value>\\d+);`));\n        assert(c[\"var\"] == \"a\");\n        assert(c[\"value\"] == \"42\");\n        popFrontN(c, 2);\n        //named groups are unaffected by range primitives\n        assert(c[\"var\"] ==\"a\");\n        assert(c.front == \"42\");\n        ----\n",
								"parameters": [
									{
										"name": "String",
										"kind": "type"
									}
								],
								"constraint": "isSomeString!String",
								"char": 7,
								"kind": "template"
							},
							{
								"endchar": 69,
								"name": "length",
								"line": 515,
								"comment": "Number of matches in this object.\n",
								"type": "const @property size_t()",
								"endline": 515,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 44,
								"name": "captures",
								"line": 518,
								"comment": "A hook for compatibility with original std.regex.\n",
								"type": "@property ref ()",
								"endline": 518,
								"char": 19,
								"kind": "function"
							}
						],
						"char": 17,
						"kind": "struct"
					}
				],
				"name": "Captures",
				"line": 368,
				"comment": "    $(D Captures) object contains submatches captured during a call\n    to $(D match) or iteration over $(D RegexMatch) range.\n\n    First element of range is the whole match.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL522_1663)\n---\nauto c = matchFirst(\"@abc#\", regex(`(\\w)(\\w)(\\w)`));\nassert(c.pre == \"@\"); // Part of input preceding match\nassert(c.post == \"#\"); // Immediately after match\nassert(c.hit == c[0] && c.hit == \"abc\"); // The whole match\nassert(c[2] == \"b\");\nassert(c.front == \"abc\");\nc.popFront();\nassert(c.front == \"a\");\nassert(c.back == \"c\");\nc.popBack();\nassert(c.back == \"b\");\npopFrontN(c, 2);\nassert(c.empty);\n\nassert(!matchFirst(\"nothing\", \"something\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL522_1663)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "DIndex",
						"default": "size_t",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RegexMatch",
						"line": 550,
						"members": [
							{
								"endchar": 5,
								"name": "pre",
								"line": 600,
								"comment": "Shorthands for front.pre, front.post, front.hit.\n",
								"type": "@property R()",
								"endline": 603,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "post",
								"line": 606,
								"comment": "ditto\n",
								"type": "@property R()",
								"endline": 609,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "hit",
								"line": 612,
								"comment": "ditto\n",
								"type": "@property R()",
								"endline": 615,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 629,
								"comment": "        Functionality for processing subsequent matches of global regexes via range interface:\n        ---\n        import std.regex;\n        auto m = matchAll(\"Hello, world!\", regex(`\\w+`));\n        assert(m.front.hit == \"Hello\");\n        m.popFront();\n        assert(m.front.hit == \"world\");\n        m.popFront();\n        assert(m.empty);\n        ---\n",
								"type": "@property ()",
								"endline": 632,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 635,
								"comment": "ditto\n",
								"type": "void()",
								"endline": 649,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 31,
								"name": "save",
								"line": 652,
								"comment": "ditto\n",
								"type": "()",
								"endline": 652,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 54,
								"name": "empty",
								"line": 655,
								"comment": "Test if this match object is empty.\n",
								"type": "@property bool()",
								"endline": 655,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 40,
										"name": "opCast",
										"line": 658,
										"type": "T()",
										"endline": 658,
										"char": 7,
										"kind": "function"
									}
								],
								"name": "opCast",
								"line": 658,
								"comment": "Same as !(x.empty), provided for its convenience  in conditional statements.\n",
								"parameters": [
									{
										"name": "T",
										"deco": "b",
										"kind": "type"
									}
								],
								"char": 7,
								"kind": "template"
							},
							{
								"endchar": 50,
								"name": "captures",
								"line": 661,
								"comment": "Same as .front, provided for compatibility with original std.regex.\n",
								"type": "@property ()",
								"endline": 661,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"char": 17,
						"kind": "struct"
					}
				],
				"name": "RegexMatch",
				"line": 550,
				"comment": "    A regex engine state, as returned by $(D match) family of functions.\n\n    Effectively it's a forward range of Captures!R, produced\n    by lazily searching for matches in a given input.\n\n    $(D alias Engine) specifies an engine type to use during matching,\n    and is automatically deduced in a call to $(D match)/$(D bmatch).\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "Engine",
						"defaultAlias": "ThompsonMatcher",
						"kind": "alias"
					}
				],
				"constraint": "isSomeString!R",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "match",
						"line": 777,
						"type": "(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 782,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "match",
				"line": 777,
				"comment": "    Start matching $(D input) to regex pattern $(D re),\n    using Thompson NFA matching scheme.\n\n    The use of this function is $(RED discouraged) - use either of\n    $(LREF matchAll) or $(LREF matchFirst).\n\n    Delegating  the kind of operation\n    to \"g\" flag is soon to be phased out along with the\n    ability to choose the exact matching scheme. The choice of\n    matching scheme to use depends highly on the pattern kind and\n    can done automatically on case by case basis.\n\n    Returns: a $(D RegexMatch) object holding engine state after first match.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(RegEx == Regex!(BasicElementOf!R))",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "match",
						"line": 785,
						"type": "(R input, String re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "String"
							}
						],
						"endline": 790,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "match",
				"line": 785,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "String",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isSomeString!String",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "matchFirst",
						"line": 817,
						"type": "(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 822,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "matchFirst",
				"line": 817,
				"comment": "    Find the first (leftmost) slice of the $(D input) that\n    matches the pattern $(D re). This function picks the most suitable\n    regular expression engine depending on the pattern properties.\n\n    $(D re) parameter can be one of three types:\n    $(UL\n      $(LI Plain string, in which case it's compiled to bytecode before matching. )\n      $(LI Regex!char (wchar/dchar) that contains a pattern in the form of\n        compiled  bytecode. )\n      $(LI StaticRegex!char (wchar/dchar) that contains a pattern in the form of\n        compiled native machine code. )\n    )\n\n    Returns:\n    $(LREF Captures) containing the extent of a match together with all submatches\n    if there was a match, otherwise an empty $(LREF Captures) object.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(RegEx == Regex!(BasicElementOf!R))",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "matchFirst",
						"line": 825,
						"type": "(R input, String re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "String"
							}
						],
						"endline": 830,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "matchFirst",
				"line": 825,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "String",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isSomeString!String",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "matchAll",
						"line": 860,
						"type": "(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 865,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "matchAll",
				"line": 860,
				"comment": "    Initiate a search for all non-overlapping matches to the pattern $(D re)\n    in the given $(D input). The result is a lazy range of matches generated\n    as they are encountered in the input going left to right.\n\n    This function picks the most suitable regular expression engine\n    depending on the pattern properties.\n\n    $(D re) parameter can be one of three types:\n    $(UL\n      $(LI Plain string, in which case it's compiled to bytecode before matching. )\n      $(LI Regex!char (wchar/dchar) that contains a pattern in the form of\n        compiled  bytecode. )\n      $(LI StaticRegex!char (wchar/dchar) that contains a pattern in the form of\n        compiled native machine code. )\n    )\n\n    Returns:\n    $(LREF RegexMatch) object that represents matcher state\n    after the first match was found or an empty one if not present.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(RegEx == Regex!(BasicElementOf!R))",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "matchAll",
						"line": 868,
						"type": "(R input, String re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "String"
							}
						],
						"endline": 873,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "matchAll",
				"line": 868,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "String",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isSomeString!String",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "bmatch",
						"line": 940,
						"type": "(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 945,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "bmatch",
				"line": 940,
				"comment": "    Start matching of $(D input) to regex pattern $(D re),\n    using traditional $(LUCKY backtracking) matching scheme.\n\n    The use of this function is $(RED discouraged) - use either of\n    $(LREF matchAll) or $(LREF matchFirst).\n\n    Delegating  the kind of operation\n    to \"g\" flag is soon to be phased out along with the\n    ability to choose the exact matching scheme. The choice of\n    matching scheme to use depends highly on the pattern kind and\n    can done automatically on case by case basis.\n\n    Returns: a $(D RegexMatch) object holding engine\n    state after first match.\n\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(RegEx == Regex!(BasicElementOf!R))",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "bmatch",
						"line": 948,
						"type": "(R input, String re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "String"
							}
						],
						"endline": 953,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "bmatch",
				"line": 948,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "String",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isSomeString!String",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceFirst",
						"line": 1054,
						"type": "R(R input, RegEx re, const(C)[] format)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							},
							{
								"name": "format",
								"type": "const(C)[]"
							}
						],
						"endline": 1058,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "replaceFirst",
				"line": 1054,
				"comment": "    Construct a new string from $(D input) by replacing the first match with\n    a string generated from it according to the $(D format) specifier.\n\n    To replace all matches use $(LREF replaceAll).\n\n    Params:\n    input = string to search\n    re = compiled regular expression to use\n    format = format string to generate replacements from,\n    see $(S_LINK Replace format string, the format string).\n\n    Returns:\n    A string of the same type with the first match (if any) replaced.\n    If no match is found returns the input string itself.\n\n    Example:\n    ---\n    assert(replaceFirst(\"noon\", regex(\"n\"), \"[$&]\") == \"[n]oon\");\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(C : dchar) && isRegexFor!(RegEx, R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceFirst",
						"line": 1083,
						"type": "R(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 1087,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "replaceFirst",
				"line": 1083,
				"comment": "    This is a general replacement tool that construct a new string by replacing\n    matches of pattern $(D re) in the $(D input). Unlike the other overload\n    there is no format string instead captures are passed to\n    to a user-defined functor $(D fun) that returns a new string\n    to use as replacement.\n\n    This version replaces the first match in $(D input),\n    see $(LREF replaceAll) to replace the all of the matches.\n\n    Returns:\n    A new string of the same type as $(D input) with all matches\n    replaced by return values of $(D fun). If no matches found\n    returns the $(D input) itself.\n\n    Example:\n    ---\n    string list = \"#21 out of 46\";\n    string newList = replaceFirst!(cap => to!string(to!int(cap.hit)+1))\n        (list, regex(`[0-9]+`));\n    assert(newList == \"#22 out of 46\");\n    ---\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "replaceFirstInto",
						"line": 1110,
						"type": "@trusted void(ref Sink sink, R input, RegEx re, const(C)[] format)",
						"parameters": [
							{
								"name": "sink",
								"type": "Sink",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							},
							{
								"name": "format",
								"type": "const(C)[]"
							}
						],
						"endline": 1117,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "replaceFirstInto",
				"line": 1110,
				"comment": "    A variation on $(LREF replaceFirst) that instead of allocating a new string\n    on each call outputs the result piece-wise to the $(D sink). In particular\n    this enables efficient construction of a final output incrementally.\n\n    Like in $(LREF replaceFirst) family of functions there is an overload\n    for the substitution guided by the $(D format) string\n    and the one with the user defined callback.\n\n    Example:\n    ---\n    import std.array;\n    string m1 = \"first message\\n\";\n    string m2 = \"second message\\n\";\n    auto result = appender!string();\n    replaceFirstInto(result, m1, regex(`([a-z]+) message`), \"$1\");\n    //equivalent of the above with user-defined callback\n    replaceFirstInto!(cap=>cap[1])(result, m2, regex(`([a-z]+) message`));\n    assert(result.data == \"first\\nsecond\\n\");\n    ---\n",
				"parameters": [
					{
						"name": "Sink",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isOutputRange!(Sink, dchar) && isSomeString!R && is(C : dchar) && isRegexFor!(RegEx, R)",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceFirstInto",
						"line": 1120,
						"type": "@trusted void(Sink sink, R input, RegEx re)",
						"parameters": [
							{
								"name": "sink",
								"type": "Sink"
							},
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 1125,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "replaceFirstInto",
				"line": 1120,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "Sink",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isOutputRange!(Sink, dchar) && isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceAll",
						"line": 1170,
						"type": "@trusted R(R input, RegEx re, const(C)[] format)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							},
							{
								"name": "format",
								"type": "const(C)[]"
							}
						],
						"endline": 1174,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "replaceAll",
				"line": 1170,
				"comment": "    Construct a new string from $(D input) by replacing all of the\n    fragments that match a pattern $(D re) with a string generated\n    from the match according to the $(D format) specifier.\n\n    To replace only the first match use $(LREF replaceFirst).\n\n    Params:\n    input = string to search\n    re = compiled regular expression to use\n    format = format string to generate replacements from,\n    see $(S_LINK Replace format string, the format string).\n\n    Returns:\n    A string of the same type as $(D input) with the all\n    of the matches (if any) replaced.\n    If no match is found returns the input string itself.\n\n    Example:\n    ---\n    // insert comma as thousands delimiter\n    auto re = regex(r\"(?<=\\d)(?=(\\d\\d\\d)+\\b)\",\"g\");\n    assert(replaceAll(\"12000 + 42100 = 54100\", re, \",\") == \"12,000 + 42,100 = 54,100\");\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(C : dchar) && isRegexFor!(RegEx, R)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceAll",
						"line": 1208,
						"type": "@trusted R(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 1212,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "replaceAll",
				"line": 1208,
				"comment": "    This is a general replacement tool that construct a new string by replacing\n    matches of pattern $(D re) in the $(D input). Unlike the other overload\n    there is no format string instead captures are passed to\n    to a user-defined functor $(D fun) that returns a new string\n    to use as replacement.\n\n    This version replaces all of the matches found in $(D input),\n    see $(LREF replaceFirst) to replace the first match only.\n\n    Returns:\n    A new string of the same type as $(D input) with all matches\n    replaced by return values of $(D fun). If no matches found\n    returns the $(D input) itself.\n\n    Params:\n    input = string to search\n    re = compiled regular expression\n    fun = delegate to use\n\n    Example:\n    Capitalize the letters 'a' and 'r':\n    ---\n    string baz(Captures!(string) m)\n    {\n        return std.string.toUpper(m.hit);\n    }\n    auto s = replaceAll!(baz)(\"Strap a rocket engine on a chicken.\",\n            regex(\"[ar]\"));\n    assert(s == \"StRAp A Rocket engine on A chicken.\");\n    ---\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "replaceAllInto",
						"line": 1222,
						"type": "@trusted void(Sink sink, R input, RegEx re, const(C)[] format)",
						"parameters": [
							{
								"name": "sink",
								"type": "Sink"
							},
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							},
							{
								"name": "format",
								"type": "const(C)[]"
							}
						],
						"endline": 1229,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "replaceAllInto",
				"line": 1222,
				"comment": "    A variation on $(LREF replaceAll) that instead of allocating a new string\n    on each call outputs the result piece-wise to the $(D sink). In particular\n    this enables efficient construction of a final output incrementally.\n\n    As with $(LREF replaceAll) there are 2 overloads - one with a format string,\n    the other one with a user defined functor.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1240_1684)\n---\n// insert comma as thousands delimiter in fifty randomly produced big numbers\nimport std.array, std.random, std.conv, std.range;\nstatic re = regex(`(?<=\\d)(?=(\\d\\d\\d)+\\b)`, \"g\");\nauto sink = appender!(char [])();\nenum ulong min = 10UL ^^ 10, max = 10UL ^^ 19;\nforeach (i; 0 .. 50)\n{\n    sink.clear();\n    replaceAllInto(sink, text(uniform(min, max)), re, \",\");\n    foreach (pos; iota(sink.data.length - 4, 0, -4))\n        assert(sink.data[pos] == ',');\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1240_1684)\n",
				"parameters": [
					{
						"name": "Sink",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isOutputRange!(Sink, dchar) && isSomeString!R && is(C : dchar) && isRegexFor!(RegEx, R)",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceAllInto",
						"line": 1232,
						"type": "@trusted void(Sink sink, R input, RegEx re)",
						"parameters": [
							{
								"name": "sink",
								"type": "Sink"
							},
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 1237,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "replaceAllInto",
				"line": 1232,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "Sink",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isOutputRange!(Sink, dchar) && isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replace",
						"line": 1304,
						"type": "R(R input, RegEx re, const(C)[] format)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							},
							{
								"name": "format",
								"type": "const(C)[]"
							}
						],
						"endline": 1308,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "replace",
				"line": 1304,
				"comment": "    Old API for replacement, operation depends on flags of pattern $(D re).\n    With \"g\" flag it performs the equivalent of $(LREF replaceAll) otherwise it\n    works the same as $(LREF replaceFirst).\n\n    The use of this function is $(RED discouraged), please use $(LREF replaceAll)\n    or $(LREF replaceFirst) explicitly.\n",
				"parameters": [
					{
						"name": "scheme",
						"defaultAlias": "match",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replace",
						"line": 1311,
						"type": "R(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 1315,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "replace",
				"line": 1311,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Splitter",
						"line": 1328,
						"members": [
							{
								"endchar": 5,
								"name": "front",
								"line": 1359,
								"comment": "Forward range primitives.\n",
								"type": "@property Range()",
								"endline": 1366,
								"char": 21,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 1369,
								"comment": "ditto\n",
								"type": "@property bool()",
								"endline": 1372,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 1375,
								"comment": "ditto\n",
								"type": "void()",
								"endline": 1389,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 1392,
								"comment": "ditto\n",
								"type": "@property ()",
								"endline": 1395,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"char": 8,
						"kind": "struct"
					}
				],
				"name": "Splitter",
				"line": 1328,
				"comment": "Range that splits a string using a regular expression as a\nseparator.\n\nExample:\n----\nauto s1 = \", abc, de,  fg, hi, \";\nassert(equal(splitter(s1, regex(\", *\")),\n    [\"\", \"abc\", \"de\", \"fg\", \"hi\", \"\"]));\n----\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"defaultAlias": "Regex",
						"kind": "alias"
					}
				],
				"constraint": "isSomeString!Range && isRegexFor!(RegEx, Range)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitter",
						"line": 1402,
						"type": "Splitter!(Range, RegEx)(Range r, RegEx pat)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "pat",
								"type": "RegEx"
							}
						],
						"endline": 1406,
						"char": 32,
						"kind": "function"
					}
				],
				"name": "splitter",
				"line": 1402,
				"comment": "    A helper function, creates a $(D Splitter) on range $(D r) separated by regex $(D pat).\n    Captured subexpressions have no effect on the resulting range.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "is(BasicElementOf!Range : dchar) && isRegexFor!(RegEx, Range)",
				"char": 32,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "split",
						"line": 1409,
						"type": "@trusted String[](String input, RegEx rx)",
						"parameters": [
							{
								"name": "input",
								"type": "String"
							},
							{
								"name": "rx",
								"type": "RegEx"
							}
						],
						"endline": 1416,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "split",
				"line": 1409,
				"comment": "An eager version of $(D splitter) that creates an array with splitted slices of $(D input).\n",
				"parameters": [
					{
						"name": "String",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!String && isRegexFor!(RegEx, String)",
				"char": 26,
				"kind": "template"
			},
			{
				"name": "RegexException",
				"line": 1419,
				"comment": "Exception object thrown in case of errors during regex compilation.\n",
				"deco": "C3std5regex8internal2ir14RegexException",
				"char": 8,
				"kind": "alias"
			}
		],
		"comment": "  $(LUCKY Regular expressions) are a commonly used method of pattern matching\n  on strings, with $(I regex) being a catchy word for a pattern in this domain\n  specific language. Typical problems usually solved by regular expressions\n  include validation of user input and the ubiquitous find $(AMP) replace\n  in text processing utilities.\n\n  $(SECTION Synopsis)\n  ---\n  import std.regex;\n  import std.stdio;\n  void main()\n  {\n      // Print out all possible dd/mm/yy(yy) dates found in user input.\n      auto r = regex(r\"\\b[0-9][0-9]?/[0-9][0-9]?/[0-9][0-9](?:[0-9][0-9])?\\b\");\n      foreach(line; stdin.byLine)\n      {\n        // matchAll() returns a range that can be iterated\n        // to get all subsequent matches.\n        foreach(c; matchAll(line, r))\n            writeln(c.hit);\n      }\n  }\n  ...\n\n  // Create a static regex at compile-time, which contains fast native code.\n  auto ctr = ctRegex!(`^.*/([^/]+)/?$`);\n\n  // It works just like a normal regex:\n  auto c2 = matchFirst(\"foo/bar\", ctr);   // First match found here, if any\n  assert(!c2.empty);   // Be sure to check if there is a match before examining contents!\n  assert(c2[1] == \"bar\");   // Captures is a range of submatches: 0 = full match.\n\n  ...\n\n  // The result of the $(D matchAll) is directly testable with if/assert/while.\n  // e.g. test if a string consists of letters:\n  assert(matchFirst(\"Letter\", `^\\p{L}+$`));\n\n\n  ---\n  $(SECTION Syntax and general information)\n  The general usage guideline is to keep regex complexity on the side of simplicity,\n  as its capabilities reside in purely character-level manipulation.\n  As such it's ill-suited for tasks involving higher level invariants\n  like matching an integer number $(U bounded) in an [a,b] interval.\n  Checks of this sort of are better addressed by additional post-processing.\n\n  The basic syntax shouldn't surprise experienced users of regular expressions.\n  For an introduction to $(D std.regex) see a\n  $(WEB dlang.org/regular-expression.html, short tour) of the module API\n  and its abilities.\n\n  There are other web resources on regular expressions to help newcomers,\n  and a good $(WEB www.regular-expressions.info, reference with tutorial)\n  can easily be found.\n\n  This library uses a remarkably common ECMAScript syntax flavor\n  with the following extensions:\n  $(UL\n    $(LI Named subexpressions, with Python syntax. )\n    $(LI Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.)\n    $(LI Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.)\n  )\n\n  $(REG_START Pattern syntax )\n  $(I std.regex operates on codepoint level,\n    'character' in this table denotes a single Unicode codepoint.)\n  $(REG_TABLE\n    $(REG_TITLE Pattern element, Semantics )\n    $(REG_TITLE Atoms, Match single characters )\n    $(REG_ROW any character except [{|*+?()^$, Matches the character itself. )\n    $(REG_ROW ., In single line mode matches any character.\n      Otherwise it matches any character except '\\n' and '\\r'. )\n    $(REG_ROW [class], Matches a single character\n      that belongs to this character class. )\n    $(REG_ROW [^class], Matches a single character that\n      does $(U not) belong to this character class.)\n    $(REG_ROW \\cC, Matches the control character corresponding to letter C)\n    $(REG_ROW \\xXX, Matches a character with hexadecimal value of XX. )\n    $(REG_ROW \\uXXXX, Matches a character  with hexadecimal value of XXXX. )\n    $(REG_ROW \\U00YYYYYY, Matches a character with hexadecimal value of YYYYYY. )\n    $(REG_ROW \\f, Matches a formfeed character. )\n    $(REG_ROW \\n, Matches a linefeed character. )\n    $(REG_ROW \\r, Matches a carriage return character. )\n    $(REG_ROW \\t, Matches a tab character. )\n    $(REG_ROW \\v, Matches a vertical tab character. )\n    $(REG_ROW \\d, Matches any Unicode digit. )\n    $(REG_ROW \\D, Matches any character except Unicode digits. )\n    $(REG_ROW \\w, Matches any word character (note: this includes numbers).)\n    $(REG_ROW \\W, Matches any non-word character.)\n    $(REG_ROW \\s, Matches whitespace, same as \\p{White_Space}.)\n    $(REG_ROW \\S, Matches any character except those recognized as $(I \\s ). )\n    $(REG_ROW \\\\, Matches \\ character. )\n    $(REG_ROW \\c where c is one of [|*+?(), Matches the character c itself. )\n    $(REG_ROW \\p{PropertyName}, Matches a character that belongs\n        to the Unicode PropertyName set.\n      Single letter abbreviations can be used without surrounding {,}. )\n    $(REG_ROW  \\P{PropertyName}, Matches a character that does not belong\n        to the Unicode PropertyName set.\n      Single letter abbreviations can be used without surrounding {,}. )\n    $(REG_ROW \\p{InBasicLatin}, Matches any character that is part of\n          the BasicLatin Unicode $(U block).)\n    $(REG_ROW \\P{InBasicLatin}, Matches any character except ones in\n          the BasicLatin Unicode $(U block).)\n    $(REG_ROW \\p{Cyrillic}, Matches any character that is part of\n        Cyrillic $(U script).)\n    $(REG_ROW \\P{Cyrillic}, Matches any character except ones in\n        Cyrillic $(U script).)\n    $(REG_TITLE Quantifiers, Specify repetition of other elements)\n    $(REG_ROW *, Matches previous character/subexpression 0 or more times.\n      Greedy version - tries as many times as possible.)\n    $(REG_ROW *?, Matches previous character/subexpression 0 or more times.\n      Lazy version  - stops as early as possible.)\n    $(REG_ROW +, Matches previous character/subexpression 1 or more times.\n      Greedy version - tries as many times as possible.)\n    $(REG_ROW +?, Matches previous character/subexpression 1 or more times.\n      Lazy version  - stops as early as possible.)\n    $(REG_ROW {n}, Matches previous character/subexpression exactly n times. )\n    $(REG_ROW {n$(COMMA)}, Matches previous character/subexpression n times or more.\n      Greedy version - tries as many times as possible. )\n    $(REG_ROW {n$(COMMA)}?, Matches previous character/subexpression n times or more.\n      Lazy version - stops as early as possible.)\n    $(REG_ROW {n$(COMMA)m}, Matches previous character/subexpression n to m times.\n      Greedy version - tries as many times as possible, but no more than m times. )\n    $(REG_ROW {n$(COMMA)m}?, Matches previous character/subexpression n to m times.\n      Lazy version - stops as early as possible, but no less then n times.)\n    $(REG_TITLE Other, Subexpressions $(AMP) alternations )\n    $(REG_ROW (regex),  Matches subexpression regex,\n      saving matched portion of text for later retrieval. )\n    $(REG_ROW (?:regex), Matches subexpression regex,\n      $(U not) saving matched portion of text. Useful to speed up matching. )\n    $(REG_ROW A|B, Matches subexpression A, or failing that, matches B. )\n    $(REG_ROW (?P$(LT)name$(GT)regex), Matches named subexpression\n        regex labeling it with name 'name'.\n        When referring to a matched portion of text,\n        names work like aliases in addition to direct numbers.\n     )\n    $(REG_TITLE Assertions, Match position rather than character )\n    $(REG_ROW ^, Matches at the begining of input or line (in multiline mode).)\n    $(REG_ROW $, Matches at the end of input or line (in multiline mode). )\n    $(REG_ROW \\b, Matches at word boundary. )\n    $(REG_ROW \\B, Matches when $(U not) at word boundary. )\n    $(REG_ROW (?=regex), Zero-width lookahead assertion.\n        Matches at a point where the subexpression\n        regex could be matched starting from the current position.\n      )\n    $(REG_ROW (?!regex), Zero-width negative lookahead assertion.\n        Matches at a point where the subexpression\n        regex could $(U not) be matched starting from the current position.\n      )\n    $(REG_ROW (?<=regex), Zero-width lookbehind assertion. Matches at a point\n        where the subexpression regex could be matched ending\n        at the current position (matching goes backwards).\n      )\n    $(REG_ROW  (?<!regex), Zero-width negative lookbehind assertion.\n      Matches at a point where the subexpression regex could $(U not)\n      be matched ending at the current position (matching goes backwards).\n     )\n  )\n\n  $(REG_START Character classes )\n  $(REG_TABLE\n    $(REG_TITLE Pattern element, Semantics )\n    $(REG_ROW Any atom, Has the same meaning as outside of a character class.)\n    $(REG_ROW a-z, Includes characters a, b, c, ..., z. )\n    $(REG_ROW [a||b]$(COMMA) [a--b]$(COMMA) [a~~b]$(COMMA) [a$(AMP)$(AMP)b],\n     Where a, b are arbitrary classes, means union, set difference,\n     symmetric set difference, and intersection respectively.\n     $(I Any sequence of character class elements implicitly forms a union.) )\n  )\n\n  $(REG_START Regex flags )\n  $(REG_TABLE\n    $(REG_TITLE Flag, Semantics )\n    $(REG_ROW g, Global regex, repeat over the whole input. )\n    $(REG_ROW i, Case insensitive matching. )\n    $(REG_ROW m, Multi-line mode, match ^, $ on start and end line separators\n       as well as start and end of input.)\n    $(REG_ROW s, Single-line mode, makes . match '\\n' and '\\r' as well. )\n    $(REG_ROW x, Free-form syntax, ignores whitespace in pattern,\n      useful for formatting complex regular expressions. )\n  )\n\n  $(SECTION Unicode support)\n\n  This library provides full Level 1 support* according to\n    $(WEB unicode.org/reports/tr18/, UTS 18). Specifically:\n  $(UL\n    $(LI 1.1 Hex notation via any of \\uxxxx, \\U00YYYYYY, \\xZZ.)\n    $(LI 1.2 Unicode properties.)\n    $(LI 1.3 Character classes with set operations.)\n    $(LI 1.4 Word boundaries use the full set of \"word\" characters.)\n    $(LI 1.5 Using simple casefolding to match case\n        insensitively across the full range of codepoints.)\n    $(LI 1.6 Respecting line breaks as any of\n        \\u000A | \\u000B | \\u000C | \\u000D | \\u0085 | \\u2028 | \\u2029 | \\u000D\\u000A.)\n    $(LI 1.7 Operating on codepoint level.)\n  )\n  *With exception of point 1.1.1, as of yet, normalization of input\n    is expected to be enforced by user.\n\n    $(SECTION Replace format string)\n\n    A set of functions in this module that do the substitution rely\n    on a simple format to guide the process. In particular the table below\n    applies to the $(D format) argument of\n    $(LREF replaceFirst) and $(LREF replaceAll).\n\n    The format string can reference parts of match using the following notation.\n    $(REG_TABLE\n        $(REG_TITLE Format specifier, Replaced by )\n        $(REG_ROW $$(AMP), the whole match. )\n        $(REG_ROW $(DOLLAR)$(BACKTICK), part of input $(I preceding) the match. )\n        $(REG_ROW $', part of input $(I following) the match. )\n        $(REG_ROW $$, '$' character. )\n        $(REG_ROW \\c $(COMMA) where c is any character, the character c itself. )\n        $(REG_ROW \\\\, '\\' character. )\n        $(REG_ROW $(DOLLAR)1 .. $(DOLLAR)99, submatch number 1 to 99 respectively. )\n    )\n\n  $(SECTION Slicing and zero memory allocations orientation)\n\n  All matches returned by pattern matching functionality in this library\n    are slices of the original input. The notable exception is the $(D replace)\n    family of functions  that generate a new string from the input.\n\n    In cases where producing the replacement is the ultimate goal\n    $(LREF replaceFirstInto) and $(LREF replaceAllInto) could come in handy\n    as functions that  avoid allocations even for replacement.\n\n    Copyright: Copyright Dmitry Olshansky, 2011-\n\n  License: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n  Authors: Dmitry Olshansky,\n\n    API and utility constructs are modeled after the original $(D std.regex)\n  by Walter Bright and Andrei Alexandrescu.\n\n  Source: $(PHOBOSSRC std/_regex/_package.d)\n\nMacros:\n    REG_ROW = $(TR $(TD $(I $1 )) $(TD $+) )\n    REG_TITLE = $(TR $(TD $(B $1)) $(TD $(B $2)) )\n    REG_TABLE = <table border=\"1\" cellspacing=\"0\" cellpadding=\"5\" > $0 </table>\n    REG_START = <h3><div align=\"center\"> $0 </div></h3>\n    SECTION = <h3><a id=\"$1\">$0</a></h3>\n    S_LINK = <a href=\"#$1\">$+</a>\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/demangle.d",
		"name": "std.demangle",
		"members": [
			{
				"endchar": 1,
				"name": "demangle",
				"line": 85,
				"comment": " Demangle D mangled names.\n\n If it is not a D mangled name, it returns its argument name.\n Example:\n        This program reads standard in and writes it to standard out,\n        pretty-printing any found D mangled names.\n-------------------\nimport core.stdc.stdio : stdin;\nimport std.stdio;\nimport std.ascii;\nimport std.demangle;\n\nvoid test(int x, float y) { }\n\nint main()\n{\n    string buffer;\n    bool inword;\n    int c;\n\n    writefln(\"Try typing in: %s\", test.mangleof);\n    while ((c = fgetc(stdin)) != EOF)\n    {\n        if (inword)\n        {\n            if (c == '_' || isAlphaNum(c))\n                buffer ~= cast(char) c;\n            else\n            {\n                inword = false;\n                write(demangle(buffer), cast(char) c);\n            }\n        }\n        else\n        {   if (c == '_' || isAlpha(c))\n            {\n                inword = true;\n                buffer.length = 0;\n                buffer ~= cast(char) c;\n            }\n            else\n                write(cast(char) c);\n        }\n    }\n    if (inword)\n        write(demangle(buffer));\n    return 0;\n}\n-------------------\n",
				"deco": "FAyaZAya",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					}
				],
				"endline": 91,
				"char": 8,
				"kind": "function"
			}
		],
		"comment": " Demangle D mangled names.\n\n Macros:\n  WIKI = Phobos/StdDemangle\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright),\n                        Thomas K$(UUML)hne, Frits van Bommel\n Source:    $(PHOBOSSRC std/_demangle.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/system.d",
		"name": "std.system",
		"members": [
			{
				"members": [
					{
						"name": "win32",
						"line": 32,
						"value": "1",
						"comment": "Microsoft 32 bit Windows systems\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "win64",
						"line": 33,
						"value": "2",
						"comment": "Microsoft 64 bit Windows systems\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "linux",
						"line": 34,
						"value": "3",
						"comment": "All Linux Systems\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "osx",
						"line": 35,
						"value": "4",
						"comment": "Mac OS X\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "freeBSD",
						"line": 36,
						"value": "5",
						"comment": "FreeBSD\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "solaris",
						"line": 37,
						"value": "6",
						"comment": "Solaris\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "android",
						"line": 38,
						"value": "7",
						"comment": "Android\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "otherPosix",
						"line": 39,
						"value": "8",
						"comment": "Other Posix Systems\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "OS",
				"line": 30,
				"comment": "        Operating system.\n\n        Note:\n            This is for cases where you need a value representing the OS at\n            runtime. If you're doing something which should compile differently\n            on different OSes, then please use $(D version(Windows)),\n            $(D version(linux)), etc.\n\n        See_Also:\n            $(DDSUBLINK spec/version,PredefinedVersions, Predefined Versions)\n",
				"baseDeco": "i",
				"char": 5,
				"kind": "enum"
			},
			{
				"name": "os",
				"line": 46,
				"comment": "The OS that the program was compiled for.\n",
				"deco": "yE3std6system2OS",
				"originalType": "OS",
				"init": "cast(OS)3",
				"char": 30,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"members": [
					{
						"name": "bigEndian",
						"line": 67,
						"value": "0",
						"comment": "Big endian byte order\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "littleEndian",
						"line": 68,
						"value": "1",
						"comment": "Little endian byte order\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "Endian",
				"line": 65,
				"comment": "        Byte order endianness.\n\n        Note:\n            This is intended for cases where you need to deal with endianness at\n            runtime. If you're doing something which should compile differently\n            depending on whether you're compiling on a big endian or little\n            endian machine, then please use $(D version(BigEndian)) and\n            $(D version(LittleEndian)).\n\n        See_Also:\n            $(DDSUBLINK spec/version,PredefinedVersions, Predefined Versions)\n",
				"baseDeco": "i",
				"char": 5,
				"kind": "enum"
			},
			{
				"name": "endian",
				"line": 72,
				"comment": "The endianness that the program was compiled for.\n",
				"deco": "yE3std6system6Endian",
				"originalType": "Endian",
				"init": "cast(Endian)1",
				"char": 34,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			}
		],
		"comment": " Information about the target operating system, environment, and CPU.\n\n Macros:\n      WIKI = Phobos/StdSystem\n\n  Copyright: Copyright Digital Mars 2000 - 2011\n  License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n  Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n  Source:    $(PHOBOSSRC std/_system.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/typetuple.d",
		"name": "std.typetuple",
		"members": [
			{
				"name": "TypeTuple",
				"line": 17,
				"comment": " Alternate name for $(XREF meta,AliasSeq) for legacy compatibility.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL20_1741)\n---\nimport std.typetuple;\nalias TL = TypeTuple!(int, double);\n\nint foo(TL td)  // same as int foo(int, double);\n{\n    return td[0] + cast(int)td[1];\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL20_1741)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL32_1742)\n---\nalias TL = TypeTuple!(int, double);\n\nalias Types = TypeTuple!(TL, char);\nstatic assert(is(Types == TypeTuple!(int, double, char)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL32_1742)\n",
				"char": 1,
				"kind": "alias"
			}
		],
		"comment": " This module was renamed to disambiguate the term tuple, use\n $(LINK2 std_meta.html, std.meta) instead.\n\n Copyright: Copyright Digital Mars 2005 - 2015.\n License: $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:\n Source:    $(PHOBOSSRC std/_typetuple.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/json.d",
		"name": "std.json",
		"members": [
			{
				"members": [
					{
						"name": "nan",
						"line": 65,
						"value": "\"NaN\"",
						"comment": "string representation of floating-point NaN\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "inf",
						"line": 66,
						"value": "\"Infinite\"",
						"comment": "string representation of floating-point Infinity\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "negativeInf",
						"line": 67,
						"value": "\"-Infinite\"",
						"comment": "string representation of floating-point negative Infinity\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "JSONFloatLiteral",
				"line": 63,
				"comment": "String literals used to represent special float values within JSON strings.\n",
				"baseDeco": "Aya",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 74,
						"value": "0",
						"comment": "standard parsing\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "specialFloatLiterals",
						"line": 75,
						"value": "1",
						"comment": "encode NaN and Inf float values as strings\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "JSONOptions",
				"line": 73,
				"comment": "Flags that control how json is encoded and parsed.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "NULL",
						"line": 84,
						"value": "cast(byte)0",
						"comment": "Indicates the type of a $(D JSONValue).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "STRING",
						"line": 85,
						"value": "1",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "INTEGER",
						"line": 86,
						"value": "2",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "UINTEGER",
						"line": 87,
						"value": "3",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "FLOAT",
						"line": 88,
						"value": "4",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "OBJECT",
						"line": 89,
						"value": "5",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ARRAY",
						"line": 90,
						"value": "6",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "TRUE",
						"line": 91,
						"value": "7",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "FALSE",
						"line": 92,
						"value": "8",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "JSON_TYPE",
				"line": 81,
				"comment": "JSON type enumeration\n",
				"baseDeco": "g",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "JSONValue",
				"line": 98,
				"comment": "JSON value node\n",
				"members": [
					{
						"endchar": 5,
						"name": "type",
						"line": 117,
						"comment": "      Returns the JSON_TYPE of the value stored in this structure.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL122_1743)\n---\nstring s = \"{ \\\"language\\\": \\\"D\\\" }\";\nJSONValue j = parseJSON(s);\nassert(j.type == JSON_TYPE.OBJECT);\nassert(j[\"language\"].type == JSON_TYPE.STRING);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL122_1743)\n",
						"deco": "xFNaNbNdNiNfZE3std4json9JSON_TYPE",
						"endline": 120,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "str",
						"line": 170,
						"comment": "Value getter/setter for $(D JSON_TYPE.STRING).\n\nThrows: $(D JSONException) for read access if $(D type) is not\n\n$(D JSON_TYPE.STRING).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL183_1744)\n---\nJSONValue j = [ \"language\": \"D\" ];\n\n// get value\nassert(j[\"language\"].str == \"D\");\n\n// change existing key to new string\nj[\"language\"].str = \"Perl\";\nassert(j[\"language\"].str == \"Perl\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL183_1744)\n",
						"deco": "NgFNaNdZNgAya",
						"endline": 175,
						"char": 29,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "str",
						"line": 177,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiAyaZAya",
						"parameters": [
							{
								"name": "v",
								"deco": "Aya"
							}
						],
						"endline": 181,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "integer",
						"line": 198,
						"comment": "Value getter/setter for $(D JSON_TYPE.INTEGER).\n\nThrows: $(D JSONException) for read access if $(D type) is not\n\n$(D JSON_TYPE.INTEGER).\n",
						"deco": "NgFNaNdNfZNgl",
						"endline": 203,
						"char": 27,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "integer",
						"line": 205,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiNflZl",
						"parameters": [
							{
								"name": "v",
								"deco": "l"
							}
						],
						"endline": 209,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "uinteger",
						"line": 214,
						"comment": "Value getter/setter for $(D JSON_TYPE.UINTEGER).\n\nThrows: $(D JSONException) for read access if $(D type) is not\n\n$(D JSON_TYPE.UINTEGER).\n",
						"deco": "NgFNaNdNfZNgm",
						"endline": 219,
						"char": 28,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "uinteger",
						"line": 221,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiNfmZm",
						"parameters": [
							{
								"name": "v",
								"deco": "m"
							}
						],
						"endline": 225,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "floating",
						"line": 230,
						"comment": "Value getter/setter for $(D JSON_TYPE.FLOAT).\n\nThrows: $(D JSONException) for read access if $(D type) is not\n\n$(D JSON_TYPE.FLOAT).\n",
						"deco": "NgFNaNdNfZNgd",
						"endline": 235,
						"char": 29,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "floating",
						"line": 237,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiNfdZd",
						"parameters": [
							{
								"name": "v",
								"deco": "d"
							}
						],
						"endline": 241,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "object",
						"line": 246,
						"comment": "Value getter/setter for $(D JSON_TYPE.OBJECT).\n\nThrows: $(D JSONException) for read access if $(D type) is not\n\n$(D JSON_TYPE.OBJECT).\n",
						"deco": "NgFNaNcNdZNgHAyaS3std4json9JSONValue",
						"endline": 251,
						"char": 44,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "object",
						"line": 253,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiHAyaS3std4json9JSONValueZHAyaS3std4json9JSONValue",
						"parameters": [
							{
								"name": "v",
								"deco": "HAyaS3std4json9JSONValue"
							}
						],
						"endline": 257,
						"char": 33,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "array",
						"line": 262,
						"comment": "Value getter/setter for $(D JSON_TYPE.ARRAY).\n\nThrows: $(D JSONException) for read access if $(D type) is not\n\n$(D JSON_TYPE.ARRAY).\n",
						"deco": "NgFNaNcNdZNgAS3std4json9JSONValue",
						"endline": 267,
						"char": 38,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "array",
						"line": 269,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiAS3std4json9JSONValueZAS3std4json9JSONValue",
						"parameters": [
							{
								"name": "v",
								"deco": "AS3std4json9JSONValue"
							}
						],
						"endline": 273,
						"char": 27,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isNull",
						"line": 276,
						"comment": "Test whether the type is $(D JSON_TYPE.NULL)\n",
						"deco": "xFNaNbNdNiNfZb",
						"endline": 279,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 380,
								"type": "(T arg)",
								"parameters": [
									{
										"name": "arg",
										"type": "T"
									}
								],
								"endline": 383,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 380,
						"comment": " Constructor for $(D JSONValue). If $(D arg) is a $(D JSONValue)\n its value and type will be copied to the new $(D JSONValue).\n Note that this is a shallow copy: if type is $(D JSON_TYPE.OBJECT)\n or $(D JSON_TYPE.ARRAY) then only the reference to the data will\n be copied.\n Otherwise, $(D arg) must be implicitly convertible to one of the\n following types: $(D typeof(null)), $(D string), $(D ulong),\n $(D long), $(D double), an associative array $(D V[K]) for any $(D V)\n and $(D K) i.e. a JSON object, any array or $(D bool). The type will\n be set accordingly.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL396_1745)\n---\nJSONValue j = JSONValue( \"a string\" );\nj = JSONValue(42);\n\nj = JSONValue( [1, 2, 3] );\nassert(j.type == JSON_TYPE.ARRAY);\n\nj = JSONValue( [\"language\": \"D\"] );\nassert(j.type == JSON_TYPE.OBJECT);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL396_1745)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "!isStaticArray!T",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 385,
								"type": "(ref T arg)",
								"parameters": [
									{
										"name": "arg",
										"type": "T",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 388,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 385,
						"comment": "Ditto\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isStaticArray!T",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 390,
								"type": "inout (inout T arg)",
								"parameters": [
									{
										"name": "arg",
										"type": "T",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 394,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 390,
						"comment": "Ditto\n",
						"parameters": [
							{
								"name": "T",
								"deco": "S3std4json9JSONValue",
								"kind": "type"
							}
						],
						"char": 5,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 420,
						"comment": "Array syntax for json arrays.\n\nThrows: $(D JSONException) if $(D type) is not $(D JSON_TYPE.ARRAY).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL429_1746)\n---\nJSONValue j = JSONValue( [42, 43, 44] );\nassert( j[0].integer == 42 );\nassert( j[1].integer == 43 );\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL429_1746)\n",
						"deco": "NgFNaNcmZNgS3std4json9JSONValue",
						"parameters": [
							{
								"name": "i",
								"deco": "m"
							}
						],
						"endline": 427,
						"originalType": "inout pure ref inout(JSONValue)(size_t i)",
						"char": 26,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 438,
						"comment": "Hash syntax for json objects.\n\nThrows: $(D JSONException) if $(D type) is not $(D JSON_TYPE.OBJECT).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL446_1747)\n---\nJSONValue j = JSONValue( [\"language\": \"D\"] );\nassert( j[\"language\"].str == \"D\" );\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL446_1747)\n",
						"deco": "NgFNaNcAyaZNgS3std4json9JSONValue",
						"parameters": [
							{
								"name": "k",
								"deco": "Aya"
							}
						],
						"endline": 444,
						"char": 26,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opIndexAssign",
								"line": 459,
								"type": "pure void(auto ref T value, string key)",
								"parameters": [
									{
										"name": "value",
										"type": "T",
										"storageClass": [
											"auto",
											"ref"
										]
									},
									{
										"name": "key",
										"type": "string"
									}
								],
								"endline": 468,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opIndexAssign",
						"line": 459,
						"comment": "Operator sets $(D value) for element of JSON object by $(D key).\n\n\n\nIf JSON value is null, then operator initializes it with object and then\n\nsets $(D value) for it.\n\n\n\nThrows: $(D JSONException) if $(D type) is not $(D JSON_TYPE.OBJECT)\n\nor $(D JSON_TYPE.NULL).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL470_1748)\n---\nJSONValue j = JSONValue( [\"language\": \"D\"] );\nj[\"language\"].str = \"Perl\";\nassert( j[\"language\"].str == \"Perl\" );\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL470_1748)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL486_1749)\n---\nJSONValue j = JSONValue( [\"Perl\", \"C\"] );\nj[1].str = \"D\";\nassert( j[1].str == \"D\" );\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL486_1749)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 549,
								"type": "const (string k)",
								"parameters": [
									{
										"name": "k",
										"type": "string"
									}
								],
								"endline": 554,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "opBinaryRight",
						"line": 549,
						"comment": " Support for the $(D in) operator.\n\n Tests wether a key can be found in an object.\n\n Returns:\n      when found, the $(D const(JSONValue)*) that matches to the key,\n      otherwise $(D null).\n\n Throws: $(D JSONException) if the right hand side argument $(D JSON_TYPE)\n is not $(D OBJECT).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL556_1750)\n---\nJSONValue j = [ \"language\": \"D\", \"author\": \"walter\" ];\nstring a = (\"author\" in j).str;\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL556_1750)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"specValue": "\"in\"",
								"kind": "value"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 595,
						"comment": "Implements the foreach $(D opApply) interface for json arrays.\n",
						"deco": "FDFmKS3std4json9JSONValueZiZi",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFmKS3std4json9JSONValueZi"
							}
						],
						"endline": 609,
						"originalType": "int(int delegate(size_t index, ref JSONValue) dg)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 612,
						"comment": "Implements the foreach $(D opApply) interface for json objects.\n",
						"deco": "FDFAyaKS3std4json9JSONValueZiZi",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFAyaKS3std4json9JSONValueZi"
							}
						],
						"endline": 626,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 631,
						"comment": "Implicitly calls $(D toJSON) on this JSONValue.\n\n\n\n$(I options) can be used to tweak the conversion behavior.\n",
						"deco": "xFxE3std4json11JSONOptionsZAya",
						"parameters": [
							{
								"name": "options",
								"deco": "xE3std4json11JSONOptions",
								"default": "cast(JSONOptions)0"
							}
						],
						"endline": 634,
						"originalType": "const string(in JSONOptions options = JSONOptions.none)",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toPrettyString",
						"line": 640,
						"comment": "Implicitly calls $(D toJSON) on this JSONValue, like $(D toString), but\n\nalso passes $(I true) as $(I pretty) argument.\n\n\n\n$(I options) can be used to tweak the conversion behavior\n",
						"deco": "xFxE3std4json11JSONOptionsZAya",
						"parameters": [
							{
								"name": "options",
								"deco": "xE3std4json11JSONOptions",
								"default": "cast(JSONOptions)0"
							}
						],
						"endline": 643,
						"originalType": "const string(in JSONOptions options = JSONOptions.none)",
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseJSON",
						"line": 654,
						"type": "JSONValue(T json, int maxDepth = -1, JSONOptions options = JSONOptions.none)",
						"parameters": [
							{
								"name": "json",
								"type": "T"
							},
							{
								"name": "maxDepth",
								"deco": "i",
								"default": "-1"
							},
							{
								"name": "options",
								"type": "JSONOptions",
								"default": "JSONOptions.none"
							}
						],
						"endline": 974,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "parseJSON",
				"line": 654,
				"comment": "Parses a serialized string and returns a tree of JSON values.\nThrows: $(XREF json,JSONException) if the depth exceeds the max depth.\nParams:\n    json = json-formatted string to parse\n    maxDepth = maximum depth of nesting allowed, -1 disables depth checking\n    options = enable decoding string representations of NaN/Inf as float values\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!T",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseJSON",
						"line": 983,
						"type": "JSONValue(T json, JSONOptions options)",
						"parameters": [
							{
								"name": "json",
								"type": "T"
							},
							{
								"name": "options",
								"type": "JSONOptions"
							}
						],
						"endline": 987,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "parseJSON",
				"line": 983,
				"comment": "Parses a serialized string and returns a tree of JSON values.\nThrows: $(XREF json,JSONException) if the depth exceeds the max depth.\nParams:\n    json = json-formatted string to parse\n    options = enable decoding string representations of NaN/Inf as float values\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!T",
				"char": 11,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "toJSON",
				"line": 998,
				"comment": "Takes a tree of JSON values and returns the serialized string.\n\nAny Object types will be serialized in a key-sorted order.\n\nIf $(D pretty) is false no whitespaces are generated.\nIf $(D pretty) is true serialized string is formatted to be human-readable.\nSet the $(specialFloatLiterals) flag is set in $(D options) to encode NaN/Infinity as strings.\n",
				"deco": "FxPS3std4json9JSONValuexbxE3std4json11JSONOptionsZAya",
				"parameters": [
					{
						"name": "root",
						"deco": "xPS3std4json9JSONValue"
					},
					{
						"name": "pretty",
						"deco": "xb",
						"default": "false"
					},
					{
						"name": "options",
						"deco": "xE3std4json11JSONOptions",
						"default": "cast(JSONOptions)0"
					}
				],
				"endline": 1163,
				"originalType": "string(in JSONValue* root, in bool pretty = false, in JSONOptions options = JSONOptions.none)",
				"char": 8,
				"kind": "function"
			},
			{
				"members": [],
				"name": "JSONException",
				"line": 1189,
				"comment": "Exception thrown on JSON errors\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": "JavaScript Object Notation\n\nSynopsis:\n----\n    //parse a file or string of json into a usable structure\n    string s = \"{ \\\"language\\\": \\\"D\\\", \\\"rating\\\": 3.14, \\\"code\\\": \\\"42\\\" }\";\n    JSONValue j = parseJSON(s);\n    writeln(\"Language: \", j[\"language\"].str(),\n            \" Rating: \", j[\"rating\"].floating()\n    );\n\n    // j and j[\"language\"] return JSONValue,\n    // j[\"language\"].str returns a string\n\n    //check a type\n    long x;\n    if (const(JSONValue)* code = \"code\" in j)\n    {\n        if (code.type() == JSON_TYPE.INTEGER)\n            x = code.integer;\n        else\n            x = to!int(code.str);\n    }\n\n    // create a json struct\n    JSONValue jj = [ \"language\": \"D\" ];\n    // rating doesnt exist yet, so use .object to assign\n    jj.object[\"rating\"] = JSONValue(3.14);\n    // create an array to assign to list\n    jj.object[\"list\"] = JSONValue( [\"a\", \"b\", \"c\"] );\n    // list already exists, so .object optional\n    jj[\"list\"].array ~= JSONValue(\"D\");\n\n    s = j.toString();\n    writeln(s);\n----\n\nCopyright: Copyright Jeremie Pelletier 2008 - 2009.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   Jeremie Pelletier, David Herberth\nReferences: $(LINK http://json.org/)\nSource:    $(PHOBOSSRC std/_json.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/stdio.d",
		"name": "std.stdio",
		"members": [
			{
				"name": "KeepTerminator",
				"line": 31,
				"comment": "If flag $(D KeepTerminator) is set to $(D KeepTerminator.yes), then the delimiter\nis included in the strings returned.\n",
				"deco": "E3std8typecons45__T4FlagVAyaa14_6b6565705465726d696e61746f72Z4Flag",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "File",
				"line": 340,
				"comment": "Encapsulates a $(D FILE*). Generally D does not attempt to provide\nthin wrappers over equivalent functions in the C standard library, but\nmanipulating $(D FILE*) values directly is unsafe and error-prone in\nmany ways. The $(D File) type ensures safe manipulation, automatic\nfile closing, and a lot of convenience.\n\nThe underlying $(D FILE*) handle is maintained in a reference-counted\nmanner, such that as soon as the last $(D File) variable bound to a\ngiven $(D FILE*) goes out of scope, the underlying $(D FILE*) is\nautomatically closed.\n\nExample:\n----\n// test.d\nvoid main(string[] args)\n{\n    auto f = File(\"test.txt\", \"w\"); // open for writing\n    f.write(\"Hello\");\n    if (args.length > 1)\n    {\n        auto g = f; // now g and f write to the same file\n                    // internal reference count is 2\n        g.write(\", \", args[1]);\n        // g exits scope, reference count decreases to 1\n    }\n    f.writeln(\"!\");\n    // f exits scope, reference count falls to zero,\n    // underlying $(D FILE*) is closed.\n}\n----\n$(CONSOLE\n% rdmd test.d Jimmy\n% cat test.txt\nHello, Jimmy!\n% __\n)\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 388,
						"comment": "Constructor taking the name of the file to open and the open mode.\n\nCopying one $(D File) object to another results in the two $(D File)\nobjects referring to the same underlying file.\n\nThe destructor automatically closes the file as soon as no $(D File)\nobject refers to it anymore.\n\nParams:\n    name = range or string representing the file _name\n    stdioOpenmode = range or string represting the open mode\n        (with the same semantics as in the C standard library\n        $(WEB cplusplus.com/reference/clibrary/cstdio/fopen.html, fopen)\n        function)\n\nThrows: $(D ErrnoException) if the file could not be opened.\n",
						"deco": "FNcNfAyaxAaZS3std5stdio4File",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							},
							{
								"name": "stdioOpenmode",
								"deco": "xAa",
								"default": "\"rb\""
							}
						],
						"endline": 411,
						"originalType": "ref @safe (string name, in char[] stdioOpenmode = \"rb\")",
						"char": 5,
						"kind": "constructor"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 414,
								"type": "(R1 name)",
								"parameters": [
									{
										"name": "name",
										"type": "R1"
									}
								],
								"endline": 419,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 414,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!R1 && isSomeChar!(ElementEncodingType!R1)",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 422,
								"type": "(R1 name, R2 mode)",
								"parameters": [
									{
										"name": "name",
										"type": "R1"
									},
									{
										"name": "mode",
										"type": "R2"
									}
								],
								"endline": 428,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 422,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!R1 && isSomeChar!(ElementEncodingType!R1) && isInputRange!R2 && isSomeChar!(ElementEncodingType!R2)",
						"char": 5,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opAssign",
						"line": 457,
						"comment": "Assigns a file to another. The target of the assignment gets detached\nfrom whatever file it was attached to, and attaches itself to the new\nfile.\n",
						"deco": "FNfS3std5stdio4FileZv",
						"parameters": [
							{
								"name": "rhs",
								"deco": "S3std5stdio4File"
							}
						],
						"endline": 462,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "open",
						"line": 472,
						"comment": "First calls $(D detach) (throwing on failure), and then attempts to\n_open file $(D name) with mode $(D stdioOpenmode). The mode has the\nsame semantics as in the C standard library $(WEB\ncplusplus.com/reference/clibrary/cstdio/fopen.html, fopen) function.\n\nThrows: $(D ErrnoException) in case of error.\n",
						"deco": "FNfAyaxAaZv",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							},
							{
								"name": "stdioOpenmode",
								"deco": "xAa",
								"default": "\"rb\""
							}
						],
						"endline": 476,
						"originalType": "@safe void(string name, in char[] stdioOpenmode = \"rb\")",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "popen",
						"line": 485,
						"comment": "First calls $(D detach) (throwing on failure), and then runs a command\nby calling the C standard library function $(WEB\nopengroup.org/onlinepubs/007908799/xsh/_popen.html, _popen).\n\nThrows: $(D ErrnoException) in case of error.\n",
						"deco": "FNfAyaxAaZv",
						"parameters": [
							{
								"name": "command",
								"deco": "Aya"
							},
							{
								"name": "stdioOpenmode",
								"deco": "xAa",
								"default": "\"r\""
							}
						],
						"endline": 493,
						"originalType": "@safe void(string command, in char[] stdioOpenmode = \"r\")",
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fdopen",
						"line": 502,
						"comment": "First calls $(D detach) (throwing on failure), and then attempts to\nassociate the given file descriptor with the $(D File). The mode must\nbe compatible with the mode of the file descriptor.\n\nThrows: $(D ErrnoException) in case of error.\n",
						"deco": "FNfixAaZv",
						"parameters": [
							{
								"name": "fd",
								"deco": "i"
							},
							{
								"name": "stdioOpenmode",
								"deco": "xAa",
								"default": "\"rb\""
							}
						],
						"endline": 505,
						"originalType": "@safe void(int fd, in char[] stdioOpenmode = \"rb\")",
						"char": 10,
						"kind": "function"
					},
					{
						"name": "windowsHandleOpen",
						"line": 557,
						"comment": "First calls $(D detach) (throwing on failure), and then attempts to\nassociate the given Windows $(D HANDLE) with the $(D File). The mode must\nbe compatible with the access attributes of the handle. Windows only.\n\nThrows: $(D ErrnoException) in case of error.\n",
						"deco": "FixAaZv",
						"parameters": [
							{
								"name": "handle",
								"deco": "i"
							},
							{
								"name": "stdioOpenmode",
								"deco": "xAa"
							}
						],
						"originalType": "void(HANDLE handle, in char[] stdioOpenmode)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isOpen",
						"line": 593,
						"comment": " Returns $(D true) if the file is opened.\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 596,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "eof",
						"line": 604,
						"comment": "Returns $(D true) if the file is at end (see $(WEB\ncplusplus.com/reference/clibrary/cstdio/feof.html, feof)).\n\nThrows: $(D Exception) if the file is not opened.\n",
						"deco": "xFNaNdNeZb",
						"endline": 610,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "name",
						"line": 615,
						"comment": " Returns the name of the last opened file, if any.\nIf a $(D File) was created with $(LREF tmpfile) and $(LREF wrapFile)\nit has no name.\n",
						"deco": "xFNaNbNdNfZAya",
						"endline": 618,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "error",
						"line": 625,
						"comment": "If the file is not opened, returns $(D false). Otherwise, returns\n$(WEB cplusplus.com/reference/clibrary/cstdio/ferror.html, ferror) for\nthe file handle.\n",
						"deco": "xFNaNbNdNeZb",
						"endline": 628,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "detach",
						"line": 647,
						"comment": "Detaches from the underlying file. If the sole owner, calls $(D close).\n\nThrows: $(D ErrnoException) on failure if closing the file.\n",
						"deco": "FNfZv",
						"endline": 658,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "close",
						"line": 686,
						"comment": "If the file was unopened, succeeds vacuously. Otherwise closes the\nfile (by calling $(WEB\ncplusplus.com/reference/clibrary/cstdio/fclose.html, fclose)),\nthrowing on error. Even if an exception is thrown, afterwards the $(D\nFile) object is empty. This is different from $(D detach) in that it\nalways closes the file; consequently, all other $(D File) objects\nreferring to the same handle will see a closed file henceforth.\n\nThrows: $(D ErrnoException) on error.\n",
						"deco": "FNeZv",
						"endline": 719,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearerr",
						"line": 726,
						"comment": "If the file is not opened, succeeds vacuously. Otherwise, returns\n$(WEB cplusplus.com/reference/clibrary/cstdio/_clearerr.html,\n_clearerr) for the file handle.\n",
						"deco": "FNaNbNfZv",
						"endline": 730,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "flush",
						"line": 740,
						"comment": "Flushes the C $(D FILE) buffers.\n\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/_fflush.html, _fflush)\nfor the file handle.\n\nThrows: $(D Exception) if the file is not opened or if the call to $(D fflush) fails.\n",
						"deco": "FNeZv",
						"endline": 746,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sync",
						"line": 774,
						"comment": "Forces any data buffered by the OS to be written to disk.\nCall $(LREF flush) before calling this function to flush the C $(D FILE) buffers first.\n\nThis function calls\n$(WEB msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx,\n$(D FlushFileBuffers)) on Windows and\n$(WEB pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html,\n$(D fsync)) on POSIX for the file handle.\n\nThrows: $(D Exception) if the file is not opened or if the OS call fails.\n",
						"deco": "FNeZv",
						"endline": 787,
						"char": 10,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "rawRead",
								"line": 803,
								"type": "T[](T[] buffer)",
								"parameters": [
									{
										"name": "buffer",
										"type": "T[]"
									}
								],
								"endline": 833,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "rawRead",
						"line": 803,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/fread.html, fread) for the\nfile handle. The number of items to read and the size of\neach item is inferred from the size and type of the input array, respectively.\n\nReturns: The slice of $(D buffer) containing the data that was actually read.\nThis will be shorter than $(D buffer) if EOF was reached before the buffer\ncould be filled.\n\nThrows: $(D Exception) if $(D buffer) is empty.\n        $(D ErrnoException) if the file is not opened or the call to $(D fread) fails.\n\n$(D rawRead) always reads in binary mode on Windows.\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 9,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "rawWrite",
								"line": 862,
								"type": "void(in T[] buffer)",
								"parameters": [
									{
										"name": "buffer",
										"type": "T[]",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 891,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "rawWrite",
						"line": 862,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/fwrite.html, fwrite) for the file\nhandle. The number of items to write and the size of each\nitem is inferred from the size and type of the input array, respectively. An\nerror is thrown if the buffer could not be written in its entirety.\n\n$(D rawWrite) always writes in binary mode on Windows.\n\nThrows: $(D ErrnoException) if the file is not opened or if the call to $(D fwrite) fails.\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "seek",
						"line": 912,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/fseek.html, fseek)\nfor the file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $(D fseek) fails.\n",
						"deco": "FNeliZv",
						"parameters": [
							{
								"name": "offset",
								"deco": "l"
							},
							{
								"name": "origin",
								"deco": "i",
								"default": "0"
							}
						],
						"endline": 930,
						"originalType": "@trusted void(long offset, int origin = SEEK_SET)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "tell",
						"line": 971,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/ftell.html, ftell) for the\nmanaged file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $(D ftell) fails.\n",
						"deco": "xFNdNeZm",
						"endline": 988,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "rewind",
						"line": 1010,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/_rewind.html, _rewind)\nfor the file handle.\n\nThrows: $(D Exception) if the file is not opened.\n",
						"deco": "FNfZv",
						"endline": 1016,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setvbuf",
						"line": 1025,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/_setvbuf.html, _setvbuf) for\nthe file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $(D setvbuf) fails.\n",
						"deco": "FNemiZv",
						"parameters": [
							{
								"name": "size",
								"deco": "m"
							},
							{
								"name": "mode",
								"deco": "i",
								"default": "0"
							}
						],
						"endline": 1032,
						"originalType": "@trusted void(size_t size, int mode = _IOFBF)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setvbuf",
						"line": 1041,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/_setvbuf.html,\n_setvbuf) for the file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $(D setvbuf) fails.\n",
						"deco": "FNeAviZv",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							},
							{
								"name": "mode",
								"deco": "i",
								"default": "0"
							}
						],
						"endline": 1049,
						"originalType": "@trusted void(void[] buf, int mode = _IOFBF)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "lock",
						"line": 1113,
						"comment": "Locks the specified file segment. If the file segment is already locked\nby another process, waits until the existing lock is released.\nIf both $(D start) and $(D length) are zero, the entire file is locked.\n\nLocks created using $(D lock) and $(D tryLock) have the following properties:\n$(UL\n $(LI All locks are automatically released when the process terminates.)\n $(LI Locks are not inherited by child processes.)\n $(LI Closing a file will release all locks associated with the file. On POSIX,\n      even locks acquired via a different $(D File) will be released as well.)\n $(LI Not all NFS implementations correctly implement file locking.)\n)\n",
						"deco": "FE3std5stdio8LockTypemmZv",
						"parameters": [
							{
								"name": "lockType",
								"deco": "E3std5stdio8LockType",
								"default": "cast(LockType)1"
							},
							{
								"name": "start",
								"deco": "m",
								"default": "0LU"
							},
							{
								"name": "length",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 1137,
						"originalType": "void(LockType lockType = LockType.readWrite, ulong start = 0, ulong length = 0)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "tryLock",
						"line": 1145,
						"comment": "Attempts to lock the specified file segment.\nIf both $(D start) and $(D length) are zero, the entire file is locked.\nReturns: $(D true) if the lock was successful, and $(D false) if the\nspecified file segment was already locked.\n",
						"deco": "FE3std5stdio8LockTypemmZb",
						"parameters": [
							{
								"name": "lockType",
								"deco": "E3std5stdio8LockType",
								"default": "cast(LockType)1"
							},
							{
								"name": "start",
								"deco": "m",
								"default": "0LU"
							},
							{
								"name": "length",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 1178,
						"originalType": "bool(LockType lockType = LockType.readWrite, ulong start = 0, ulong length = 0)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "unlock",
						"line": 1183,
						"comment": "Removes the lock over the specified file segment.\n",
						"deco": "FmmZv",
						"parameters": [
							{
								"name": "start",
								"deco": "m",
								"default": "0LU"
							},
							{
								"name": "length",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 1202,
						"originalType": "void(ulong start = 0, ulong length = 0)",
						"char": 10,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "write",
								"line": 1287,
								"type": "void(S args)",
								"parameters": [
									{
										"name": "args",
										"type": "S"
									}
								],
								"endline": 1328,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "write",
						"line": 1287,
						"comment": "Writes its arguments in text format to the file.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
						"parameters": [
							{
								"name": "S",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "writeln",
								"line": 1336,
								"type": "void(S args)",
								"parameters": [
									{
										"name": "args",
										"type": "S"
									}
								],
								"endline": 1339,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "writeln",
						"line": 1336,
						"comment": "Writes its arguments in text format to the file, followed by a newline.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
						"parameters": [
							{
								"name": "S",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "writef",
								"line": 1348,
								"type": "void(in Char[] fmt, A args)",
								"parameters": [
									{
										"name": "fmt",
										"type": "Char[]",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "args",
										"type": "A"
									}
								],
								"endline": 1353,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "writef",
						"line": 1348,
						"comment": "Writes its arguments in text format to the file, according to the\nformat in the first argument.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
						"parameters": [
							{
								"name": "Char",
								"kind": "type"
							},
							{
								"name": "A",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "writefln",
								"line": 1362,
								"type": "void(in Char[] fmt, A args)",
								"parameters": [
									{
										"name": "fmt",
										"type": "Char[]",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "args",
										"type": "A"
									}
								],
								"endline": 1369,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "writefln",
						"line": 1362,
						"comment": "Writes its arguments in text format to the file, according to the\nformat in the first argument, followed by a newline.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
						"parameters": [
							{
								"name": "Char",
								"kind": "type"
							},
							{
								"name": "A",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "readln",
								"line": 1404,
								"type": "S(dchar terminator = '\\x0a')",
								"parameters": [
									{
										"name": "terminator",
										"deco": "w",
										"default": "'\\x0a'"
									}
								],
								"endline": 1410,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "readln",
						"line": 1404,
						"comment": "Read line from the file handle and return it as a specified type.\n\nThis version manages its own read buffer, which means one memory allocation per call. If you are not\nretaining a reference to the read data, consider the $(D File.readln(buf)) version, which may offer\nbetter performance as it can reuse its read buffer.\n\nParams:\n    S = Template parameter; the type of the allocated buffer, and the type returned. Defaults to $(D string).\n    terminator = Line terminator (by default, $(D '\\n')).\n\nNote:\n    String terminators are not supported due to ambiguity with readln(buf) below.\n\nReturns:\n    The line that was read, including the line terminator character.\n\nThrows:\n    $(D StdioException) on I/O error, or $(D UnicodeException) on Unicode conversion error.\n\nExample:\n---\n// Reads $(D stdin) and writes it to $(D stdout).\nimport std.stdio;\n\nvoid main()\n{\n    string line;\n    while ((line = stdin.readln()) !is null)\n        write(line);\n}\n---\n",
						"parameters": [
							{
								"name": "S",
								"default": "string",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "readln",
								"line": 1532,
								"type": "size_t(ref C[] buf, dchar terminator = '\\x0a')",
								"parameters": [
									{
										"name": "buf",
										"type": "C[]",
										"storageClass": [
											"ref"
										]
									},
									{
										"name": "terminator",
										"deco": "w",
										"default": "'\\x0a'"
									}
								],
								"endline": 1561,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "readln",
						"line": 1532,
						"comment": "Read line from the file handle and write it to $(D buf[]), including\nterminating character.\n\nThis can be faster than $(D line = File.readln()) because you can reuse\nthe buffer for each call. Note that reusing the buffer means that you\nmust copy the previous contents if you wish to retain them.\n\nParams:\nbuf = Buffer used to store the resulting line data. buf is\nresized as necessary.\nterminator = Line terminator (by default, $(D '\\n')). Use\n$(XREF ascii, newline) for portability (unless the file was opened in\ntext mode).\n\nReturns:\n0 for end of file, otherwise number of characters read\n\nThrows: $(D StdioException) on I/O error, or $(D UnicodeException) on Unicode\nconversion error.\n\nExample:\n---\n// Read lines from $(D stdin) into a string\n// Ignore lines starting with '#'\n// Write the string to $(D stdout)\n\nvoid main()\n{\n    string output;\n    char[] buf;\n\n    while (stdin.readln(buf))\n    {\n        if (buf[0] == '#')\n            continue;\n\n        output ~= buf;\n    }\n\n    write(output);\n}\n---\n\nThis method can be more efficient than the one in the previous example\nbecause $(D stdin.readln(buf)) reuses (if possible) memory allocated\nfor $(D buf), whereas $(D line = stdin.readln()) makes a new memory allocation\nfor every line.\n\nFor even better performance you can help $(D readln) by passing in a\nlarge buffer to avoid memory reallocations. This can be done by reusing the\nlargest buffer returned by $(D readln):\n\nExample:\n---\n// Read lines from $(D stdin) and count words\n\nvoid main()\n{\n    char[] buf;\n    size_t words = 0;\n\n    while (!stdin.eof)\n    {\n        char[] line = buf;\n        stdin.readln(line);\n        if (line.length > buf.length)\n            buf = line;\n\n        words += line.split.length;\n    }\n\n    writeln(words);\n}\n---\nThis is actually what $(LREF byLine) does internally, so its usage\nis recommended if you want to process a complete file.\n",
						"parameters": [
							{
								"name": "C",
								"kind": "type"
							}
						],
						"constraint": "isSomeChar!C && is(Unqual!C == C) && !is(C == enum)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "readln",
								"line": 1603,
								"type": "size_t(ref C[] buf, R terminator)",
								"parameters": [
									{
										"name": "buf",
										"type": "C[]",
										"storageClass": [
											"ref"
										]
									},
									{
										"name": "terminator",
										"type": "R"
									}
								],
								"endline": 1625,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "readln",
						"line": 1603,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "C",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isSomeChar!C && is(Unqual!C == C) && !is(C == enum) && isBidirectionalRange!R && is(typeof(terminator.front == (dchar).init))",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "readf",
								"line": 1655,
								"type": "uint(in char[] format, Data data)",
								"parameters": [
									{
										"name": "format",
										"type": "char[]",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "data",
										"type": "Data"
									}
								],
								"endline": 1662,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "readf",
						"line": 1655,
						"comment": " Read data from the file according to the specified\n $(LINK2 std_format.html#_format-string, format specifier) using\n $(XREF _format,formattedRead).\n",
						"parameters": [
							{
								"name": "Data",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "tmpfile",
						"line": 1688,
						"comment": " Returns a temporary file by calling $(WEB\n cplusplus.com/reference/clibrary/cstdio/_tmpfile.html, _tmpfile).\n Note that the created file has no $(LREF name).\n",
						"deco": "FNfZS3std5stdio4File",
						"endline": 1695,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "wrapFile",
						"line": 1701,
						"comment": "Unsafe function that wraps an existing $(D FILE*). The resulting $(D\nFile) never takes the initiative in closing the file.\nNote that the created file has no $(LREF name)\n",
						"deco": "FNfPOS4core4stdc5stdio8_IO_FILEZS3std5stdio4File",
						"parameters": [
							{
								"name": "f",
								"deco": "POS4core4stdc5stdio8_IO_FILE"
							}
						],
						"endline": 1707,
						"originalType": "@safe File(FILE* f)",
						"char": 29,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getFP",
						"line": 1712,
						"comment": "Returns the $(D FILE*) corresponding to this object.\n",
						"deco": "FNaNfZPOS4core4stdc5stdio8_IO_FILE",
						"endline": 1719,
						"originalType": "pure @safe FILE*()",
						"char": 11,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fileno",
						"line": 1730,
						"comment": "Returns the file number corresponding to this object.\n",
						"deco": "xFNdNeZi",
						"endline": 1736,
						"char": 38,
						"kind": "function"
					},
					{
						"name": "windowsHandle",
						"line": 1742,
						"comment": "Returns the underlying operating system $(D HANDLE) (Windows only).\n",
						"deco": "FNdZi",
						"originalType": "@property HANDLE()",
						"char": 22,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "byLine",
								"line": 1923,
								"type": "(KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a')",
								"parameters": [
									{
										"name": "keepTerminator",
										"type": "KeepTerminator",
										"default": "KeepTerminator.no"
									},
									{
										"name": "terminator",
										"type": "Terminator",
										"default": "'\\x0a'"
									}
								],
								"endline": 1929,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "byLine",
						"line": 1923,
						"comment": "Returns an input range set up to read from the file handle one line\nat a time.\n\nThe element type for the range will be $(D Char[]). Range primitives\nmay throw $(D StdioException) on I/O error.\n\nNote:\nEach $(D front) will not persist after $(D\npopFront) is called, so the caller must copy its contents (e.g. by\ncalling $(D to!string)) when retention is needed. If the caller needs\nto retain a copy of every line, use the $(LREF byLineCopy) function\ninstead.\n\nParams:\nChar = Character type for each line, defaulting to $(D char).\nkeepTerminator = Use $(D KeepTerminator.yes) to include the\nterminator at the end of each line.\nterminator = Line separator ($(D '\\n') by default). Use\n$(XREF ascii, newline) for portability (unless the file was opened in\ntext mode).\n\nExample:\n----\nimport std.algorithm, std.stdio, std.string;\n// Count words in a file using ranges.\nvoid main()\n{\n    auto file = File(\"file.txt\"); // Open for reading\n    const wordCount = file.byLine()            // Read lines\n                          .map!split           // Split into words\n                          .map!(a => a.length) // Count words per line\n                          .sum();              // Total word count\n    writeln(wordCount);\n}\n----\n\nExample:\n----\nimport std.range, std.stdio;\n// Read lines using foreach.\nvoid main()\n{\n    auto file = File(\"file.txt\"); // Open for reading\n    auto range = file.byLine();\n    // Print first three lines\n    foreach (line; range.take(3))\n        writeln(line);\n    // Print remaining lines beginning with '#'\n    foreach (line; range)\n    {\n        if (!line.empty && line[0] == '#')\n            writeln(line);\n    }\n}\n----\nNotice that neither example accesses the line data returned by\n$(D front) after the corresponding $(D popFront) call is made (because\nthe contents may well have changed).\n",
						"parameters": [
							{
								"defaultDeco": "a",
								"name": "Terminator",
								"kind": "type"
							},
							{
								"defaultDeco": "a",
								"name": "Char",
								"kind": "type"
							}
						],
						"constraint": "isScalarType!Terminator",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "byLine",
								"line": 1932,
								"type": "(KeepTerminator keepTerminator, Terminator terminator)",
								"parameters": [
									{
										"name": "keepTerminator",
										"type": "KeepTerminator"
									},
									{
										"name": "terminator",
										"type": "Terminator"
									}
								],
								"endline": 1937,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "byLine",
						"line": 1932,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "Terminator",
								"kind": "type"
							},
							{
								"defaultDeco": "a",
								"name": "Char",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!(ElementEncodingType!Terminator) == Char)",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "byLineCopy",
								"line": 2060,
								"type": "(KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a')",
								"parameters": [
									{
										"name": "keepTerminator",
										"type": "KeepTerminator",
										"default": "KeepTerminator.no"
									},
									{
										"name": "terminator",
										"type": "Terminator",
										"default": "'\\x0a'"
									}
								],
								"endline": 2066,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "byLineCopy",
						"line": 2060,
						"comment": "Returns an input range set up to read from the file handle one line\nat a time. Each line will be newly allocated. $(D front) will cache\nits value to allow repeated calls without unnecessary allocations.\n\nNote: Due to caching byLineCopy can be more memory-efficient than\n$(D File.byLine.map!idup).\n\nThe element type for the range will be $(D Char[]). Range\nprimitives may throw $(D StdioException) on I/O error.\n\nParams:\nChar = Character type for each line, defaulting to $(D immutable char).\nkeepTerminator = Use $(D KeepTerminator.yes) to include the\nterminator at the end of each line.\nterminator = Line separator ($(D '\\n') by default). Use\n$(XREF ascii, newline) for portability (unless the file was opened in\ntext mode).\n\nExample:\n----\nimport std.algorithm, std.array, std.stdio;\n// Print sorted lines of a file.\nvoid main()\n{\n    auto sortedLines = File(\"file.txt\")   // Open for reading\n                       .byLineCopy()      // Read persistent lines\n                       .array()           // into an array\n                       .sort();           // then sort them\n    foreach (line; sortedLines)\n        writeln(line);\n}\n----\nSee_Also:\n$(XREF file,readText)\n",
						"parameters": [
							{
								"defaultDeco": "a",
								"name": "Terminator",
								"kind": "type"
							},
							{
								"defaultDeco": "ya",
								"name": "Char",
								"kind": "type"
							}
						],
						"constraint": "isScalarType!Terminator",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "byLineCopy",
								"line": 2069,
								"type": "(KeepTerminator keepTerminator, Terminator terminator)",
								"parameters": [
									{
										"name": "keepTerminator",
										"type": "KeepTerminator"
									},
									{
										"name": "terminator",
										"type": "Terminator"
									}
								],
								"endline": 2074,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "byLineCopy",
						"line": 2069,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "Terminator",
								"kind": "type"
							},
							{
								"defaultDeco": "ya",
								"name": "Char",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!(ElementEncodingType!Terminator) == Unqual!Char)",
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "byChunk",
						"line": 2397,
						"comment": "Returns an input range set up to read from the file handle a chunk at a\ntime.\n\nThe element type for the range will be $(D ubyte[]). Range primitives\nmay throw $(D StdioException) on I/O error.\n\nExample:\n---------\nvoid main()\n{\n    // Read standard input 4KB at a time\n    foreach (ubyte[] buffer; stdin.byChunk(4096))\n    {\n        ... use buffer ...\n    }\n}\n---------\n\nThe parameter may be a number (as shown in the example above) dictating the\nsize of each chunk. Alternatively, $(D byChunk) accepts a\nuser-provided buffer that it uses directly.\n\nExample:\n---------\nvoid main()\n{\n    // Read standard input 4KB at a time\n    foreach (ubyte[] buffer; stdin.byChunk(new ubyte[4096]))\n    {\n        ... use buffer ...\n    }\n}\n---------\n\nIn either case, the content of the buffer is reused across calls. That means\n$(D front) will not persist after $(D popFront) is called, so if retention is\nneeded, the caller must copy its contents (e.g. by calling $(D buffer.dup)).\n\nIn the  example above, $(D buffer.length) is 4096 for all iterations, except\nfor the last one, in which case $(D buffer.length) may be less than 4096 (but\nalways greater than zero).\n\nWith the mentioned limitations, $(D byChunks) works with any algorithm\ncompatible with input ranges.\n\nExample:\n---\n// Efficient file copy, 1MB at a time.\nimport std.algorithm, std.stdio;\nvoid main()\n{\n    stdin.byChunk(1024 * 1024).copy(stdout.lockingTextWriter());\n}\n---\n\n$(XREF_PACK algorithm,iteration,joiner) can be used to join chunks together into\na single range lazily.\nExample:\n---\nimport std.algorithm, std.stdio;\nvoid main()\n{\n    //Range of ranges\n    static assert(is(typeof(stdin.byChunk(4096).front) == ubyte[]));\n    //Range of elements\n    static assert(is(typeof(stdin.byChunk(4096).joiner.front) == ubyte));\n}\n---\n\nReturns: A call to $(D byChunk) returns a range initialized with the $(D File)\nobject and the appropriate buffer.\n\nThrows: If the user-provided size is zero or the user-provided buffer\nis empty, throws an $(D Exception). In case of an I/O error throws\n$(D StdioException).\n",
						"deco": "FmZS3std5stdio4File7ByChunk",
						"parameters": [
							{
								"name": "chunkSize",
								"deco": "m"
							}
						],
						"endline": 2400,
						"originalType": "(size_t chunkSize)",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					},
					{
						"endchar": 5,
						"name": "byChunk",
						"line": 2402,
						"comment": "Ditto\n",
						"deco": "FAhZS3std5stdio4File7ByChunk",
						"parameters": [
							{
								"name": "buffer",
								"deco": "Ah"
							}
						],
						"endline": 2405,
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "lockingTextWriter",
						"line": 2640,
						"comment": " Returns an output range that locks the file and allows fast writing to it.\n\nSee $(LREF byChunk) for an example.\n",
						"deco": "FNfZS3std5stdio4File17LockingTextWriter",
						"endline": 2643,
						"originalType": "@safe ()",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					},
					{
						"endchar": 5,
						"name": "size",
						"line": 2646,
						"comment": "Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.\n",
						"deco": "FNdNfZm",
						"endline": 2655,
						"char": 21,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "read",
						"line": 2846,
						"value": "0",
						"comment": "Specifies a _read (shared) lock. A _read lock denies all processes\n\nwrite access to the specified region of the file, including the\n\nprocess that first locks the region. All processes can _read the\n\nlocked region. Multiple simultaneous _read locks are allowed, as\n\nlong as there are no exclusive locks.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "readWrite",
						"line": 2851,
						"value": "1",
						"comment": "Specifies a read/write (exclusive) lock. A read/write lock denies all\n\nother processes both read and write access to the locked file region.\n\nIf a segment has an exclusive lock, it may not have any shared locks\n\nor other exclusive locks.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "LockType",
				"line": 2839,
				"comment": "Used to specify the lock type for $(D File.lock) and $(D File.tryLock).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "isFileHandle",
						"line": 3007,
						"init": "is(T : FILE*) || is(T : File)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isFileHandle",
				"line": 3005,
				"comment": " Indicates whether $(D T) is a file handle of some kind.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "isStreamingDevice",
				"line": 3022,
				"comment": " $(RED Deprecated. Please use $(D isFileHandle) instead. This alias will be\n       removed in June 2015.)\n",
				"storageClass": [
					"deprecated"
				],
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "write",
						"line": 3037,
						"type": "void(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3040,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "write",
				"line": 3037,
				"comment": "For each argument $(D arg) in $(D args), format the argument (as per\n$(LINK2 std_conv.html, to!(string)(arg))) and write the resulting\nstring to $(D args[0]). A call without any arguments will fail to\ncompile.\n\nThrows: In case of an I/O error, throws an $(D StdioException).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "!is(T[0] : File)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "writeln",
						"line": 3073,
						"type": "void(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3108,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "writeln",
				"line": 3073,
				"comment": " Equivalent to $(D write(args, '\\n')).  Calling $(D writeln) without\n arguments is valid and just prints a newline to the standard\n output.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "writef",
						"line": 3248,
						"type": "void(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3251,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "writef",
				"line": 3248,
				"comment": "Writes formatted data to standard output (without a trailing newline).\n\nParams:\nargs = The first argument $(D args[0]) should be the format string, specifying\nhow to format the rest of the arguments. For a full description of the syntax\nof the format string and how it controls the formatting of the rest of the\narguments, please refer to the documentation for $(XREF format,\nformattedWrite).\n\nNote: In older versions of Phobos, it used to be possible to write:\n\n------\nwritef(stderr, \"%s\", \"message\");\n------\n\nto print a message to $(D stderr). This syntax is no longer supported, and has\nbeen superceded by:\n\n------\nstderr.writef(\"%s\", \"message\");\n------\n\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "writefln",
						"line": 3279,
						"type": "void(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3282,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "writefln",
				"line": 3279,
				"comment": " Equivalent to $(D writef(args, '\\n')).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "readf",
						"line": 3329,
						"type": "uint(in char[] format, A args)",
						"parameters": [
							{
								"name": "format",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "args",
								"type": "A"
							}
						],
						"endline": 3332,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "readf",
				"line": 3329,
				"comment": " Read data from $(D stdin) according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n",
				"parameters": [
					{
						"name": "A",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "readln",
						"line": 3374,
						"type": "S(dchar terminator = '\\x0a')",
						"parameters": [
							{
								"name": "terminator",
								"deco": "w",
								"default": "'\\x0a'"
							}
						],
						"endline": 3378,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "readln",
				"line": 3374,
				"comment": " Read line from $(D stdin).\n\n This version manages its own read buffer, which means one memory allocation per call. If you are not\n retaining a reference to the read data, consider the $(D readln(buf)) version, which may offer\n better performance as it can reuse its read buffer.\n\n Returns:\n        The line that was read, including the line terminator character.\n Params:\n        S = Template parameter; the type of the allocated buffer, and the type returned. Defaults to $(D string).\n        terminator = Line terminator (by default, $(D '\\n')).\n Note:\n        String terminators are not supported due to ambiguity with readln(buf) below.\n Throws:\n        $(D StdioException) on I/O error, or $(D UnicodeException) on Unicode conversion error.\n Example:\n        Reads $(D stdin) and writes it to $(D stdout).\n---\nimport std.stdio;\n\nvoid main()\n{\n    string line;\n    while ((line = readln()) !is null)\n        write(line);\n}\n---\n",
				"parameters": [
					{
						"name": "S",
						"default": "string",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "readln",
						"line": 3408,
						"type": "size_t(ref C[] buf, dchar terminator = '\\x0a')",
						"parameters": [
							{
								"name": "buf",
								"type": "C[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "terminator",
								"deco": "w",
								"default": "'\\x0a'"
							}
						],
						"endline": 3412,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "readln",
				"line": 3408,
				"comment": " Read line from $(D stdin) and write it to buf[], including terminating character.\n\n This can be faster than $(D line = readln()) because you can reuse\n the buffer for each call. Note that reusing the buffer means that you\n must copy the previous contents if you wish to retain them.\n\n Returns:\n        $(D size_t) 0 for end of file, otherwise number of characters read\n Params:\n        buf = Buffer used to store the resulting line data. buf is resized as necessary.\n        terminator = Line terminator (by default, $(D '\\n')). Use $(XREF ascii, newline)\n        for portability (unless the file was opened in text mode).\n Throws:\n        $(D StdioException) on I/O error, or $(D UnicodeException) on Unicode conversion error.\n Example:\n        Reads $(D stdin) and writes it to $(D stdout).\n---\nimport std.stdio;\n\nvoid main()\n{\n    char[] buf;\n    while (readln(buf))\n        write(buf);\n}\n---\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C && is(Unqual!C == C) && !is(C == enum)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "readln",
						"line": 3415,
						"type": "size_t(ref C[] buf, R terminator)",
						"parameters": [
							{
								"name": "buf",
								"type": "C[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "terminator",
								"type": "R"
							}
						],
						"endline": 3420,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "readln",
				"line": 3415,
				"comment": " ditto\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C && is(Unqual!C == C) && !is(C == enum) && isBidirectionalRange!R && is(typeof(terminator.front == (dchar).init))",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "popen",
						"line": 3494,
						"type": "nothrow @nogc @trusted FILE*(R1 name, R2 mode = \"r\")",
						"parameters": [
							{
								"name": "name",
								"type": "R1"
							},
							{
								"name": "mode",
								"type": "R2",
								"default": "\"r\""
							}
						],
						"endline": 3509,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "popen",
				"line": 3494,
				"comment": " Convenience function that forwards to $(D core.sys.posix.stdio.popen)\n with appropriately-constructed C-style strings.\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "(isInputRange!R1 && isSomeChar!(ElementEncodingType!R1) || isSomeString!R1) && (isInputRange!R2 && isSomeChar!(ElementEncodingType!R2) || isSomeString!R2)",
				"char": 11,
				"kind": "template"
			},
			{
				"name": "lines",
				"line": 3570,
				"comment": " Iterates through the lines of a file by using $(D foreach).\n\n Example:\n\n---------\nvoid main()\n{\n  foreach (string line; lines(stdin))\n  {\n    ... use line ...\n  }\n}\n---------\nThe line terminator ($(D '\\n') by default) is part of the string read (it\ncould be missing in the last line of the file). Several types are\nsupported for $(D line), and the behavior of $(D lines)\nchanges accordingly:\n\n$(OL $(LI If $(D line) has type $(D string), $(D\nwstring), or $(D dstring), a new string of the respective type\nis allocated every read.) $(LI If $(D line) has type $(D\nchar[]), $(D wchar[]), $(D dchar[]), the line's content\nwill be reused (overwritten) across reads.) $(LI If $(D line)\nhas type $(D immutable(ubyte)[]), the behavior is similar to\ncase (1), except that no UTF checking is attempted upon input.) $(LI\nIf $(D line) has type $(D ubyte[]), the behavior is\nsimilar to case (2), except that no UTF checking is attempted upon\ninput.))\n\nIn all cases, a two-symbols versions is also accepted, in which case\nthe first symbol (of integral type, e.g. $(D ulong) or $(D\nuint)) tracks the zero-based number of the current line.\n\nExample:\n----\n  foreach (ulong i, string line; lines(stdin))\n  {\n    ... use line ...\n  }\n----\n\n In case of an I/O error, an $(D StdioException) is thrown.\n\nSee_Also:\n$(LREF byLine)\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3582,
						"comment": "    Constructor.\n    Params:\n    f = File to read lines from.\n    terminator = Line separator ($(D '\\n') by default).\n",
						"deco": "FNcS3std5stdio4FilewZS3std5stdio5lines",
						"parameters": [
							{
								"name": "f",
								"deco": "S3std5stdio4File"
							},
							{
								"name": "terminator",
								"deco": "w",
								"default": "'\\x0a'"
							}
						],
						"endline": 3586,
						"originalType": "ref (File f, dchar terminator = '\\x0a')",
						"char": 5,
						"kind": "constructor"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "chunks",
				"line": 3832,
				"comment": "Iterates through a file a chunk at a time by using $(D foreach).\n\nExample:\n\n---------\nvoid main()\n{\n    foreach (ubyte[] buffer; chunks(stdin, 4096))\n    {\n        ... use buffer ...\n    }\n}\n---------\n\nThe content of $(D buffer) is reused across calls. In the\n example above, $(D buffer.length) is 4096 for all iterations,\n except for the last one, in which case $(D buffer.length) may\n be less than 4096 (but always greater than zero).\n\n In case of an I/O error, an $(D StdioException) is thrown.\n",
				"deco": "FS3std5stdio4FilemZS3std5stdio10ChunksImpl",
				"parameters": [
					{
						"name": "f",
						"deco": "S3std5stdio4File"
					},
					{
						"name": "size",
						"deco": "m"
					}
				],
				"endline": 3835,
				"originalType": "(File f, size_t size)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "errno",
						"line": 3935,
						"comment": "Operating system error code.\n",
						"deco": "k",
						"char": 10,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3940,
						"comment": "Initialize with a message and an error code.\n",
						"deco": "FAyakZC3std5stdio14StdioException",
						"parameters": [
							{
								"name": "message",
								"deco": "Aya"
							},
							{
								"name": "e",
								"deco": "k",
								"default": "cast(uint)errno()"
							}
						],
						"endline": 3971,
						"originalType": "(string message, uint e = core.stdc.errno.errno)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opCall",
						"line": 3974,
						"comment": " Convenience functions that throw an $(D StdioException).\n",
						"deco": "FAyaZv",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							}
						],
						"endline": 3977,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "opCall",
						"line": 3980,
						"comment": "ditto\n",
						"deco": "FZv",
						"endline": 3983,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"name": "StdioException",
				"line": 3931,
				"comment": " Thrown if I/O errors happen.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "stdin",
				"line": 4008,
				"comment": " The standard input stream.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4010_1808)\n---\n// Read stdin, sort lines, write to stdout\nimport std.stdio, std.array, std.algorithm : sort, copy;\n\nvoid main() {\n    stdin                       // read from stdin\n    .byLineCopy(KeepTerminator.yes) // copying each line\n    .array()                    // convert to array of lines\n    .sort()                     // sort the lines\n    .copy(                      // copy output of .sort to an OutputRange\n        stdout.lockingTextWriter()); // the OutputRange\n}\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4010_1808)\n",
				"deco": "S3std5stdio4File",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"__gshared"
				]
			},
			{
				"name": "stdout",
				"line": 4025,
				"comment": "The standard output stream.\n",
				"deco": "S3std5stdio4File",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"__gshared"
				]
			},
			{
				"name": "stderr",
				"line": 4026,
				"comment": "The standard error stream.\n",
				"deco": "S3std5stdio4File",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"__gshared"
				]
			},
			{
				"endchar": 5,
				"name": "openNetwork",
				"line": 4533,
				"comment": " Experimental network access via the File interface\n\n        Opens a TCP connection to the given host and port, then returns\n        a File struct with read and write access through the same interface\n        as any other file (meaning writef and the byLine ranges work!).\n\n        Authors:\n                Adam D. Ruppe\n\n        Bugs:\n                Only works on Linux\n",
				"deco": "FAyatZS3std5stdio4File",
				"parameters": [
					{
						"name": "host",
						"deco": "Aya"
					},
					{
						"name": "port",
						"deco": "t"
					}
				],
				"endline": 4571,
				"char": 10,
				"kind": "function"
			}
		],
		"comment": "Standard I/O functions that extend $(B core.stdc.stdio).  $(B core.stdc.stdio)\nis $(D_PARAM public)ally imported when importing $(B std.stdio).\n\nSource: $(PHOBOSSRC std/_stdio.d)\nMacros:\nWIKI=Phobos/StdStdio\n\nCopyright: Copyright Digital Mars 2007-.\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Alex Rønne Petersen\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/meta.d",
		"name": "std.meta",
		"members": [
			{
				"members": [
					{
						"name": "AliasSeq",
						"line": 39,
						"type": "TList",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "AliasSeq",
				"line": 37,
				"comment": " Creates a sequence of zero or more aliases. This is most commonly\n used as template parameters or arguments.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL43_1811)\n---\nimport std.meta;\nalias TL = AliasSeq!(int, double);\n\nint foo(TL td)  // same as int foo(int, double);\n{\n    return td[0] + cast(int)td[1];\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL43_1811)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL55_1812)\n---\nalias TL = AliasSeq!(int, double);\n\nalias Types = AliasSeq!(TL, char);\nstatic assert(is(Types == AliasSeq!(int, double, char)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL55_1812)\n",
				"parameters": [
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "staticIndexOf",
						"line": 70,
						"init": "genericIndexOf!(T, TList).index",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "staticIndexOf",
				"line": 68,
				"comment": " Returns the index of the first occurrence of type T in the\n sequence of zero or more types TList.\n If not found, -1 is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL80_1813)\n---\nimport std.stdio;\n\nvoid foo()\n{\n    writefln(\"The index of long is %s\",\n             staticIndexOf!(long, AliasSeq!(int, long, double)));\n    // prints: The index of long is 1\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL80_1813)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "staticIndexOf",
						"line": 76,
						"init": "genericIndexOf!(T, TList).index",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "staticIndexOf",
				"line": 74,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "IndexOf",
				"line": 143,
				"comment": "Kept for backwards compatibility\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "Erase",
						"line": 151,
						"type": "GenericErase!(T, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Erase",
				"line": 149,
				"comment": " Returns a typetuple created from TList with the first occurrence,\n if any, of T removed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL161_1815)\n---\nalias Types = AliasSeq!(int, long, double, char);\nalias TL = Erase!(long, Types);\nstatic assert(is(TL == AliasSeq!(int, double, char)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL161_1815)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Erase",
						"line": 157,
						"type": "GenericErase!(T, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Erase",
				"line": 155,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "EraseAll",
						"line": 209,
						"type": "GenericEraseAll!(T, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "EraseAll",
				"line": 207,
				"comment": " Returns a typetuple created from TList with the all occurrences,\n if any, of T removed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL219_1817)\n---\nalias Types = AliasSeq!(int, long, long, int);\n\nalias TL = EraseAll!(long, Types);\nstatic assert(is(TL == AliasSeq!(int, int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL219_1817)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "EraseAll",
						"line": 215,
						"type": "GenericEraseAll!(T, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "EraseAll",
				"line": 213,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "NoDuplicates",
				"line": 267,
				"comment": " Returns a typetuple created from TList with the all duplicate\n types removed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL277_1819)\n---\nalias Types = AliasSeq!(int, long, long, int, float);\n\nalias TL = NoDuplicates!(Types);\nstatic assert(is(TL == AliasSeq!(int, long, float)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL277_1819)\n",
				"parameters": [
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Replace",
						"line": 300,
						"type": "GenericReplace!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Replace",
				"line": 298,
				"comment": " Returns a typetuple created from TList with the first occurrence\n of type T, if found, replaced with type U.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL322_1821)\n---\nalias Types = AliasSeq!(int, long, long, int, float);\n\nalias TL = Replace!(long, char, Types);\nstatic assert(is(TL == AliasSeq!(int, char, long, int, float)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL322_1821)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Replace",
						"line": 306,
						"type": "GenericReplace!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Replace",
				"line": 304,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "U",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Replace",
						"line": 312,
						"type": "GenericReplace!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Replace",
				"line": 310,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Replace",
						"line": 318,
						"type": "GenericReplace!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Replace",
				"line": 316,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "U",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ReplaceAll",
						"line": 380,
						"type": "GenericReplaceAll!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ReplaceAll",
				"line": 378,
				"comment": " Returns a typetuple created from TList with all occurrences\n of type T, if found, replaced with type U.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL402_1823)\n---\nalias Types = AliasSeq!(int, long, long, int, float);\n\nalias TL = ReplaceAll!(long, char, Types);\nstatic assert(is(TL == AliasSeq!(int, char, char, int, float)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL402_1823)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ReplaceAll",
						"line": 386,
						"type": "GenericReplaceAll!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ReplaceAll",
				"line": 384,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "U",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ReplaceAll",
						"line": 392,
						"type": "GenericReplaceAll!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ReplaceAll",
				"line": 390,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ReplaceAll",
						"line": 398,
						"type": "GenericReplaceAll!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ReplaceAll",
				"line": 396,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "U",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Reverse",
				"line": 457,
				"comment": " Returns a typetuple created from TList with the order reversed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL473_1825)\n---\nalias Types = AliasSeq!(int, long, long, int, float);\n\nalias TL = Reverse!(Types);\nstatic assert(is(TL == AliasSeq!(float, int, long, long, int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL473_1825)\n",
				"parameters": [
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "MostDerived",
				"line": 485,
				"comment": " Returns the type from TList that is the most derived from type T.\n If none are found, T is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL496_1826)\n---\nclass A { }\nclass B : A { }\nclass C : B { }\nalias Types = AliasSeq!(A, C, B);\n\nMostDerived!(Object, Types) x;  // x is declared as type C\nstatic assert(is(typeof(x) == C));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL496_1826)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "DerivedToFront",
				"line": 511,
				"comment": " Returns the typetuple TList with the types sorted so that the most\n derived types come first.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL524_1827)\n---\nclass A { }\nclass B : A { }\nclass C : B { }\nalias Types = AliasSeq!(A, C, B);\n\nalias TL = DerivedToFront!(Types);\nstatic assert(is(TL == AliasSeq!(C, B, A)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL524_1827)\n",
				"parameters": [
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "staticMap",
				"line": 538,
				"comment": "Evaluates to $(D AliasSeq!(F!(T[0]), F!(T[1]), ..., F!(T[$ - 1]))).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL558_1828)\n---\nimport std.traits : Unqual;\nalias TL = staticMap!(Unqual, int, const int, immutable int);\nstatic assert(is(TL == AliasSeq!(int, int, int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL558_1828)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "allSatisfy",
				"line": 588,
				"comment": "Tests whether all given items satisfy a template predicate, i.e. evaluates to\n$(D F!(T[0]) && F!(T[1]) && ... && F!(T[$ - 1])).\n\nEvaluation is $(I not) short-circuited if a false result is encountered; the\ntemplate predicate must be instantiable with all the given items.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL607_1830)\n---\nimport std.traits : isIntegral;\n\nstatic assert(!allSatisfy!(isIntegral, int, double));\nstatic assert( allSatisfy!(isIntegral, int, long));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL607_1830)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "anySatisfy",
				"line": 622,
				"comment": "Tests whether any given items satisfy a template predicate, i.e. evaluates to\n$(D F!(T[0]) || F!(T[1]) || ... || F!(T[$ - 1])).\n\nEvaluation is $(I not) short-circuited if a true result is encountered; the\ntemplate predicate must be instantiable with all the given items.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL641_1831)\n---\nimport std.traits : isIntegral;\n\nstatic assert(!anySatisfy!(isIntegral, string, double));\nstatic assert( anySatisfy!(isIntegral, int, double));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL641_1831)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Filter",
				"line": 654,
				"comment": " Filters an $(D AliasSeq) using a template predicate. Returns a\n $(D AliasSeq) of the elements which satisfy the predicate.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL677_1832)\n---\nimport std.traits : isNarrowString, isUnsigned;\n\nalias Types1 = AliasSeq!(string, wstring, dchar[], char[], dstring, int);\nalias TL1 = Filter!(isNarrowString, Types1);\nstatic assert(is(TL1 == AliasSeq!(string, wstring, char[])));\n\nalias Types2 = AliasSeq!(int, byte, ubyte, dstring, dchar, uint, ulong);\nalias TL2 = Filter!(isUnsigned, Types2);\nstatic assert(is(TL2 == AliasSeq!(ubyte, uint, ulong)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL677_1832)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"name": "templateNot",
								"line": 724,
								"init": "!pred!T",
								"char": 10,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							}
						],
						"name": "templateNot",
						"line": 724,
						"parameters": [
							{
								"name": "T",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "templateNot",
				"line": 722,
				"comment": " Negates the passed template predicate.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL728_1834)\n---\nimport std.traits : isPointer;\n\nalias isNoPointer = templateNot!isPointer;\nstatic assert(!isNoPointer!(int*));\nstatic assert(allSatisfy!(isNoPointer, string, char, float));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL728_1834)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [],
						"name": "templateAnd",
						"line": 758,
						"parameters": [
							{
								"name": "T",
								"kind": "tuple"
							}
						],
						"char": 5,
						"kind": "template"
					}
				],
				"name": "templateAnd",
				"line": 756,
				"comment": " Combines several template predicates using logical AND, i.e. constructs a new\n predicate which evaluates to true for a given input T if and only if all of\n the passed predicates are true for T.\n\n The predicates are evaluated from left to right, aborting evaluation in a\n short-cut manner if a false result is encountered, in which case the latter\n instantiations do not need to compile.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL775_1836)\n---\nimport std.traits : isNumeric, isUnsigned;\n\nalias storesNegativeNumbers = templateAnd!(isNumeric, templateNot!isUnsigned);\nstatic assert(storesNegativeNumbers!int);\nstatic assert(!storesNegativeNumbers!string && !storesNegativeNumbers!uint);\n\n// An empty list of predicates always yields true.\nalias alwaysTrue = templateAnd!();\nstatic assert(alwaysTrue!int);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL775_1836)\n",
				"parameters": [
					{
						"name": "Preds",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [],
						"name": "templateOr",
						"line": 816,
						"parameters": [
							{
								"name": "T",
								"kind": "tuple"
							}
						],
						"char": 5,
						"kind": "template"
					}
				],
				"name": "templateOr",
				"line": 814,
				"comment": " Combines several template predicates using logical OR, i.e. constructs a new\n predicate which evaluates to true for a given input T if and only at least\n one of the passed predicates is true for T.\n\n The predicates are evaluated from left to right, aborting evaluation in a\n short-cut manner if a true result is encountered, in which case the latter\n instantiations do not need to compile.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL833_1838)\n---\nimport std.traits : isPointer, isUnsigned;\n\nalias isPtrOrUnsigned = templateOr!(isPointer, isUnsigned);\nstatic assert( isPtrOrUnsigned!uint &&  isPtrOrUnsigned!(short*));\nstatic assert(!isPtrOrUnsigned!int  && !isPtrOrUnsigned!(string));\n\n// An empty list of predicates never yields true.\nalias alwaysFalse = templateOr!();\nstatic assert(!alwaysFalse!int);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL833_1838)\n",
				"parameters": [
					{
						"name": "Preds",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "aliasSeqOf",
				"line": 869,
				"comment": " Converts an input range $(D range) to an alias sequence.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL903_1840)\n---\nimport std.algorithm : map, sort;\nimport std.string : capitalize;\n\nstruct S\n{\n    int a;\n    int c;\n    int b;\n}\n\nalias capMembers = aliasSeqOf!([__traits(allMembers, S)].sort().map!capitalize());\nstatic assert(capMembers[0] == \"A\");\nstatic assert(capMembers[1] == \"B\");\nstatic assert(capMembers[2] == \"C\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL903_1840)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL922_1841)\n---\nenum REF = [0, 1, 2, 3];\nforeach(I, V; aliasSeqOf!([0, 1, 2, 3]))\n{\n    static assert(V == I);\n    static assert(V == REF[I]);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL922_1841)\n",
				"parameters": [
					{
						"name": "range",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": " Templates to manipulate template argument lists (also known as type lists).\n\n Some operations on alias sequences are built in to the language,\n such as TL[$(I n)] which gets the $(I n)th type from the\n alias sequence. TL[$(I lwr) .. $(I upr)] returns a new type\n list that is a slice of the old one.\n\n Several templates in this module use or operate on eponymous templates that\n take a single argument and evaluate to a boolean constant. Such templates\n are referred to as $(I template predicates).\n\n References:\n  Based on ideas in Table 3.1 from\n  $(LINK2 http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768,\n      Modern C++ Design),\n   Andrei Alexandrescu (Addison-Wesley Professional, 2001)\n Macros:\n  WIKI = Phobos/StdMeta\n\n Copyright: Copyright Digital Mars 2005 - 2015.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:\n     $(WEB digitalmars.com, Walter Bright),\n     $(WEB klickverbot.at, David Nadlinger)\n Source:    $(PHOBOSSRC std/_meta.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/uri.d",
		"name": "std.uri",
		"members": [
			{
				"members": [],
				"name": "URIException",
				"line": 44,
				"comment": " This Exception is thrown if something goes wrong when encoding or\ndecoding a URI.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decode",
						"line": 342,
						"type": "string(in Char[] encodedURI)",
						"parameters": [
							{
								"name": "encodedURI",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 346,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "decode",
				"line": 342,
				"comment": " Decodes the URI string encodedURI into a UTF-8 string and returns it.\n Escape sequences that resolve to reserved URI characters are not replaced.\n Escape sequences that resolve to the '#' character are not replaced.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decodeComponent",
						"line": 353,
						"type": "string(in Char[] encodedURIComponent)",
						"parameters": [
							{
								"name": "encodedURIComponent",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 357,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "decodeComponent",
				"line": 353,
				"comment": " Decodes the URI string encodedURI into a UTF-8 string and returns it. All\n escape sequences are decoded.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 364,
						"type": "string(in Char[] uri)",
						"parameters": [
							{
								"name": "uri",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 368,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 364,
				"comment": " Encodes the UTF-8 string uri into a URI and returns that URI. Any character\n not a valid URI character is escaped. The '#' character is not escaped.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encodeComponent",
						"line": 375,
						"type": "string(in Char[] uriComponent)",
						"parameters": [
							{
								"name": "uriComponent",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 379,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encodeComponent",
				"line": 375,
				"comment": " Encodes the UTF-8 string uriComponent into a URI and returns that URI.\n Any character not a letter, digit, or one of -_.!~*'() is escaped.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uriLength",
						"line": 388,
						"type": "ptrdiff_t(in Char[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 438,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "uriLength",
				"line": 388,
				"comment": " Does string s[] start with a URL?\n Returns:\n  -1   it does not\n  len  it does, and s[0..len] is the slice of s[] that is that URL\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL441_1847)\n---\nstring s1 = \"http://www.digitalmars.com/~fred/fredsRX.html#foo end!\";\nassert (uriLength(s1) == 49);\nstring s2 = \"no uri here\";\nassert (uriLength(s2) == -1);\nassert (uriLength(\"issue 14924\") < 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL441_1847)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emailLength",
						"line": 459,
						"type": "ptrdiff_t(in Char[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 502,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "emailLength",
				"line": 459,
				"comment": " Does string s[] start with an email address?\n Returns:\n  -1    it does not\n  len   it does, and s[0..i] is the slice of s[] that is that email address\n References:\n  RFC2822\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL505_1848)\n---\nstring s1 = \"my.e-mail@www.example-domain.com with garbage added\";\nassert (emailLength(s1) == 32);\nstring s2 = \"no email address here\";\nassert (emailLength(s2) == -1);\nassert (emailLength(\"issue 14924\") < 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL505_1848)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 11,
				"kind": "template"
			}
		],
		"comment": " Encode and decode Uniform Resource Identifiers (URIs).\n URIs are used in internet transfer protocols.\n Valid URI characters consist of letters, digits,\n and the characters $(B ;/?:@&amp;=+$,-_.!~*'())\n Reserved URI characters are $(B ;/?:@&amp;=+$,)\n Escape sequences consist of $(B %) followed by two hex digits.\n\n See_Also:\n  $(LINK2 http://www.ietf.org/rfc/rfc3986.txt, RFC 3986)<br>\n  $(LINK2 http://en.wikipedia.org/wiki/Uniform_resource_identifier, Wikipedia)\n Macros:\n  WIKI = Phobos/StdUri\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_uri.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/csv.d",
		"name": "std.csv",
		"members": [
			{
				"members": [
					{
						"offset": 72,
						"name": "row",
						"line": 112,
						"comment": "\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 80,
						"name": "col",
						"line": 112,
						"comment": "\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 17,
						"kind": "variable"
					}
				],
				"name": "CSVException",
				"line": 109,
				"comment": " Exception containing the row and column for when an exception was thrown.\n\n Numbering of both row and col start at one and corresponds to the location\n in the file rather than any specified header. Special consideration should\n be made when there is failure to match the header see $(LREF\n HeaderMismatchException) for details.\n\n When performing type conversions, $(XREF ConvException) is stored in the $(D\n next) field.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"offset": 88,
						"name": "partialData",
						"line": 172,
						"comment": "Data pulled from input before finding a problem\n\n\n\nThis field is populated when using $(LREF csvReader)\n\nbut not by $(LREF csvNextToken) as this data will have\n\nalready been fed to the output range.\n",
						"deco": "Ayw",
						"char": 13,
						"kind": "variable"
					}
				],
				"name": "IncompleteCellException",
				"line": 165,
				"comment": " Exception thrown when a Token is identified to not be completed: a quote is\n found in an unquoted field, data continues after a closing quote, or the\n quoted field was not closed before data was empty.\n",
				"base": "std.csv.CSVException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "HeaderMismatchException",
				"line": 214,
				"comment": " Exception thrown under different conditions based on the type of $(D\n Contents).\n\n Structure, Class, and Associative Array\n $(UL\n     $(LI When a header is provided but a matching column is not found)\n  )\n\n Other\n $(UL\n     $(LI When a header is provided but a matching column is not found)\n     $(LI Order did not match that found in the input)\n  )\n\n Since a row and column is not meaningful when a column specified by the\n header is not found in the data, both row and col will be zero. Otherwise\n row is always one and col is the first instance found in header that\n occurred before the previous starting at one.\n",
				"base": "std.csv.CSVException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "ignore",
						"line": 255,
						"value": "0",
						"comment": "No exceptions are thrown due to incorrect CSV.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "throwException",
						"line": 257,
						"value": "1",
						"comment": "Use exceptions when input has incorrect CSV.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Malformed",
				"line": 252,
				"comment": " Determines the behavior for when an error is detected.\n\n Disabling exception will follow these rules:\n $(UL\n     $(LI A quote can appear in a field if the field was not quoted.)\n     $(LI If in a quoted field any quote by itself, not at the end of a\n     field, will end processing for that field.)\n     $(LI The field is ended when there is no input, even if the quote was\n     not closed.)\n     $(LI If the given header does not match the order in the input, the\n     content will return as it is found in the input.)\n     $(LI If the given header contains columns not found in the input they\n     will be ignored.)\n  )\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "csvReader",
						"line": 329,
						"type": "(Range input, Separator delimiter = ',', Separator quote = '\"')",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							},
							{
								"name": "delimiter",
								"type": "Separator",
								"default": "','"
							},
							{
								"name": "quote",
								"type": "Separator",
								"default": "'\"'"
							}
						],
						"endline": 338,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "csvReader",
				"line": 329,
				"comment": " Returns an input range for iterating over records found in $(D\n input).\n\n The $(D Contents) of the input can be provided if all the records are the\n same type such as all integer data:\n\n -------\n string str = `76,26,22`;\n int[] ans = [76,26,22];\n auto records = csvReader!int(str);\n\n foreach(record; records)\n {\n     assert(equal(record, ans));\n }\n -------\n\n Example using a struct with modified delimiter:\n\n -------\n string str = \"Hello;65;63.63\\nWorld;123;3673.562\";\n struct Layout\n {\n     string name;\n     int value;\n     double other;\n }\n\n auto records = csvReader!Layout(str,';');\n\n foreach(record; records)\n {\n     writeln(record.name);\n     writeln(record.value);\n     writeln(record.other);\n }\n -------\n\n Specifying $(D ErrorLevel) as Malformed.ignore will lift restrictions\n on the format. This example shows that an exception is not thrown when\n finding a quote in a field not quoted.\n\n -------\n string str = \"A \\\" is now part of the data\";\n auto records = csvReader!(string,Malformed.ignore)(str);\n auto record = records.front;\n\n assert(record.front == str);\n -------\n\n Returns:\n        An input range R as defined by\n        $(XREF_PACK range,primitives,isInputRange). When $(D Contents) is a\n        struct, class, or an associative array, the element type of R is\n        $(D Contents), otherwise the element type of R is itself a range with\n        element type $(D Contents).\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n",
				"parameters": [
					{
						"name": "Contents",
						"default": "string",
						"kind": "type"
					},
					{
						"name": "ErrorLevel",
						"defaultValue": "Malformed.throwException",
						"deco": "E3std3csv9Malformed",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar) && isSomeChar!Separator && !is(Contents T : T[U], U : string)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "csvReader",
						"line": 414,
						"type": "(Range input, Header header, Separator delimiter = ',', Separator quote = '\"')",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							},
							{
								"name": "header",
								"type": "Header"
							},
							{
								"name": "delimiter",
								"type": "Separator",
								"default": "','"
							},
							{
								"name": "quote",
								"type": "Separator",
								"default": "'\"'"
							}
						],
						"endline": 427,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "csvReader",
				"line": 414,
				"comment": " An optional $(D header) can be provided. The first record will be read in\n as the header. If $(D Contents) is a struct then the header provided is\n expected to correspond to the fields in the struct. When $(D Contents) is\n not a type which can contain the entire record, the $(D header) must be\n provided in the same order as the input or an exception is thrown.\n\n Read only column \"b\":\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader!int(str, [\"b\"]);\n\n auto ans = [[65],[123]];\n foreach(record; records)\n {\n     assert(equal(record, ans.front));\n     ans.popFront();\n }\n -------\n\n Read from header of different order:\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n struct Layout\n {\n     int value;\n     double other;\n     string name;\n }\n\n auto records = csvReader!Layout(str, [\"b\",\"c\",\"a\"]);\n -------\n\n The header can also be left empty if the input contains a header but\n all columns should be iterated. The header from the input can always\n be accessed from the header field.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader(str, null);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Returns:\n        An input range R as defined by\n        $(XREF_PACK range,primitives,isInputRange). When $(D Contents) is a\n        struct, class, or an associative array, the element type of R is\n        $(D Contents), otherwise the element type of R is itself a range with\n        element type $(D Contents).\n\n        The returned range provides a header field for accessing the header\n        from the input in array form.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\";\n auto records = csvReader(str, [\"a\"]);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n",
				"parameters": [
					{
						"name": "Contents",
						"default": "string",
						"kind": "type"
					},
					{
						"name": "ErrorLevel",
						"defaultValue": "Malformed.throwException",
						"deco": "E3std3csv9Malformed",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Header",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar) && isSomeChar!Separator && isForwardRange!Header && isSomeString!(ElementType!Header)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "csvReader",
						"line": 430,
						"type": "(Range input, Header header, Separator delimiter = ',', Separator quote = '\"')",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							},
							{
								"name": "header",
								"type": "Header"
							},
							{
								"name": "delimiter",
								"type": "Separator",
								"default": "','"
							},
							{
								"name": "quote",
								"type": "Separator",
								"default": "'\"'"
							}
						],
						"endline": 442,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "csvReader",
				"line": 430,
				"comment": "\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1115_1868)\n---\nimport std.algorithm;\n\nstring str = `76;^26^;22`;\nint[] ans = [76,26,22];\nauto records = CsvReader!(int,Malformed.ignore,string,char,string[])\n      (str, ';', '^');\n\nforeach(record; records)\n{\n    assert(equal(record, ans));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1115_1868)\n",
				"parameters": [
					{
						"name": "Contents",
						"default": "string",
						"kind": "type"
					},
					{
						"name": "ErrorLevel",
						"defaultValue": "Malformed.throwException",
						"deco": "E3std3csv9Malformed",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Header",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar) && isSomeChar!Separator && is(Header : typeof(null))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "csvNextToken",
						"line": 1361,
						"type": "void(ref Range input, ref Output ans, Separator sep, Separator quote, bool startQuoted = false)",
						"parameters": [
							{
								"name": "input",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "ans",
								"type": "Output",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "sep",
								"type": "Separator"
							},
							{
								"name": "quote",
								"type": "Separator"
							},
							{
								"name": "startQuoted",
								"deco": "b",
								"default": "false"
							}
						],
						"endline": 1461,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "csvNextToken",
				"line": 1361,
				"comment": " Lower level control over parsing CSV\n\n This function consumes the input. After each call the input will\n start with either a delimiter or record break (\\n, \\r\\n, \\r) which\n must be removed for subsequent calls.\n\n params:\n       input = Any CSV input\n       ans   = The first field in the input\n       sep   = The character to represent a comma in the specification\n       quote = The character to represent a quote in the specification\n       startQuoted = Whether the input should be considered to already be in\n quotes\n\n Throws:\n       $(LREF IncompleteCellException) When a quote is found in an unquoted\n       field, data continues after a closing quote, or the quoted field was\n       not closed before data was empty.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1464_1869)\n---\nimport std.array : appender;\nstring str = \"65,63\\n123,3673\";\n\nauto a = appender!(char[])();\n\ncsvNextToken(str,a,',','\"');\nassert(a.data == \"65\");\nassert(str == \",63\\n123,3673\");\n\nstr.popFront();\na.shrinkTo(0);\ncsvNextToken(str,a,',','\"');\nassert(a.data == \"63\");\nassert(str == \"\\n123,3673\");\n\nstr.popFront();\na.shrinkTo(0);\ncsvNextToken(str,a,',','\"');\nassert(a.data == \"123\");\nassert(str == \",3673\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1464_1869)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "ErrorLevel",
						"defaultValue": "Malformed.throwException",
						"deco": "E3std3csv9Malformed",
						"kind": "value"
					},
					{
						"name": "Separator",
						"kind": "type"
					},
					{
						"name": "Output",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Separator && isInputRange!Range && is(Unqual!(ElementType!Range) == dchar) && isOutputRange!(Output, dchar)",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": " Implements functionality to read Comma Separated Values and its variants\n from a input range of $(D dchar).\n\n Comma Separated Values provide a simple means to transfer and store\n tabular data. It has been common for programs to use their own\n variant of the CSV format. This parser will loosely follow the\n $(WEB tools.ietf.org/html/rfc4180, RFC-4180). CSV input should adhered\n to the following criteria, differences from RFC-4180 in parentheses.\n\n $(UL\n     $(LI A record is separated by a new line (CRLF,LF,CR))\n     $(LI A final record may end with a new line)\n     $(LI A header may be provided as the first record in input)\n     $(LI A record has fields separated by a comma (customizable))\n     $(LI A field containing new lines, commas, or double quotes\n          should be enclosed in double quotes (customizable))\n     $(LI Double quotes in a field are escaped with a double quote)\n     $(LI Each record should contain the same number of fields)\n   )\n\n Example:\n\n -------\n import std.algorithm;\n import std.array;\n import std.csv;\n import std.stdio;\n import std.typecons;\n\n void main()\n {\n     auto text = \"Joe,Carpenter,300000\\nFred,Blacksmith,400000\\r\\n\";\n\n     foreach(record; csvReader!(Tuple!(string, string, int))(text))\n     {\n         writefln(\"%s works as a %s and earns $%d per year\",\n                  record[0], record[1], record[2]);\n     }\n\n     // To read the same string from the file \"filename.csv\":\n\n     auto file = File(\"filename.csv\", \"r\");\n     foreach(record;\n         file.byLine.joiner(\"\\n\").csvReader!(Tuple!(string, string, int)))\n     {\n         writefln(\"%s works as a %s and earns $%d per year\",\n                  record[0], record[1], record[2]);\n     }\n }\n }\n -------\n\n When an input contains a header the $(D Contents) can be specified as an\n associative array. Passing null to signify that a header is present.\n\n -------\n auto text = \"Name,Occupation,Salary\\r\"\n     \"Joe,Carpenter,300000\\nFred,Blacksmith,400000\\r\\n\";\n\n foreach(record; csvReader!(string[string])\n         (text, null))\n {\n     writefln(\"%s works as a %s and earns $%s per year.\",\n              record[\"Name\"], record[\"Occupation\"],\n              record[\"Salary\"]);\n }\n -------\n\n This module allows content to be iterated by record stored in a struct,\n class, associative array, or as a range of fields. Upon detection of an\n error an CSVException is thrown (can be disabled). csvNextToken has been\n made public to allow for attempted recovery.\n\n Disabling exceptions will lift many restrictions specified above. A quote\n can appear in a field if the field was not quoted. If in a quoted field any\n quote by itself, not at the end of a field, will end processing for that\n field. The field is ended when there is no input, even if the quote was not\n closed.\n\n   See_Also:\n      $(WEB en.wikipedia.org/wiki/Comma-separated_values, Wikipedia\n      Comma-separated values)\n\n   Copyright: Copyright 2011\n   License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n   Authors:   Jesse Phillips\n   Source:    $(PHOBOSSRC std/_csv.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/encoding.d",
		"name": "std.encoding",
		"members": [
			{
				"name": "INVALID_SEQUENCE",
				"line": 374,
				"comment": " Special value returned by $(D safeDecode)\n",
				"deco": "w",
				"init": "'\\Uffffffff'",
				"char": 12,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [],
				"name": "AsciiChar",
				"line": 744,
				"comment": " Defines various character sets.\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "AsciiString",
				"line": 746,
				"comment": "Ditto\n",
				"deco": "AyE3std8encoding9AsciiChar",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "Latin1Char",
				"line": 824,
				"comment": " Defines an Latin1-encoded character.\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Latin1String",
				"line": 829,
				"comment": "Defines an Latin1-encoded string (as an array of $(D\nimmutable(Latin1Char))).\n",
				"deco": "AyE3std8encoding10Latin1Char",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "Latin2Char",
				"line": 900,
				"comment": "Defines a Latin2-encoded character.\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Latin2String",
				"line": 906,
				"comment": " Defines an Latin2-encoded string (as an array of $(D\n immutable(Latin2Char))).\n",
				"deco": "AyE3std8encoding10Latin2Char",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "Windows1250Char",
				"line": 980,
				"comment": "Defines a Windows1250-encoded character.\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Windows1250String",
				"line": 986,
				"comment": " Defines an Windows1250-encoded string (as an array of $(D\n immutable(Windows1250Char))).\n",
				"deco": "AyE3std8encoding15Windows1250Char",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "Windows1252Char",
				"line": 1073,
				"comment": "Defines a Windows1252-encoded character.\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Windows1252String",
				"line": 1079,
				"comment": " Defines an Windows1252-encoded string (as an array of $(D\n immutable(Windows1252Char))).\n",
				"deco": "AyE3std8encoding15Windows1252Char",
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "isValidCodePoint",
				"line": 1467,
				"comment": "Returns true if c is a valid code point\n\n Note that this includes the non-character code points U+FFFE and U+FFFF,\n since these are valid code points (even though they are not valid\n characters).\n\n Supersedes:\n This function supersedes $(D std.utf.startsValidDchar()).\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    c = the code point to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 1470,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encodingName",
						"line": 1481,
						"type": "@property string()",
						"endline": 1484,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "encodingName",
				"line": 1481,
				"comment": " Returns the name of an encoding.\n\n The type of encoding cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1487_1877)\n---\nassert(encodingName!(char) == \"UTF-8\");\nassert(encodingName!(wchar) == \"UTF-16\");\nassert(encodingName!(dchar) == \"UTF-32\");\nassert(encodingName!(AsciiChar) == \"ASCII\");\nassert(encodingName!(Latin1Char) == \"ISO-8859-1\");\nassert(encodingName!(Latin2Char) == \"ISO-8859-2\");\nassert(encodingName!(Windows1250Char) == \"windows-1250\");\nassert(encodingName!(Windows1252Char) == \"windows-1252\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1487_1877)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "canEncode",
						"line": 1509,
						"type": "bool(dchar c)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 1512,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "canEncode",
				"line": 1509,
				"comment": " Returns true iff it is possible to represent the specified codepoint\n in the encoding.\n\n The type of encoding cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1515_1878)\n---\nassert( canEncode!(Latin1Char)('A'));\nassert( canEncode!(Latin2Char)('A'));\nassert(!canEncode!(AsciiChar)('\\u00A0'));\nassert( canEncode!(Latin1Char)('\\u00A0'));\nassert( canEncode!(Latin2Char)('\\u00A0'));\nassert( canEncode!(Windows1250Char)('\\u20AC'));\nassert(!canEncode!(Windows1250Char)('\\u20AD'));\nassert(!canEncode!(Windows1250Char)('\\uFFFD'));\nassert( canEncode!(Windows1252Char)('\\u20AC'));\nassert(!canEncode!(Windows1252Char)('\\u20AD'));\nassert(!canEncode!(Windows1252Char)('\\uFFFD'));\nassert(!canEncode!(char)(cast(dchar)0x110000));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1515_1878)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isValidCodeUnit",
						"line": 1542,
						"type": "bool(E c)",
						"parameters": [
							{
								"name": "c",
								"type": "E"
							}
						],
						"endline": 1545,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isValidCodeUnit",
				"line": 1542,
				"comment": " Returns true if the code unit is legal. For example, the byte 0x80 would\n not be legal in ASCII, because ASCII code units must always be in the range\n 0x00 to 0x7F.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    c = the code unit to be tested\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1548_1879)\n---\nassert(!isValidCodeUnit(cast(char)0xC0));\nassert(!isValidCodeUnit(cast(char)0xFF));\nassert( isValidCodeUnit(cast(wchar)0xD800));\nassert(!isValidCodeUnit(cast(dchar)0xD800));\nassert(!isValidCodeUnit(cast(AsciiChar)0xA0));\nassert( isValidCodeUnit(cast(Windows1250Char)0x80));\nassert(!isValidCodeUnit(cast(Windows1250Char)0x81));\nassert( isValidCodeUnit(cast(Windows1252Char)0x80));\nassert(!isValidCodeUnit(cast(Windows1252Char)0x81));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1548_1879)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isValid",
						"line": 1575,
						"type": "bool(const(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]"
							}
						],
						"endline": 1578,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isValid",
				"line": 1575,
				"comment": " Returns true if the string is encoded correctly\n\n Supersedes:\n This function supersedes std.utf.validate(), however note that this\n function returns a bool indicating whether the input was valid or not,\n whereas the older function would throw an exception.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    s = the string to be tested\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1581_1880)\n---\nassert( isValid(\"\\u20AC100\"));\nassert(!isValid(cast(char[3])[167, 133, 175]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1581_1880)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "validLength",
						"line": 1597,
						"type": "size_t(const(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]"
							}
						],
						"endline": 1607,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "validLength",
				"line": 1597,
				"comment": " Returns the length of the longest possible substring, starting from\n the first code unit, which is validly encoded.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    s = the string to be tested\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sanitize",
						"line": 1626,
						"type": "immutable(E)[](immutable(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "immutable(E)[]"
							}
						],
						"endline": 1663,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "sanitize",
				"line": 1626,
				"comment": " Sanitizes a string by replacing malformed code unit sequences with valid\n code unit sequences. The result is guaranteed to be valid for this encoding.\n\n If the input string is already valid, this function returns the original,\n otherwise it constructs a new string by replacing all illegal code unit\n sequences with the encoding's replacement character, Invalid sequences will\n be replaced with the Unicode replacement character (U+FFFD) if the\n character repertoire contains it, otherwise invalid sequences will be\n replaced with '?'.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    s = the string to be sanitized\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1666_1881)\n---\nassert(sanitize(\"hello \\xF0\\x80world\") == \"hello \\xEF\\xBF\\xBDworld\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1666_1881)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "firstSequence",
						"line": 1683,
						"type": "size_t(const(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]"
							}
						],
						"endline": 1695,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "firstSequence",
				"line": 1683,
				"comment": " Returns the length of the first encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n s = the string to be sliced\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1698_1882)\n---\nassert(firstSequence(\"\\u20AC1000\") == \"\\u20AC\".length);\nassert(firstSequence(\"hel\") == \"h\".length);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1698_1882)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastSequence",
						"line": 1716,
						"type": "size_t(const(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]"
							}
						],
						"endline": 1727,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "lastSequence",
				"line": 1716,
				"comment": " Returns the length of the last encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    s = the string to be sliced\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1730_1883)\n---\nassert(lastSequence(\"1000\\u20AC\") == \"\\u20AC\".length);\nassert(lastSequence(\"hellö\") == \"ö\".length);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1730_1883)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "index",
						"line": 1752,
						"type": "ptrdiff_t(const(E)[] s, int n)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]"
							},
							{
								"name": "n",
								"deco": "i"
							}
						],
						"endline": 1763,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "index",
				"line": 1752,
				"comment": " Returns the array index at which the (n+1)th code point begins.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supersedes:\n This function supersedes std.utf.toUTFindex().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    s = the string to be counted\n    n = the current code point index\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1766_1884)\n---\nassert(index(\"\\u20AC100\",1) == 3);\nassert(index(\"hällo\",2) == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1766_1884)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decode",
						"line": 1791,
						"type": "dchar(ref S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1801,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "decode",
				"line": 1791,
				"comment": " Decodes a single code point.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supersedes:\n This function supersedes std.utf.decode(), however, note that the\n function codePoints() supersedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decodeReverse",
						"line": 1818,
						"type": "dchar(ref const(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1827,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "decodeReverse",
				"line": 1818,
				"comment": " Decodes a single code point from the end of a string.\n\n This function removes one or more code units from the end of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "safeDecode",
						"line": 1845,
						"type": "dchar(ref S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1853,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "safeDecode",
				"line": 1845,
				"comment": " Decodes a single code point. The input does not have to be valid.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n This function will accept an invalidly encoded string as input.\n If an invalid sequence is found at the start of the string, this\n function will remove it, and return the value INVALID_SEQUENCE.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encodedLength",
						"line": 1870,
						"type": "size_t(dchar c)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 1878,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encodedLength",
				"line": 1870,
				"comment": " Returns the number of code units required to encode a single code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 1902,
						"type": "E[](dchar c)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 1910,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 1902,
				"comment": " Encodes a single code point.\n\n This function encodes a single code point into one or more code units.\n It returns a string containing those code units.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supersedes:\n This function supersedes std.utf.encode(), however, note that the\n function codeUnits() supersedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 1939,
						"type": "size_t(dchar c, E[] array)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							},
							{
								"name": "array",
								"type": "E[]"
							}
						],
						"endline": 1949,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 1939,
				"comment": " Encodes a single code point into an array.\n\n This function encodes a single code point into one or more code units\n The code units are stored in a user-supplied fixed-size array,\n which must be passed by reference.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supersedes:\n This function supersedes std.utf.encode(), however, note that the\n function codeUnits() supersedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    c     = the code point to be encoded\n    array = the destination array\n\n Returns:\n          the number of code units written to the array\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 2076,
						"type": "void(dchar c, void delegate(E) dg)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							},
							{
								"name": "dg",
								"type": "void delegate(E)"
							}
						],
						"endline": 2084,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 2076,
				"comment": " Encodes a single code point to a delegate.\n\n This function encodes a single code point into one or more code units.\n The code units are passed one at a time to the supplied delegate.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supersedes:\n This function supersedes std.utf.encode(), however, note that the\n function codeUnits() supersedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    c  = the code point to be encoded\n    dg = the delegate to invoke for each code unit\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 2096,
						"type": "size_t(in Src[] s, R range)",
						"parameters": [
							{
								"name": "s",
								"type": "Src[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2104,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 2096,
				"comment": "Encodes the contents of $(D s) in units of type $(D Tgt), writing the result to an\noutput range.\n\nReturns: The number of $(D Tgt) elements written.\nParams:\nTgt = Element type of $(D range).\ns = Input array.\nrange = Output range.\n",
				"parameters": [
					{
						"name": "Tgt",
						"kind": "type"
					},
					{
						"name": "Src",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "codePoints",
						"line": 2139,
						"type": "CodePoints!E(immutable(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "immutable(E)[]"
							}
						],
						"endline": 2147,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "codePoints",
				"line": 2139,
				"comment": " Returns a foreachable struct which can bidirectionally iterate over all\n code points in a string.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n You can foreach either\n with or without an index. If an index is specified, it will be initialized\n at each iteration with the offset into the string at which the code point\n begins.\n\n Supersedes:\n This function supersedes std.utf.decode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    s = the string to be decoded\n\n Example:\n --------------------------------------------------------\n string s = \"hello world\";\n foreach(c;codePoints(s))\n {\n     // do something with c (which will always be a dchar)\n }\n --------------------------------------------------------\n\n Note that, currently, foreach(c:codePoints(s)) is superior to foreach(c;s)\n in that the latter will fall over on encountering U+FFFF.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2150_1886)\n---\nstring s = \"hello\";\nstring t;\nforeach(c;codePoints(s))\n{\n    t ~= cast(char)c;\n}\nassert(s == t);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2150_1886)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "codeUnits",
						"line": 2180,
						"type": "CodeUnits!E(dchar c)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 2188,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "codeUnits",
				"line": 2180,
				"comment": " Returns a foreachable struct which can bidirectionally iterate over all\n code units in a code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type in the template parameter.\n\n Supersedes:\n This function supersedes std.utf.encode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2191_1887)\n---\nchar[] a;\nforeach(c;codeUnits!(char)(cast(dchar)'\\u20AC'))\n{\n    a ~= c;\n}\nassert(a.length == 3);\nassert(a[0] == 0xE2);\nassert(a[1] == 0x82);\nassert(a[2] == 0xAC);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2191_1887)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "transcode",
						"line": 2223,
						"type": "void(immutable(Src)[] s, out immutable(Dst)[] r)",
						"parameters": [
							{
								"name": "s",
								"type": "immutable(Src)[]"
							},
							{
								"name": "r",
								"type": "immutable(Dst)[]",
								"storageClass": [
									"out"
								]
							}
						],
						"endline": 2270,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "transcode",
				"line": 2223,
				"comment": " Convert a string from one encoding to another.\n\n Supersedes:\n This function supersedes std.utf.toUTF8(), std.utf.toUTF16() and\n std.utf.toUTF32()\n (but note that to!() supersedes it more conveniently).\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,\n WINDOWS-1252\n\n Params:\n    s = Source string. $(B Must) be validly encoded.\n        This is enforced by the function's in-contract.\n    r = Destination string\n\n See_Also:\n    $(XREF conv, to)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2273_1888)\n---\nwstring ws;\n// transcode from UTF-8 to UTF-16\ntranscode(\"hello world\",ws);\nassert(ws == \"hello world\"w);\n\nLatin1String ls;\n// transcode from UTF-16 to ISO-8859-1\ntranscode(ws, ls);\nassert(ws == \"hello world\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2273_1888)\n",
				"parameters": [
					{
						"name": "Src",
						"kind": "type"
					},
					{
						"name": "Dst",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [],
				"name": "EncodingException",
				"line": 2328,
				"comment": " The base class for exceptions thrown by this module\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "EncodingScheme",
				"line": 2336,
				"comment": " Abstract base class of all encoding schemes\n",
				"members": [
					{
						"endchar": 5,
						"name": "register",
						"line": 2357,
						"comment": " Registers a subclass of EncodingScheme.\n\n This function allows user-defined subclasses of EncodingScheme to\n be declared in other modules.\n\n Example:\n ----------------------------------------------\n class Amiga1251 : EncodingScheme\n {\n     shared static this()\n     {\n         EncodingScheme.register(\"path.to.Amiga1251\");\n     }\n }\n ----------------------------------------------\n",
						"deco": "FAyaZv",
						"parameters": [
							{
								"name": "className",
								"deco": "Aya"
							}
						],
						"endline": 2366,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "create",
						"line": 2380,
						"comment": " Obtains a subclass of EncodingScheme which is capable of encoding\n and decoding the named encoding scheme.\n\n This function is only aware of EncodingSchemes which have been\n registered with the register() function.\n\n Example:\n ---------------------------------------------------\n auto scheme = EncodingScheme.create(\"Amiga-1251\");\n ---------------------------------------------------\n",
						"deco": "FAyaZC3std8encoding14EncodingScheme",
						"parameters": [
							{
								"name": "encodingName",
								"deco": "Aya"
							}
						],
						"endline": 2389,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"name": "toString",
						"line": 2396,
						"comment": " Returns the standard name of the encoding scheme\n",
						"deco": "xFZAya",
						"char": 34,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"abstract",
							"override"
						]
					},
					{
						"name": "names",
						"line": 2401,
						"comment": " Returns an array of all known names for this encoding scheme\n",
						"deco": "xFZAAya",
						"char": 27,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "canEncode",
						"line": 2407,
						"comment": " Returns true if the character c can be represented\n in this encoding scheme.\n",
						"deco": "xFwZb",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"char": 23,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "encodedLength",
						"line": 2420,
						"comment": " Returns the number of ubytes required to encode this code point.\n\n The input to this function MUST be a valid code point.\n\n Params:\n    c = the code point to be encoded\n\n Returns:\n    the number of ubytes required.\n",
						"deco": "xFwZm",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"originalType": "const size_t(dchar c)",
						"char": 25,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "encode",
						"line": 2439,
						"comment": " Encodes a single code point into a user-supplied, fixed-size buffer.\n\n This function encodes a single code point into one or more ubytes.\n The supplied buffer must be code unit aligned.\n (For example, UTF-16LE or UTF-16BE must be wchar-aligned,\n UTF-32LE or UTF-32BE must be dchar-aligned, etc.)\n\n The input to this function MUST be a valid code point.\n\n Params:\n    c      = the code point to be encoded\n    buffer = the destination array\n\n Returns:\n    the number of ubytes written.\n",
						"deco": "xFwAhZm",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							},
							{
								"name": "buffer",
								"deco": "Ah"
							}
						],
						"originalType": "const size_t(dchar c, ubyte[] buffer)",
						"char": 25,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "decode",
						"line": 2452,
						"comment": " Decodes a single code point.\n\n This function removes one or more ubytes from the start of an array,\n and returns the decoded code point which those ubytes represent.\n\n The input to this function MUST be validly encoded.\n\n Params:\n    s = the array whose first code point is to be decoded\n",
						"deco": "xFKAxhZw",
						"parameters": [
							{
								"name": "s",
								"storageClass": [
									"ref"
								],
								"deco": "Axh"
							}
						],
						"char": 24,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "safeDecode",
						"line": 2467,
						"comment": " Decodes a single code point. The input does not have to be valid.\n\n This function removes one or more ubytes from the start of an array,\n and returns the decoded code point which those ubytes represent.\n\n This function will accept an invalidly encoded array as input.\n If an invalid sequence is found at the start of the string, this\n function will remove it, and return the value INVALID_SEQUENCE.\n\n Params:\n    s = the array whose first code point is to be decoded\n",
						"deco": "xFKAxhZw",
						"parameters": [
							{
								"name": "s",
								"storageClass": [
									"ref"
								],
								"deco": "Axh"
							}
						],
						"char": 24,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "replacementSequence",
						"line": 2476,
						"comment": " Returns the sequence of ubytes to be used to represent\n any character which cannot be represented in the encoding scheme.\n\n Normally this will be a representation of some substitution\n character, such as U+FFFD or '?'.\n",
						"deco": "xFNdZAyh",
						"char": 47,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"endchar": 5,
						"name": "isValid",
						"line": 2485,
						"comment": " Returns true if the array is encoded correctly\n\n Params:\n    s = the array to be tested\n",
						"deco": "FAxhZb",
						"parameters": [
							{
								"name": "s",
								"deco": "Axh"
							}
						],
						"endline": 2494,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "validLength",
						"line": 2503,
						"comment": " Returns the length of the longest possible substring, starting from\n the first element, which is validly encoded.\n\n Params:\n    s = the array to be tested\n",
						"deco": "FAxhZm",
						"parameters": [
							{
								"name": "s",
								"deco": "Axh"
							}
						],
						"endline": 2513,
						"originalType": "size_t(const(ubyte)[] s)",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sanitize",
						"line": 2527,
						"comment": " Sanitizes an array by replacing malformed ubyte sequences with valid\n ubyte sequences. The result is guaranteed to be valid for this\n encoding scheme.\n\n If the input array is already valid, this function returns the\n original, otherwise it constructs a new array by replacing all illegal\n sequences with the encoding scheme's replacement sequence.\n\n Params:\n    s = the string to be sanitized\n",
						"deco": "FAyhZAyh",
						"parameters": [
							{
								"name": "s",
								"deco": "Ayh"
							}
						],
						"endline": 2564,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 2577,
							"deco": "FZv",
							"endline": 2577,
							"char": 5,
							"kind": "function"
						},
						"name": "firstSequence",
						"line": 2575,
						"comment": " Returns the length of the first encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the array to be sliced\n",
						"deco": "FAxhZm",
						"parameters": [
							{
								"name": "s",
								"deco": "Axh"
							}
						],
						"endline": 2587,
						"originalType": "size_t(const(ubyte)[] s)",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 2600,
							"deco": "FZv",
							"endline": 2600,
							"char": 5,
							"kind": "function"
						},
						"name": "count",
						"line": 2598,
						"comment": " Returns the total number of code points encoded in a ubyte array.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the string to be counted\n",
						"deco": "FAxhZm",
						"parameters": [
							{
								"name": "s",
								"deco": "Axh"
							}
						],
						"endline": 2612,
						"originalType": "size_t(const(ubyte)[] s)",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 2626,
							"deco": "FZv",
							"endline": 2626,
							"char": 5,
							"kind": "function"
						},
						"name": "index",
						"line": 2624,
						"comment": " Returns the array index at which the (n+1)th code point begins.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the string to be counted\n    n = the current code point index\n",
						"deco": "FAxhmZl",
						"parameters": [
							{
								"name": "s",
								"deco": "Axh"
							},
							{
								"name": "n",
								"deco": "m"
							}
						],
						"endline": 2635,
						"originalType": "ptrdiff_t(const(ubyte)[] s, size_t n)",
						"char": 15,
						"kind": "function"
					}
				],
				"char": 10,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeASCII",
				"line": 2656,
				"comment": " EncodingScheme to handle ASCII\n\n This scheme recognises the following names:\n                 \"ANSI_X3.4-1968\",\n                 \"ANSI_X3.4-1986\",\n                 \"ASCII\",\n                 \"IBM367\",\n                 \"ISO646-US\",\n                 \"ISO_646.irv:1991\",\n                 \"US-ASCII\",\n                 \"cp367\",\n                 \"csASCII\"\n                 \"iso-ir-6\",\n                 \"us\"\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeLatin1",
				"line": 2741,
				"comment": " EncodingScheme to handle Latin-1\n\n This scheme recognises the following names:\n                 \"CP819\",\n                 \"IBM819\",\n                 \"ISO-8859-1\",\n                 \"ISO_8859-1\",\n                 \"ISO_8859-1:1987\",\n                 \"csISOLatin1\",\n                 \"iso-ir-100\",\n                 \"l1\",\n                 \"latin1\"\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeLatin2",
				"line": 2820,
				"comment": " EncodingScheme to handle Latin-2\n\n This scheme recognises the following names:\n                 \"Latin 2\",\n                 \"ISO-8859-2\",\n                 \"ISO_8859-2\",\n                 \"ISO_8859-2:1999\",\n                 \"Windows-28592\"\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeWindows1250",
				"line": 2891,
				"comment": " EncodingScheme to handle Windows-1250\n\n This scheme recognises the following names:\n                 \"windows-1250\"\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeWindows1252",
				"line": 2958,
				"comment": " EncodingScheme to handle Windows-1252\n\n This scheme recognises the following names:\n                 \"windows-1252\"\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeUtf8",
				"line": 3025,
				"comment": " EncodingScheme to handle UTF-8\n\n This scheme recognises the following names:\n                 \"UTF-8\"\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeUtf16Native",
				"line": 3093,
				"comment": " EncodingScheme to handle UTF-16 in native byte order\n\n This scheme recognises the following names:\n                 \"UTF-16LE\" (little-endian architecture only)\n                 \"UTF-16BE\" (big-endian architecture only)\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeUtf32Native",
				"line": 3188,
				"comment": " EncodingScheme to handle UTF-32 in native byte order\n\n This scheme recognises the following names:\n                 \"UTF-32LE\" (little-endian architecture only)\n                 \"UTF-32BE\" (big-endian architecture only)\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": "Classes and functions for handling and transcoding between various encodings.\n\nFor cases where the _encoding is known at compile-time, functions are provided\nfor arbitrary _encoding and decoding of characters, arbitrary transcoding\nbetween strings of different type, as well as validation and sanitization.\n\nEncodings currently supported are UTF-8, UTF-16, UTF-32, ASCII, ISO-8859-1\n(also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250 and WINDOWS-1252.\n\n$(UL\n$(LI The type $(D AsciiChar) represents an ASCII character.)\n$(LI The type $(D AsciiString) represents an ASCII string.)\n$(LI The type $(D Latin1Char) represents an ISO-8859-1 character.)\n$(LI The type $(D Latin1String) represents an ISO-8859-1 string.)\n$(LI The type $(D Latin2Char) represents an ISO-8859-2 character.)\n$(LI The type $(D Latin2String) represents an ISO-8859-2 string.)\n$(LI The type $(D Windows1250Char) represents a Windows-1250 character.)\n$(LI The type $(D Windows1250String) represents a Windows-1250 string.)\n$(LI The type $(D Windows1252Char) represents a Windows-1252 character.)\n$(LI The type $(D Windows1252String) represents a Windows-1252 string.))\n\nFor cases where the _encoding is not known at compile-time, but is\nknown at run-time, we provide the abstract class $(D EncodingScheme)\nand its subclasses.  To construct a run-time encoder/decoder, one does\ne.g.\n\n----------------------------------------------------\n    auto e = EncodingScheme.create(\"utf-8\");\n----------------------------------------------------\n\nThis library supplies $(D EncodingScheme) subclasses for ASCII,\nISO-8859-1 (also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250,\nWINDOWS-1252, UTF-8, and (on little-endian architectures) UTF-16LE and\nUTF-32LE; or (on big-endian architectures) UTF-16BE and UTF-32BE.\n\nThis library provides a mechanism whereby other modules may add $(D\nEncodingScheme) subclasses for any other _encoding.\n\nMacros:\n    WIKI=Phobos/StdEncoding\n\nCopyright: Copyright Janice Caron 2008 - 2009.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   Janice Caron\nSource:    $(PHOBOSSRC std/_encoding.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/mmfile.d",
		"name": "std.mmfile",
		"members": [
			{
				"name": "MmFile",
				"line": 54,
				"comment": " MmFile objects control the memory mapped file resource.\n",
				"members": [
					{
						"members": [
							{
								"name": "read",
								"line": 61,
								"value": "0",
								"comment": "Read existing file\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "readWriteNew",
								"line": 62,
								"value": "1",
								"comment": "Delete existing file, write new file\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "readWrite",
								"line": 63,
								"value": "2",
								"comment": "Read/Write existing file, create if not existing\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "readCopyOnWrite",
								"line": 64,
								"value": "3",
								"comment": "Read/Write existing file, copy on write\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "Mode",
						"line": 59,
						"comment": " The mode the memory mapped file is opened with.\n",
						"baseDeco": "i",
						"char": 5,
						"kind": "enum"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 73,
						"comment": " Open memory mapped file filename for reading.\n File is closed when the object instance is deleted.\n Throws:\n  std.file.FileException\n",
						"deco": "FAyaZC3std6mmfile6MmFile",
						"parameters": [
							{
								"name": "filename",
								"deco": "Aya"
							}
						],
						"endline": 76,
						"originalType": "(string filename)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 171,
						"comment": " Open memory mapped file filename in mode.\n File is closed when the object instance is deleted.\n Params:\n  filename = name of the file.\n      If null, an anonymous file mapping is created.\n  mode = access mode defined above.\n  size =  the size of the file. If 0, it is taken to be the\n      size of the existing file.\n  address = the preferred address to map the file to,\n      although the system is not required to honor it.\n      If null, the system selects the most convenient address.\n  window = preferred block size of the amount of data to map at one time\n      with 0 meaning map the entire file. The window size must be a\n      multiple of the memory allocation page size.\n Throws:\n  std.file.FileException\n",
						"deco": "FAyaE3std6mmfile6MmFile4ModemPvmZC3std6mmfile6MmFile",
						"parameters": [
							{
								"name": "filename",
								"deco": "Aya"
							},
							{
								"name": "mode",
								"deco": "E3std6mmfile6MmFile4Mode"
							},
							{
								"name": "size",
								"deco": "m"
							},
							{
								"name": "address",
								"deco": "Pv"
							},
							{
								"name": "window",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 369,
						"originalType": "(string filename, Mode mode, ulong size, void* address, size_t window = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "~this",
						"line": 374,
						"comment": " Flushes pending output and closes the memory mapped file.\n",
						"deco": "FZv",
						"endline": 410,
						"char": 5,
						"kind": "destructor"
					},
					{
						"endchar": 5,
						"name": "length",
						"line": 436,
						"comment": " Gives size in bytes of the memory mapped file.\n",
						"deco": "xFNdZm",
						"endline": 440,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "mode",
						"line": 445,
						"comment": " Read-only property returning the file mode.\n",
						"deco": "FZE3std6mmfile6MmFile4Mode",
						"endline": 449,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opSlice",
						"line": 454,
						"comment": " Returns entire file contents as an array.\n",
						"deco": "FZAv",
						"endline": 458,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opSlice",
						"line": 463,
						"comment": " Returns slice of file contents as an array.\n",
						"deco": "FmmZAv",
						"parameters": [
							{
								"name": "i1",
								"deco": "m"
							},
							{
								"name": "i2",
								"deco": "m"
							}
						],
						"endline": 470,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 475,
						"comment": " Returns byte at index i in file.\n",
						"deco": "FmZh",
						"parameters": [
							{
								"name": "i",
								"deco": "m"
							}
						],
						"endline": 481,
						"char": 11,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndexAssign",
						"line": 486,
						"comment": " Sets and returns byte at index i in file to value.\n",
						"deco": "FhmZh",
						"parameters": [
							{
								"name": "value",
								"deco": "h"
							},
							{
								"name": "i",
								"deco": "m"
							}
						],
						"endline": 492,
						"char": 11,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " Read and write memory mapped files.\n Macros:\n  WIKI=Phobos/StdMmfile\n\n Copyright: Copyright Digital Mars 2004 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright),\n            Matthew Wilson\n Source:    $(PHOBOSSRC std/_mmfile.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/complex.d",
		"name": "std.complex",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "complex",
						"line": 37,
						"type": "pure nothrow @nogc @safe (R re)",
						"parameters": [
							{
								"name": "re",
								"type": "R"
							}
						],
						"endline": 43,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "complex",
				"line": 37,
				"comment": " Helper function that returns a _complex number with the specified\n    real and imaginary parts.\n\n    Params:\n        R = (template parameter) type of real part of complex number\n        I = (template parameter) type of imaginary part of complex number\n\n        re = real part of complex number to be constructed\n        im = (optional) imaginary part of complex number\n\n    Returns:\n        $(D Complex) instance with real and imaginary parts set\n        to the values provided as input.  If neither $(D re) nor\n        $(D im) are floating-point numbers, the return type will\n        be $(D Complex!double).  Otherwise, the return type is\n        deduced using $(D std.traits.CommonType!(R, I)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL56_1915)\n---\nauto a = complex(1.0);\nstatic assert (is(typeof(a) == Complex!double));\nassert (a.re == 1.0);\nassert (a.im == 0.0);\n\nauto b = complex(2.0L);\nstatic assert (is(typeof(b) == Complex!real));\nassert (b.re == 2.0L);\nassert (b.im == 0.0L);\n\nauto c = complex(1.0, 2.0);\nstatic assert (is(typeof(c) == Complex!double));\nassert (c.re == 1.0);\nassert (c.im == 2.0);\n\nauto d = complex(3.0, 4.0L);\nstatic assert (is(typeof(d) == Complex!real));\nassert (d.re == 3.0);\nassert (d.im == 4.0L);\n\nauto e = complex(1);\nstatic assert (is(typeof(e) == Complex!double));\nassert (e.re == 1);\nassert (e.im == 0);\n\nauto f = complex(1L, 2);\nstatic assert (is(typeof(f) == Complex!double));\nassert (f.re == 1L);\nassert (f.im == 2);\n\nauto g = complex(3, 4.0L);\nstatic assert (is(typeof(g) == Complex!real));\nassert (g.re == 3);\nassert (g.im == 4.0L);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL56_1915)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "is(R : double)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "complex",
						"line": 46,
						"type": "pure nothrow @nogc @safe (R re, I im)",
						"parameters": [
							{
								"name": "re",
								"type": "R"
							},
							{
								"name": "im",
								"type": "I"
							}
						],
						"endline": 53,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "complex",
				"line": 46,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "type"
					}
				],
				"constraint": "is(R : double) && is(I : double)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Complex",
						"line": 98,
						"members": [
							{
								"name": "re",
								"line": 103,
								"comment": " The real part of the number.\n",
								"type": "T",
								"char": 7,
								"kind": "variable"
							},
							{
								"name": "im",
								"line": 106,
								"comment": " The imaginary part of the number.\n",
								"type": "T",
								"char": 7,
								"kind": "variable"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 117,
								"comment": " Converts the complex number to a string representation.\n\n    The second form of this function is usually not called directly;\n    instead, it is used via $(XREF string,format), as shown in the examples\n    below.  Supported format characters are 'e', 'f', 'g', 'a', and 's'.\n\n    See the $(LINK2 std_format.html, std.format) and $(XREF string, format)\n    documentation for more information.\n",
								"type": "const string()",
								"endline": 125,
								"char": 12,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "toString",
										"line": 145,
										"type": "const void(scope void delegate(const(Char)[]) sink, FormatSpec!Char formatSpec)",
										"parameters": [
											{
												"name": "sink",
												"type": "void delegate(const(Char)[])",
												"storageClass": [
													"scope"
												]
											},
											{
												"name": "formatSpec",
												"type": "FormatSpec!Char"
											}
										],
										"endline": 154,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "toString",
								"line": 145,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Char",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Complex",
				"line": 98,
				"comment": " A complex number parametrised by a type $(D T), which must be either\n    $(D float), $(D double) or $(D real).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "abs",
						"line": 657,
						"type": "pure nothrow @nogc @safe T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 661,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "abs",
				"line": 657,
				"comment": "   Params: z = A complex number.\n   Returns: The absolute value (or modulus) of `z`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL664_1921)\n---\nassert (abs(complex(1.0)) == 1.0);\nassert (abs(complex(0.0, 1.0)) == 1.0);\nassert (abs(complex(1.0L, -2.0L)) == std.math.sqrt(5.0L));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL664_1921)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sqAbs",
						"line": 679,
						"type": "pure nothrow @nogc @safe T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 682,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "sqAbs",
				"line": 679,
				"comment": "   Params:\n    z = A complex number.\n    x = A real number.\n   Returns: The squared modulus of `z`.\n   For genericity, if called on a real number, returns its square.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL685_1922)\n---\nimport std.math;\nassert (sqAbs(complex(0.0)) == 0.0);\nassert (sqAbs(complex(1.0)) == 1.0);\nassert (sqAbs(complex(0.0, 1.0)) == 1.0);\nassert (approxEqual(sqAbs(complex(1.0L, -2.0L)), 5.0L));\nassert (approxEqual(sqAbs(complex(-3.0L, 1.0L)), 10.0L));\nassert (approxEqual(sqAbs(complex(1.0f,-1.0f)), 2.0f));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL685_1922)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sqAbs",
						"line": 697,
						"type": "pure nothrow @nogc @safe T(T x)",
						"parameters": [
							{
								"name": "x",
								"type": "T"
							}
						],
						"endline": 701,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "sqAbs",
				"line": 697,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "arg",
						"line": 717,
						"type": "pure nothrow @nogc @safe T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 721,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "arg",
				"line": 717,
				"comment": " Params: z = A complex number.\n Returns: The argument (or phase) of `z`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL724_1924)\n---\nimport std.math;\nassert (arg(complex(1.0)) == 0.0);\nassert (arg(complex(0.0L, 1.0L)) == PI_2);\nassert (arg(complex(1.0L, 1.0L)) == PI_4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL724_1924)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "conj",
						"line": 737,
						"type": "pure nothrow @nogc @safe Complex!T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 740,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "conj",
				"line": 737,
				"comment": "  Params: z = A complex number.\n  Returns: The complex conjugate of `z`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL743_1925)\n---\nassert (conj(complex(1.0)) == complex(1.0));\nassert (conj(complex(1.0, 2.0)) == complex(1.0, -2.0));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL743_1925)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "fromPolar",
						"line": 757,
						"type": "pure nothrow @nogc @safe Complex!(CommonType!(T, U))(T modulus, U argument)",
						"parameters": [
							{
								"name": "modulus",
								"type": "T"
							},
							{
								"name": "argument",
								"type": "U"
							}
						],
						"endline": 762,
						"char": 29,
						"kind": "function"
					}
				],
				"name": "fromPolar",
				"line": 757,
				"comment": "  Constructs a complex number given its absolute value and argument.\n  Params:\n    modulus = The modulus\n    argument = The argument\n  Returns: The complex number with the given modulus and argument.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL765_1926)\n---\nimport std.math;\nauto z = fromPolar(std.math.sqrt(2.0), PI_4);\nassert (approxEqual(z.re, 1.0L, real.epsilon));\nassert (approxEqual(z.im, 1.0L, real.epsilon));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL765_1926)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "type"
					}
				],
				"char": 29,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sin",
						"line": 780,
						"type": "pure nothrow @nogc @safe Complex!T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 786,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "sin",
				"line": 780,
				"comment": "    Trigonometric functions on complex numbers.\n\n    Params: z = A complex number.\n    Returns: The sine and cosine of `z`, respectively.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL789_1927)\n---\nassert(sin(complex(0.0)) == 0.0);\nassert(sin(complex(2.0L, 0)) == std.math.sin(2.0L));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL789_1927)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL806_1928)\n---\nimport std.math;\nimport std.complex;\nassert(cos(complex(0.0)) == 1.0);\nassert(cos(complex(1.3L)) == std.math.cos(1.3L));\nassert(cos(complex(0, 5.2L)) == cosh(5.2L));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL806_1928)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cos",
						"line": 797,
						"type": "pure nothrow @nogc @safe Complex!T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 803,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "cos",
				"line": 797,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "expi",
				"line": 825,
				"comment": "    Params: y = A real number.\n    Returns: The value of cos(y) + i sin(y).\n\n    Note:\n    $(D expi) is included here for convenience and for easy migration of code\n    that uses $(XREF math,_expi).  Unlike $(XREF math,_expi), which uses the\n    x87 $(I fsincos) instruction when possible, this function is no faster\n    than calculating cos(y) and sin(y) separately.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL832_1929)\n---\nassert(expi(1.3e5L) == complex(std.math.cos(1.3e5L), std.math.sin(1.3e5L)));\nassert(expi(0.0L) == 1.0L);\nauto z1 = expi(1.234);\nauto z2 = std.math.expi(1.234);\nassert(z1.re == z2.re && z1.im == z2.im);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL832_1929)\n",
				"deco": "FNaNbNiNeeZS3std7complex14__T7ComplexTeZ7Complex",
				"parameters": [
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 829,
				"char": 14,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sqrt",
						"line": 846,
						"type": "pure nothrow @nogc @safe Complex!T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 888,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "sqrt",
				"line": 846,
				"comment": "    Params: z = A complex number.\n    Returns: The square root of `z`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL891_1930)\n---\nassert (sqrt(complex(0.0)) == 0.0);\nassert (sqrt(complex(1.0L, 0)) == std.math.sqrt(1.0L));\nassert (sqrt(complex(-1.0L, 0)) == complex(0, 1.0L));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL891_1930)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			}
		],
		"comment": " This module contains the $(LREF Complex) type, which is used to represent\n    _complex numbers, along with related mathematical operations and functions.\n\n    $(LREF Complex) will eventually\n    $(DDLINK deprecate, Deprecated Features, replace)\n    the built-in types $(D cfloat), $(D cdouble), $(D creal), $(D ifloat),\n    $(D idouble), and $(D ireal).\n\n    Authors:    Lars Tandle Kyllingstad, Don Clugston\n    Copyright:  Copyright (c) 2010, Lars T. Kyllingstad.\n    License:    $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n    Source:     $(PHOBOSSRC std/_complex.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/parallelism.d",
		"name": "std.parallelism",
		"members": [
			{
				"members": [
					{
						"name": "Task",
						"line": 423,
						"members": [
							{
								"name": "ReturnType",
								"line": 503,
								"comment": "    The return type of the function called by this $(D Task).  This can be\n    $(D void).\n",
								"type": "typeof(fun(_args))",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "spinForce",
								"line": 572,
								"comment": "    If the $(D Task) isn't started yet, execute it in the current thread.\n    If it's done, return its return value, if any.  If it's in progress,\n    busy spin until it's done, then return the return value.  If it threw\n    an exception, rethrow that exception.\n\n    This function should be used when you expect the result of the\n    $(D Task) to be available on a timescale shorter than that of an OS\n    context switch.\n",
								"type": "@property ref @trusted ReturnType()",
								"endline": 589,
								"char": 30,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "yieldForce",
								"line": 600,
								"comment": "    If the $(D Task) isn't started yet, execute it in the current thread.\n    If it's done, return its return value, if any.  If it's in progress,\n    wait on a condition variable.  If it threw an exception, rethrow that\n    exception.\n\n    This function should be used for expensive functions, as waiting on a\n    condition variable introduces latency, but avoids wasted CPU cycles.\n",
								"type": "@property ref @trusted ReturnType()",
								"endline": 634,
								"char": 30,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "workForce",
								"line": 645,
								"comment": "    If this $(D Task) was not started yet, execute it in the current\n    thread.  If it is finished, return its result.  If it is in progress,\n    execute any other $(D Task) from the $(D TaskPool) instance that\n    this $(D Task) was submitted to until this one\n    is finished.  If it threw an exception, rethrow that exception.\n    If no other tasks are available or this $(D Task) was executed using\n    $(D executeInNewThread), wait on a condition variable.\n",
								"type": "@property ref @trusted ReturnType()",
								"endline": 708,
								"char": 30,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "done",
								"line": 716,
								"comment": "    Returns $(D true) if the $(D Task) is finished executing.\n\n    Throws:  Rethrows any exception thrown during the execution of the\n             $(D Task).\n",
								"type": "@property @trusted bool()",
								"endline": 720,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "executeInNewThread",
								"line": 730,
								"comment": "    Create a new thread for executing this $(D Task), execute it in the\n    newly created thread, then terminate the thread.  This can be used for\n    future/promise parallelism.  An explicit priority may be given\n    to the $(D Task).  If one is provided, its value is forwarded to\n    $(D core.thread.Thread.priority). See $(XREF parallelism, task) for\n    usage example.\n",
								"type": "@trusted void()",
								"endline": 733,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "executeInNewThread",
								"line": 736,
								"comment": "Ditto\n",
								"type": "@trusted void(int priority)",
								"parameters": [
									{
										"name": "priority",
										"deco": "i"
									}
								],
								"endline": 739,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Task",
				"line": 423,
				"comment": "$(D Task) represents the fundamental unit of work.  A $(D Task) may be\nexecuted in parallel with any other $(D Task).  Using this struct directly\nallows future/promise _parallelism.  In this paradigm, a function (or delegate\nor other callable) is executed in a thread other than the one it was called\nfrom.  The calling thread does not block while the function is being executed.\nA call to $(D workForce), $(D yieldForce), or $(D spinForce) is used to\nensure that the $(D Task) has finished executing and to obtain the return\nvalue, if any.  These functions and $(D done) also act as full memory barriers,\nmeaning that any memory writes made in the thread that executed the $(D Task)\nare guaranteed to be visible in the calling thread after one of these functions\nreturns.\n\nThe $(XREF parallelism, task) and $(XREF parallelism, scopedTask) functions can\nbe used to create an instance of this struct.  See $(D task) for usage examples.\n\nFunction results are returned from $(D yieldForce), $(D spinForce) and\n$(D workForce) by ref.  If $(D fun) returns by ref, the reference will point\nto the returned reference of $(D fun).  Otherwise it will point to a\nfield in this struct.\n\nCopying of this struct is disabled, since it would provide no useful semantics.\nIf you want to pass this struct around, you should do so by reference or\npointer.\n\nBugs:  Changes to $(D ref) and $(D out) arguments are not propagated to the\n       call site, only to $(D args) in this struct.\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "task",
						"line": 828,
						"type": "(Args args)",
						"parameters": [
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 831,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "task",
				"line": 828,
				"comment": "Creates a $(D Task) on the GC heap that calls an alias.  This may be executed\nvia $(D Task.executeInNewThread) or by submitting to a\n$(XREF parallelism, TaskPool).  A globally accessible instance of\n$(D TaskPool) is provided by $(XREF parallelism, taskPool).\n\nReturns:  A pointer to the $(D Task).\n\nExample:\n---\n// Read two files into memory at the same time.\nimport std.file;\n\nvoid main()\n{\n    // Create and execute a Task for reading\n    // foo.txt.\n    auto file1Task = task!read(\"foo.txt\");\n    file1Task.executeInNewThread();\n\n    // Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    // Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce;\n}\n---\n\n---\n// Sorts an array using a parallel quick sort algorithm.\n// The first partition is done serially.  Both recursion\n// branches are then executed in parallel.\n//\n// Timings for sorting an array of 1,000,000 doubles on\n// an Athlon 64 X2 dual core machine:\n//\n// This implementation:               176 milliseconds.\n// Equivalent serial implementation:  280 milliseconds\nvoid parallelSort(T)(T[] data)\n{\n    // Sort small subarrays serially.\n    if(data.length < 100)\n    {\n         std.algorithm.sort(data);\n         return;\n    }\n\n    // Partition the array.\n    swap(data[$ / 2], data[$ - 1]);\n    auto pivot = data[$ - 1];\n    bool lessThanPivot(T elem) { return elem < pivot; }\n\n    auto greaterEqual = partition!lessThanPivot(data[0..$ - 1]);\n    swap(data[$ - greaterEqual.length - 1], data[$ - 1]);\n\n    auto less = data[0..$ - greaterEqual.length - 1];\n    greaterEqual = data[$ - greaterEqual.length..$];\n\n    // Execute both recursion branches in parallel.\n    auto recurseTask = task!parallelSort(greaterEqual);\n    taskPool.put(recurseTask);\n    parallelSort(less);\n    recurseTask.yieldForce;\n}\n---\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "task",
						"line": 864,
						"type": "(F delegateOrFp, Args args)",
						"parameters": [
							{
								"name": "delegateOrFp",
								"type": "F"
							},
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 868,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "task",
				"line": 864,
				"comment": "Creates a $(D Task) on the GC heap that calls a function pointer, delegate, or\nclass/struct with overloaded opCall.\n\nExample:\n---\n// Read two files in at the same time again,\n// but this time use a function pointer instead\n// of an alias to represent std.file.read.\nimport std.file;\n\nvoid main()\n{\n    // Create and execute a Task for reading\n    // foo.txt.\n    auto file1Task = task(&read, \"foo.txt\");\n    file1Task.executeInNewThread();\n\n    // Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    // Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce;\n}\n---\n\nNotes: This function takes a non-scope delegate, meaning it can be\n       used with closures.  If you can't allocate a closure due to objects\n       on the stack that have scoped destruction, see $(D scopedTask), which\n       takes a scope delegate.\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(typeof(delegateOrFp(args))) && !isSafeTask!F",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "task",
						"line": 891,
						"type": "@trusted (F fun, Args args)",
						"parameters": [
							{
								"name": "fun",
								"type": "F"
							},
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 895,
						"char": 15,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "task",
				"line": 891,
				"comment": "Version of $(D task) usable from $(D @safe) code.  Usage mechanics are\nidentical to the non-@safe case, but safety introduces some restrictions:\n\n1.  $(D fun) must be @safe or @trusted.\n\n2.  $(D F) must not have any unshared aliasing as defined by\n    $(XREF traits, hasUnsharedAliasing).  This means it\n    may not be an unshared delegate or a non-shared class or struct\n    with overloaded $(D opCall).  This also precludes accepting template\n    alias parameters.\n\n3.  $(D Args) must not have unshared aliasing.\n\n4.  $(D fun) must not return by reference.\n\n5.  The return type must not have unshared aliasing unless $(D fun) is\n    $(D pure) or the $(D Task) is executed via $(D executeInNewThread) instead\n    of using a $(D TaskPool).\n\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(typeof(fun(args))) && isSafeTask!F",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "scopedTask",
						"line": 918,
						"type": "(Args args)",
						"parameters": [
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 923,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "scopedTask",
				"line": 918,
				"comment": "These functions allow the creation of $(D Task) objects on the stack rather\nthan the GC heap.  The lifetime of a $(D Task) created by $(D scopedTask)\ncannot exceed the lifetime of the scope it was created in.\n\n$(D scopedTask) might be preferred over $(D task):\n\n1.  When a $(D Task) that calls a delegate is being created and a closure\n    cannot be allocated due to objects on the stack that have scoped\n    destruction.  The delegate overload of $(D scopedTask) takes a $(D scope)\n    delegate.\n\n2.  As a micro-optimization, to avoid the heap allocation associated with\n    $(D task) or with the creation of a closure.\n\nUsage is otherwise identical to $(D task).\n\nNotes:  $(D Task) objects created using $(D scopedTask) will automatically\ncall $(D Task.yieldForce) in their destructor if necessary to ensure\nthe $(D Task) is complete before the stack frame they reside on is destroyed.\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "scopedTask",
						"line": 926,
						"type": "(scope F delegateOrFp, Args args)",
						"parameters": [
							{
								"name": "delegateOrFp",
								"type": "F",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 932,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "scopedTask",
				"line": 926,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(typeof(delegateOrFp(args))) && !isSafeTask!F",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "scopedTask",
						"line": 935,
						"type": "@trusted (F fun, Args args)",
						"parameters": [
							{
								"name": "fun",
								"type": "F"
							},
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 941,
						"char": 15,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "scopedTask",
				"line": 935,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(typeof(fun(args))) && isSafeTask!F",
				"char": 15,
				"kind": "template"
			},
			{
				"name": "totalCPUs",
				"line": 947,
				"comment": "The total number of CPU cores available on the current machine, as reported by\nthe operating system.\n",
				"deco": "yk",
				"originalType": "uint",
				"char": 16,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "TaskPool",
				"line": 1004,
				"comment": "This class encapsulates a task queue and a set of worker threads.  Its purpose\nis to efficiently map a large number of $(D Task)s onto a smaller number of\nthreads.  A task queue is a FIFO queue of $(D Task) objects that have been\nsubmitted to the $(D TaskPool) and are awaiting execution.  A worker thread is a\nthread that executes the $(D Task) at the front of the queue when one is\navailable and sleeps when the queue is empty.\n\nThis class should usually be used via the global instantiation\navailable via the $(XREF parallelism, taskPool) property.\nOccasionally it is useful to explicitly instantiate a $(D TaskPool):\n\n1.  When you want $(D TaskPool) instances with multiple priorities, for example\n    a low priority pool and a high priority pool.\n\n2.  When the threads in the global task pool are waiting on a synchronization\n    primitive (for example a mutex), and you want to parallelize the code that\n    needs to run before these threads can be resumed.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1414,
						"comment": "    Default constructor that initializes a $(D TaskPool) with\n    $(D totalCPUs) - 1 worker threads.  The minus 1 is included because the\n    main thread will also be available to do work.\n\n    Note:  On single-core machines, the primitives provided by $(D TaskPool)\n           operate transparently in single-threaded mode.\n",
						"deco": "FNeZC3std11parallelism8TaskPool",
						"endline": 1417,
						"originalType": "@trusted ()",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1422,
						"comment": "    Allows for custom number of worker threads.\n",
						"deco": "FNemZC3std11parallelism8TaskPool",
						"parameters": [
							{
								"name": "nWorkers",
								"deco": "m"
							}
						],
						"endline": 1447,
						"originalType": "@trusted (size_t nWorkers)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "parallel",
								"line": 1520,
								"type": "ParallelForeach!R(R range, size_t workUnitSize)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									},
									{
										"name": "workUnitSize",
										"type": "size_t"
									}
								],
								"endline": 1525,
								"char": 23,
								"kind": "function"
							}
						],
						"name": "parallel",
						"line": 1520,
						"comment": "    Implements a parallel foreach loop over a range.  This works by implicitly\n    creating and submitting one $(D Task) to the $(D TaskPool) for each worker\n    thread.  A work unit is a set of consecutive elements of $(D range) to\n    be processed by a worker thread between communication with any other\n    thread.  The number of elements processed per work unit is controlled by the\n    $(D workUnitSize) parameter.  Smaller work units provide better load\n    balancing, but larger work units avoid the overhead of communicating\n    with other threads frequently to fetch the next work unit.  Large work\n    units also avoid false sharing in cases where the range is being modified.\n    The less time a single iteration of the loop takes, the larger\n    $(D workUnitSize) should be.  For very expensive loop bodies,\n    $(D workUnitSize) should  be 1.  An overload that chooses a default work\n    unit size is also available.\n\n    Example:\n    ---\n    // Find the logarithm of every number from 1 to\n    // 10_000_000 in parallel.\n    auto logs = new double[10_000_000];\n\n    // Parallel foreach works with or without an index\n    // variable.  It can be iterate by ref if range.front\n    // returns by ref.\n\n    // Iterate over logs using work units of size 100.\n    foreach(i, ref elem; taskPool.parallel(logs, 100))\n    {\n        elem = log(i + 1.0);\n    }\n\n    // Same thing, but use the default work unit size.\n    //\n    // Timings on an Athlon 64 X2 dual core machine:\n    //\n    // Parallel foreach:  388 milliseconds\n    // Regular foreach:   619 milliseconds\n    foreach(i, ref elem; taskPool.parallel(logs))\n    {\n        elem = log(i + 1.0);\n    }\n    ---\n\n    Notes:\n\n    The memory usage of this implementation is guaranteed to be constant\n    in $(D range.length).\n\n    Breaking from a parallel foreach loop via a break, labeled break,\n    labeled continue, return or goto statement throws a\n    $(D ParallelForeachError).\n\n    In the case of non-random access ranges, parallel foreach buffers lazily\n    to an array of size $(D workUnitSize) before executing the parallel portion\n    of the loop.  The exception is that, if a parallel foreach is executed\n    over a range returned by $(D asyncBuf) or $(D map), the copying is elided\n    and the buffers are simply swapped.  In this case $(D workUnitSize) is\n    ignored and the work unit size is set to the  buffer size of $(D range).\n\n    A memory barrier is guaranteed to be executed on exit from the loop,\n    so that results produced by all threads are visible in the calling thread.\n\n    $(B Exception Handling):\n\n    When at least one exception is thrown from inside a parallel foreach loop,\n    the submission of additional $(D Task) objects is terminated as soon as\n    possible, in a non-deterministic manner.  All executing or\n    enqueued work units are allowed to complete.  Then, all exceptions that\n    were thrown by any work unit are chained using $(D Throwable.next) and\n    rethrown.  The order of the exception chaining is non-deterministic.\n",
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"char": 23,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "parallel",
								"line": 1529,
								"type": "ParallelForeach!R(R range)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									}
								],
								"endline": 1544,
								"char": 23,
								"kind": "function"
							}
						],
						"name": "parallel",
						"line": 1529,
						"comment": "Ditto\n",
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"char": 23,
						"kind": "template"
					},
					{
						"members": [
							{
								"members": [
									{
										"endchar": 9,
										"name": "amap",
										"line": 1632,
										"type": "(Args args)",
										"parameters": [
											{
												"name": "args",
												"type": "Args"
											}
										],
										"endline": 1740,
										"char": 14,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "amap",
								"line": 1632,
								"comment": "        Eager parallel map.  The eagerness of this function means it has less\n        overhead than the lazily evaluated $(D TaskPool.map) and should be\n        preferred where the memory requirements of eagerness are acceptable.\n        $(D functions) are the functions to be evaluated, passed as template\n        alias parameters in a style similar to\n        $(XREF_PACK algorithm,iteration,map).\n        The first argument must be a random access range. For performance\n        reasons, amap will assume the range elements have not yet been\n        initialized. Elements will be overwritten without calling a destructor\n        nor doing an assignment. As such, the range must not contain meaningful\n        data: either un-initialized objects, or objects in their $(D .init)\n        state.\n\n        ---\n        auto numbers = iota(100_000_000.0);\n\n        // Find the square roots of numbers.\n        //\n        // Timings on an Athlon 64 X2 dual core machine:\n        //\n        // Parallel eager map:                   0.802 s\n        // Equivalent serial implementation:     1.768 s\n        auto squareRoots = taskPool.amap!sqrt(numbers);\n        ---\n\n        Immediately after the range argument, an optional work unit size argument\n        may be provided.  Work units as used by $(D amap) are identical to those\n        defined for parallel foreach.  If no work unit size is provided, the\n        default work unit size is used.\n\n        ---\n        // Same thing, but make work unit size 100.\n        auto squareRoots = taskPool.amap!sqrt(numbers, 100);\n        ---\n\n        An output range for returning the results may be provided as the last\n        argument.  If one is not provided, an array of the proper type will be\n        allocated on the garbage collected heap.  If one is provided, it must be a\n        random access range with assignable elements, must have reference\n        semantics with respect to assignment to its elements, and must have the\n        same length as the input range.  Writing to adjacent elements from\n        different threads must be safe.\n\n        ---\n        // Same thing, but explicitly allocate an array\n        // to return the results in.  The element type\n        // of the array may be either the exact type\n        // returned by functions or an implicit conversion\n        // target.\n        auto squareRoots = new float[numbers.length];\n        taskPool.amap!sqrt(numbers, squareRoots);\n\n        // Multiple functions, explicit output range, and\n        // explicit work unit size.\n        auto results = new Tuple!(float, real)[numbers.length];\n        taskPool.amap!(sqrt, log)(numbers, 100, results);\n        ---\n\n        Note:\n\n        A memory barrier is guaranteed to be executed after all results are written\n        but before returning so that results produced by all threads are visible\n        in the calling thread.\n\n        Tips:\n\n        To perform the mapping operation in place, provide the same range for the\n        input and output range.\n\n        To parallelize the copying of a range with expensive to evaluate elements\n        to an array, pass an identity function (a function that just returns\n        whatever argument is provided to it) to $(D amap).\n\n        $(B Exception Handling):\n\n        When at least one exception is thrown from inside the map functions,\n        the submission of additional $(D Task) objects is terminated as soon as\n        possible, in a non-deterministic manner.  All currently executing or\n        enqueued work units are allowed to complete.  Then, all exceptions that\n        were thrown from any work unit are chained using $(D Throwable.next) and\n        rethrown.  The order of the exception chaining is non-deterministic.\n",
								"parameters": [
									{
										"name": "Args",
										"kind": "tuple"
									}
								],
								"constraint": "isRandomAccessRange!(Args[0])",
								"char": 14,
								"kind": "template"
							}
						],
						"name": "amap",
						"line": 1547,
						"comment": "\n",
						"parameters": [
							{
								"name": "functions",
								"kind": "tuple"
							}
						],
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"members": [
									{
										"endchar": 9,
										"name": "map",
										"line": 1816,
										"type": "(S source, size_t bufSize = 100, size_t workUnitSize = size_t.max)",
										"parameters": [
											{
												"name": "source",
												"type": "S"
											},
											{
												"name": "bufSize",
												"type": "size_t",
												"default": "100"
											},
											{
												"name": "workUnitSize",
												"type": "size_t",
												"default": "size_t.max"
											}
										],
										"endline": 2077,
										"char": 9,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "map",
								"line": 1816,
								"comment": "        A semi-lazy parallel map that can be used for pipelining.  The map\n        functions are evaluated for the first $(D bufSize) elements and stored in a\n        buffer and made available to $(D popFront).  Meanwhile, in the\n        background a second buffer of the same size is filled.  When the first\n        buffer is exhausted, it is swapped with the second buffer and filled while\n        the values from what was originally the second buffer are read.  This\n        implementation allows for elements to be written to the buffer without\n        the need for atomic operations or synchronization for each write, and\n        enables the mapping function to be evaluated efficiently in parallel.\n\n        $(D map) has more overhead than the simpler procedure used by $(D amap)\n        but avoids the need to keep all results in memory simultaneously and works\n        with non-random access ranges.\n\n        Params:\n\n        source = The input range to be mapped.  If $(D source) is not random\n        access it will be lazily buffered to an array of size $(D bufSize) before\n        the map function is evaluated.  (For an exception to this rule, see Notes.)\n\n        bufSize = The size of the buffer to store the evaluated elements.\n\n        workUnitSize = The number of elements to evaluate in a single\n        $(D Task).  Must be less than or equal to $(D bufSize), and\n        should be a fraction of $(D bufSize) such that all worker threads can be\n        used.  If the default of size_t.max is used, workUnitSize will be set to\n        the pool-wide default.\n\n        Returns:  An input range representing the results of the map.  This range\n                  has a length iff $(D source) has a length.\n\n        Notes:\n\n        If a range returned by $(D map) or $(D asyncBuf) is used as an input to\n        $(D map), then as an optimization the copying from the output buffer\n        of the first range to the input buffer of the second range is elided, even\n        though the ranges returned by $(D map) and $(D asyncBuf) are non-random\n        access ranges.  This means that the $(D bufSize) parameter passed to the\n        current call to $(D map) will be ignored and the size of the buffer\n        will be the buffer size of $(D source).\n\n        Example:\n        ---\n        // Pipeline reading a file, converting each line\n        // to a number, taking the logarithms of the numbers,\n        // and performing the additions necessary to find\n        // the sum of the logarithms.\n\n        auto lineRange = File(\"numberList.txt\").byLine();\n        auto dupedLines = std.algorithm.map!\"a.idup\"(lineRange);\n        auto nums = taskPool.map!(to!double)(dupedLines);\n        auto logs = taskPool.map!log10(nums);\n\n        double sum = 0;\n        foreach(elem; logs)\n        {\n            sum += elem;\n        }\n        ---\n\n        $(B Exception Handling):\n\n        Any exceptions thrown while iterating over $(D source)\n        or computing the map function are re-thrown on a call to $(D popFront) or,\n        if thrown during construction, are simply allowed to propagate to the\n        caller.  In the case of exceptions thrown while computing the map function,\n        the exceptions are chained as in $(D TaskPool.amap).\n",
								"parameters": [
									{
										"name": "S",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!S",
								"char": 9,
								"kind": "template"
							}
						],
						"name": "map",
						"line": 1744,
						"comment": "\n",
						"parameters": [
							{
								"name": "functions",
								"kind": "tuple"
							}
						],
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "asyncBuf",
								"line": 2123,
								"type": "(S source, size_t bufSize = 100)",
								"parameters": [
									{
										"name": "source",
										"type": "S"
									},
									{
										"name": "bufSize",
										"type": "size_t",
										"default": "100"
									}
								],
								"endline": 2258,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "asyncBuf",
						"line": 2123,
						"comment": "    Given a $(D source) range that is expensive to iterate over, returns an\n    input range that asynchronously buffers the contents of\n    $(D source) into a buffer of $(D bufSize) elements in a worker thread,\n    while making previously buffered elements from a second buffer, also of size\n    $(D bufSize), available via the range interface of the returned\n    object.  The returned range has a length iff $(D hasLength!S).\n    $(D asyncBuf) is useful, for example, when performing expensive operations\n    on the elements of ranges that represent data on a disk or network.\n\n    Example:\n    ---\n    import std.conv, std.stdio;\n\n    void main()\n    {\n        // Fetch lines of a file in a background thread\n        // while processing previously fetched lines,\n        // dealing with byLine's buffer recycling by\n        // eagerly duplicating every line.\n        auto lines = File(\"foo.txt\").byLine();\n        auto duped = std.algorithm.map!\"a.idup\"(lines);\n\n        // Fetch more lines in the background while we\n        // process the lines already read into memory\n        // into a matrix of doubles.\n        double[][] matrix;\n        auto asyncReader = taskPool.asyncBuf(duped);\n\n        foreach(line; asyncReader)\n        {\n            auto ls = line.split(\"\\t\");\n            matrix ~= to!(double[])(ls);\n        }\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D source) are re-thrown on a\n    call to $(D popFront) or, if thrown during construction, simply\n    allowed to propagate to the caller.\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!S",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "asyncBuf",
								"line": 2323,
								"type": "(C1 next, C2 empty, size_t initialBufSize = 0, size_t nBuffers = 100)",
								"parameters": [
									{
										"name": "next",
										"type": "C1"
									},
									{
										"name": "empty",
										"type": "C2"
									},
									{
										"name": "initialBufSize",
										"type": "size_t",
										"default": "0"
									},
									{
										"name": "nBuffers",
										"type": "size_t",
										"default": "100"
									}
								],
								"endline": 2331,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "asyncBuf",
						"line": 2323,
						"comment": "    Given a callable object $(D next) that writes to a user-provided buffer and\n    a second callable object $(D empty) that determines whether more data is\n    available to write via $(D next), returns an input range that\n    asynchronously calls $(D next) with a set of size $(D nBuffers) of buffers\n    and makes the results available in the order they were obtained via the\n    input range interface of the returned object.  Similarly to the\n    input range overload of $(D asyncBuf), the first half of the buffers\n    are made available via the range interface while the second half are\n    filled and vice-versa.\n\n    Params:\n\n    next = A callable object that takes a single argument that must be an array\n           with mutable elements.  When called, $(D next) writes data to\n           the array provided by the caller.\n\n    empty = A callable object that takes no arguments and returns a type\n            implicitly convertible to $(D bool).  This is used to signify\n            that no more data is available to be obtained by calling $(D next).\n\n    initialBufSize = The initial size of each buffer.  If $(D next) takes its\n                     array by reference, it may resize the buffers.\n\n    nBuffers = The number of buffers to cycle through when calling $(D next).\n\n    Example:\n    ---\n    // Fetch lines of a file in a background\n    // thread while processing previously fetched\n    // lines, without duplicating any lines.\n    auto file = File(\"foo.txt\");\n\n    void next(ref char[] buf)\n    {\n        file.readln(buf);\n    }\n\n    // Fetch more lines in the background while we\n    // process the lines already read into memory\n    // into a matrix of doubles.\n    double[][] matrix;\n    auto asyncReader = taskPool.asyncBuf(&next, &file.eof);\n\n    foreach(line; asyncReader)\n    {\n        auto ls = line.split(\"\\t\");\n        matrix ~= to!(double[])(ls);\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D range) are re-thrown on a\n    call to $(D popFront).\n\n    Warning:\n\n    Using the range returned by this function in a parallel foreach loop\n    will not work because buffers may be overwritten while the task that\n    processes them is in queue.  This is checked for at compile time\n    and will result in a static assertion failure.\n",
						"parameters": [
							{
								"name": "C1",
								"kind": "type"
							},
							{
								"name": "C2",
								"kind": "type"
							}
						],
						"constraint": "is(typeof(C2.init()) : bool) && Parameters!C1.length == 1 && Parameters!C2.length == 0 && isArray!(Parameters!C1[0])",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"members": [
									{
										"endchar": 9,
										"name": "reduce",
										"line": 2420,
										"type": "(Args args)",
										"parameters": [
											{
												"name": "args",
												"type": "Args"
											}
										],
										"endline": 2710,
										"char": 14,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "reduce",
								"line": 2420,
								"comment": "        Parallel reduce on a random access range.  Except as otherwise noted,\n        usage is similar to $(XREF_PACK algorithm,iteration,_reduce).  This\n        function works by splitting the range to be reduced into work units,\n        which are slices to be reduced in parallel.  Once the results from all\n        work units are computed, a final serial reduction is performed on these\n        results to compute the final answer. Therefore, care must be taken to\n        choose the seed value appropriately.\n\n        Because the reduction is being performed in parallel, $(D functions)\n        must be associative.  For notational simplicity, let # be an\n        infix operator representing $(D functions).  Then, (a # b) # c must equal\n        a # (b # c).  Floating point addition is not associative\n        even though addition in exact arithmetic is.  Summing floating\n        point numbers using this function may give different results than summing\n        serially.  However, for many practical purposes floating point addition\n        can be treated as associative.\n\n        Note that, since $(D functions) are assumed to be associative,\n        additional optimizations are made to the serial portion of the reduction\n        algorithm. These take advantage of the instruction level parallelism of\n        modern CPUs, in addition to the thread-level parallelism that the rest\n        of this module exploits.  This can lead to better than linear speedups\n        relative to $(XREF_PACK algorithm,iteration,_reduce), especially for\n        fine-grained benchmarks like dot products.\n\n        An explicit seed may be provided as the first argument.  If\n        provided, it is used as the seed for all work units and for the final\n        reduction of results from all work units.  Therefore, if it is not the\n        identity value for the operation being performed, results may differ\n        from those generated by $(XREF_PACK algorithm,iteration,_reduce) or\n        depending on how many work units are used.  The next argument must be\n        the range to be reduced.\n        ---\n        // Find the sum of squares of a range in parallel, using\n        // an explicit seed.\n        //\n        // Timings on an Athlon 64 X2 dual core machine:\n        //\n        // Parallel reduce:                     72 milliseconds\n        // Using std.algorithm.reduce instead:  181 milliseconds\n        auto nums = iota(10_000_000.0f);\n        auto sumSquares = taskPool.reduce!\"a + b\"(\n            0.0, std.algorithm.map!\"a * a\"(nums)\n        );\n        ---\n\n        If no explicit seed is provided, the first element of each work unit\n        is used as a seed.  For the final reduction, the result from the first\n        work unit is used as the seed.\n        ---\n        // Find the sum of a range in parallel, using the first\n        // element of each work unit as the seed.\n        auto sum = taskPool.reduce!\"a + b\"(nums);\n        ---\n\n        An explicit work unit size may be specified as the last argument.\n        Specifying too small a work unit size will effectively serialize the\n        reduction, as the final reduction of the result of each work unit will\n        dominate computation time.  If $(D TaskPool.size) for this instance\n        is zero, this parameter is ignored and one work unit is used.\n        ---\n        // Use a work unit size of 100.\n        auto sum2 = taskPool.reduce!\"a + b\"(nums, 100);\n\n        // Work unit size of 100 and explicit seed.\n        auto sum3 = taskPool.reduce!\"a + b\"(0.0, nums, 100);\n        ---\n\n        Parallel reduce supports multiple functions, like\n        $(D std.algorithm.reduce).\n        ---\n        // Find both the min and max of nums.\n        auto minMax = taskPool.reduce!(min, max)(nums);\n        assert(minMax[0] == reduce!min(nums));\n        assert(minMax[1] == reduce!max(nums));\n        ---\n\n        $(B Exception Handling):\n\n        After this function is finished executing, any exceptions thrown\n        are chained together via $(D Throwable.next) and rethrown.  The chaining\n        order is non-deterministic.\n",
								"parameters": [
									{
										"name": "Args",
										"kind": "tuple"
									}
								],
								"char": 14,
								"kind": "template"
							}
						],
						"name": "reduce",
						"line": 2334,
						"comment": "\n",
						"parameters": [
							{
								"name": "functions",
								"kind": "tuple"
							}
						],
						"char": 5,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "workerIndex",
						"line": 2752,
						"comment": "    Gets the index of the current thread relative to this $(D TaskPool).  Any\n    thread not in this pool will receive an index of 0.  The worker threads in\n    this pool receive unique indices of 1 through $(D this.size).\n\n    This function is useful for maintaining worker-local resources.\n\n    Example:\n    ---\n    // Execute a loop that computes the greatest common\n    // divisor of every number from 0 through 999 with\n    // 42 in parallel.  Write the results out to\n    // a set of files, one for each thread.  This allows\n    // results to be written out without any synchronization.\n\n    import std.conv, std.range, std.numeric, std.stdio;\n\n    void main()\n    {\n        auto filesHandles = new File[taskPool.size + 1];\n        scope(exit) {\n            foreach(ref handle; fileHandles) {\n                handle.close();\n            }\n        }\n\n        foreach(i, ref handle; fileHandles)\n        {\n            handle = File(\"workerResults\" ~ to!string(i) ~ \".txt\");\n        }\n\n        foreach(num; parallel(iota(1_000)))\n        {\n            auto outHandle = fileHandles[taskPool.workerIndex];\n            outHandle.writeln(num, '\\t', gcd(num, 42));\n        }\n    }\n    ---\n",
						"deco": "xFNbNdNfZm",
						"endline": 2757,
						"originalType": "const nothrow @property @safe size_t()",
						"char": 12,
						"kind": "function"
					},
					{
						"members": [
							{
								"name": "WorkerLocalStorage",
								"line": 2804,
								"members": [
									{
										"endchar": 9,
										"name": "get",
										"line": 2882,
										"comment": "        Get the current thread's instance.  Returns by ref.\n        Note that calling $(D get) from any thread\n        outside the $(D TaskPool) that created this instance will return the\n        same reference, so an instance of worker-local storage should only be\n        accessed from one thread outside the pool that created it.  If this\n        rule is violated, undefined behavior will result.\n\n        If assertions are enabled and $(D toRange) has been called, then this\n        WorkerLocalStorage instance is no longer worker-local and an assertion\n        failure will result when calling this method.  This is not checked\n        when assertions are disabled for performance reasons.\n",
										"type": "@property ref T()",
										"endline": 2889,
										"char": 15,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "get",
										"line": 2895,
										"comment": "        Assign a value to the current thread's instance.  This function has\n        the same caveats as its overload.\n",
										"type": "@property void(T val)",
										"parameters": [
											{
												"name": "val",
												"type": "T"
											}
										],
										"endline": 2903,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "toRange",
										"line": 2915,
										"comment": "        Returns a range view of the values for all threads, which can be used\n        to further process the results of each thread after running the parallel\n        part of your algorithm.  Do not use this method in the parallel portion\n        of your algorithm.\n\n        Calling this function sets a flag indicating that this struct is no\n        longer worker-local, and attempting to use the $(D get) method again\n        will result in an assertion failure if assertions are enabled.\n",
										"type": "@property WorkerLocalStorageRange!T()",
										"endline": 2932,
										"char": 35,
										"kind": "function"
									}
								],
								"char": 12,
								"kind": "struct"
							}
						],
						"name": "WorkerLocalStorage",
						"line": 2804,
						"comment": "    Struct for creating worker-local storage.  Worker-local storage is\n    thread-local storage that exists only for worker threads in a given\n    $(D TaskPool) plus a single thread outside the pool.  It is allocated on the\n    garbage collected heap in a way that avoids _false sharing, and doesn't\n    necessarily have global scope within any thread.  It can be accessed from\n    any worker thread in the $(D TaskPool) that created it, and one thread\n    outside this $(D TaskPool).  All threads outside the pool that created a\n    given instance of worker-local storage share a single slot.\n\n    Since the underlying data for this struct is heap-allocated, this struct\n    has reference semantics when passed between functions.\n\n    The main uses cases for $(D WorkerLocalStorageStorage) are:\n\n    1.  Performing parallel reductions with an imperative, as opposed to\n    functional, programming style.  In this case, it's useful to treat\n    $(D WorkerLocalStorageStorage) as local to each thread for only the parallel\n    portion of an algorithm.\n\n    2.  Recycling temporary buffers across iterations of a parallel foreach loop.\n\n    Example:\n    ---\n    // Calculate pi as in our synopsis example, but\n    // use an imperative instead of a functional style.\n    immutable n = 1_000_000_000;\n    immutable delta = 1.0L / n;\n\n    auto sums = taskPool.workerLocalStorage(0.0L);\n    foreach(i; parallel(iota(n)))\n    {\n        immutable x = ( i - 0.5L ) * delta;\n        immutable toAdd = delta / ( 1.0 + x * x );\n        sums.get += toAdd;\n    }\n\n    // Add up the results from each worker thread.\n    real pi = 0;\n    foreach(threadResult; sums.toRange)\n    {\n        pi += 4.0L * threadResult;\n    }\n    ---\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"name": "WorkerLocalStorageRange",
								"line": 2947,
								"members": [],
								"char": 12,
								"kind": "struct"
							}
						],
						"name": "WorkerLocalStorageRange",
						"line": 2947,
						"comment": "    Range primitives for worker-local storage.  The purpose of this is to\n    access results produced by each worker thread from a single thread once you\n    are no longer using the worker-local storage from multiple threads.\n    Do not use this struct in the parallel portion of your algorithm.\n\n    The proper way to instantiate this object is to call\n    $(D WorkerLocalStorage.toRange).  Once instantiated, this object behaves\n    as a finite random-access range with assignable, lvalue elements and\n    a length equal to the number of worker threads in the $(D TaskPool) that\n    created it plus 1.\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "workerLocalStorage",
								"line": 3032,
								"type": "WorkerLocalStorage!T(lazy T initialVal = T.init)",
								"parameters": [
									{
										"name": "initialVal",
										"type": "T",
										"storageClass": [
											"lazy"
										],
										"default": "T.init"
									}
								],
								"endline": 3047,
								"char": 26,
								"kind": "function"
							}
						],
						"name": "workerLocalStorage",
						"line": 3032,
						"comment": "    Creates an instance of worker-local storage, initialized with a given\n    value.  The value is $(D lazy) so that you can, for example, easily\n    create one instance of a class for each worker.  For usage example,\n    see the $(D WorkerLocalStorage) struct.\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 26,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "stop",
						"line": 3060,
						"comment": "    Signals to all worker threads to terminate as soon as they are finished\n    with their current $(D Task), or immediately if they are not executing a\n    $(D Task).  $(D Task)s that were in queue will not be executed unless\n    a call to $(D Task.workForce), $(D Task.yieldForce) or $(D Task.spinForce)\n    causes them to be executed.\n\n    Use only if you have waited on every $(D Task) and therefore know the\n    queue is empty, or if you speculatively executed some tasks and no longer\n    need the results.\n",
						"deco": "FNeZv",
						"endline": 3066,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "finish",
						"line": 3081,
						"comment": "    Signals worker threads to terminate when the queue becomes empty.\n\n    If blocking argument is true, wait for all worker threads to terminate\n    before returning.  This option might be used in applications where\n    task results are never consumed-- e.g. when $(D TaskPool) is employed as a\n    rudimentary scheduler for tasks which communicate by means other than\n    return values.\n\n    Warning:  Calling this function with $(D blocking = true) from a worker\n              thread that is a member of the same $(D TaskPool) that\n              $(D finish) is being called on will result in a deadlock.\n",
						"deco": "FNebZv",
						"parameters": [
							{
								"name": "blocking",
								"deco": "b",
								"default": "false"
							}
						],
						"endline": 3109,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "size",
						"line": 3112,
						"comment": "Returns the number of worker threads in the pool.\n",
						"deco": "xFNaNbNdNfZm",
						"endline": 3115,
						"originalType": "const pure nothrow @property @safe size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "put",
								"line": 3149,
								"type": "void(ref Task!(fun, Args) task)",
								"parameters": [
									{
										"name": "task",
										"type": "Task!(fun, Args)",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 3154,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "put",
						"line": 3149,
						"comment": "    Put a $(D Task) object on the back of the task queue.  The $(D Task)\n    object may be passed by pointer or reference.\n\n    Example:\n    ---\n    import std.file;\n\n    // Create a task.\n    auto t = task!read(\"foo.txt\");\n\n    // Add it to the queue to be executed.\n    taskPool.put(t);\n    ---\n\n    Notes:\n\n    @trusted overloads of this function are called for $(D Task)s if\n    $(XREF traits, hasUnsharedAliasing) is false for the $(D Task)'s\n    return type or the function the $(D Task) executes is $(D pure).\n    $(D Task) objects that meet all other requirements specified in the\n    $(D @trusted) overloads of $(D task) and $(D scopedTask) may be created\n    and executed from $(D @safe) code via $(D Task.executeInNewThread) but\n    not via $(D TaskPool).\n\n    While this function takes the address of variables that may\n    be on the stack, some overloads are marked as @trusted.\n    $(D Task) includes a destructor that waits for the task to complete\n    before destroying the stack frame it is allocated on.  Therefore,\n    it is impossible for the stack frame to be destroyed before the task is\n    complete and no longer referenced by a $(D TaskPool).\n",
						"parameters": [
							{
								"name": "fun",
								"kind": "alias"
							},
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"constraint": "!isSafeReturn!(typeof(task))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "put",
								"line": 3157,
								"type": "void(Task!(fun, Args)* task)",
								"parameters": [
									{
										"name": "task",
										"type": "Task!(fun, Args)*"
									}
								],
								"endline": 3162,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "put",
						"line": 3157,
						"comment": "Ditto\n",
						"parameters": [
							{
								"name": "fun",
								"kind": "alias"
							},
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"constraint": "!isSafeReturn!(typeof(*task))",
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "isDaemon",
						"line": 3194,
						"comment": "    These properties control whether the worker threads are daemon threads.\n    A daemon thread is automatically terminated when all non-daemon threads\n    have terminated.  A non-daemon thread will prevent a program from\n    terminating as long as it has not terminated.\n\n    If any $(D TaskPool) with non-daemon threads is active, either $(D stop)\n    or $(D finish) must be called on it before the program can terminate.\n\n    The worker treads in the $(D TaskPool) instance returned by the\n    $(D taskPool) property are daemon by default.  The worker threads of\n    manually instantiated task pools are non-daemon by default.\n\n    Note:  For a size zero pool, the getter arbitrarily returns true and the\n           setter has no effect.\n",
						"deco": "FNdNeZb",
						"endline": 3199,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isDaemon",
						"line": 3202,
						"comment": "Ditto\n",
						"deco": "FNdNebZv",
						"parameters": [
							{
								"name": "newVal",
								"deco": "b"
							}
						],
						"endline": 3210,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "priority",
						"line": 3221,
						"comment": "    These functions allow getting and setting the OS scheduling priority of\n    the worker threads in this $(D TaskPool).  They forward to\n    $(D core.thread.Thread.priority), so a given priority value here means the\n    same thing as an identical priority value in $(D core.thread).\n\n    Note:  For a size zero pool, the getter arbitrarily returns\n           $(D core.thread.Thread.PRIORITY_MIN) and the setter has no effect.\n",
						"deco": "FNdNeZi",
						"endline": 3225,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "priority",
						"line": 3228,
						"comment": "Ditto\n",
						"deco": "FNdNeiZv",
						"parameters": [
							{
								"name": "newPriority",
								"deco": "i"
							}
						],
						"endline": 3237,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "taskPool",
				"line": 3247,
				"comment": "Returns a lazily initialized global instantiation of $(D TaskPool).\nThis function can safely be called concurrently from multiple non-worker\nthreads.  The worker threads in this pool are daemon threads, meaning that it\nis not necessary to call $(D TaskPool.stop) or $(D TaskPool.finish) before\nterminating the main thread.\n",
				"deco": "FNdNeZC3std11parallelism8TaskPool",
				"endline": 3256,
				"char": 20,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "defaultPoolThreads",
				"line": 3270,
				"comment": "These properties get and set the number of worker threads in the $(D TaskPool)\ninstance returned by $(D taskPool).  The default value is $(D totalCPUs) - 1.\nCalling the setter after the first call to $(D taskPool) does not changes\nnumber of worker threads in the instance returned by $(D taskPool).\n",
				"deco": "FNdNeZk",
				"endline": 3273,
				"char": 16,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "defaultPoolThreads",
				"line": 3276,
				"comment": "Ditto\n",
				"deco": "FNdNekZv",
				"parameters": [
					{
						"name": "newVal",
						"deco": "k"
					}
				],
				"endline": 3279,
				"char": 16,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parallel",
						"line": 3299,
						"type": "ParallelForeach!R(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 3302,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "parallel",
				"line": 3299,
				"comment": "Convenience functions that forwards to $(D taskPool.parallel).  The\npurpose of these is to make parallel foreach less verbose and more\nreadable.\n\nExample:\n---\n// Find the logarithm of every number from\n// 1 to 1_000_000 in parallel, using the\n// default TaskPool instance.\nauto logs = new double[1_000_000];\n\nforeach(i, ref elem; parallel(logs)) {\n    elem = log(i + 1.0);\n}\n---\n\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parallel",
						"line": 3305,
						"type": "ParallelForeach!R(R range, size_t workUnitSize)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "workUnitSize",
								"type": "size_t"
							}
						],
						"endline": 3308,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "parallel",
				"line": 3305,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 19,
				"kind": "template"
			}
		],
		"comment": "$(D std._parallelism) implements high-level primitives for SMP _parallelism.\nThese include parallel foreach, parallel reduce, parallel eager map, pipelining\nand future/promise _parallelism.  $(D std._parallelism) is recommended when the\nsame operation is to be executed in parallel on different data, or when a\nfunction is to be executed in a background thread and its result returned to a\nwell-defined main thread.  For communication between arbitrary threads, see\n$(D std.concurrency).\n\n$(D std._parallelism) is based on the concept of a $(D Task).  A $(D Task) is an\nobject that represents the fundamental unit of work in this library and may be\nexecuted in parallel with any other $(D Task).  Using $(D Task)\ndirectly allows programming with a future/promise paradigm.  All other\nsupported _parallelism paradigms (parallel foreach, map, reduce, pipelining)\nrepresent an additional level of abstraction over $(D Task).  They\nautomatically create one or more $(D Task) objects, or closely related types\nthat are conceptually identical but not part of the public API.\n\nAfter creation, a $(D Task) may be executed in a new thread, or submitted\nto a $(D TaskPool) for execution.  A $(D TaskPool) encapsulates a task queue\nand its worker threads.  Its purpose is to efficiently map a large\nnumber of $(D Task)s onto a smaller number of threads.  A task queue is a\nFIFO queue of $(D Task) objects that have been submitted to the\n$(D TaskPool) and are awaiting execution.  A worker thread is a thread that\nis associated with exactly one task queue.  It executes the $(D Task) at the\nfront of its queue when the queue has work available, or sleeps when\nno work is available.  Each task queue is associated with zero or\nmore worker threads.  If the result of a $(D Task) is needed before execution\nby a worker thread has begun, the $(D Task) can be removed from the task queue\nand executed immediately in the thread where the result is needed.\n\nWarning:  Unless marked as $(D @trusted) or $(D @safe), artifacts in\n          this module allow implicit data sharing between threads and cannot\n          guarantee that client code is free from low level data races.\n\nSynopsis:\n\n---\nimport std.algorithm, std.parallelism, std.range;\n\nvoid main() {\n    // Parallel reduce can be combined with\n    // std.algorithm.map to interesting effect.\n    // The following example (thanks to Russel Winder)\n    // calculates pi by quadrature  using\n    // std.algorithm.map and TaskPool.reduce.\n    // getTerm is evaluated in parallel as needed by\n    // TaskPool.reduce.\n    //\n    // Timings on an Athlon 64 X2 dual core machine:\n    //\n    // TaskPool.reduce:       12.170 s\n    // std.algorithm.reduce:  24.065 s\n\n    immutable n = 1_000_000_000;\n    immutable delta = 1.0 / n;\n\n    real getTerm(int i)\n    {\n        immutable x = ( i - 0.5 ) * delta;\n        return delta / ( 1.0 + x * x ) ;\n    }\n\n    immutable pi = 4.0 * taskPool.reduce!\"a + b\"(\n        std.algorithm.map!getTerm(iota(n))\n    );\n}\n---\n\nSource:    $(PHOBOSSRC std/_parallelism.d)\nAuthor:  David Simcha\nCopyright:  Copyright (c) 2009-2011, David Simcha.\nLicense:    $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/uni.d",
		"name": "std.uni",
		"members": [
			{
				"name": "lineSep",
				"line": 707,
				"comment": "Constant $(CODEPOINT) (0x2028) - line separator.\n",
				"deco": "w",
				"init": "'\\U00002028'",
				"char": 19,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "paraSep",
				"line": 708,
				"comment": "Constant $(CODEPOINT) (0x2029) - paragraph separator.\n",
				"deco": "w",
				"init": "'\\U00002029'",
				"char": 19,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "nelSep",
				"line": 709,
				"comment": "Constant $(CODEPOINT) (0x0085) - next line.\n",
				"deco": "w",
				"init": "'\\x85'",
				"char": 19,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [],
				"name": "isCodepointSet",
				"line": 1842,
				"comment": "    Tests if T is some kind a set of code points. Intended for template constraints.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isIntegralPair",
						"line": 1863,
						"init": "is(typeof((T x)\n{\nV a = x[0];\nV b = x[1];\n}\n)) && !is(typeof((T x)\n{\nV c = x[2];\n}\n))",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isIntegralPair",
				"line": 1861,
				"comment": "    Tests if $(D T) is a pair of integers that implicitly convert to $(D V).\n    The following code must compile for any pair $(D T):\n    ---\n    (T x){ V a = x[0]; V b = x[1];}\n    ---\n    The following must not compile:\n     ---\n    (T x){ V c = x[2];}\n    ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"defaultDeco": "k",
						"name": "V",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"name": "CodepointSet",
				"line": 1872,
				"comment": "    The recommended default type for set of $(CODEPOINTS).\n    For details, see the current implementation: $(LREF InversionList).\n",
				"deco": "S3std3uni38__T13InversionListTS3std3uni8GcPolicyZ13InversionList",
				"char": 8,
				"kind": "alias"
			},
			{
				"name": "CodepointInterval",
				"line": 1885,
				"comment": "    The recommended type of $(XREF _typecons, Tuple)\n    to represent [a, b$(RPAREN) intervals of $(CODEPOINTS). As used in $(LREF InversionList).\n    Any interval type should pass $(LREF isIntegralPair) trait.\n",
				"members": [],
				"char": 8,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "InversionList",
						"line": 1980,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 1989,
										"type": "pure (Set set)",
										"parameters": [
											{
												"name": "set",
												"type": "Set"
											}
										],
										"endline": 1999,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 1989,
								"comment": "        Construct from another code point set of any type.\n",
								"parameters": [
									{
										"name": "Set",
										"kind": "type"
									}
								],
								"constraint": "isCodepointSet!Set",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 2004,
										"type": "pure (Range intervals)",
										"parameters": [
											{
												"name": "intervals",
												"type": "Range"
											}
										],
										"endline": 2015,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 2004,
								"comment": "        Construct a set from a forward range of code point intervals.\n",
								"parameters": [
									{
										"name": "Range",
										"kind": "type"
									}
								],
								"constraint": "isForwardRange!Range && isIntegralPair!(ElementType!Range)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 2050,
										"type": "(uint[] intervals...)",
										"parameters": [
											{
												"name": "intervals",
												"type": "uint[]"
											}
										],
										"endline": 2065,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 2050,
								"comment": "        Construct a set from plain values of code point intervals.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2068_1955)\n---\nimport std.algorithm.comparison : equal;\n\nauto set = CodepointSet('a', 'z'+1, 'а', 'я'+1);\nforeach(v; 'a'..'z'+1)\n    assert(set[v]);\n// Cyrillic lowercase interval\nforeach(v; 'а'..'я'+1)\n    assert(set[v]);\n//specific order is not required, intervals may interesect\nauto set2 = CodepointSet('а', 'я'+1, 'a', 'd', 'b', 'z'+1);\n//the same end result\nassert(set2.byInterval.equal(set.byInterval));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2068_1955)\n",
								"parameters": [],
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "byInterval",
								"line": 2097,
								"comment": "        Get range that spans all of the $(CODEPOINT) intervals in this $(LREF InversionList).\n\n        Example:\n        -----------\n        import std.algorithm.comparison : equal;\n        import std.typecons : tuple;\n\n        auto set = CodepointSet('A', 'D'+1, 'a', 'd'+1);\n\n        assert(set.byInterval.equal([tuple('A','E'), tuple('a','e')]));\n        -----------\n",
								"type": "@property ()",
								"endline": 2100,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "opIndex",
								"line": 2105,
								"comment": "        Tests the presence of code point $(D val) in this set.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2113_1956)\n---\nauto gothic = unicode.Gothic;\n// Gothic letter ahsa\nassert(gothic['\\U00010330']);\n// no ascii in Gothic obviously\nassert(!gothic['$']);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2113_1956)\n",
								"type": "const bool(uint val)",
								"parameters": [
									{
										"name": "val",
										"deco": "k"
									}
								],
								"endline": 2110,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 2136,
								"comment": "Number of $(CODEPOINTS) in this set\n",
								"type": "@property size_t()",
								"endline": 2144,
								"char": 22,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 2160,
										"type": "This(U rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "U"
											}
										],
										"endline": 2195,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 2160,
								"comment": "        $(P Sets support natural syntax for set algebra, namely: )\n        $(BOOKTABLE ,\n            $(TR $(TH Operator) $(TH Math notation) $(TH Description) )\n            $(TR $(TD &) $(TD a ∩ b) $(TD intersection) )\n            $(TR $(TD |) $(TD a ∪ b) $(TD union) )\n            $(TR $(TD -) $(TD a ∖ b) $(TD subtraction) )\n            $(TR $(TD ~) $(TD a ~ b) $(TD symmetric set difference i.e. (a ∪ b) \\ (a ∩ b)) )\n        )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2198_1957)\n---\nimport std.algorithm.comparison : equal;\nimport std.range : iota;\n\nauto lower = unicode.LowerCase;\nauto upper = unicode.UpperCase;\nauto ascii = unicode.ASCII;\n\nassert((lower & upper).empty); // no intersection\nauto lowerASCII = lower & ascii;\nassert(lowerASCII.byCodepoint.equal(iota('a', 'z'+1)));\n// throw away all of the lowercase ASCII\nassert((ascii - lower).length == 128 - 26);\n\nauto onlyOneOf = lower ~ ascii;\nassert(!onlyOneOf['Δ']); // not ASCII and not lowercase\nassert(onlyOneOf['$']); // ASCII and not lowercase\nassert(!onlyOneOf['a']); // ASCII and lowercase\nassert(onlyOneOf['я']); // not ASCII but lowercase\n\n// throw away all cased letters from ASCII\nauto noLetters = ascii - (lower | upper);\nassert(noLetters.length == 128 - 26*2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2198_1957)\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isCodepointSet!U || is(U : dchar)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 2225,
										"type": "ref This(U rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "U"
											}
										],
										"endline": 2251,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 2225,
								"comment": "The 'op=' versions of the above overloaded operators.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isCodepointSet!U || is(U : dchar)",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinaryRight",
										"line": 2257,
										"type": "const bool(U ch)",
										"parameters": [
											{
												"name": "ch",
												"type": "U"
											}
										],
										"endline": 2261,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opBinaryRight",
								"line": 2257,
								"comment": "        Tests the presence of codepoint $(D ch) in this set,\n        the same as $(LREF opIndex).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2264_1958)\n---\nassert('я' in unicode.Cyrillic);\nassert(!('z' in unicode.Cyrillic));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2264_1958)\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"in\"",
										"kind": "value"
									},
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "is(U : dchar)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opUnary",
										"line": 2277,
										"type": "()",
										"endline": 2280,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "opUnary",
								"line": 2277,
								"comment": " Obtains a set that is the inversion of this set.\n\n See_Also: $(LREF inverted)\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"!\"",
										"kind": "value"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "byCodepoint",
								"line": 2285,
								"comment": "        A range that spans each $(CODEPOINT) in this set.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2326_1959)\n---\nimport std.algorithm.comparison : equal;\nimport std.range : iota;\n\nauto set = unicode.ASCII;\nset.byCodepoint.equal(iota(0, 0x80));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2326_1959)\n",
								"type": "@property ()",
								"endline": 2323,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 2361,
								"comment": " Obtain a textual representation of this InversionList\n in form of open-right intervals.\n\n The formatting flag is applied individually to each value, for example:\n $(LI $(B %s) and $(B %d) format the intervals as a [low..high$(RPAREN) range of integrals)\n $(LI $(B %x) formats the intervals as a [low..high$(RPAREN) range of lowercase hex characters)\n $(LI $(B %X) formats the intervals as a [low..high$(RPAREN) range of uppercase hex characters)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2385_1960)\n---\nimport std.conv : to;\nimport std.format : format;\nimport std.uni : unicode;\n\nassert(unicode.Cyrillic.to!string ==\n    \"[1024..1157) [1159..1320) [7467..7468) [7544..7545) [11744..11776) [42560..42648) [42655..42656)\");\n\n// The specs '%s' and '%d' are equivalent to the to!string call above.\nassert(format(\"%d\", unicode.Cyrillic) == unicode.Cyrillic.to!string);\n\nassert(format(\"%#x\", unicode.Cyrillic) ==\n    \"[0x400..0x485) [0x487..0x528) [0x1d2b..0x1d2c) [0x1d78..0x1d79) [0x2de0..0x2e00) [0xa640..0xa698) [0xa69f..0xa6a0)\");\n\nassert(format(\"%#X\", unicode.Cyrillic) ==\n    \"[0X400..0X485) [0X487..0X528) [0X1D2B..0X1D2C) [0X1D78..0X1D79) [0X2DE0..0X2E00) [0XA640..0XA698) [0XA69F..0XA6A0)\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2385_1960)\n",
								"type": "void(scope void delegate(const(char)[]) sink, FormatSpec!char fmt)",
								"parameters": [
									{
										"name": "sink",
										"type": "void delegate(const(char)[])",
										"storageClass": [
											"scope"
										]
									},
									{
										"name": "fmt",
										"type": "FormatSpec!char"
									}
								],
								"endline": 2382,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "add",
										"line": 2415,
										"type": "ref (uint a, uint b)",
										"parameters": [
											{
												"name": "a",
												"deco": "k"
											},
											{
												"name": "b",
												"deco": "k"
											}
										],
										"endline": 2419,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "add",
								"line": 2415,
								"comment": "        Add an interval [a, b$(RPAREN) to this set.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2422_1962)\n---\nCodepointSet someSet;\nsomeSet.add('0', '5').add('A','Z'+1);\nsomeSet.add('5', '9'+1);\nassert(someSet['0']);\nassert(someSet['5']);\nassert(someSet['9']);\nassert(someSet['Z']);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2422_1962)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2459_1963)\n---\nassert(unicode.Cyrillic.intersect('-').byInterval.empty);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2459_1963)\n",
								"parameters": [],
								"char": 9,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "inverted",
								"line": 2504,
								"comment": "        Obtains a set that is the inversion of this set.\n\n        See the '!' $(LREF opUnary) for the same but using operators.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2527_1964)\n---\nauto set = unicode.ASCII;\n// union with the inverse gets all of the code points in the Unicode\nassert((set | set.inverted).length == 0x110000);\n// no intersection with the inverse\nassert((set & set.inverted).empty);\n}\n\n/**\nGenerates string with D source code of unary function with name of\n$(D funcName) taking a single $(D dchar) argument. If $(D funcName) is empty\nthe code is adjusted to be a lambda function.\n\nThe function generated tests if the $(CODEPOINT) passed\nbelongs to this set or not. The result is to be used with string mixin.\nThe intended usage area is aggressive optimization via meta programming\nin parser generators and the like.\n\nNote: Use with care for relatively small or regular sets. It\ncould end up being slower then just using multi-staged tables.\n\nExample:\n---\nimport std.stdio;\n\n// construct set directly from [a, b$RPAREN intervals\nauto set = CodepointSet(10, 12, 45, 65, 100, 200);\nwriteln(set);\nwriteln(set.toSourceCode(\"func\"));\n---\n\nThe above outputs something along the lines of:\n---\nbool func(dchar ch)  @safe pure nothrow @nogc\n{\n    if(ch < 45)\n    {\n        if(ch == 10 || ch == 11) return true;\n        return false;\n    }\n    else if (ch < 65) return true;\n    else\n    {\n        if(ch < 100) return false;\n        if(ch < 200) return true;\n        return false;\n    }\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2527_1964)\n",
								"type": "@property ()",
								"endline": 2524,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "toSourceCode",
								"line": 2578,
								"comment": "        Generates string with D source code of unary function with name of\n        $(D funcName) taking a single $(D dchar) argument. If $(D funcName) is empty\n        the code is adjusted to be a lambda function.\n\n        The function generated tests if the $(CODEPOINT) passed\n        belongs to this set or not. The result is to be used with string mixin.\n        The intended usage area is aggressive optimization via meta programming\n        in parser generators and the like.\n\n        Note: Use with care for relatively small or regular sets. It\n        could end up being slower then just using multi-staged tables.\n\n        Example:\n        ---\n        import std.stdio;\n\n        // construct set directly from [a, b$RPAREN intervals\n        auto set = CodepointSet(10, 12, 45, 65, 100, 200);\n        writeln(set);\n        writeln(set.toSourceCode(\"func\"));\n        ---\n\n        The above outputs something along the lines of:\n        ---\n        bool func(dchar ch)  @safe pure nothrow @nogc\n        {\n            if(ch < 45)\n            {\n                if(ch == 10 || ch == 11) return true;\n                return false;\n            }\n            else if (ch < 65) return true;\n            else\n            {\n                if(ch < 100) return false;\n                if(ch < 200) return true;\n                return false;\n            }\n        }\n        ---\n",
								"type": "string(string funcName = \"\")",
								"parameters": [
									{
										"name": "funcName",
										"type": "string",
										"default": "\"\""
									}
								],
								"endline": 2671,
								"char": 12,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 2676,
								"comment": "        True if this set doesn't contain any $(CODEPOINTS).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2682_1965)\n---\nCodepointSet emptySet;\nassert(emptySet.length == 0);\nassert(emptySet.empty);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2682_1965)\n",
								"type": "const @property bool()",
								"endline": 2679,
								"char": 20,
								"kind": "function"
							}
						],
						"char": 17,
						"kind": "struct"
					}
				],
				"name": "InversionList",
				"line": 1980,
				"comment": "    $(P\n    $(D InversionList) is a set of $(CODEPOINTS)\n    represented as an array of open-right [a, b$(RPAREN)\n    intervals (see $(LREF CodepointInterval) above).\n    The name comes from the way the representation reads left to right.\n    For instance a set of all values [10, 50$(RPAREN), [80, 90$(RPAREN),\n    plus a singular value 60 looks like this:\n    )\n    ---\n    10, 50, 60, 61, 80, 90\n    ---\n    $(P\n    The way to read this is: start with negative meaning that all numbers\n    smaller then the next one are not present in this set (and positive\n    - the contrary). Then switch positive/negative after each\n    number passed from left to right.\n    )\n    $(P This way negative spans until 10, then positive until 50,\n    then negative until 60, then positive until 61, and so on.\n    As seen this provides a space-efficient storage of highly redundant data\n    that comes in long runs. A description which Unicode $(CHARACTER)\n    properties fit nicely. The technique itself could be seen as a variation\n    on $(LUCKY RLE encoding).\n    )\n\n    $(P Sets are value types (just like $(D int) is) thus they\n        are never aliased.\n    )\n        Example:\n        ---\n        auto a = CodepointSet('a', 'z'+1);\n        auto b = CodepointSet('A', 'Z'+1);\n        auto c = a;\n        a = a | b;\n        assert(a == CodepointSet('A', 'Z'+1, 'a', 'z'+1));\n        assert(a != c);\n        ---\n    $(P See also $(LREF unicode) for simpler construction of sets\n        from predefined ones.\n    )\n\n    $(P Memory usage is 8 bytes per each contiguous interval in a set.\n    The value semantics are achieved by using the\n    $(WEB en.wikipedia.org/wiki/Copy-on-write, COW) technique\n    and thus it's $(RED not) safe to cast this type to $(D_KEYWORD shared).\n    )\n\n    Note:\n    $(P It's not recommended to rely on the template parameters\n    or the exact type of a current $(CODEPOINT) set in $(D std.uni).\n    The type and parameters may change when the standard\n    allocators design is finalized.\n    Use $(LREF isCodepointSet) with templates or just stick with the default\n    alias $(LREF CodepointSet) throughout the whole code base.\n    )\n",
				"parameters": [
					{
						"name": "SP",
						"default": "GcPolicy",
						"kind": "type"
					}
				],
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "codepointSetTrie",
								"line": 4173,
								"type": "(Set set)",
								"parameters": [
									{
										"name": "set",
										"type": "Set"
									}
								],
								"endline": 4180,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "codepointSetTrie",
						"line": 4173,
						"parameters": [
							{
								"name": "Set",
								"kind": "type"
							}
						],
						"constraint": "isCodepointSet!Set",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "codepointSetTrie",
				"line": 4170,
				"comment": "    A shorthand for creating a custom multi-level fixed Trie\n    from a $(D CodepointSet). $(D sizes) are numbers of bits per level,\n    with the most significant bits used first.\n\n    Note: The sum of $(D sizes) must be equal 21.\n\n    See_Also: $(LREF toTrie), which is even simpler.\n\n    Example:\n    ---\n    {\n        import std.stdio;\n        auto set = unicode(\"Number\");\n        auto trie = codepointSetTrie!(8, 5, 8)(set);\n        writeln(\"Input code points to test:\");\n        foreach(line; stdin.byLine)\n        {\n            int count=0;\n            foreach(dchar ch; line)\n                if(trie[ch])// is number\n                    count++;\n            writefln(\"Contains %d number code points.\", count);\n        }\n    }\n    ---\n",
				"parameters": [
					{
						"name": "sizes",
						"kind": "tuple"
					}
				],
				"constraint": "sumOfIntegerTuple!sizes == 21",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CodepointSetTrie",
						"line": 4188,
						"type": "typeof(TrieBuilder!(bool, dchar, lastDchar + 1, Prefix)(false).build())",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CodepointSetTrie",
				"line": 4184,
				"comment": "Type of Trie generated by codepointSetTrie function.\n",
				"parameters": [
					{
						"name": "sizes",
						"kind": "tuple"
					}
				],
				"constraint": "sumOfIntegerTuple!sizes == 21",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "codepointTrie",
								"line": 4215,
								"type": "(T[dchar] map, T defValue = T.init)",
								"parameters": [
									{
										"name": "map",
										"type": "T[dchar]"
									},
									{
										"name": "defValue",
										"type": "T",
										"default": "T.init"
									}
								],
								"endline": 4218,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "codepointTrie",
						"line": 4215,
						"parameters": [],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "codepointTrie",
								"line": 4221,
								"type": "(R range, T defValue = T.init)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									},
									{
										"name": "defValue",
										"type": "T",
										"default": "T.init"
									}
								],
								"endline": 4229,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "codepointTrie",
						"line": 4221,
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!R && is(typeof(ElementType!R.init[0]) : T) && is(typeof(ElementType!R.init[1]) : dchar)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "codepointTrie",
				"line": 4201,
				"comment": "    A slightly more general tool for building fixed $(D Trie)\n    for the Unicode data.\n\n    Specifically unlike $(D codepointSetTrie) it's allows creating mappings\n    of $(D dchar) to an arbitrary type $(D T).\n\n    Note: Overload taking $(D CodepointSet)s will naturally convert\n    only to bool mapping $(D Trie)s.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "sizes",
						"kind": "tuple"
					}
				],
				"constraint": "sumOfIntegerTuple!sizes == 21",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CodepointTrie",
						"line": 4290,
						"type": "typeof(TrieBuilder!(T, dchar, lastDchar + 1, Prefix)(T.init).build())",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CodepointTrie",
				"line": 4286,
				"comment": "Type of Trie as generated by codepointTrie function.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "sizes",
						"kind": "tuple"
					}
				],
				"constraint": "sumOfIntegerTuple!sizes == 21",
				"char": 8,
				"kind": "template"
			},
			{
				"name": "MatcherConcept",
				"line": 4461,
				"comment": "    Conceptual type that outlines the common properties of all UTF Matchers.\n\n    Note: For illustration purposes only, every method\n    call results in assertion failure.\n    Use $(LREF utfMatcher) to obtain a concrete matcher\n    for UTF-8 or UTF-16 encodings.\n",
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "match",
								"line": 4480,
								"type": "bool(ref Range inp)",
								"parameters": [
									{
										"name": "inp",
										"type": "Range",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 4484,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "match",
						"line": 4480,
						"comment": "        $(P Perform a semantic equivalent 2 operations:\n        decoding a $(CODEPOINT) at front of $(D inp) and testing if\n        it belongs to the set of $(CODEPOINTS) of this matcher. )\n\n        $(P The effect on $(D inp) depends on the kind of function called:)\n\n        $(P Match. If the codepoint is found in the set then range $(D inp)\n        is advanced by its size in $(S_LINK Code unit, code units),\n        otherwise the range is not modifed.)\n\n        $(P Skip. The range is always advanced by the size\n        of the tested $(CODEPOINT) regardless of the result of test.)\n\n        $(P Test. The range is left unaffected regardless\n        of the result of test.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4500_1976)\n---\nstring truth = \"2² = 4\";\nauto m = utfMatcher!char(unicode.Number);\nassert(m.match(truth)); // '2' is a number all right\nassert(truth == \"² = 4\"); // skips on match\nassert(m.match(truth)); // so is the superscript '2'\nassert(!m.match(truth)); // space is not a number\nassert(truth == \" = 4\"); // unaffected on no match\nassert(!m.skip(truth)); // same test ...\nassert(truth == \"= 4\"); // but skips a codepoint regardless\nassert(!m.test(truth)); // '=' is not a number\nassert(truth == \"= 4\"); // test never affects argument\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4500_1976)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4537_1977)\n---\nauto m = utfMatcher!char(unicode.Number);\nstring square = \"2²\";\n// about sub-matchers\nassert(!m.subMatcher!(2,3,4).test(square)); // ASCII no covered\nassert(m.subMatcher!1.match(square)); // ASCII-only, works\nassert(!m.subMatcher!1.test(square)); // unicode '²'\nassert(m.subMatcher!(2,3,4).match(square));  //\nassert(square == \"\");\nwstring wsquare = \"2²\";\nauto m16 = utfMatcher!wchar(unicode.Number);\n// may keep ref, but the orignal (m16) must be kept alive\nauto bmp = m16.subMatcher!1;\nassert(bmp.match(wsquare)); // Okay, in basic multilingual plan\nassert(bmp.match(wsquare)); // And '²' too\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4537_1977)\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Range && is(ElementType!Range : char)",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "skip",
								"line": 4487,
								"type": "bool(ref Range inp)",
								"parameters": [
									{
										"name": "inp",
										"type": "Range",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 4491,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "skip",
						"line": 4487,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Range && is(ElementType!Range : char)",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "test",
								"line": 4494,
								"type": "bool(ref Range inp)",
								"parameters": [
									{
										"name": "inp",
										"type": "Range",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 4498,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "test",
						"line": 4494,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Range && is(ElementType!Range : char)",
						"char": 17,
						"kind": "template"
					}
				],
				"char": 8,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "isUtfMatcher",
						"line": 4559,
						"init": "__traits(compiles, ()\n{\nC[] s;\nauto d = s.decoder;\nM m;\nassert(is(typeof(m.match(d)) == bool));\nassert(is(typeof(m.test(d)) == bool));\nstatic if (is(typeof(m.skip(d))))\n{\nassert(is(typeof(m.skip(d)) == bool));\nassert(is(typeof(m.skip(s)) == bool));\n}\n\nassert(is(typeof(m.match(s)) == bool));\nassert(is(typeof(m.test(s)) == bool));\n}\n)",
						"char": 13,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isUtfMatcher",
				"line": 4559,
				"comment": "    Test if $(D M) is an UTF Matcher for ranges of $(D Char).\n",
				"parameters": [
					{
						"name": "M",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "utfMatcher",
						"line": 5140,
						"type": "@trusted (Set set)",
						"parameters": [
							{
								"name": "set",
								"type": "Set"
							}
						],
						"endline": 5152,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "utfMatcher",
				"line": 5140,
				"comment": "    Constructs a matcher object\n    to classify $(CODEPOINTS) from the $(D set) for encoding\n    that has $(D Char) as code unit.\n\n    See $(LREF MatcherConcept) for API outline.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Set",
						"kind": "type"
					}
				],
				"constraint": "isCodepointSet!Set",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toTrie",
						"line": 5364,
						"type": "(Set set)",
						"parameters": [
							{
								"name": "set",
								"type": "Set"
							}
						],
						"endline": 5378,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toTrie",
				"line": 5364,
				"comment": "    Convenience function to construct optimal configurations for\n    packed Trie from any $(D set) of $(CODEPOINTS).\n\n    The parameter $(D level) indicates the number of trie levels to use,\n    allowed values are: 1, 2, 3 or 4. Levels represent different trade-offs\n    speed-size wise.\n\n    $(P Level 1 is fastest and the most memory hungry (a bit array). )\n    $(P Level 4 is the slowest and has the smallest footprint. )\n\n    See the $(S_LINK Synopsis, Synopsis) section for example.\n\n    Note:\n    Level 4 stays very practical (being faster and more predictable)\n    compared to using direct lookup on the $(D set) itself.\n\n\n",
				"parameters": [
					{
						"name": "level",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Set",
						"kind": "type"
					}
				],
				"constraint": "isCodepointSet!Set",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toDelegate",
						"line": 5390,
						"type": "(Set set)",
						"parameters": [
							{
								"name": "set",
								"type": "Set"
							}
						],
						"endline": 5396,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toDelegate",
				"line": 5390,
				"comment": "    $(P Builds a $(D Trie) with typically optimal speed-size trade-off\n    and wraps it into a delegate of the following type:\n    $(D bool delegate(dchar ch)). )\n\n    $(P Effectively this creates a 'tester' lambda suitable\n    for algorithms like std.algorithm.find that take unary predicates. )\n\n    See the $(S_LINK Synopsis, Synopsis) section for example.\n",
				"parameters": [
					{
						"name": "Set",
						"kind": "type"
					}
				],
				"constraint": "isCodepointSet!Set",
				"char": 13,
				"kind": "template"
			},
			{
				"name": "unicode",
				"line": 6012,
				"comment": "    A single entry point to lookup Unicode $(CODEPOINT) sets by name or alias of\n    a block, script or general category.\n\n    It uses well defined standard rules of property name lookup.\n    This includes fuzzy matching of names, so that\n    'White_Space', 'white-SpAce' and 'whitespace' are all considered equal\n    and yield the same set of white space $(CHARACTERS).\n",
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "opDispatch",
								"line": 6029,
								"type": "pure @property ()",
								"endline": 6035,
								"char": 27,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "opDispatch",
						"line": 6029,
						"comment": "        Performs the lookup of set of $(CODEPOINTS)\n        with compile-time correctness checking.\n        This short-cut version combines 3 searches:\n        across blocks, scripts, and common binary properties.\n\n        Note that since scripts and blocks overlap the\n        usual trick to disambiguate is used - to get a block use\n        $(D unicode.InBlockName), to search a script\n        use $(D unicode.ScriptName).\n\n        See_Also: $(LREF block), $(LREF script)\n        and (not included in this search) $(LREF hangulSyllableType).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6038_2003)\n---\nauto ascii = unicode.ASCII;\nassert(ascii['A']);\nassert(ascii['~']);\nassert(!ascii['\\u00e0']);\n// matching is case-insensitive\nassert(ascii == unicode.ascII);\nassert(!ascii['à']);\n// underscores, '-' and whitespace in names are ignored too\nauto latin = unicode.in_latin1_Supplement;\nassert(latin['à']);\nassert(!latin['$']);\n// BTW Latin 1 Supplement is a block, hence \"In\" prefix\nassert(latin == unicode(\"In Latin 1 Supplement\"));\nimport std.exception;\n// run-time look up throws if no such set is found\nassert(collectException(unicode(\"InCyrilliac\")));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6038_2003)\n",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"char": 27,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCall",
								"line": 6068,
								"type": "(in C[] name)",
								"parameters": [
									{
										"name": "name",
										"type": "C[]",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 6072,
								"char": 17,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "opCall",
						"line": 6068,
						"comment": "        The same lookup across blocks, scripts, or binary properties,\n        but performed at run-time.\n        This version is provided for cases where $(D name)\n        is not known beforehand; otherwise compile-time\n        checked $(LREF opDispatch) is typically a better choice.\n\n        See the $(S_LINK Unicode properties, table of properties) for available\n        sets.\n",
						"parameters": [
							{
								"name": "C",
								"kind": "type"
							}
						],
						"constraint": "is(C : dchar)",
						"char": 17,
						"kind": "template"
					},
					{
						"name": "block",
						"line": 6084,
						"comment": "        Narrows down the search for sets of $(CODEPOINTS) to all Unicode blocks.\n\n        Note:\n        Here block names are unambiguous as no scripts are searched\n        and thus to search use simply $(D unicode.block.BlockName) notation.\n\n        See $(S_LINK Unicode properties, table of properties) for available sets.\n        See_Also: $(S_LINK Unicode properties, table of properties).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6090_2004)\n---\n// use .block for explicitness\nassert(unicode.block.Greek_and_Coptic == unicode.InGreek_and_Coptic);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6090_2004)\n",
						"members": [],
						"char": 5,
						"kind": "struct"
					},
					{
						"name": "script",
						"line": 6102,
						"comment": "        Narrows down the search for sets of $(CODEPOINTS) to all Unicode scripts.\n\n        See the $(S_LINK Unicode properties, table of properties) for available\n        sets.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6108_2005)\n---\nauto arabicScript = unicode.script.arabic;\nauto arabicBlock = unicode.block.arabic;\n// there is an intersection between script and block\nassert(arabicBlock['؁']);\nassert(arabicScript['؁']);\n// but they are different\nassert(arabicBlock != arabicScript);\nassert(arabicBlock == unicode.inArabic);\nassert(arabicScript == unicode.arabic);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6108_2005)\n",
						"members": [],
						"char": 5,
						"kind": "struct"
					},
					{
						"name": "hangulSyllableType",
						"line": 6132,
						"comment": "        Fetch a set of $(CODEPOINTS) that have the given hangul syllable type.\n\n        Other non-binary properties (once supported) follow the same\n        notation - $(D unicode.propertyName.propertyValue) for compile-time\n        checked access and $(D unicode.propertyName(propertyValue))\n        for run-time checked one.\n\n        See the $(S_LINK Unicode properties, table of properties) for available\n        sets.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6138_2006)\n---\n// L here is syllable type not Letter as in unicode.L short-cut\nauto leadingVowel = unicode.hangulSyllableType(\"L\");\n// check that some leading vowels are present\nforeach(vowel; '\\u1110'..'\\u115F')\n    assert(leadingVowel[vowel]);\nassert(leadingVowel == unicode.hangulSyllableType.L);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6138_2006)\n",
						"members": [],
						"char": 5,
						"kind": "struct"
					}
				],
				"char": 14,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "graphemeStride",
						"line": 6334,
						"type": "size_t(in C[] input, size_t index)",
						"parameters": [
							{
								"name": "input",
								"type": "C[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 6341,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "graphemeStride",
				"line": 6334,
				"comment": "    Computes the length of grapheme cluster starting at $(D index).\n    Both the resulting length and the $(D index) are measured\n    in $(S_LINK Code unit, code units).\n\n    Params:\n        C = type that is implicitly convertible to $(D dchars)\n        input = array of grapheme clusters\n        index = starting index into $(D input[])\n\n    Returns:\n        length of grapheme cluster\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6344_2008)\n---\nassert(graphemeStride(\"  \", 1) == 1);\n// A + combing ring above\nstring city = \"A\\u030Arhus\";\nsize_t first = graphemeStride(city, 0);\nassert(first == 3); //\\u030A has 2 UTF-8 code units\nassert(city[0..first] == \"A\\u030A\");\nassert(city[first..$] == \"rhus\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6344_2008)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(C : dchar)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decodeGrapheme",
						"line": 6364,
						"type": "Grapheme(ref Input inp)",
						"parameters": [
							{
								"name": "inp",
								"type": "Input",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 6368,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "decodeGrapheme",
				"line": 6364,
				"comment": "    Reads one full grapheme cluster from an input range of dchar $(D inp).\n\n    For examples see the $(LREF Grapheme) below.\n\n    Note:\n    This function modifies $(D inp) and thus $(D inp)\n    must be an L-value.\n",
				"parameters": [
					{
						"name": "Input",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Input && is(Unqual!(ElementType!Input) == dchar)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byGrapheme",
						"line": 6395,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 6431,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byGrapheme",
				"line": 6395,
				"comment": "    $(P Iterate a string by grapheme.)\n\n    $(P Useful for doing string manipulation that needs to be aware\n    of graphemes.)\n\n    See_Also:\n        $(LREF byCodePoint)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6434_2010)\n---\nimport std.conv;\nimport std.range;\nimport std.algorithm;\nauto text = \"noe\\u0308l\"; // noël using e + combining diaeresis\nassert(text.walkLength == 5); // 5 code points\n\nauto gText = text.byGrapheme;\nassert(gText.walkLength == 4); // 4 graphemes\n\nassert(gText.take(3).equal(\"noe\\u0308\".byGrapheme));\nassert(gText.drop(3).equal(\"l\".byGrapheme));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6434_2010)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byCodePoint",
						"line": 6497,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 6537,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byCodePoint",
				"line": 6497,
				"comment": "    $(P Lazily transform a range of $(LREF Grapheme)s to a range of code points.)\n\n    $(P Useful for converting the result to a string after doing operations\n    on graphemes.)\n\n    $(P Acts as the identity function when given a range of code points.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6547_2012)\n---\nimport std.conv : text;\nimport std.range;\n\nstring s = \"noe\\u0308l\"; // noël\n\n// reverse it and convert the result to a string\nstring reverse = s.byGrapheme\n    .array\n    .retro\n    .byCodePoint\n    .text;\n\nassert(reverse == \"le\\u0308on\"); // lëon\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6547_2012)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == Grapheme)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byCodePoint",
						"line": 6540,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 6544,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "byCodePoint",
				"line": 6540,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar)",
				"char": 7,
				"kind": "template"
			},
			{
				"name": "Grapheme",
				"line": 6597,
				"comment": "    $(P A structure designed to effectively pack $(CHARACTERS)\n    of a $(CLUSTER).\n    )\n\n    $(P $(D Grapheme) has value semantics so 2 copies of a $(D Grapheme)\n    always refer to distinct objects. In most actual scenarios a $(D Grapheme)\n    fits on the stack and avoids memory allocation overhead for all but quite\n    long clusters.\n    )\n\n    See_Also: $(LREF decodeGrapheme), $(LREF graphemeStride)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6826_2016)\n---\nimport std.algorithm : filter;\nstring bold = \"ku\\u0308hn\";\n\n// note that decodeGrapheme takes parameter by ref\nauto first = decodeGrapheme(bold);\n\nassert(first.length == 1);\nassert(first[0] == 'k');\n\n// the next grapheme is 2 characters long\nauto wideOne = decodeGrapheme(bold);\n// slicing a grapheme yields a random-access range of dchar\nassert(wideOne[].equalS(\"u\\u0308\"));\nassert(wideOne.length == 2);\nstatic assert(isRandomAccessRange!(typeof(wideOne[])));\n\n// all of the usual range manipulation is possible\nassert(wideOne[].filter!isMark().equalS(\"\\u0308\"));\n\nauto g = Grapheme(\"A\");\nassert(g.valid);\ng ~= '\\u0301';\nassert(g[].equalS(\"A\\u0301\"));\nassert(g.valid);\ng ~= \"B\";\n// not a valid grapheme cluster anymore\nassert(!g.valid);\n// still could be useful though\nassert(g[].equalS(\"A\\u0301B\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6826_2016)\n",
				"members": [
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 6616,
						"comment": "Gets a $(CODEPOINT) at the given index in this cluster.\n",
						"deco": "xFNaNbNiNemZw",
						"parameters": [
							{
								"name": "index",
								"deco": "m"
							}
						],
						"endline": 6620,
						"originalType": "const pure nothrow @nogc @trusted dchar(size_t index)",
						"char": 11,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndexAssign",
						"line": 6629,
						"comment": "        Writes a $(CODEPOINT) $(D ch) at given index in this cluster.\n\n        Warning:\n        Use of this facility may invalidate grapheme cluster,\n        see also $(LREF Grapheme.valid).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6636_2014)\n---\nauto g = Grapheme(\"A\\u0302\");\nassert(g[0] == 'A');\nassert(g.valid);\ng[1] = '~'; // ASCII tilda is not a combining mark\nassert(g[1] == '~');\nassert(!g.valid);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6636_2014)\n",
						"deco": "FNaNbNiNewmZv",
						"parameters": [
							{
								"name": "ch",
								"deco": "w"
							},
							{
								"name": "index",
								"deco": "m"
							}
						],
						"endline": 6633,
						"originalType": "pure nothrow @nogc @trusted void(dchar ch, size_t index)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opSlice",
						"line": 6652,
						"comment": "        Random-access range over Grapheme's $(CHARACTERS).\n\n        Warning: Invalidates when this Grapheme leaves the scope,\n        attempts to use it then would lead to memory corruption.\n",
						"deco": "FNaNbNimmZS3std3uni41__T16SliceOverIndexedTS3std3uni8GraphemeZ16SliceOverIndexed",
						"parameters": [
							{
								"name": "a",
								"deco": "m"
							},
							{
								"name": "b",
								"deco": "m"
							}
						],
						"endline": 6655,
						"originalType": "pure nothrow @nogc @system (size_t a, size_t b)",
						"char": 18,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					},
					{
						"endchar": 5,
						"name": "opSlice",
						"line": 6658,
						"comment": "ditto\n",
						"deco": "FNaNbNiZS3std3uni41__T16SliceOverIndexedTS3std3uni8GraphemeZ16SliceOverIndexed",
						"endline": 6661,
						"originalType": "pure nothrow @nogc @system ()",
						"char": 18,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					},
					{
						"endchar": 5,
						"name": "length",
						"line": 6664,
						"comment": "Grapheme cluster length in $(CODEPOINTS).\n",
						"deco": "xFNaNbNdNiNeZm",
						"endline": 6667,
						"originalType": "const pure nothrow @nogc @property @trusted size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 6677,
								"type": "ref (dchar ch)",
								"parameters": [
									{
										"name": "ch",
										"deco": "w"
									}
								],
								"endline": 6705,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 6677,
						"comment": "        Append $(CHARACTER) $(D ch) to this grapheme.\n        Warning:\n        Use of this facility may invalidate grapheme cluster,\n        see also $(D valid).\n\n        See_Also: $(LREF Grapheme.valid)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6708_2015)\n---\nimport std.algorithm.comparison : equal;\nauto g = Grapheme(\"A\");\nassert(g.valid);\ng ~= '\\u0301';\nassert(g[].equal(\"A\\u0301\"));\nassert(g.valid);\ng ~= \"B\";\n// not a valid grapheme cluster anymore\nassert(!g.valid);\n// still could be useful though\nassert(g[].equal(\"A\\u0301B\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6708_2015)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"char": 9,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 6724,
								"type": "ref (Input inp)",
								"parameters": [
									{
										"name": "inp",
										"type": "Input"
									}
								],
								"endline": 6735,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 6724,
						"comment": "Append all $(CHARACTERS) from the input range $(D inp) to this Grapheme.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "Input",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Input && is(ElementType!Input : dchar)",
						"char": 9,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "valid",
								"line": 6746,
								"type": "@property bool()",
								"endline": 6751,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "valid",
						"line": 6746,
						"comment": "        True if this object contains valid extended grapheme cluster.\n        Decoding primitives of this module always return a valid $(D Grapheme).\n\n        Appending to and direct manipulation of grapheme's $(CHARACTERS) may\n        render it no longer valid. Certain applications may chose to use\n        Grapheme as a \"small string\" of any $(CODEPOINTS) and ignore this property\n        entirely.\n",
						"parameters": [],
						"char": 20,
						"kind": "template"
					}
				],
				"char": 10,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sicmp",
						"line": 6940,
						"type": "int(S1 str1, S2 str2)",
						"parameters": [
							{
								"name": "str1",
								"type": "S1"
							},
							{
								"name": "str2",
								"type": "S2"
							}
						],
						"endline": 6982,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "sicmp",
				"line": 6940,
				"comment": "    $(P Does basic case-insensitive comparison of strings $(D str1) and $(D str2).\n    This function uses simpler comparison rule thus achieving better performance\n    than $(LREF icmp). However keep in mind the warning below.)\n\n    Params:\n        str1 = a string or a $(D ForwardRange) of $(D dchar)s\n        str2 = a string or a $(D ForwardRange) of $(D dchar)s\n\n    Returns:\n        An $(D int) that is 0 if the strings match,\n        &lt;0 if $(D str1) is lexicographically \"less\" than $(D str2),\n        &gt;0 if $(D str1) is lexicographically \"greater\" than $(D str2)\n\n    Warning:\n    This function only handles 1:1 $(CODEPOINT) mapping\n    and thus is not sufficient for certain alphabets\n    like German, Greek and few others.\n\n    See_Also:\n        $(LREF icmp)\n        $(XREF_PACK algorithm,comparison,cmp)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6985_2019)\n---\nassert(sicmp(\"Август\", \"авгусТ\") == 0);\n// Greek also works as long as there is no 1:M mapping in sight\nassert(sicmp(\"ΌΎ\", \"όύ\") == 0);\n// things like the following won't get matched as equal\n// Greek small letter iota with dialytika and tonos\nassert(sicmp(\"ΐ\", \"\\u03B9\\u0308\\u0301\") != 0);\n\n// while icmp has no problem with that\nassert(icmp(\"ΐ\", \"\\u03B9\\u0308\\u0301\") == 0);\nassert(icmp(\"ΌΎ\", \"όύ\") == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6985_2019)\n",
				"parameters": [
					{
						"name": "S1",
						"kind": "type"
					},
					{
						"name": "S2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!S1 && is(Unqual!(ElementType!S1) == dchar) && isForwardRange!S2 && is(Unqual!(ElementType!S2) == dchar)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "icmp",
						"line": 7055,
						"type": "int(S1 str1, S2 str2)",
						"parameters": [
							{
								"name": "str1",
								"type": "S1"
							},
							{
								"name": "str2",
								"type": "S2"
							}
						],
						"endline": 7085,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "icmp",
				"line": 7055,
				"comment": "    $(P Does case insensitive comparison of $(D str1) and $(D str2).\n    Follows the rules of full case-folding mapping.\n    This includes matching as equal german ß with \"ss\" and\n    other 1:M $(CODEPOINT) mappings unlike $(LREF sicmp).\n    The cost of $(D icmp) being pedantically correct is\n    slightly worse performance.\n    )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7088_2020)\n---\nassert(icmp(\"Rußland\", \"Russland\") == 0);\nassert(icmp(\"ᾩ -> \\u1F70\\u03B9\", \"\\u1F61\\u03B9 -> ᾲ\") == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7088_2020)\n",
				"parameters": [
					{
						"name": "S1",
						"kind": "type"
					},
					{
						"name": "S2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!S1 && is(Unqual!(ElementType!S1) == dchar) && isForwardRange!S2 && is(Unqual!(ElementType!S2) == dchar)",
				"char": 5,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "combiningClass",
				"line": 7245,
				"comment": "    $(P Returns the $(S_LINK Combining class, combining class) of $(D ch).)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7251_2025)\n---\n// shorten the code\nalias CC = combiningClass;\n\n// combining tilda\nassert(CC('\\u0303') == 230);\n// combining ring below\nassert(CC('\\u0325') == 220);\n// the simple consequence is that  \"tilda\" should be\n// placed after a \"ring below\" in a sequence\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7251_2025)\n",
				"deco": "FNaNbNiNfwZh",
				"parameters": [
					{
						"name": "ch",
						"deco": "w"
					}
				],
				"endline": 7248,
				"char": 7,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "Canonical",
						"line": 7276,
						"value": "0",
						"comment": "Canonical decomposition. The result is canonically equivalent sequence.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "Compatibility",
						"line": 7282,
						"value": "1",
						"comment": "         Compatibility decomposition. The result is compatibility equivalent sequence.\n         Note: Compatibility decomposition is a $(B lossy) conversion,\n         typically suitable only for fuzzy matching and internal processing.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "UnicodeDecomposition",
				"line": 7274,
				"comment": "Unicode character decomposition type.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"endchar": 1,
				"name": "compose",
				"line": 7304,
				"comment": "    Try to canonically compose 2 $(CHARACTERS).\n    Returns the composed $(CHARACTER) if they do compose and dchar.init otherwise.\n\n    The assumption is that $(D first) comes before $(D second) in the original text,\n    usually meaning that the first is a starter.\n\n    Note: Hangul syllables are not covered by this function.\n    See $(D composeJamo) below.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7326_2027)\n---\nassert(compose('A','\\u0308') == '\\u00C4');\nassert(compose('A', 'B') == dchar.init);\nassert(compose('C', '\\u0301') == '\\u0106');\n// note that the starter is the first one\n// thus the following doesn't compose\nassert(compose('\\u0308', 'A') == dchar.init);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7326_2027)\n",
				"deco": "FNaNbNewwZw",
				"parameters": [
					{
						"name": "first",
						"deco": "w"
					},
					{
						"name": "second",
						"deco": "w"
					}
				],
				"endline": 7323,
				"char": 14,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decompose",
						"line": 7350,
						"type": "Grapheme(dchar ch)",
						"parameters": [
							{
								"name": "ch",
								"deco": "w"
							}
						],
						"endline": 7369,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "decompose",
				"line": 7350,
				"comment": "    Returns a full $(S_LINK Canonical decomposition, Canonical)\n    (by default) or $(S_LINK Compatibility decomposition, Compatibility)\n    decomposition of $(CHARACTER) $(D ch).\n    If no decomposition is available returns a $(LREF Grapheme)\n    with the $(D ch) itself.\n\n    Note:\n    This function also decomposes hangul syllables\n    as prescribed by the standard.\n\n    See_Also: $(LREF decomposeHangul) for a restricted version\n    that takes into account only hangul syllables  but\n    no other decompositions.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7372_2028)\n---\nassert(compose('A','\\u0308') == '\\u00C4');\nassert(compose('A', 'B') == dchar.init);\nassert(compose('C', '\\u0301') == '\\u0106');\n// note that the starter is the first one\n// thus the following doesn't compose\nassert(compose('\\u0308', 'A') == dchar.init);\n\nassert(decompose('Ĉ')[].equalS(\"C\\u0302\"));\nassert(decompose('D')[].equalS(\"D\"));\nassert(decompose('\\uD4DC')[].equalS(\"\\u1111\\u1171\\u11B7\"));\nassert(decompose!Compatibility('¹')[].equalS(\"1\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7372_2028)\n",
				"parameters": [
					{
						"name": "decompType",
						"defaultValue": "Canonical",
						"deco": "E3std3uni20UnicodeDecomposition",
						"kind": "value"
					}
				],
				"char": 17,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "decomposeHangul",
				"line": 7461,
				"comment": "    Decomposes a Hangul syllable. If $(D ch) is not a composed syllable\n    then this function returns $(LREF Grapheme) containing only $(D ch) as is.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7478_2029)\n---\nimport std.algorithm;\nassert(decomposeHangul('\\uD4DB')[].equal(\"\\u1111\\u1171\\u11B6\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7478_2029)\n",
				"deco": "FNewZS3std3uni8Grapheme",
				"parameters": [
					{
						"name": "ch",
						"deco": "w"
					}
				],
				"endline": 7475,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "composeJamo",
				"line": 7493,
				"comment": "    Try to compose hangul syllable out of a leading consonant ($(D lead)),\n    a $(D vowel) and optional $(D trailing) consonant jamos.\n\n    On success returns the composed LV or LVT hangul syllable.\n\n    If any of $(D lead) and $(D vowel) are not a valid hangul jamo\n    of the respective $(CHARACTER) class returns dchar.init.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7507_2030)\n---\nassert(composeJamo('\\u1111', '\\u1171', '\\u11B6') == '\\uD4DB');\n// leaving out T-vowel, or passing any codepoint\n// that is not trailing consonant composes an LV-syllable\nassert(composeJamo('\\u1111', '\\u1171') == '\\uD4CC');\nassert(composeJamo('\\u1111', '\\u1171', ' ') == '\\uD4CC');\nassert(composeJamo('\\u1111', 'A') == dchar.init);\nassert(composeJamo('A', '\\u1171') == dchar.init);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7507_2030)\n",
				"deco": "FNaNbNiNewwwZw",
				"parameters": [
					{
						"name": "lead",
						"deco": "w"
					},
					{
						"name": "vowel",
						"deco": "w"
					},
					{
						"name": "trailing",
						"deco": "w",
						"default": "'\\U0000ffff'"
					}
				],
				"endline": 7504,
				"originalType": "pure nothrow @nogc @trusted dchar(dchar lead, dchar vowel, dchar trailing = (dchar).init)",
				"char": 7,
				"kind": "function"
			},
			{
				"members": [],
				"name": "NormalizationForm",
				"line": 7545,
				"comment": "    Enumeration type for normalization forms,\n    passed as template parameter for functions like $(LREF normalize).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "NFC",
				"line": 7557,
				"value": "(NormalizationForm).NFC",
				"comment": "        Shorthand aliases from values indicating normalization forms.\n",
				"char": 5,
				"kind": "enum member"
			},
			{
				"name": "NFD",
				"line": 7559,
				"value": "(NormalizationForm).NFD",
				"comment": "ditto\n",
				"char": 5,
				"kind": "enum member"
			},
			{
				"name": "NFKC",
				"line": 7561,
				"value": "(NormalizationForm).NFKC",
				"comment": "ditto\n",
				"char": 5,
				"kind": "enum member"
			},
			{
				"name": "NFKD",
				"line": 7563,
				"value": "(NormalizationForm).NFKD",
				"comment": "ditto\n",
				"char": 5,
				"kind": "enum member"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "normalize",
						"line": 7577,
						"type": "inout(C)[](inout(C)[] input)",
						"parameters": [
							{
								"name": "input",
								"type": "inout(C)[]"
							}
						],
						"endline": 7666,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "normalize",
				"line": 7577,
				"comment": "    Returns $(D input) string normalized to the chosen form.\n    Form C is used by default.\n\n    For more information on normalization forms see\n    the $(S_LINK Normalization, normalization section).\n\n    Note:\n    In cases where the string in question is already normalized,\n    it is returned unmodified and no memory allocation happens.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7669_2032)\n---\n// any encoding works\nwstring greet = \"Hello world\";\nassert(normalize(greet) is greet); // the same exact slice\n\n// An example of a character with all 4 forms being different:\n// Greek upsilon with acute and hook symbol (code point 0x03D3)\nassert(normalize!NFC(\"ϓ\") == \"\\u03D3\");\nassert(normalize!NFD(\"ϓ\") == \"\\u03D2\\u0301\");\nassert(normalize!NFKC(\"ϓ\") == \"\\u038E\");\nassert(normalize!NFKD(\"ϓ\") == \"\\u03A5\\u0301\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7669_2032)\n",
				"parameters": [
					{
						"name": "norm",
						"defaultValue": "NFC",
						"deco": "E3std3uni17NormalizationForm",
						"kind": "value"
					},
					{
						"name": "C",
						"kind": "type"
					}
				],
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allowedIn",
						"line": 7827,
						"type": "bool(dchar ch)",
						"parameters": [
							{
								"name": "ch",
								"deco": "w"
							}
						],
						"endline": 7830,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "allowedIn",
				"line": 7827,
				"comment": "    Tests if dchar $(D ch) is always allowed (Quick_Check=YES) in normalization\n    form $(D norm).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7833_2034)\n---\n// e.g. Cyrillic is always allowed, so is ASCII\nassert(allowedIn!NFC('я'));\nassert(allowedIn!NFD('я'));\nassert(allowedIn!NFKC('я'));\nassert(allowedIn!NFKD('я'));\nassert(allowedIn!NFC('Z'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7833_2034)\n",
				"parameters": [
					{
						"name": "norm",
						"deco": "E3std3uni17NormalizationForm",
						"kind": "value"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "isWhite",
				"line": 7912,
				"comment": "    Whether or not $(D c) is a Unicode whitespace $(CHARACTER).\n    (general Unicode category: Part of C0(tab, vertical tab, form feed,\n    carriage return, and linefeed characters), Zs, Zl, Zp, and NEL(U+0085))\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 7915,
				"char": 13,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isLower",
				"line": 7921,
				"comment": "    Return whether $(D c) is a Unicode lowercase $(CHARACTER).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 7927,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isUpper",
				"line": 7954,
				"comment": "    Return whether $(D c) is a Unicode uppercase $(CHARACTER).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 7960,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toLower",
				"line": 7990,
				"comment": "    If $(D c) is a Unicode uppercase $(CHARACTER), then its lowercase equivalent\n    is returned. Otherwise $(D c) is returned.\n\n    Warning: certain alphabets like German and Greek have no 1:1\n    upper-lower mapping. Use overload of toLower which takes full string instead.\n",
				"deco": "FNaNbNiNfwZw",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 8007,
				"char": 7,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asLowerCase",
						"line": 8176,
						"type": "(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 8191,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asLowerCase",
				"line": 8176,
				"comment": " Convert input range or string to upper or lower case.\n\n Does not allocate memory.\n Characters in UTF-8 or UTF-16 format that cannot be decoded\n are treated as $(XREF utf, replacementDchar).\n\n Params:\n      str = string or range of characters\n\n Returns:\n      an InputRange of dchars\n\n See_Also:\n      $(LREF toUpper), $(LREF toLower)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8212_2039)\n---\nimport std.algorithm.comparison : equal;\n\nassert(\"hEllo\".asUpperCase.equal(\"HELLO\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8212_2039)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asUpperCase",
						"line": 8194,
						"type": "(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 8209,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asUpperCase",
				"line": 8194,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asCapitalized",
						"line": 8387,
						"type": "(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 8402,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asCapitalized",
				"line": 8387,
				"comment": " Capitalize input range or string, meaning convert the first\n character to upper case and subsequent characters to lower case.\n\n Does not allocate memory.\n Characters in UTF-8 or UTF-16 format that cannot be decoded\n are treated as $(XREF utf, replacementDchar).\n\n Params:\n      str = string or range of characters\n\n Returns:\n      an InputRange of dchars\n\n See_Also:\n      $(LREF toUpper), $(LREF toLower)\n      $(LREF asUpperCase), $(LREF asLowerCase)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8405_2042)\n---\nimport std.algorithm.comparison : equal;\n\nassert(\"hEllo\".asCapitalized.equal(\"Hello\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8405_2042)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toLowerInPlace",
						"line": 8729,
						"type": "pure @trusted void(ref C[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "C[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 8733,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "toLowerInPlace",
				"line": 8729,
				"comment": "    Converts $(D s) to lowercase (by performing Unicode lowercase mapping) in place.\n    For a few characters string length may increase after the transformation,\n    in such a case the function reallocates exactly once.\n    If $(D s) does not have any uppercase characters, then $(D s) is unaltered.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(C == char) || is(C == wchar) || is(C == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUpperInPlace",
						"line": 8751,
						"type": "pure @trusted void(ref C[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "C[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 8755,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "toUpperInPlace",
				"line": 8751,
				"comment": "    Converts $(D s) to uppercase  (by performing Unicode uppercase mapping) in place.\n    For a few characters string length may increase after the transformation,\n    in such a case the function reallocates exactly once.\n    If $(D s) does not have any lowercase characters, then $(D s) is unaltered.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(C == char) || is(C == wchar) || is(C == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toLower",
						"line": 8772,
						"type": "pure @trusted S(S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 8776,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toLower",
				"line": 8772,
				"comment": "    Returns a string which is identical to $(D s) except that all of its\n    characters are converted to lowercase (by preforming Unicode lowercase mapping).\n    If none of $(D s) characters were affected, then $(D s) itself is returned.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "toUpper",
				"line": 8883,
				"comment": "    If $(D c) is a Unicode lowercase $(CHARACTER), then its uppercase equivalent\n    is returned. Otherwise $(D c) is returned.\n\n    Warning:\n    Certain alphabets like German and Greek have no 1:1\n    upper-lower mapping. Use overload of toUpper which takes full string instead.\n\n    toUpper can be used as an argument to $(XREF_PACK algorithm,iteration,map)\n    to produce an algorithm that can convert a range of characters to upper case\n    without allocating memory.\n    A string can then be produced by using $(XREF_PACK algorithm,mutation,copy)\n    to send it to an $(XREF array, appender).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8903_2051)\n---\nimport std.algorithm;\nimport std.uni;\nimport std.array;\n\nauto abuf = appender!(char[])();\n\"hello\".map!toUpper.copy(&abuf);\nassert(abuf.data == \"HELLO\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8903_2051)\n",
				"deco": "FNaNbNiNfwZw",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 8900,
				"char": 7,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUpper",
						"line": 8935,
						"type": "pure @trusted S(S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 8939,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toUpper",
				"line": 8935,
				"comment": "    Returns a string which is identical to $(D s) except that all of its\n    characters are converted to uppercase (by preforming Unicode uppercase mapping).\n    If none of $(D s) characters were affected, then $(D s) itself is returned.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "isAlpha",
				"line": 9043,
				"comment": "    Returns whether $(D c) is a Unicode alphabetic $(CHARACTER)\n    (general Unicode category: Alphabetic).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9061,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isMark",
				"line": 9078,
				"comment": "    Returns whether $(D c) is a Unicode mark\n    (general Unicode category: Mn, Me, Mc).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9081,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isNumber",
				"line": 9097,
				"comment": "    Returns whether $(D c) is a Unicode numerical $(CHARACTER)\n    (general Unicode category: Nd, Nl, No).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9100,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isPunctuation",
				"line": 9117,
				"comment": "    Returns whether $(D c) is a Unicode punctuation $(CHARACTER)\n    (general Unicode category: Pd, Ps, Pe, Pc, Po, Pi, Pf).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9120,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSymbol",
				"line": 9140,
				"comment": "    Returns whether $(D c) is a Unicode symbol $(CHARACTER)\n    (general Unicode category: Sm, Sc, Sk, So).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9143,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSpace",
				"line": 9163,
				"comment": "    Returns whether $(D c) is a Unicode space $(CHARACTER)\n    (general Unicode category: Zs)\n    Note: This doesn't include '\\n', '\\r', \\t' and other non-space $(CHARACTER).\n    For commonly used less strict semantics see $(LREF isWhite).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9166,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isGraphical",
				"line": 9185,
				"comment": "    Returns whether $(D c) is a Unicode graphical $(CHARACTER)\n    (general Unicode category: L, M, N, P, S, Zs).\n\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9188,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isControl",
				"line": 9207,
				"comment": "    Returns whether $(D c) is a Unicode control $(CHARACTER)\n    (general Unicode category: Cc).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9210,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isFormat",
				"line": 9230,
				"comment": "    Returns whether $(D c) is a Unicode formatting $(CHARACTER)\n    (general Unicode category: Cf).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9233,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isPrivateUse",
				"line": 9251,
				"comment": "    Returns whether $(D c) is a Unicode Private Use $(CODEPOINT)\n    (general Unicode category: Co).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9256,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSurrogate",
				"line": 9263,
				"comment": "    Returns whether $(D c) is a Unicode surrogate $(CODEPOINT)\n    (general Unicode category: Cs).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9266,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSurrogateHi",
				"line": 9272,
				"comment": "    Returns whether $(D c) is a Unicode high surrogate (lead surrogate).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9275,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSurrogateLo",
				"line": 9281,
				"comment": "    Returns whether $(D c) is a Unicode low surrogate (trail surrogate).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9284,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isNonCharacter",
				"line": 9292,
				"comment": "    Returns whether $(D c) is a Unicode non-character i.e.\n    a $(CODEPOINT) with no assigned abstract character.\n    (general Unicode category: Cn)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9295,
				"char": 6,
				"kind": "function"
			}
		],
		"comment": "    $(P The $(D std.uni) module provides an implementation\n    of fundamental Unicode algorithms and data structures.\n    This doesn't include UTF encoding and decoding primitives,\n    see $(XREF _utf, decode) and $(XREF _utf, encode) in std.utf\n    for this functionality. )\n\n    $(P All primitives listed operate on Unicode characters and\n    sets of characters. For functions which operate on ASCII characters\n    and ignore Unicode $(CHARACTERS), see $(LINK2 std_ascii.html, std.ascii).\n    For definitions of Unicode $(CHARACTER), $(CODEPOINT) and other terms\n    used throughout this module see the $(S_LINK Terminology, terminology) section\n    below.\n    )\n\n    $(P The focus of this module is the core needs of developing Unicode-aware\n    applications. To that effect it provides the following optimized primitives:\n    )\n    $(UL\n    $(LI Character classification by category and common properties:\n        $(LREF isAlpha), $(LREF isWhite) and others.\n    )\n    $(LI\n        Case-insensitive string comparison ($(LREF sicmp), $(LREF icmp)).\n    )\n    $(LI\n        Converting text to any of the four normalization forms via $(LREF normalize).\n    )\n    $(LI\n        Decoding ($(LREF decodeGrapheme))  and iteration ($(LREF byGrapheme), $(LREF graphemeStride))\n        by user-perceived characters, that is by $(LREF Grapheme) clusters.\n    )\n    $(LI\n        Decomposing and composing of individual character(s) according to canonical\n        or compatibility rules, see $(LREF compose) and $(LREF decompose),\n        including the specific version for Hangul syllables $(LREF composeJamo)\n        and $(LREF decomposeHangul).\n    )\n    )\n    $(P It's recognized that an application may need further enhancements\n    and extensions, such as less commonly known algorithms,\n    or tailoring existing ones for region specific needs. To help users\n    with building any extra functionality beyond the core primitives,\n    the module provides:\n    )\n    $(UL\n    $(LI\n        $(LREF CodepointSet), a type for easy manipulation of sets of characters.\n        Besides the typical set algebra it provides an unusual feature:\n        a D source code generator for detection of $(CODEPOINTS) in this set.\n        This is a boon for meta-programming parser frameworks,\n        and is used internally to power classification in small\n        sets like $(LREF isWhite).\n    )\n    $(LI\n        A way to construct optimal packed multi-stage tables also known as a\n        special case of $(LUCKY Trie).\n        The functions $(LREF codepointTrie), $(LREF codepointSetTrie)\n        construct custom tries that map dchar to value.\n        The end result is a fast and predictable $(BIGOH 1) lookup that powers\n        functions like $(LREF isAlpha) and $(LREF combiningClass),\n        but for user-defined data sets.\n    )\n    $(LI\n        A useful technique for Unicode-aware parsers that perform\n        character classification of encoded $(CODEPOINTS)\n        is to avoid unnecassary decoding at all costs.\n        $(LREF utfMatcher) provides an improvement over the usual workflow\n        of decode-classify-process, combining the decoding and classification\n        steps. By extracting necessary bits directly from encoded\n        $(S_LINK Code unit, code units) matchers achieve\n        significant performance improvements. See $(LREF MatcherConcept) for\n        the common interface of UTF matchers.\n    )\n    $(LI\n        Generally useful building blocks for customized normalization:\n        $(LREF combiningClass) for querying combining class\n        and $(LREF allowedIn) for testing the Quick_Check\n        property of a given normalization form.\n    )\n    $(LI\n        Access to a large selection of commonly used sets of $(CODEPOINTS).\n        $(S_LINK Unicode properties, Supported sets) include Script,\n        Block and General Category. The exact contents of a set can be\n        observed in the CLDR utility, on the\n        $(WEB www.unicode.org/cldr/utility/properties.jsp, property index) page\n        of the Unicode website.\n        See $(LREF unicode) for easy and (optionally) compile-time checked set\n        queries.\n    )\n    )\n    $(SECTION Synopsis)\n    ---\n    import std.uni;\n    void main()\n    {\n        // initialize code point sets using script/block or property name\n        // now 'set' contains code points from both scripts.\n        auto set = unicode(\"Cyrillic\") | unicode(\"Armenian\");\n        // same thing but simpler and checked at compile-time\n        auto ascii = unicode.ASCII;\n        auto currency = unicode.Currency_Symbol;\n\n        // easy set ops\n        auto a = set & ascii;\n        assert(a.empty); // as it has no intersection with ascii\n        a = set | ascii;\n        auto b = currency - a; // subtract all ASCII, Cyrillic and Armenian\n\n        // some properties of code point sets\n        assert(b.length > 45); // 46 items in Unicode 6.1, even more in 6.2\n        // testing presence of a code point in a set\n        // is just fine, it is O(logN)\n        assert(!b['$']);\n        assert(!b['\\u058F']); // Armenian dram sign\n        assert(b['¥']);\n\n        // building fast lookup tables, these guarantee O(1) complexity\n        // 1-level Trie lookup table essentially a huge bit-set ~262Kb\n        auto oneTrie = toTrie!1(b);\n        // 2-level far more compact but typically slightly slower\n        auto twoTrie = toTrie!2(b);\n        // 3-level even smaller, and a bit slower yet\n        auto threeTrie = toTrie!3(b);\n        assert(oneTrie['£']);\n        assert(twoTrie['£']);\n        assert(threeTrie['£']);\n\n        // build the trie with the most sensible trie level\n        // and bind it as a functor\n        auto cyrillicOrArmenian = toDelegate(set);\n        auto balance = find!(cyrillicOrArmenian)(\"Hello ընկեր!\");\n        assert(balance == \"ընկեր!\");\n        // compatible with bool delegate(dchar)\n        bool delegate(dchar) bindIt = cyrillicOrArmenian;\n\n        // Normalization\n        string s = \"Plain ascii (and not only), is always normalized!\";\n        assert(s is normalize(s));// is the same string\n\n        string nonS = \"A\\u0308ffin\"; // A ligature\n        auto nS = normalize(nonS); // to NFC, the W3C endorsed standard\n        assert(nS == \"Äffin\");\n        assert(nS != nonS);\n        string composed = \"Äffin\";\n\n        assert(normalize!NFD(composed) == \"A\\u0308ffin\");\n        // to NFKD, compatibility decomposition useful for fuzzy matching/searching\n        assert(normalize!NFKD(\"2¹⁰\") == \"210\");\n    }\n    ---\n    $(SECTION Terminology)\n    $(P The following is a list of important Unicode notions\n    and definitions. Any conventions used specifically in this\n    module alone are marked as such. The descriptions are based on the formal\n    definition as found in $(WEB www.unicode.org/versions/Unicode6.2.0/ch03.pdf,\n    chapter three of The Unicode Standard Core Specification.)\n    )\n\n    $(P $(DEF Abstract character) A unit of information used for the organization,\n    control, or representation of textual data.\n    Note that:\n        $(UL\n        $(LI When representing data, the nature of that data\n        is generally symbolic as opposed to some other\n        kind of data (for example, visual).)\n\n        $(LI An abstract character has no concrete form\n        and should not be confused with a $(S_LINK Glyph, glyph).)\n\n        $(LI An abstract character does not necessarily\n        correspond to what a user thinks of as a “character”\n         and should not be confused with a $(LREF Grapheme).)\n\n        $(LI The abstract characters encoded (see Encoded character)\n        are known as Unicode abstract characters.)\n\n        $(LI Abstract characters not directly\n        encoded by the Unicode Standard can often be\n        represented by the use of combining character sequences.)\n        )\n    )\n\n    $(P $(DEF Canonical decomposition)\n    The decomposition of a character or character sequence\n    that results from recursively applying the canonical\n    mappings found in the Unicode Character Database\n    and these described in Conjoining Jamo Behavior\n    (section 12 of\n    $(WEB www.unicode.org/uni2book/ch03.pdf, Unicode Conformance)).\n    )\n\n    $(P $(DEF Canonical composition)\n    The precise definition of the Canonical composition\n    is the algorithm as specified in $(WEB www.unicode.org/uni2book/ch03.pdf,\n    Unicode Conformance) section 11.\n    Informally it's the process that does the reverse of the canonical\n    decomposition with the addition of certain rules\n    that e.g. prevent legacy characters from appearing in the composed result.\n    )\n\n    $(P $(DEF Canonical equivalent)\n    Two character sequences are said to be canonical equivalents if\n    their full canonical decompositions are identical.\n    )\n\n    $(P $(DEF Character) Typically differs by context.\n    For the purpose of this documentation the term $(I character)\n    implies $(I encoded character), that is, a code point having\n    an assigned abstract character (a symbolic meaning).\n    )\n\n    $(P $(DEF Code point) Any value in the Unicode codespace;\n    that is, the range of integers from 0 to 10FFFF (hex).\n    Not all code points are assigned to encoded characters.\n    )\n\n    $(P $(DEF Code unit) The minimal bit combination that can represent\n    a unit of encoded text for processing or interchange.\n    Depending on the encoding this could be:\n    8-bit code units in the UTF-8 ($(D char)),\n    16-bit code units in the UTF-16 ($(D wchar)),\n    and 32-bit code units in the UTF-32 ($(D dchar)).\n    $(I Note that in UTF-32, a code unit is a code point\n    and is represented by the D $(D dchar) type.)\n    )\n\n    $(P $(DEF Combining character) A character with the General Category\n     of Combining Mark(M).\n        $(UL\n            $(LI All characters with non-zero canonical combining class\n            are combining characters, but the reverse is not the case:\n            there are combining characters with a zero combining class.\n            )\n            $(LI These characters are not normally used in isolation\n            unless they are being described. They include such characters\n            as accents, diacritics, Hebrew points, Arabic vowel signs,\n            and Indic matras.\n            )\n        )\n    )\n\n    $(P $(DEF Combining class)\n        A numerical value used by the Unicode Canonical Ordering Algorithm\n        to determine which sequences of combining marks are to be\n        considered canonically equivalent and  which are not.\n    )\n\n    $(P $(DEF Compatibility decomposition)\n    The decomposition of a character or character sequence that results\n    from recursively applying both the compatibility mappings and\n    the canonical mappings found in the Unicode Character Database, and those\n    described in Conjoining Jamo Behavior no characters\n    can be further decomposed.\n    )\n\n    $(P $(DEF Compatibility equivalent)\n    Two character sequences are said to be compatibility\n    equivalents if their full compatibility decompositions are identical.\n    )\n\n    $(P $(DEF Encoded character) An association (or mapping)\n    between an abstract character and a code point.\n    )\n\n    $(P $(DEF Glyph) The actual, concrete image of a glyph representation\n    having been rasterized or otherwise imaged onto some display surface.\n    )\n\n    $(P $(DEF Grapheme base) A character with the property\n     Grapheme_Base, or any standard Korean syllable block.\n    )\n\n    $(P $(DEF Grapheme cluster) Defined as the text between\n        grapheme boundaries  as specified by Unicode Standard Annex #29,\n        $(WEB www.unicode.org/reports/tr29/, Unicode text segmentation).\n        Important general properties of a grapheme:\n        $(UL\n            $(LI The grapheme cluster represents a horizontally segmentable\n            unit of text, consisting of some grapheme base (which may\n            consist of a Korean syllable) together with any number of\n            nonspacing marks applied to it.\n            )\n            $(LI  A grapheme cluster typically starts with a grapheme base\n            and then extends across any subsequent sequence of nonspacing marks.\n            A grapheme cluster is most directly relevant to text rendering and\n            processes such as cursor placement and text selection in editing,\n            but may also be relevant to comparison and searching.\n            )\n            $(LI For many processes, a grapheme cluster behaves as if it was a\n            single character with the same properties as its grapheme base.\n            Effectively, nonspacing marks apply $(I graphically) to the base,\n            but do not change its properties.\n            )\n        )\n        $(P This module defines a number of primitives that work with graphemes:\n        $(LREF Grapheme), $(LREF decodeGrapheme) and $(LREF graphemeStride).\n        All of them are using $(I extended grapheme) boundaries\n        as defined in the aforementioned standard annex.\n        )\n    )\n\n\n    $(P $(DEF Nonspacing mark) A combining character with the\n        General Category of Nonspacing Mark (Mn) or Enclosing Mark (Me).\n    )\n\n    $(P $(DEF Spacing mark) A combining character that is not a nonspacing mark.)\n\n\n    $(SECTION Normalization)\n\n    $(P The concepts of $(S_LINK Canonical equivalent, canonical equivalent)\n     or $(S_LINK Compatibility equivalent, compatibility equivalent)\n    characters in the Unicode Standard make it necessary to have a full, formal\n    definition of equivalence for Unicode strings.\n    String equivalence is determined by a process called normalization,\n    whereby strings are converted into forms which are compared\n    directly for identity. This is the primary goal of the normalization process,\n    see the function $(LREF normalize) to convert into any of\n    the four defined forms.\n    )\n\n    $(P A very important attribute of the Unicode Normalization Forms\n    is that they must remain stable between versions of the Unicode Standard.\n    A Unicode string normalized to a particular Unicode Normalization Form\n    in one version of the standard is guaranteed to remain in that Normalization\n    Form for implementations of future versions of the standard.\n    )\n\n    $(P The Unicode Standard specifies four normalization forms.\n    Informally, two of these forms are defined by maximal decomposition\n    of equivalent sequences, and two of these forms are defined\n    by maximal $(I composition) of equivalent sequences.\n        $(UL\n        $(LI Normalization Form D (NFD): The $(S_LINK Canonical decomposition,\n            canonical decomposition) of a character sequence.)\n        $(LI Normalization Form KD (NFKD): The $(S_LINK Compatibility decomposition,\n            compatibility decomposition) of a character sequence.)\n        $(LI Normalization Form C (NFC): The canonical composition of the\n            $(S_LINK Canonical decomposition, canonical decomposition)\n            of a coded character sequence.)\n        $(LI Normalization Form KC (NFKC): The canonical composition\n        of the $(S_LINK Compatibility decomposition,\n            compatibility decomposition) of a character sequence)\n        )\n    )\n\n    $(P The choice of the normalization form depends on the particular use case.\n    NFC is the best form for general text, since it's more compatible with\n    strings converted from legacy encodings. NFKC is the preferred form for\n    identifiers, especially where there are security concerns. NFD and NFKD\n    are the most useful for internal processing.\n    )\n\n    $(SECTION Construction of lookup tables)\n\n    $(P The Unicode standard describes a set of algorithms that\n    depend on having the ability to quickly look up various properties\n    of a code point. Given the the codespace of about 1 million $(CODEPOINTS),\n    it is not a trivial task to provide a space-efficient solution for\n    the multitude of properties.)\n\n    $(P Common approaches such as hash-tables or binary search over\n     sorted code point intervals (as in $(LREF InversionList)) are insufficient.\n     Hash-tables have enormous memory footprint and binary search\n     over intervals is not fast enough for some heavy-duty algorithms.\n     )\n\n    $(P The recommended solution (see Unicode Implementation Guidelines)\n    is using multi-stage tables that are an implementation of the\n    $(WEB en.wikipedia.org/wiki/Trie, Trie) data structure with integer\n    keys and a fixed number of stages. For the remainder of the section\n    this will be called a fixed trie. The following describes a particular\n    implementation that is aimed for the speed of access at the expense\n    of ideal size savings.\n    )\n\n    $(P Taking a 2-level Trie as an example the principle of operation is as follows.\n        Split the number of bits in a key (code point, 21 bits) into 2 components\n        (e.g. 15 and 8).  The first is the number of bits in the index of the trie\n         and the other is number of bits in each page of the trie.\n        The layout of the trie is then an array of size 2^^bits-of-index followed\n        an array of memory chunks of size 2^^bits-of-page/bits-per-element.\n    )\n\n    $(P The number of pages is variable (but not less then 1)\n        unlike the number of entries in the index. The slots of the index\n        all have to contain a number of a page that is present. The lookup is then\n        just a couple of operations - slice the upper bits,\n        lookup an index for these, take a page at this index and use\n        the lower bits as an offset within this page.\n\n        Assuming that pages are laid out consequently\n        in one array at $(D pages), the pseudo-code is:\n    )\n    ---\n    auto elemsPerPage = (2 ^^ bits_per_page) / Value.sizeOfInBits;\n    pages[index[n >> bits_per_page]][n & (elemsPerPage - 1)];\n    ---\n    $(P Where if $(D elemsPerPage) is a power of 2 the whole process is\n    a handful of simple instructions and 2 array reads. Subsequent levels\n    of the trie are introduced by recursing on this notion - the index array\n    is treated as values. The number of bits in index is then again\n    split into 2 parts, with pages over 'current-index' and the new 'upper-index'.\n    )\n\n    $(P For completeness a level 1 trie is simply an array.\n    The current implementation takes advantage of bit-packing values\n    when the range is known to be limited in advance (such as $(D bool)).\n    See also $(LREF BitPacked) for enforcing it manually.\n    The major size advantage however comes from the fact\n    that multiple $(B identical pages on every level are merged) by construction.\n    )\n\n    $(P The process of constructing a trie is more involved and is hidden from\n    the user in a form of the convenience functions $(LREF codepointTrie),\n    $(LREF codepointSetTrie) and the even more convenient $(LREF toTrie).\n    In general a set or built-in AA with $(D dchar) type\n    can be turned into a trie. The trie object in this module\n    is read-only (immutable); it's effectively frozen after construction.\n    )\n\n    $(SECTION Unicode properties)\n\n    $(P This is a full list of Unicode properties accessible through $(LREF unicode)\n    with specific helpers per category nested within. Consult the\n    $(WEB www.unicode.org/cldr/utility/properties.jsp, CLDR utility)\n    when in doubt about the contents of a particular set.)\n\n    $(P General category sets listed below are only accessible with the\n    $(LREF unicode) shorthand accessor.)\n    $(BOOKTABLE $(B General category ),\n         $(TR $(TH Abb.) $(TH Long form)\n            $(TH Abb.) $(TH Long form)$(TH Abb.) $(TH Long form))\n        $(TR $(TD L) $(TD Letter)\n            $(TD Cn) $(TD Unassigned)  $(TD Po) $(TD Other_Punctuation))\n        $(TR $(TD Ll) $(TD Lowercase_Letter)\n            $(TD Co) $(TD Private_Use) $(TD Ps) $(TD Open_Punctuation))\n        $(TR $(TD Lm) $(TD Modifier_Letter)\n            $(TD Cs) $(TD Surrogate)   $(TD S) $(TD Symbol))\n        $(TR $(TD Lo) $(TD Other_Letter)\n            $(TD N) $(TD Number)  $(TD Sc) $(TD Currency_Symbol))\n        $(TR $(TD Lt) $(TD Titlecase_Letter)\n          $(TD Nd) $(TD Decimal_Number)  $(TD Sk) $(TD Modifier_Symbol))\n        $(TR $(TD Lu) $(TD Uppercase_Letter)\n          $(TD Nl) $(TD Letter_Number)   $(TD Sm) $(TD Math_Symbol))\n        $(TR $(TD M) $(TD Mark)\n          $(TD No) $(TD Other_Number)    $(TD So) $(TD Other_Symbol))\n        $(TR $(TD Mc) $(TD Spacing_Mark)\n          $(TD P) $(TD Punctuation) $(TD Z) $(TD Separator))\n        $(TR $(TD Me) $(TD Enclosing_Mark)\n          $(TD Pc) $(TD Connector_Punctuation)   $(TD Zl) $(TD Line_Separator))\n        $(TR $(TD Mn) $(TD Nonspacing_Mark)\n          $(TD Pd) $(TD Dash_Punctuation)    $(TD Zp) $(TD Paragraph_Separator))\n        $(TR $(TD C) $(TD Other)\n          $(TD Pe) $(TD Close_Punctuation) $(TD Zs) $(TD Space_Separator))\n        $(TR $(TD Cc) $(TD Control) $(TD Pf)\n          $(TD Final_Punctuation)   $(TD -) $(TD Any))\n        $(TR $(TD Cf) $(TD Format)\n          $(TD Pi) $(TD Initial_Punctuation) $(TD -) $(TD ASCII))\n    )\n    $(P Sets for other commonly useful properties that are\n    accessible with $(LREF unicode):)\n    $(BOOKTABLE $(B Common binary properties),\n        $(TR $(TH Name) $(TH Name) $(TH Name))\n        $(TR $(TD Alphabetic)  $(TD Ideographic) $(TD Other_Uppercase))\n        $(TR $(TD ASCII_Hex_Digit) $(TD IDS_Binary_Operator) $(TD Pattern_Syntax))\n        $(TR $(TD Bidi_Control)    $(TD ID_Start)    $(TD Pattern_White_Space))\n        $(TR $(TD Cased)   $(TD IDS_Trinary_Operator)    $(TD Quotation_Mark))\n        $(TR $(TD Case_Ignorable)  $(TD Join_Control)    $(TD Radical))\n        $(TR $(TD Dash)    $(TD Logical_Order_Exception) $(TD Soft_Dotted))\n        $(TR $(TD Default_Ignorable_Code_Point)    $(TD Lowercase)   $(TD STerm))\n        $(TR $(TD Deprecated)  $(TD Math)    $(TD Terminal_Punctuation))\n        $(TR $(TD Diacritic)   $(TD Noncharacter_Code_Point) $(TD Unified_Ideograph))\n        $(TR $(TD Extender)    $(TD Other_Alphabetic)    $(TD Uppercase))\n        $(TR $(TD Grapheme_Base)   $(TD Other_Default_Ignorable_Code_Point)  $(TD Variation_Selector))\n        $(TR $(TD Grapheme_Extend) $(TD Other_Grapheme_Extend)   $(TD White_Space))\n        $(TR $(TD Grapheme_Link)   $(TD Other_ID_Continue)   $(TD XID_Continue))\n        $(TR $(TD Hex_Digit)   $(TD Other_ID_Start)  $(TD XID_Start))\n        $(TR $(TD Hyphen)  $(TD Other_Lowercase) )\n        $(TR $(TD ID_Continue) $(TD Other_Math)  )\n    )\n    $(P Bellow is the table with block names accepted by $(LREF unicode.block).\n    Note that the shorthand version $(LREF unicode) requires \"In\"\n    to be prepended to the names of blocks so as to disambiguate\n    scripts and blocks.)\n\n    $(BOOKTABLE $(B Blocks),\n        $(TR $(TD Aegean Numbers)    $(TD Ethiopic Extended) $(TD Mongolian))\n        $(TR $(TD Alchemical Symbols)    $(TD Ethiopic Extended-A)   $(TD Musical Symbols))\n        $(TR $(TD Alphabetic Presentation Forms) $(TD Ethiopic Supplement)   $(TD Myanmar))\n        $(TR $(TD Ancient Greek Musical Notation)    $(TD General Punctuation)   $(TD Myanmar Extended-A))\n        $(TR $(TD Ancient Greek Numbers) $(TD Geometric Shapes)  $(TD New Tai Lue))\n        $(TR $(TD Ancient Symbols)   $(TD Georgian)  $(TD NKo))\n        $(TR $(TD Arabic)    $(TD Georgian Supplement)   $(TD Number Forms))\n        $(TR $(TD Arabic Extended-A) $(TD Glagolitic)    $(TD Ogham))\n        $(TR $(TD Arabic Mathematical Alphabetic Symbols)    $(TD Gothic)    $(TD Ol Chiki))\n        $(TR $(TD Arabic Presentation Forms-A)   $(TD Greek and Coptic)  $(TD Old Italic))\n        $(TR $(TD Arabic Presentation Forms-B)   $(TD Greek Extended)    $(TD Old Persian))\n        $(TR $(TD Arabic Supplement) $(TD Gujarati)  $(TD Old South Arabian))\n        $(TR $(TD Armenian)  $(TD Gurmukhi)  $(TD Old Turkic))\n        $(TR $(TD Arrows)    $(TD Halfwidth and Fullwidth Forms) $(TD Optical Character Recognition))\n        $(TR $(TD Avestan)   $(TD Hangul Compatibility Jamo) $(TD Oriya))\n        $(TR $(TD Balinese)  $(TD Hangul Jamo)   $(TD Osmanya))\n        $(TR $(TD Bamum) $(TD Hangul Jamo Extended-A)    $(TD Phags-pa))\n        $(TR $(TD Bamum Supplement)  $(TD Hangul Jamo Extended-B)    $(TD Phaistos Disc))\n        $(TR $(TD Basic Latin)   $(TD Hangul Syllables)  $(TD Phoenician))\n        $(TR $(TD Batak) $(TD Hanunoo)   $(TD Phonetic Extensions))\n        $(TR $(TD Bengali)   $(TD Hebrew)    $(TD Phonetic Extensions Supplement))\n        $(TR $(TD Block Elements)    $(TD High Private Use Surrogates)   $(TD Playing Cards))\n        $(TR $(TD Bopomofo)  $(TD High Surrogates)   $(TD Private Use Area))\n        $(TR $(TD Bopomofo Extended) $(TD Hiragana)  $(TD Rejang))\n        $(TR $(TD Box Drawing)   $(TD Ideographic Description Characters)    $(TD Rumi Numeral Symbols))\n        $(TR $(TD Brahmi)    $(TD Imperial Aramaic)  $(TD Runic))\n        $(TR $(TD Braille Patterns)  $(TD Inscriptional Pahlavi) $(TD Samaritan))\n        $(TR $(TD Buginese)  $(TD Inscriptional Parthian)    $(TD Saurashtra))\n        $(TR $(TD Buhid) $(TD IPA Extensions)    $(TD Sharada))\n        $(TR $(TD Byzantine Musical Symbols) $(TD Javanese)  $(TD Shavian))\n        $(TR $(TD Carian)    $(TD Kaithi)    $(TD Sinhala))\n        $(TR $(TD Chakma)    $(TD Kana Supplement)   $(TD Small Form Variants))\n        $(TR $(TD Cham)  $(TD Kanbun)    $(TD Sora Sompeng))\n        $(TR $(TD Cherokee)  $(TD Kangxi Radicals)   $(TD Spacing Modifier Letters))\n        $(TR $(TD CJK Compatibility) $(TD Kannada)   $(TD Specials))\n        $(TR $(TD CJK Compatibility Forms)   $(TD Katakana)  $(TD Sundanese))\n        $(TR $(TD CJK Compatibility Ideographs)  $(TD Katakana Phonetic Extensions)  $(TD Sundanese Supplement))\n        $(TR $(TD CJK Compatibility Ideographs Supplement)   $(TD Kayah Li)  $(TD Superscripts and Subscripts))\n        $(TR $(TD CJK Radicals Supplement)   $(TD Kharoshthi)    $(TD Supplemental Arrows-A))\n        $(TR $(TD CJK Strokes)   $(TD Khmer) $(TD Supplemental Arrows-B))\n        $(TR $(TD CJK Symbols and Punctuation)   $(TD Khmer Symbols) $(TD Supplemental Mathematical Operators))\n        $(TR $(TD CJK Unified Ideographs)    $(TD Lao)   $(TD Supplemental Punctuation))\n        $(TR $(TD CJK Unified Ideographs Extension A)    $(TD Latin-1 Supplement)    $(TD Supplementary Private Use Area-A))\n        $(TR $(TD CJK Unified Ideographs Extension B)    $(TD Latin Extended-A)  $(TD Supplementary Private Use Area-B))\n        $(TR $(TD CJK Unified Ideographs Extension C)    $(TD Latin Extended Additional) $(TD Syloti Nagri))\n        $(TR $(TD CJK Unified Ideographs Extension D)    $(TD Latin Extended-B)  $(TD Syriac))\n        $(TR $(TD Combining Diacritical Marks)   $(TD Latin Extended-C)  $(TD Tagalog))\n        $(TR $(TD Combining Diacritical Marks for Symbols)   $(TD Latin Extended-D)  $(TD Tagbanwa))\n        $(TR $(TD Combining Diacritical Marks Supplement)    $(TD Lepcha)    $(TD Tags))\n        $(TR $(TD Combining Half Marks)  $(TD Letterlike Symbols)    $(TD Tai Le))\n        $(TR $(TD Common Indic Number Forms) $(TD Limbu) $(TD Tai Tham))\n        $(TR $(TD Control Pictures)  $(TD Linear B Ideograms)    $(TD Tai Viet))\n        $(TR $(TD Coptic)    $(TD Linear B Syllabary)    $(TD Tai Xuan Jing Symbols))\n        $(TR $(TD Counting Rod Numerals) $(TD Lisu)  $(TD Takri))\n        $(TR $(TD Cuneiform) $(TD Low Surrogates)    $(TD Tamil))\n        $(TR $(TD Cuneiform Numbers and Punctuation) $(TD Lycian)    $(TD Telugu))\n        $(TR $(TD Currency Symbols)  $(TD Lydian)    $(TD Thaana))\n        $(TR $(TD Cypriot Syllabary) $(TD Mahjong Tiles) $(TD Thai))\n        $(TR $(TD Cyrillic)  $(TD Malayalam) $(TD Tibetan))\n        $(TR $(TD Cyrillic Extended-A)   $(TD Mandaic)   $(TD Tifinagh))\n        $(TR $(TD Cyrillic Extended-B)   $(TD Mathematical Alphanumeric Symbols) $(TD Transport And Map Symbols))\n        $(TR $(TD Cyrillic Supplement)   $(TD Mathematical Operators)    $(TD Ugaritic))\n        $(TR $(TD Deseret)   $(TD Meetei Mayek)  $(TD Unified Canadian Aboriginal Syllabics))\n        $(TR $(TD Devanagari)    $(TD Meetei Mayek Extensions)   $(TD Unified Canadian Aboriginal Syllabics Extended))\n        $(TR $(TD Devanagari Extended)   $(TD Meroitic Cursive)  $(TD Vai))\n        $(TR $(TD Dingbats)  $(TD Meroitic Hieroglyphs)  $(TD Variation Selectors))\n        $(TR $(TD Domino Tiles)  $(TD Miao)  $(TD Variation Selectors Supplement))\n        $(TR $(TD Egyptian Hieroglyphs)  $(TD Miscellaneous Mathematical Symbols-A)  $(TD Vedic Extensions))\n        $(TR $(TD Emoticons) $(TD Miscellaneous Mathematical Symbols-B)  $(TD Vertical Forms))\n        $(TR $(TD Enclosed Alphanumerics)    $(TD Miscellaneous Symbols) $(TD Yijing Hexagram Symbols))\n        $(TR $(TD Enclosed Alphanumeric Supplement)  $(TD Miscellaneous Symbols and Arrows)  $(TD Yi Radicals))\n        $(TR $(TD Enclosed CJK Letters and Months)   $(TD Miscellaneous Symbols And Pictographs) $(TD Yi Syllables))\n        $(TR $(TD Enclosed Ideographic Supplement)   $(TD Miscellaneous Technical)   )\n        $(TR $(TD Ethiopic)  $(TD Modifier Tone Letters) )\n    )\n\n    $(P Bellow is the table with script names accepted by $(LREF unicode.script)\n    and by the shorthand version $(LREF unicode):)\n    $(BOOKTABLE $(B Scripts),\n        $(TR $(TD Arabic)  $(TD Hanunoo) $(TD Old_Italic))\n        $(TR $(TD Armenian)    $(TD Hebrew)  $(TD Old_Persian))\n        $(TR $(TD Avestan) $(TD Hiragana)    $(TD Old_South_Arabian))\n        $(TR $(TD Balinese)    $(TD Imperial_Aramaic)    $(TD Old_Turkic))\n        $(TR $(TD Bamum)   $(TD Inherited)   $(TD Oriya))\n        $(TR $(TD Batak)   $(TD Inscriptional_Pahlavi)   $(TD Osmanya))\n        $(TR $(TD Bengali) $(TD Inscriptional_Parthian)  $(TD Phags_Pa))\n        $(TR $(TD Bopomofo)    $(TD Javanese)    $(TD Phoenician))\n        $(TR $(TD Brahmi)  $(TD Kaithi)  $(TD Rejang))\n        $(TR $(TD Braille) $(TD Kannada) $(TD Runic))\n        $(TR $(TD Buginese)    $(TD Katakana)    $(TD Samaritan))\n        $(TR $(TD Buhid)   $(TD Kayah_Li)    $(TD Saurashtra))\n        $(TR $(TD Canadian_Aboriginal) $(TD Kharoshthi)  $(TD Sharada))\n        $(TR $(TD Carian)  $(TD Khmer)   $(TD Shavian))\n        $(TR $(TD Chakma)  $(TD Lao) $(TD Sinhala))\n        $(TR $(TD Cham)    $(TD Latin)   $(TD Sora_Sompeng))\n        $(TR $(TD Cherokee)    $(TD Lepcha)  $(TD Sundanese))\n        $(TR $(TD Common)  $(TD Limbu)   $(TD Syloti_Nagri))\n        $(TR $(TD Coptic)  $(TD Linear_B)    $(TD Syriac))\n        $(TR $(TD Cuneiform)   $(TD Lisu)    $(TD Tagalog))\n        $(TR $(TD Cypriot) $(TD Lycian)  $(TD Tagbanwa))\n        $(TR $(TD Cyrillic)    $(TD Lydian)  $(TD Tai_Le))\n        $(TR $(TD Deseret) $(TD Malayalam)   $(TD Tai_Tham))\n        $(TR $(TD Devanagari)  $(TD Mandaic) $(TD Tai_Viet))\n        $(TR $(TD Egyptian_Hieroglyphs)    $(TD Meetei_Mayek)    $(TD Takri))\n        $(TR $(TD Ethiopic)    $(TD Meroitic_Cursive)    $(TD Tamil))\n        $(TR $(TD Georgian)    $(TD Meroitic_Hieroglyphs)    $(TD Telugu))\n        $(TR $(TD Glagolitic)  $(TD Miao)    $(TD Thaana))\n        $(TR $(TD Gothic)  $(TD Mongolian)   $(TD Thai))\n        $(TR $(TD Greek)   $(TD Myanmar) $(TD Tibetan))\n        $(TR $(TD Gujarati)    $(TD New_Tai_Lue) $(TD Tifinagh))\n        $(TR $(TD Gurmukhi)    $(TD Nko) $(TD Ugaritic))\n        $(TR $(TD Han) $(TD Ogham)   $(TD Vai))\n        $(TR $(TD Hangul)  $(TD Ol_Chiki)    $(TD Yi))\n    )\n\n    $(P Bellow is the table of names accepted by $(LREF unicode.hangulSyllableType).)\n    $(BOOKTABLE $(B Hangul syllable type),\n        $(TR $(TH Abb.) $(TH Long form))\n        $(TR $(TD L)   $(TD Leading_Jamo))\n        $(TR $(TD LV)  $(TD LV_Syllable))\n        $(TR $(TD LVT) $(TD LVT_Syllable) )\n        $(TR $(TD T)   $(TD Trailing_Jamo))\n        $(TR $(TD V)   $(TD Vowel_Jamo))\n    )\n    References:\n        $(WEB www.digitalmars.com/d/ascii-table.html, ASCII Table),\n        $(WEB en.wikipedia.org/wiki/Unicode, Wikipedia),\n        $(WEB www.unicode.org, The Unicode Consortium),\n        $(WEB www.unicode.org/reports/tr15/, Unicode normalization forms),\n        $(WEB www.unicode.org/reports/tr29/, Unicode text segmentation)\n        $(WEB www.unicode.org/uni2book/ch05.pdf,\n            Unicode Implementation Guidelines)\n        $(WEB www.unicode.org/uni2book/ch03.pdf,\n            Unicode Conformance)\n    Trademarks:\n        Unicode(tm) is a trademark of Unicode, Inc.\n\n    Macros:\n        WIKI=Phobos/StdUni\n\n    Copyright: Copyright 2013 -\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   Dmitry Olshansky\n    Source:    $(PHOBOSSRC std/_uni.d)\n    Standards: $(WEB www.unicode.org/versions/Unicode6.2.0/, Unicode v6.2)\n\nMacros:\n\nSECTION = <h3><a id=\"$1\">$0</a></h3>\nDEF = <div><a id=\"$1\"><i>$0</i></a></div>\nS_LINK = <a href=\"#$1\">$+</a>\nCODEPOINT = $(S_LINK Code point, code point)\nCODEPOINTS = $(S_LINK Code point, code points)\nCHARACTER = $(S_LINK Character, character)\nCHARACTERS = $(S_LINK Character, characters)\nCLUSTER = $(S_LINK Grapheme cluster, grapheme cluster)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/xml.d",
		"name": "std.xml",
		"members": [
			{
				"endchar": 1,
				"name": "isChar",
				"line": 147,
				"comment": " Returns true if the character is a character according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 169,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSpace",
				"line": 214,
				"comment": " Returns true if the character is whitespace according to the XML standard\n\n Only the following characters are considered whitespace in XML - space, tab,\n carriage return and linefeed\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 217,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isDigit",
				"line": 227,
				"comment": " Returns true if the character is a digit according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 233,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isLetter",
				"line": 252,
				"comment": " Returns true if the character is a letter according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 255,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isIdeographic",
				"line": 266,
				"comment": " Returns true if the character is an ideographic character according to the\n XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 275,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isBaseChar",
				"line": 301,
				"comment": " Returns true if the character is a base character according to the XML\n standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 304,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isCombiningChar",
				"line": 315,
				"comment": " Returns true if the character is a combining character according to the\n XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 318,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isExtender",
				"line": 328,
				"comment": " Returns true if the character is an extender according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 331,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 357,
						"type": "S(S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 383,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 357,
				"comment": " Encodes a string by replacing all characters which need to be escaped with\n appropriate predefined XML entities.\n\n encode() escapes certain characters (ampersand, quote, apostrophe, less-than\n and greater-than), and similarly, decode() unescapes them. These functions\n are provided for convenience only. You do not need to use them when using\n the std.xml classes, because then all the encoding and decoding will be done\n for you automatically.\n\n If the string is not modified, the original will be returned.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n      s = The string to be encoded\n\n Returns: The encoded string\n\n Example:\n --------------\n writefln(encode(\"a > b\")); // writes \"a &gt; b\"\n --------------\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [],
				"name": "DecodeMode",
				"line": 403,
				"comment": " Mode to use for decoding.\n\n $(DDOC_ENUM_MEMBERS NONE) Do not decode\n $(DDOC_ENUM_MEMBERS LOOSE) Decode, but ignore errors\n $(DDOC_ENUM_MEMBERS STRICT) Decode, and throw exception on error\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"endchar": 1,
				"name": "decode",
				"line": 442,
				"comment": " Decodes a string by unescaping all predefined XML entities.\n\n encode() escapes certain characters (ampersand, quote, apostrophe, less-than\n and greater-than), and similarly, decode() unescapes them. These functions\n are provided for convenience only. You do not need to use them when using\n the std.xml classes, because then all the encoding and decoding will be done\n for you automatically.\n\n This function decodes the entities &amp;amp;, &amp;quot;, &amp;apos;,\n &amp;lt; and &amp;gt,\n as well as decimal and hexadecimal entities such as &amp;#x20AC;\n\n If the string does not contain an ampersand, the original will be returned.\n\n Note that the \"mode\" parameter can be one of DecodeMode.NONE (do not\n decode), DecodeMode.LOOSE (decode, but ignore errors), or DecodeMode.STRICT\n (decode, and throw a DecodeException in the event of an error).\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n      s = The string to be decoded\n      mode = (optional) Mode to use for decoding. (Defaults to LOOSE).\n\n Throws: DecodeException if mode == DecodeMode.STRICT and decode fails\n\n Returns: The decoded string\n\n Example:\n --------------\n writefln(decode(\"a &gt; b\")); // writes \"a > b\"\n --------------\n",
				"deco": "FAyaE3std3xml10DecodeModeZAya",
				"parameters": [
					{
						"name": "s",
						"deco": "Aya"
					},
					{
						"name": "mode",
						"deco": "E3std3xml10DecodeMode",
						"default": "cast(DecodeMode)1"
					}
				],
				"endline": 494,
				"originalType": "string(string s, DecodeMode mode = DecodeMode.LOOSE)",
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"offset": 120,
						"name": "prolog",
						"line": 544,
						"comment": " Contains all text which occurs before the root element.\n Defaults to &lt;?xml version=\"1.0\"?&gt;\n",
						"deco": "Aya",
						"init": "\"<?xml version=\\\"1.0\\\"?>\"",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 136,
						"name": "epilog",
						"line": 549,
						"comment": " Contains all text which occurs after the root element.\n Defaults to the empty string\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 562,
						"comment": " Constructs a Document by parsing XML text.\n\n This function creates a complete DOM (Document Object Model) tree.\n\n The input to this function MUST be valid XML.\n This is enforced by DocumentParser's in contract.\n\n Params:\n      s = the complete XML text.\n",
						"deco": "FAyaZC3std3xml8Document",
						"parameters": [
							{
								"name": "s",
								"deco": "Aya"
							}
						],
						"endline": 576,
						"originalType": "(string s)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 584,
						"comment": " Constructs a Document from a Tag.\n\n Params:\n      tag = the start tag of the document.\n",
						"deco": "FxC3std3xml3TagZC3std3xml8Document",
						"parameters": [
							{
								"name": "tag",
								"deco": "xC3std3xml3Tag"
							}
						],
						"endline": 587,
						"originalType": "(const(Tag) tag)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 9,
						"name": "opEquals",
						"line": 600,
						"comment": " Compares two Documents for equality\n\n Example:\n --------------\n Document d1,d2;\n if (d1 == d2) { }\n --------------\n",
						"deco": "xFC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 608,
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.xml.Element.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "opCmp",
						"line": 622,
						"comment": " Compares two Documents\n\n You should rarely need to call this function. It exists so that\n Documents can be used as associative array keys.\n\n Example:\n --------------\n Document d1,d2;\n if (d1 < d2) { }\n --------------\n",
						"deco": "xFC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 633,
						"char": 22,
						"kind": "function",
						"overrides": [
							"std.xml.Element.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "toHash",
						"line": 641,
						"comment": " Returns the hash of a Document\n\n You should rarely need to call this function. It exists so that\n Documents can be used as associative array keys.\n",
						"deco": "xFNbNeZm",
						"endline": 644,
						"originalType": "const @trusted size_t()",
						"char": 25,
						"kind": "function",
						"overrides": [
							"std.xml.Element.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "toString",
						"line": 650,
						"comment": " Returns the string representation of a Document. (That is, the\n complete XML of a document).\n",
						"deco": "xFZAya",
						"endline": 653,
						"char": 25,
						"kind": "function",
						"overrides": [
							"std.xml.Element.toString"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "Document",
				"line": 538,
				"comment": " Class representing an XML document.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n",
				"base": "std.xml.Element",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"offset": 16,
						"name": "tag",
						"line": 664,
						"comment": "The start tag of the element\n",
						"deco": "C3std3xml3Tag",
						"originalType": "Tag",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "items",
						"line": 665,
						"comment": "The element's items\n",
						"deco": "AC3std3xml4Item",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 40,
						"name": "texts",
						"line": 666,
						"comment": "The element's text items\n",
						"deco": "AC3std3xml4Text",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 56,
						"name": "cdatas",
						"line": 667,
						"comment": "The element's CData items\n",
						"deco": "AC3std3xml5CData",
						"char": 13,
						"kind": "variable"
					},
					{
						"offset": 72,
						"name": "comments",
						"line": 668,
						"comment": "The element's comments\n",
						"deco": "AC3std3xml7Comment",
						"char": 15,
						"kind": "variable"
					},
					{
						"offset": 88,
						"name": "pis",
						"line": 669,
						"comment": "The element's processing instructions\n",
						"deco": "AC3std3xml21ProcessingInstruction",
						"char": 29,
						"kind": "variable"
					},
					{
						"offset": 104,
						"name": "elements",
						"line": 670,
						"comment": "The element's child elements\n",
						"deco": "AC3std3xml7Element",
						"char": 15,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 686,
						"comment": " Constructs an Element given a name and a string to be used as a Text\n interior.\n\n Params:\n      name = the name of the element.\n      interior = (optional) the string interior.\n\n Example:\n -------------------------------------------------------\n auto element = new Element(\"title\",\"Serenity\")\n     // constructs the element <title>Serenity</title>\n -------------------------------------------------------\n",
						"deco": "FAyaAyaZC3std3xml7Element",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							},
							{
								"name": "interior",
								"deco": "Aya",
								"default": "null"
							}
						],
						"endline": 690,
						"originalType": "(string name, string interior = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 698,
						"comment": " Constructs an Element from a Tag.\n\n Params:\n      tag_ = the start or empty tag of the element.\n",
						"deco": "FxC3std3xml3TagZC3std3xml7Element",
						"parameters": [
							{
								"name": "tag_",
								"deco": "xC3std3xml3Tag"
							}
						],
						"endline": 704,
						"originalType": "(const(Tag) tag_)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 718,
						"comment": " Append a text item to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Example:\n --------------\n Element element;\n element ~= new Text(\"hello\");\n --------------\n",
						"deco": "FC3std3xml4TextZv",
						"parameters": [
							{
								"name": "item",
								"deco": "C3std3xml4Text"
							}
						],
						"endline": 722,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 736,
						"comment": " Append a CData item to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Example:\n --------------\n Element element;\n element ~= new CData(\"hello\");\n --------------\n",
						"deco": "FC3std3xml5CDataZv",
						"parameters": [
							{
								"name": "item",
								"deco": "C3std3xml5CData"
							}
						],
						"endline": 740,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 754,
						"comment": " Append a comment to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Example:\n --------------\n Element element;\n element ~= new Comment(\"hello\");\n --------------\n",
						"deco": "FC3std3xml7CommentZv",
						"parameters": [
							{
								"name": "item",
								"deco": "C3std3xml7Comment"
							}
						],
						"endline": 758,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 772,
						"comment": " Append a processing instruction to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Example:\n --------------\n Element element;\n element ~= new ProcessingInstruction(\"hello\");\n --------------\n",
						"deco": "FC3std3xml21ProcessingInstructionZv",
						"parameters": [
							{
								"name": "item",
								"deco": "C3std3xml21ProcessingInstruction"
							}
						],
						"endline": 776,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 792,
						"comment": " Append a complete element to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Example:\n --------------\n Element element;\n Element other = new Element(\"br\");\n element ~= other;\n    // appends element representing <br />\n --------------\n",
						"deco": "FC3std3xml7ElementZv",
						"parameters": [
							{
								"name": "item",
								"deco": "C3std3xml7Element"
							}
						],
						"endline": 796,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 831,
						"comment": " Compares two Elements for equality\n\n Example:\n --------------\n Element e1,e2;\n if (e1 == e2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 841,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 855,
						"comment": " Compares two Elements\n\n You should rarely need to call this function. It exists so that Elements\n can be used as associative array keys.\n\n Example:\n --------------\n Element e1,e2;\n if (e1 < e2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 866,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "toHash",
						"line": 874,
						"comment": " Returns the hash of an Element\n\n You should rarely need to call this function. It exists so that Elements\n can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 879,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "text",
						"line": 895,
						"comment": " Returns the decoded interior of an element.\n\n The element is assumed to contain text <i>only</i>. So, for\n example, given XML such as \"&lt;title&gt;Good &amp;amp;\n Bad&lt;/title&gt;\", will return \"Good &amp; Bad\".\n\n Params:\n      mode = (optional) Mode to use for decoding. (Defaults to LOOSE).\n\n Throws: DecodeException if decode fails\n",
						"deco": "xFE3std3xml10DecodeModeZAya",
						"parameters": [
							{
								"name": "mode",
								"deco": "E3std3xml10DecodeMode",
								"default": "cast(DecodeMode)1"
							}
						],
						"endline": 905,
						"originalType": "const string(DecodeMode mode = DecodeMode.LOOSE)",
						"char": 16,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "pretty",
						"line": 914,
						"comment": " Returns an indented string representation of this item\n\n Params:\n      indent = (optional) number of spaces by which to indent this\n          element. Defaults to 2.\n",
						"deco": "xFkZAAya",
						"parameters": [
							{
								"name": "indent",
								"deco": "k",
								"default": "2u"
							}
						],
						"endline": 939,
						"originalType": "const string[](uint indent = 2)",
						"char": 27,
						"kind": "function",
						"overrides": [
							"std.xml.Item.pretty"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "toString",
						"line": 950,
						"comment": " Returns the string representation of an Element\n\n Example:\n --------------\n auto element = new Element(\"br\");\n writefln(element.toString()); // writes \"<br />\"\n --------------\n",
						"deco": "xFZAya",
						"endline": 958,
						"char": 25,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "Element",
				"line": 662,
				"comment": " Class representing an XML element.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "TagType",
				"line": 972,
				"comment": " Tag types.\n\n $(DDOC_ENUM_MEMBERS START) Used for start tags\n $(DDOC_ENUM_MEMBERS END) Used for end tags\n $(DDOC_ENUM_MEMBERS EMPTY) Used for empty tags\n\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Tag",
				"line": 986,
				"comment": " Class representing an XML tag.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n The class invariant guarantees\n <ul>\n <li> that $(B type) is a valid enum TagType value</li>\n <li> that $(B name) consists of valid characters</li>\n <li> that each attribute name consists of valid characters</li>\n </ul>\n",
				"members": [
					{
						"offset": 16,
						"name": "type",
						"line": 988,
						"comment": "Type of tag\n",
						"deco": "E3std3xml7TagType",
						"init": "cast(TagType)0",
						"char": 13,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "name",
						"line": 989,
						"comment": "Tag name\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 40,
						"name": "attr",
						"line": 990,
						"comment": "Associative array of attributes\n",
						"deco": "HAyaAya",
						"char": 20,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1032,
						"comment": " Constructs an instance of Tag with a specified name and type\n\n The constructor does not initialize the attributes. To initialize the\n attributes, you access the $(B attr) member variable.\n\n Params:\n      name = the Tag's name\n      type = (optional) the Tag's type. If omitted, defaults to\n          TagType.START.\n\n Example:\n --------------\n auto tag = new Tag(\"img\",Tag.EMPTY);\n tag.attr[\"src\"] = \"http://example.com/example.jpg\";\n --------------\n",
						"deco": "FAyaE3std3xml7TagTypeZC3std3xml3Tag",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							},
							{
								"name": "type",
								"deco": "E3std3xml7TagType",
								"default": "cast(TagType)0"
							}
						],
						"endline": 1036,
						"originalType": "(string name, TagType type = TagType.START)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 9,
						"name": "opEquals",
						"line": 1098,
						"comment": " Compares two Tags for equality\n\n You should rarely need to call this function. It exists so that Tags\n can be used as associative array keys.\n\n Example:\n --------------\n Tag tag1,tag2\n if (tag1 == tag2) { }\n --------------\n",
						"deco": "xFC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1106,
						"char": 23,
						"kind": "function",
						"overrides": [
							"object.Object.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "opCmp",
						"line": 1117,
						"comment": " Compares two Tags\n\n Example:\n --------------\n Tag tag1,tag2\n if (tag1 < tag2) { }\n --------------\n",
						"deco": "xFC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1126,
						"char": 22,
						"kind": "function",
						"overrides": [
							"object.Object.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "toHash",
						"line": 1134,
						"comment": " Returns the hash of a Tag\n\n You should rarely need to call this function. It exists so that Tags\n can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1137,
						"originalType": "const size_t()",
						"char": 25,
						"kind": "function",
						"overrides": [
							"object.Object.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "toString",
						"line": 1148,
						"comment": " Returns the string representation of a Tag\n\n Example:\n --------------\n auto tag = new Tag(\"book\",TagType.START);\n writefln(tag.toString()); // writes \"<book>\"\n --------------\n",
						"deco": "xFZAya",
						"endline": 1152,
						"char": 25,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 66,
						"name": "isStart",
						"line": 1179,
						"comment": " Returns true if the Tag is a start tag\n\n Example:\n --------------\n if (tag.isStart) { }\n --------------\n",
						"deco": "xFNdZb",
						"endline": 1179,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 66,
						"name": "isEnd",
						"line": 1189,
						"comment": " Returns true if the Tag is an end tag\n\n Example:\n --------------\n if (tag.isEnd) { }\n --------------\n",
						"deco": "xFNdZb",
						"endline": 1189,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 66,
						"name": "isEmpty",
						"line": 1199,
						"comment": " Returns true if the Tag is an empty tag\n\n Example:\n --------------\n if (tag.isEmpty) { }\n --------------\n",
						"deco": "xFNdZb",
						"endline": 1199,
						"char": 24,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1225,
						"comment": " Construct a comment\n\n Params:\n      content = the body of the comment\n\n Throws: CommentException if the comment body is illegal (contains \"--\"\n or exactly equals \"-\")\n\n Example:\n --------------\n auto item = new Comment(\"This is a comment\");\n    // constructs <!--This is a comment-->\n --------------\n",
						"deco": "FAyaZC3std3xml7Comment",
						"parameters": [
							{
								"name": "content",
								"deco": "Aya"
							}
						],
						"endline": 1230,
						"originalType": "(string content)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1241,
						"comment": " Compares two comments for equality\n\n Example:\n --------------\n Comment item1,item2;\n if (item1 == item2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1246,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1260,
						"comment": " Compares two comments\n\n You should rarely need to call this function. It exists so that Comments\n can be used as associative array keys.\n\n Example:\n --------------\n Comment item1,item2;\n if (item1 < item2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1266,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 60,
						"name": "toHash",
						"line": 1274,
						"comment": " Returns the hash of a Comment\n\n You should rarely need to call this function. It exists so that Comments\n can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1274,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 73,
						"name": "toString",
						"line": 1279,
						"comment": " Returns a string representation of this comment\n",
						"deco": "xFZAya",
						"endline": 1279,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 64,
						"name": "isEmptyXML",
						"line": 1281,
						"comment": "Returns false always\n",
						"deco": "xFNdZb",
						"endline": 1281,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.xml.Item.isEmptyXML"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "Comment",
				"line": 1206,
				"comment": " Class representing a comment\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1305,
						"comment": " Construct a character data section\n\n Params:\n      content = the body of the character data segment\n\n Throws: CDataException if the segment body is illegal (contains \"]]>\")\n\n Example:\n --------------\n auto item = new CData(\"<b>hello</b>\");\n    // constructs <![CDATA[<b>hello</b>]]>\n --------------\n",
						"deco": "FAyaZC3std3xml5CData",
						"parameters": [
							{
								"name": "content",
								"deco": "Aya"
							}
						],
						"endline": 1309,
						"originalType": "(string content)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1320,
						"comment": " Compares two CDatas for equality\n\n Example:\n --------------\n CData item1,item2;\n if (item1 == item2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1325,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1339,
						"comment": " Compares two CDatas\n\n You should rarely need to call this function. It exists so that CDatas\n can be used as associative array keys.\n\n Example:\n --------------\n CData item1,item2;\n if (item1 < item2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1345,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 60,
						"name": "toHash",
						"line": 1353,
						"comment": " Returns the hash of a CData\n\n You should rarely need to call this function. It exists so that CDatas\n can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1353,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 72,
						"name": "toString",
						"line": 1358,
						"comment": " Returns a string representation of this CData section\n",
						"deco": "xFZAya",
						"endline": 1358,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 64,
						"name": "isEmptyXML",
						"line": 1360,
						"comment": "Returns false always\n",
						"deco": "xFNdZb",
						"endline": 1360,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.xml.Item.isEmptyXML"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "CData",
				"line": 1287,
				"comment": " Class representing a Character Data section\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1383,
						"comment": " Construct a text (aka PCData) section\n\n Params:\n      content = the text. This function encodes the text before\n      insertion, so it is safe to insert any text\n\n Example:\n --------------\n auto Text = new CData(\"a < b\");\n    // constructs a &lt; b\n --------------\n",
						"deco": "FAyaZC3std3xml4Text",
						"parameters": [
							{
								"name": "content",
								"deco": "Aya"
							}
						],
						"endline": 1386,
						"originalType": "(string content)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1397,
						"comment": " Compares two text sections for equality\n\n Example:\n --------------\n Text item1,item2;\n if (item1 == item2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1402,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1416,
						"comment": " Compares two text sections\n\n You should rarely need to call this function. It exists so that Texts\n can be used as associative array keys.\n\n Example:\n --------------\n Text item1,item2;\n if (item1 < item2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1422,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 60,
						"name": "toHash",
						"line": 1430,
						"comment": " Returns the hash of a text section\n\n You should rarely need to call this function. It exists so that Texts\n can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1430,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 56,
						"name": "toString",
						"line": 1435,
						"comment": " Returns a string representation of this Text section\n",
						"deco": "xFZAya",
						"endline": 1435,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 78,
						"name": "isEmptyXML",
						"line": 1440,
						"comment": " Returns true if the content is the empty string\n",
						"deco": "xFNdZb",
						"endline": 1440,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.xml.Item.isEmptyXML"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "Text",
				"line": 1366,
				"comment": " Class representing a text (aka Parsed Character Data) section\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1464,
						"comment": " Construct an XML Instruction section\n\n Params:\n      content = the body of the instruction segment\n\n Throws: XIException if the segment body is illegal (contains \">\")\n\n Example:\n --------------\n auto item = new XMLInstruction(\"ATTLIST\");\n    // constructs <!ATTLIST>\n --------------\n",
						"deco": "FAyaZC3std3xml14XMLInstruction",
						"parameters": [
							{
								"name": "content",
								"deco": "Aya"
							}
						],
						"endline": 1468,
						"originalType": "(string content)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1479,
						"comment": " Compares two XML instructions for equality\n\n Example:\n --------------\n XMLInstruction item1,item2;\n if (item1 == item2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1484,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1498,
						"comment": " Compares two XML instructions\n\n You should rarely need to call this function. It exists so that\n XmlInstructions can be used as associative array keys.\n\n Example:\n --------------\n XMLInstruction item1,item2;\n if (item1 < item2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1504,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 60,
						"name": "toHash",
						"line": 1512,
						"comment": " Returns the hash of an XMLInstruction\n\n You should rarely need to call this function. It exists so that\n XmlInstructions can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1512,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 69,
						"name": "toString",
						"line": 1517,
						"comment": " Returns a string representation of this XmlInstruction\n",
						"deco": "xFZAya",
						"endline": 1517,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 64,
						"name": "isEmptyXML",
						"line": 1519,
						"comment": "Returns false always\n",
						"deco": "xFNdZb",
						"endline": 1519,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.xml.Item.isEmptyXML"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "XMLInstruction",
				"line": 1446,
				"comment": " Class representing an XML Instruction section\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1543,
						"comment": " Construct a Processing Instruction section\n\n Params:\n      content = the body of the instruction segment\n\n Throws: PIException if the segment body is illegal (contains \"?>\")\n\n Example:\n --------------\n auto item = new ProcessingInstruction(\"php\");\n    // constructs <?php?>\n --------------\n",
						"deco": "FAyaZC3std3xml21ProcessingInstruction",
						"parameters": [
							{
								"name": "content",
								"deco": "Aya"
							}
						],
						"endline": 1547,
						"originalType": "(string content)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1558,
						"comment": " Compares two processing instructions for equality\n\n Example:\n --------------\n ProcessingInstruction item1,item2;\n if (item1 == item2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1563,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1577,
						"comment": " Compares two processing instructions\n\n You should rarely need to call this function. It exists so that\n ProcessingInstructions can be used as associative array keys.\n\n Example:\n --------------\n ProcessingInstruction item1,item2;\n if (item1 < item2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1583,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 60,
						"name": "toHash",
						"line": 1591,
						"comment": " Returns the hash of a ProcessingInstruction\n\n You should rarely need to call this function. It exists so that\n ProcessingInstructions can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1591,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 70,
						"name": "toString",
						"line": 1596,
						"comment": " Returns a string representation of this ProcessingInstruction\n",
						"deco": "xFZAya",
						"endline": 1596,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 64,
						"name": "isEmptyXML",
						"line": 1598,
						"comment": "Returns false always\n",
						"deco": "xFNdZb",
						"endline": 1598,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.xml.Item.isEmptyXML"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "ProcessingInstruction",
				"line": 1525,
				"comment": " Class representing a Processing Instruction section\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Item",
				"line": 1604,
				"comment": " Abstract base class for XML items\n",
				"members": [
					{
						"name": "opEquals",
						"line": 1607,
						"comment": "Compares with another Item of same type for equality\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"char": 28,
						"kind": "function",
						"overrides": [
							"object.Object.opEquals"
						],
						"storageClass": [
							"abstract",
							"override"
						]
					},
					{
						"name": "opCmp",
						"line": 1610,
						"comment": "Compares with another Item of same type\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"char": 27,
						"kind": "function",
						"overrides": [
							"object.Object.opCmp"
						],
						"storageClass": [
							"abstract",
							"override"
						]
					},
					{
						"name": "toHash",
						"line": 1613,
						"comment": "Returns the hash of this item\n",
						"deco": "xFNbNfZm",
						"originalType": "const size_t()",
						"char": 30,
						"kind": "function",
						"overrides": [
							"object.Object.toHash"
						],
						"storageClass": [
							"abstract",
							"override"
						]
					},
					{
						"name": "toString",
						"line": 1616,
						"comment": "Returns a string representation of this item\n",
						"deco": "xFZAya",
						"char": 30,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"abstract",
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "pretty",
						"line": 1624,
						"comment": " Returns an indented string representation of this item\n\n Params:\n      indent = number of spaces by which to indent child elements\n",
						"deco": "xFkZAAya",
						"parameters": [
							{
								"name": "indent",
								"deco": "k"
							}
						],
						"endline": 1628,
						"char": 14,
						"kind": "function"
					},
					{
						"name": "isEmptyXML",
						"line": 1631,
						"comment": "Returns true if the item represents empty XML text\n",
						"deco": "xFNdZb",
						"char": 29,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					}
				],
				"char": 10,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1662,
						"comment": " Constructs a DocumentParser.\n\n The input to this function MUST be valid XML.\n This is enforced by the function's in contract.\n\n Params:\n      xmlText_ = the entire XML document as text\n\n",
						"deco": "FAyaZC3std3xml14DocumentParser",
						"parameters": [
							{
								"name": "xmlText_",
								"deco": "Aya"
							}
						],
						"endline": 1683,
						"originalType": "(string xmlText_)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "DocumentParser",
				"line": 1648,
				"comment": " Class for parsing an XML Document.\n\n This is a subclass of ElementParser. Most of the useful functions are\n documented there.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Bugs:\n      Currently only supports UTF documents.\n\n      If there is an encoding attribute in the prolog, it is ignored.\n\n",
				"base": "std.xml.ElementParser",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "ElementParser",
				"line": 1697,
				"comment": " Class for parsing an XML element.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Note that you cannot construct instances of this class directly. You can\n construct a DocumentParser (which is a subclass of ElementParser), but\n otherwise, Instances of ElementParser will be created for you by the\n library, and passed your way via onStartTag handlers.\n\n",
				"members": [
					{
						"endchar": 53,
						"name": "tag",
						"line": 1737,
						"comment": " The Tag at the start of the element being parsed. You can read this to\n determine the tag's name and attributes.\n",
						"deco": "xFNdZxC3std3xml3Tag",
						"endline": 1737,
						"char": 26,
						"kind": "function"
					},
					{
						"offset": 144,
						"name": "onStartTag",
						"line": 1773,
						"comment": " Register a handler which will be called whenever a start tag is\n encountered which matches the specified name. You can also pass null as\n the name, in which case the handler will be called for any unmatched\n start tag.\n\n Example:\n --------------\n // Call this function whenever a <podcast> start tag is encountered\n onStartTag[\"podcast\"] = (ElementParser xml)\n {\n     // Your code here\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n\n // call myEpisodeStartHandler (defined elsewhere) whenever an <episode>\n // start tag is encountered\n onStartTag[\"episode\"] = &myEpisodeStartHandler;\n\n // call delegate dg for all other start tags\n onStartTag[null] = dg;\n --------------\n\n This library will supply your function with a new instance of\n ElementHandler, which may be used to parse inside the element whose\n start tag was just found, or to identify the tag attributes of the\n element, etc.\n\n Note that your function will be called for both start tags and empty\n tags. That is, we make no distinction between &lt;br&gt;&lt;/br&gt;\n and &lt;br/&gt;.\n",
						"deco": "HAyaDFC3std3xml13ElementParserZv",
						"originalType": "ParserHandler[string]",
						"char": 27,
						"kind": "variable"
					},
					{
						"offset": 152,
						"name": "onEndTag",
						"line": 1804,
						"comment": " Register a handler which will be called whenever an end tag is\n encountered which matches the specified name. You can also pass null as\n the name, in which case the handler will be called for any unmatched\n end tag.\n\n Example:\n --------------\n // Call this function whenever a </podcast> end tag is encountered\n onEndTag[\"podcast\"] = (in Element e)\n {\n     // Your code here\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n\n // call myEpisodeEndHandler (defined elsewhere) whenever an </episode>\n // end tag is encountered\n onEndTag[\"episode\"] = &myEpisodeEndHandler;\n\n // call delegate dg for all other end tags\n onEndTag[null] = dg;\n --------------\n\n Note that your function will be called for both start tags and empty\n tags. That is, we make no distinction between &lt;br&gt;&lt;/br&gt;\n and &lt;br/&gt;.\n",
						"deco": "HAyaDFxC3std3xml7ElementZv",
						"originalType": "ElementHandler[string]",
						"char": 28,
						"kind": "variable"
					},
					{
						"endchar": 69,
						"name": "onText",
						"line": 1829,
						"comment": " Register a handler which will be called whenever text is encountered.\n\n Example:\n --------------\n // Call this function whenever text is encountered\n onText = (string s)\n {\n     // Your code here\n\n     // The passed parameter s will have been decoded by the time you see\n     // it, and so may contain any character.\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FNdDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1829,
						"originalType": "@property void(Handler handler)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 65,
						"name": "onTextRaw",
						"line": 1855,
						"comment": " Register an alternative handler which will be called whenever text\n is encountered. This differs from onText in that onText will decode\n the text, whereas onTextRaw will not. This allows you to make design\n choices, since onText will be more accurate, but slower, while\n onTextRaw will be faster, but less accurate. Of course, you can\n still call decode() within your handler, if you want, but you'd\n probably want to use onTextRaw only in circumstances where you\n know that decoding is unnecessary.\n\n Example:\n --------------\n // Call this function whenever text is encountered\n onText = (string s)\n {\n     // Your code here\n\n     // The passed parameter s will NOT have been decoded.\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1855,
						"originalType": "void(Handler handler)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 71,
						"name": "onCData",
						"line": 1876,
						"comment": " Register a handler which will be called whenever a character data\n segment is encountered.\n\n Example:\n --------------\n // Call this function whenever a CData section is encountered\n onCData = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <![CDATA[\n     // nor closing ]]>\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FNdDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1876,
						"originalType": "@property void(Handler handler)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 75,
						"name": "onComment",
						"line": 1897,
						"comment": " Register a handler which will be called whenever a comment is\n encountered.\n\n Example:\n --------------\n // Call this function whenever a comment is encountered\n onComment = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <!-- nor\n     // closing -->\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FNdDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1897,
						"originalType": "@property void(Handler handler)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 65,
						"name": "onPI",
						"line": 1918,
						"comment": " Register a handler which will be called whenever a processing\n instruction is encountered.\n\n Example:\n --------------\n // Call this function whenever a processing instruction is encountered\n onPI = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <? nor\n     // closing ?>\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FNdDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1918,
						"originalType": "@property void(Handler handler)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 65,
						"name": "onXI",
						"line": 1941,
						"comment": " Register a handler which will be called whenever an XML instruction is\n encountered.\n\n Example:\n --------------\n // Call this function whenever an XML instruction is encountered\n // (Note: XML instructions may only occur preceding the root tag of a\n // document).\n onPI = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <! nor\n     // closing >\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FNdDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1941,
						"originalType": "@property void(Handler handler)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "parse",
						"line": 1952,
						"comment": " Parse an XML element.\n\n Parsing will continue until the end of the current element. Any items\n encountered for which a handler has been registered will invoke that\n handler.\n\n Throws: various kinds of XMLException\n",
						"deco": "FZv",
						"endline": 2073,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 2078,
						"comment": " Returns that part of the element which has already been parsed\n",
						"deco": "xFZAya",
						"endline": 2082,
						"char": 21,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "check",
				"line": 2631,
				"comment": " Check an entire XML document for well-formedness\n\n Params:\n      s = the document to be checked, passed as a string\n\n Throws: CheckException if the document is not well formed\n\n CheckException's toString() method will yield the complete hierarchy of\n parse failure (the XML equivalent of a stack trace), giving the line and\n column number of every failure at every level.\n",
				"deco": "FAyaZv",
				"parameters": [
					{
						"name": "s",
						"deco": "Aya"
					}
				],
				"endline": 2644,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [],
				"name": "XMLException",
				"line": 2743,
				"comment": " The base class for exceptions thrown by this module\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "CommentException",
				"line": 2748,
				"comment": "Thrown during Comment constructor\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "CDataException",
				"line": 2752,
				"comment": "Thrown during CData constructor\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "XIException",
				"line": 2756,
				"comment": "Thrown during XMLInstruction constructor\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "PIException",
				"line": 2760,
				"comment": "Thrown during ProcessingInstruction constructor\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "TextException",
				"line": 2764,
				"comment": "Thrown during Text constructor\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "DecodeException",
				"line": 2768,
				"comment": "Thrown during decode()\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "InvalidTypeException",
				"line": 2772,
				"comment": "Thrown if comparing with wrong type\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "TagException",
				"line": 2776,
				"comment": "Thrown when parsing for Tags\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "err",
						"line": 2784,
						"comment": "Parent in hierarchy\n",
						"deco": "C3std3xml14CheckException",
						"originalType": "CheckException",
						"char": 20,
						"kind": "variable"
					},
					{
						"offset": 96,
						"name": "msg",
						"line": 2790,
						"comment": " Name of production rule which failed to parse,\n or specific error message\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 112,
						"name": "line",
						"line": 2791,
						"comment": "Line number at which parse failure occurred\n",
						"deco": "m",
						"originalType": "size_t",
						"init": "0LU",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 120,
						"name": "column",
						"line": 2792,
						"comment": "Column number at which parse failure occurred\n",
						"deco": "m",
						"originalType": "size_t",
						"init": "0LU",
						"char": 12,
						"kind": "variable"
					}
				],
				"name": "CheckException",
				"line": 2782,
				"comment": " Thrown during check()\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": "$(RED Warning: This module is considered out-dated and not up to Phobos'\n      current standards. It will remain until we have a suitable replacement,\n      but be aware that it will not remain long term.)\n\nClasses and functions for creating and parsing XML\n\nThe basic architecture of this module is that there are standalone functions,\nclasses for constructing an XML document from scratch (Tag, Element and\nDocument), and also classes for parsing a pre-existing XML file (ElementParser\nand DocumentParser). The parsing classes <i>may</i> be used to build a\nDocument, but that is not their primary purpose. The handling capabilities of\nDocumentParser and ElementParser are sufficiently customizable that you can\nmake them do pretty much whatever you want.\n\nExample: This example creates a DOM (Document Object Model) tree\n    from an XML file.\n------------------------------------------------------------------------------\nimport std.xml;\nimport std.stdio;\nimport std.string;\nimport std.file;\n\n// books.xml is used in various samples throughout the Microsoft XML Core\n// Services (MSXML) SDK.\n//\n// See http://msdn2.microsoft.com/en-us/library/ms762271(VS.85).aspx\n\nvoid main()\n{\n    string s = cast(string)std.file.read(\"books.xml\");\n\n    // Check for well-formedness\n    check(s);\n\n    // Make a DOM tree\n    auto doc = new Document(s);\n\n    // Plain-print it\n    writeln(doc);\n}\n------------------------------------------------------------------------------\n\nExample: This example does much the same thing, except that the file is\n    deconstructed and reconstructed by hand. This is more work, but the\n    techniques involved offer vastly more power.\n------------------------------------------------------------------------------\nimport std.xml;\nimport std.stdio;\nimport std.string;\n\nstruct Book\n{\n    string id;\n    string author;\n    string title;\n    string genre;\n    string price;\n    string pubDate;\n    string description;\n}\n\nvoid main()\n{\n    string s = cast(string)std.file.read(\"books.xml\");\n\n    // Check for well-formedness\n    check(s);\n\n    // Take it apart\n    Book[] books;\n\n    auto xml = new DocumentParser(s);\n    xml.onStartTag[\"book\"] = (ElementParser xml)\n    {\n        Book book;\n        book.id = xml.tag.attr[\"id\"];\n\n        xml.onEndTag[\"author\"]       = (in Element e) { book.author      = e.text(); };\n        xml.onEndTag[\"title\"]        = (in Element e) { book.title       = e.text(); };\n        xml.onEndTag[\"genre\"]        = (in Element e) { book.genre       = e.text(); };\n        xml.onEndTag[\"price\"]        = (in Element e) { book.price       = e.text(); };\n        xml.onEndTag[\"publish-date\"] = (in Element e) { book.pubDate     = e.text(); };\n        xml.onEndTag[\"description\"]  = (in Element e) { book.description = e.text(); };\n\n        xml.parse();\n\n        books ~= book;\n    };\n    xml.parse();\n\n    // Put it back together again;\n    auto doc = new Document(new Tag(\"catalog\"));\n    foreach(book;books)\n    {\n        auto element = new Element(\"book\");\n        element.tag.attr[\"id\"] = book.id;\n\n        element ~= new Element(\"author\",      book.author);\n        element ~= new Element(\"title\",       book.title);\n        element ~= new Element(\"genre\",       book.genre);\n        element ~= new Element(\"price\",       book.price);\n        element ~= new Element(\"publish-date\",book.pubDate);\n        element ~= new Element(\"description\", book.description);\n\n        doc ~= element;\n    }\n\n    // Pretty-print it\n    writefln(join(doc.pretty(3),\"\\n\"));\n}\n-------------------------------------------------------------------------------\nMacros:\n    WIKI=Phobos/StdXml\n\nCopyright: Copyright Janice Caron 2008 - 2009.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   Janice Caron\nSource:    $(PHOBOSSRC std/_xml.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/stdiobase.d",
		"name": "std.stdiobase",
		"members": [],
		"comment": " The only purpose of this module is to do the static construction for\n std.stdio, to eliminate cyclic construction errors.\n\n Copyright: Copyright Andrei Alexandrescu 2008 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB erdani.org, Andrei Alexandrescu)\n Source:    $(PHOBOSSRC std/_stdiobase.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/utf.d",
		"name": "std.utf",
		"members": [
			{
				"members": [],
				"name": "UTFException",
				"line": 36,
				"comment": "    Exception thrown on errors in std.utf functions.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "isValidDchar",
				"line": 205,
				"comment": "    Check whether the given Unicode code point is valid.\n\n    Params:\n        c = code point to check\n\n    Returns:\n        $(D true) iff $(D c) is a valid Unicode code point\n\n    Note:\n    $(D '\\uFFFE') and $(D '\\uFFFF') are considered valid by $(D isValidDchar),\n    as they are permitted for internal use by an application, but they are\n    not allowed for interchange by the Unicode standard.\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 215,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 264,
						"type": "uint(auto ref S str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 276,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 264,
				"comment": "    Calculate the length of the UTF sequence starting at $(D index)\n    in $(D str).\n\n    Params:\n        str = input range of UTF code units. Must be random access if\n        $(D index) is passed\n        index = starting index of UTF sequence (default: $(D 0))\n\n    Returns:\n        The number of code units in the UTF sequence. For UTF-8, this is a\n        value between 1 and 4 (as per $(WEB tools.ietf.org/html/rfc3629#section-3, RFC 3629$(COMMA) section 3)).\n        For UTF-16, it is either 1 or 2. For UTF-32, it is always 1.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not the start of a\n        valid UTF sequence.\n\n    Note:\n        $(D stride) will only analyze the first $(D str[index]) element. It\n        will not fully verify the validity of the UTF sequence, nor even verify\n        the presence of the sequence: it will not actually guarantee that\n        $(D index + stride(str, index) <= str.length).\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(char[])) || isRandomAccessRange!S && is(Unqual!(ElementType!S) == char)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 279,
						"type": "uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 292,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 279,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(char[])) || isInputRange!S && is(Unqual!(ElementType!S) == char)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 387,
						"type": "uint(auto ref S str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 395,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 387,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(wchar[])) || isRandomAccessRange!S && is(Unqual!(ElementType!S) == wchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 398,
						"type": "pure @safe uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 402,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 398,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(wchar[]))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 405,
						"type": "uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 411,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 405,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!S && is(Unqual!(ElementType!S) == wchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 481,
						"type": "uint(auto ref S str, size_t index = 0)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t",
								"default": "0"
							}
						],
						"endline": 490,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 481,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(dchar[])) || isInputRange!S && is(Unqual!(ElementEncodingType!S) == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 583,
						"type": "uint(auto ref S str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 611,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 583,
				"comment": "    Calculate the length of the UTF sequence ending one code unit before\n    $(D index) in $(D str).\n\n    Params:\n        str = bidirectional range of UTF code units. Must be random access if\n        $(D index) is passed\n        index = index one past end of UTF sequence (default: $(D str.length))\n\n    Returns:\n        The number of code units in the UTF sequence. For UTF-8, this is a\n        value between 1 and 4 (as per $(WEB tools.ietf.org/html/rfc3629#section-3, RFC 3629$(COMMA) section 3)).\n        For UTF-16, it is either 1 or 2. For UTF-32, it is always 1.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not one past the\n        end of a valid UTF sequence.\n\n    Note:\n        $(D strideBack) will only analyze the element at $(D str[index - 1])\n        element. It will not fully verify the validity of the UTF sequence, nor\n        even verify the presence of the sequence: it will not actually\n        guarantee that $(D strideBack(str, index) <= index).\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(char[])) || isRandomAccessRange!S && is(Unqual!(ElementType!S) == char)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 614,
						"type": "uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 619,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 614,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(char[])) || isRandomAccessRange!S && hasLength!S && is(Unqual!(ElementType!S) == char)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 622,
						"type": "uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 636,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 622,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!S && is(Unqual!(ElementType!S) == char) && !isRandomAccessRange!S",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 708,
						"type": "uint(auto ref S str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 718,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 708,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(wchar[])) || isRandomAccessRange!S && is(Unqual!(ElementType!S) == wchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 721,
						"type": "uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 733,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 721,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(wchar[])) || isBidirectionalRange!S && is(Unqual!(ElementType!S) == wchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 803,
						"type": "uint(auto ref S str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 810,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 803,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!S && is(Unqual!(ElementEncodingType!S) == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 813,
						"type": "uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 818,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 813,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!S && is(Unqual!(ElementEncodingType!S) == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUCSindex",
						"line": 895,
						"type": "pure @safe size_t(const(C)[] str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "const(C)[]"
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 918,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "toUCSindex",
				"line": 895,
				"comment": "    Given $(D index) into $(D str) and assuming that $(D index) is at the start\n    of a UTF sequence, $(D toUCSindex) determines the number of UCS characters\n    up to $(D index). So, $(D index) is the index of a code unit at the\n    beginning of a code point, and the return value is how many code points into\n    the string that that code point is.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL921_2084)\n---\nassert(toUCSindex(`hello world`, 7) == 7);\nassert(toUCSindex(`hello world`w, 7) == 7);\nassert(toUCSindex(`hello world`d, 7) == 7);\n\nassert(toUCSindex(`Ma Chérie`, 7) == 6);\nassert(toUCSindex(`Ma Chérie`w, 7) == 7);\nassert(toUCSindex(`Ma Chérie`d, 7) == 7);\n\nassert(toUCSindex(`さいごの果実 / ミツバチと科学者`, 9) == 3);\nassert(toUCSindex(`さいごの果実 / ミツバチと科学者`w, 9) == 9);\nassert(toUCSindex(`さいごの果実 / ミツバチと科学者`d, 9) == 9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL921_2084)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUTFindex",
						"line": 942,
						"type": "pure @safe size_t(const(C)[] str, size_t n)",
						"parameters": [
							{
								"name": "str",
								"type": "const(C)[]"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 958,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "toUTFindex",
				"line": 942,
				"comment": "    Given a UCS index $(D n) into $(D str), returns the UTF index.\n    So, $(D n) is how many code points into the string the code point is, and\n    the array index of the code unit is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL961_2085)\n---\nassert(toUTFindex(`hello world`, 7) == 7);\nassert(toUTFindex(`hello world`w, 7) == 7);\nassert(toUTFindex(`hello world`d, 7) == 7);\n\nassert(toUTFindex(`Ma Chérie`, 6) == 7);\nassert(toUTFindex(`Ma Chérie`w, 7) == 7);\nassert(toUTFindex(`Ma Chérie`d, 7) == 7);\n\nassert(toUTFindex(`さいごの果実 / ミツバチと科学者`, 3) == 9);\nassert(toUTFindex(`さいごの果実 / ミツバチと科学者`w, 9) == 9);\nassert(toUTFindex(`さいごの果実 / ミツバチと科学者`d, 9) == 9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL961_2085)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 8,
				"kind": "template"
			},
			{
				"name": "UseReplacementDchar",
				"line": 980,
				"comment": "Whether or not to replace invalid UTF with $(LREF replacementDchar)\n",
				"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decode",
						"line": 1004,
						"type": "dchar(auto ref S str, ref size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1021,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "decode",
				"line": 1004,
				"comment": "    Decodes and returns the code point starting at $(D str[index]). $(D index)\n    is advanced to one past the decoded code point. If the code point is not\n    well-formed, then a $(D UTFException) is thrown and $(D index) remains\n    unchanged.\n\n    decode will only work with strings and random access ranges of code units\n    with length and slicing, whereas $(LREF decodeFront) will work with any\n    input range of code units.\n\n    Params:\n        useReplacementDchar = if invalid UTF, return replacementDchar rather than throwing\n        str = input string or indexable Range\n        index = starting index into s[]; incremented by number of code units processed\n\n    Returns:\n        decoded character\n\n    Throws:\n        $(LREF UTFException) if $(D str[index]) is not the start of a valid UTF\n        sequence and useReplacementDchar is UseReplacementDchar.no\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "UseReplacementDchar.no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isSomeString!S && isRandomAccessRange!S && hasSlicing!S && hasLength!S && isSomeChar!(ElementType!S)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decodeFront",
						"line": 1064,
						"type": "dchar(ref S str, out size_t numCodeUnits)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "numCodeUnits",
								"type": "size_t",
								"storageClass": [
									"out"
								]
							}
						],
						"endline": 1098,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "decodeFront",
				"line": 1064,
				"comment": "    $(D decodeFront) is a variant of $(LREF decode) which specifically decodes\n    the first code point. Unlike $(LREF decode), $(D decodeFront) accepts any\n    input range of code units (rather than just a string or random access\n    range). It also takes the range by $(D ref) and pops off the elements as it\n    decodes them. If $(D numCodeUnits) is passed in, it gets set to the number\n    of code units which were in the code point which was decoded.\n\n    Params:\n        useReplacementDchar = if invalid UTF, return replacementDchar rather than throwing\n        str = input string or indexable Range\n        numCodeUnits = set to number of code units processed\n\n    Returns:\n        decoded character\n\n    Throws:\n        $(LREF UTFException) if $(D str.front) is not the start of a valid UTF\n        sequence. If an exception is thrown, then there is no guarantee as to\n        the number of code units which were popped off, as it depends on the\n        type of range being used and how many code units had to be popped off\n        before the code point was determined to be invalid.\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "UseReplacementDchar.no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isSomeString!S && isInputRange!S && isSomeChar!(ElementType!S)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decodeFront",
						"line": 1128,
						"type": "dchar(ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1133,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "decodeFront",
				"line": 1128,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "UseReplacementDchar.no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!S && isSomeChar!(ElementType!S)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 1863,
						"type": "pure @safe size_t(ref char[4] buf, dchar c)",
						"parameters": [
							{
								"name": "buf",
								"type": "char[4]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 1904,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 1863,
				"comment": "    Encodes $(D c) into the static array, $(D buf), and returns the actual\n    length of the encoded character (a number between $(D 1) and $(D 4) for\n    $(D char[4]) buffers and a number between $(D 1) and $(D 2) for\n    $(D wchar[2]) buffers).\n\n    Throws:\n        $(D UTFException) if $(D c) is not a valid UTF code point.\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "UseReplacementDchar.no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 1938,
						"type": "pure @safe size_t(ref wchar[2] buf, dchar c)",
						"parameters": [
							{
								"name": "buf",
								"type": "wchar[2]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 1961,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 1938,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "UseReplacementDchar.no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 1991,
						"type": "pure @safe size_t(ref dchar[1] buf, dchar c)",
						"parameters": [
							{
								"name": "buf",
								"type": "dchar[1]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 2000,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 1991,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "UseReplacementDchar.no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 2034,
						"type": "pure @safe void(ref char[] str, dchar c)",
						"parameters": [
							{
								"name": "str",
								"type": "char[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 2086,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 2034,
				"comment": "    Encodes $(D c) in $(D str)'s encoding and appends it to $(D str).\n\n    Throws:\n        $(D UTFException) if $(D c) is not a valid UTF code point.\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "UseReplacementDchar.no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 2143,
						"type": "pure @safe void(ref wchar[] str, dchar c)",
						"parameters": [
							{
								"name": "str",
								"type": "wchar[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 2174,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 2143,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "UseReplacementDchar.no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 2204,
						"type": "pure @safe void(ref dchar[] str, dchar c)",
						"parameters": [
							{
								"name": "str",
								"type": "dchar[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 2212,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 2204,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "UseReplacementDchar.no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "codeLength",
						"line": 2245,
						"type": "pure nothrow @nogc @safe ubyte(dchar c)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 2265,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "codeLength",
				"line": 2245,
				"comment": "    Returns the number of code units that are required to encode the code point\n    $(D c) when $(D C) is the character type used to encode it.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2268_2101)\n---\nassert(codeLength!char('a') == 1);\nassert(codeLength!wchar('a') == 1);\nassert(codeLength!dchar('a') == 1);\n\nassert(codeLength!char('\\U0010FFFF') == 4);\nassert(codeLength!wchar('\\U0010FFFF') == 2);\nassert(codeLength!dchar('\\U0010FFFF') == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2268_2101)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "codeLength",
						"line": 2286,
						"type": "size_t(InputRange input)",
						"parameters": [
							{
								"name": "input",
								"type": "InputRange"
							}
						],
						"endline": 2301,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "codeLength",
				"line": 2286,
				"comment": "    Returns the number of code units that are required to encode $(D str)\n    in a string whose character type is $(D C). This is particularly useful\n    when slicing one string with the length of another and the two string\n    types use different character types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2304_2102)\n---\nimport std.conv : to;\nassert(codeLength!char(\"hello world\") ==\n       to!string(\"hello world\").length);\nassert(codeLength!wchar(\"hello world\") ==\n       to!wstring(\"hello world\").length);\nassert(codeLength!dchar(\"hello world\") ==\n       to!dstring(\"hello world\").length);\n\nassert(codeLength!char(`プログラミング`) ==\n       to!string(`プログラミング`).length);\nassert(codeLength!wchar(`プログラミング`) ==\n       to!wstring(`プログラミング`).length);\nassert(codeLength!dchar(`プログラミング`) ==\n       to!dstring(`プログラミング`).length);\n\nstring haystack = `Être sans la verité, ça, ce ne serait pas bien.`;\nwstring needle = `Être sans la verité`;\nassert(haystack[codeLength!char(needle) .. $] ==\n       `, ça, ce ne serait pas bien.`);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2304_2102)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "InputRange",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!InputRange && is(ElementType!InputRange : dchar)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "validate",
						"line": 2400,
						"type": "pure @safe void(in S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 2408,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "validate",
				"line": 2400,
				"comment": "    Checks to see if $(D str) is well-formed unicode or not.\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "toUTF8",
				"line": 2466,
				"comment": " Encodes string $(D_PARAM s) into UTF-8 and returns the encoded string.\n",
				"deco": "FNaNfxAaZAya",
				"parameters": [
					{
						"name": "s",
						"deco": "xAa"
					}
				],
				"endline": 2470,
				"originalType": "pure @safe string(in char[] s)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF8",
				"line": 2473,
				"comment": "ditto\n",
				"deco": "FNaNfxAuZAya",
				"parameters": [
					{
						"name": "s",
						"deco": "xAu"
					}
				],
				"endline": 2496,
				"originalType": "pure @safe string(in wchar[] s)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF8",
				"line": 2499,
				"comment": "ditto\n",
				"deco": "FNaNfxAwZAya",
				"parameters": [
					{
						"name": "s",
						"deco": "xAw"
					}
				],
				"endline": 2524,
				"originalType": "pure @safe string(in dchar[] s)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF16",
				"line": 2552,
				"comment": " Encodes string $(D s) into UTF-16 and returns the encoded string.\n",
				"deco": "FNaNfxAaZAyu",
				"parameters": [
					{
						"name": "s",
						"deco": "xAa"
					}
				],
				"endline": 2575,
				"originalType": "pure @safe wstring(in char[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF16",
				"line": 2578,
				"comment": "ditto\n",
				"deco": "FNaNfxAuZAyu",
				"parameters": [
					{
						"name": "s",
						"deco": "xAu"
					}
				],
				"endline": 2582,
				"originalType": "pure @safe wstring(in wchar[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF16",
				"line": 2585,
				"comment": "ditto\n",
				"deco": "FNaNfxAwZAyu",
				"parameters": [
					{
						"name": "s",
						"deco": "xAw"
					}
				],
				"endline": 2598,
				"originalType": "pure @safe wstring(in dchar[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF32",
				"line": 2606,
				"comment": " Encodes string $(D_PARAM s) into UTF-32 and returns the encoded string.\n",
				"deco": "FNaNfxAaZAyw",
				"parameters": [
					{
						"name": "s",
						"deco": "xAa"
					}
				],
				"endline": 2624,
				"originalType": "pure @safe dstring(in char[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF32",
				"line": 2627,
				"comment": "ditto\n",
				"deco": "FNaNfxAuZAyw",
				"parameters": [
					{
						"name": "s",
						"deco": "xAu"
					}
				],
				"endline": 2645,
				"originalType": "pure @safe dstring(in wchar[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF32",
				"line": 2648,
				"comment": "ditto\n",
				"deco": "FNaNfxAwZAyw",
				"parameters": [
					{
						"name": "s",
						"deco": "xAw"
					}
				],
				"endline": 2652,
				"originalType": "pure @safe dstring(in dchar[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "toUTFz",
								"line": 2698,
								"type": "pure @safe P(S str)",
								"parameters": [
									{
										"name": "str",
										"type": "S"
									}
								],
								"endline": 2701,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "toUTFz",
						"line": 2698,
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"char": 7,
						"kind": "template"
					}
				],
				"name": "toUTFz",
				"line": 2696,
				"comment": "    Returns a C-style zero-terminated string equivalent to $(D str). $(D str)\n    must not contain embedded $(D '\\0')'s as any C function will treat the first\n    $(D '\\0') that it sees as the end of the string. If $(D str.empty) is\n    $(D true), then a string containing only $(D '\\0') is returned.\n\n    $(D toUTFz) accepts any type of string and is templated on the type of\n    character pointer that you wish to convert to. It will avoid allocating a\n    new string if it can, but there's a decent chance that it will end up having\n    to allocate a new string - particularly when dealing with character types\n    other than $(D char).\n\n    $(RED Warning 1:) If the result of $(D toUTFz) equals $(D str.ptr), then if\n    anything alters the character one past the end of $(D str) (which is the\n    $(D '\\0') character terminating the string), then the string won't be\n    zero-terminated anymore. The most likely scenarios for that are if you\n    append to $(D str) and no reallocation takes place or when $(D str) is a\n    slice of a larger array, and you alter the character in the larger array\n    which is one character past the end of $(D str). Another case where it could\n    occur would be if you had a mutable character array immediately after\n    $(D str) in memory (for example, if they're member variables in a\n    user-defined type with one declared right after the other) and that\n    character array happened to start with $(D '\\0'). Such scenarios will never\n    occur if you immediately use the zero-terminated string after calling\n    $(D toUTFz) and the C function using it doesn't keep a reference to it.\n    Also, they are unlikely to occur even if you save the zero-terminated string\n    (the cases above would be among the few examples of where it could happen).\n    However, if you save the zero-terminate string and want to be absolutely\n    certain that the string stays zero-terminated, then simply append a\n    $(D '\\0') to the string and use its $(D ptr) property rather than calling\n    $(D toUTFz).\n\n    $(RED Warning 2:) When passing a character pointer to a C function, and the\n    C function keeps it around for any reason, make sure that you keep a\n    reference to it in your D code. Otherwise, it may go away during a garbage\n    collection cycle and cause a nasty bug when the C code tries to use it.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2705_2107)\n---\nauto p1 = toUTFz!(char*)(\"hello world\");\nauto p2 = toUTFz!(const(char)*)(\"hello world\");\nauto p3 = toUTFz!(immutable(char)*)(\"hello world\");\nauto p4 = toUTFz!(char*)(\"hello world\"d);\nauto p5 = toUTFz!(const(wchar)*)(\"hello world\");\nauto p6 = toUTFz!(immutable(dchar)*)(\"hello world\"w);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2705_2107)\n",
				"parameters": [
					{
						"name": "P",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUTF16z",
						"line": 2909,
						"type": "pure @safe const(wchar)*(const(C)[] str)",
						"parameters": [
							{
								"name": "str",
								"type": "const(C)[]"
							}
						],
						"endline": 2913,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "toUTF16z",
				"line": 2909,
				"comment": "    $(D toUTF16z) is a convenience function for $(D toUTFz!(const(wchar)*)).\n\n    Encodes string $(D s) into UTF-16 and returns the encoded string.\n    $(D toUTF16z) is suitable for calling the 'W' functions in the Win32 API\n    that take an $(D LPWSTR) or $(D LPCWSTR) argument.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "count",
						"line": 2968,
						"type": "pure nothrow @nogc @trusted size_t(const(C)[] str)",
						"parameters": [
							{
								"name": "str",
								"type": "const(C)[]"
							}
						],
						"endline": 2972,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "count",
				"line": 2968,
				"comment": "    Returns the total number of code points encoded in $(D str).\n\n    Supercedes: This function supercedes $(LREF toUCSindex).\n\n    Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 8,
				"kind": "template"
			},
			{
				"name": "replacementDchar",
				"line": 3093,
				"comment": " Inserted in place of invalid UTF sequences.\n\n References:\n      $(LINK http://en.wikipedia.org/wiki/Replacement_character#Replacement_character)\n",
				"deco": "w",
				"init": "'\\U0000fffd'",
				"char": 12,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byCodeUnit",
						"line": 3106,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3158,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byCodeUnit",
				"line": 3106,
				"comment": " Iterate a range of char, wchar, or dchars by code unit.\n\n The purpose is to bypass the special case decoding that\n $(XREF array,front) does to character arrays.\n Params:\n      r = input range of characters, or array of characters\n Returns:\n      input range\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isAutodecodableString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byCodeUnit",
						"line": 3161,
						"type": "ref (R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3166,
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byCodeUnit",
				"line": 3161,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "!isAutodecodableString!R && isInputRange!R && isSomeChar!(ElementEncodingType!R)",
				"char": 10,
				"kind": "template"
			},
			{
				"name": "byChar",
				"line": 3258,
				"comment": " Iterate an input range of characters by char, wchar, or dchar.\n These aliases simply forward to $(LREF byUTF) with the\n corresponding C argument.\n\n Params:\n      r = input range of characters, or array of characters\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "byWchar",
				"line": 3261,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "byDchar",
				"line": 3264,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "byUTF",
				"line": 3500,
				"comment": " Iterate an input range of characters by char type C.\n\n UTF sequences that cannot be converted to UTF-8 are replaced by U+FFFD\n per \"5.22 Best Practice for U+FFFD Substitution\" of the Unicode Standard 6.2.\n Hence byUTF is not symmetric.\n This algorithm is lazy, and does not allocate memory.\n Purity, nothrow, and safety are inferred from the r parameter.\n\n Params:\n      C = char, wchar, or dchar\n      r = input range of characters, or array of characters\n Returns:\n      input range of type C\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3576_2118)\n---\nforeach (c; \"h\".byUTF!char())\n    assert(c == 'h');\nforeach (c; \"h\".byUTF!wchar())\n    assert(c == 'h');\nforeach (c; \"h\".byUTF!dchar())\n    assert(c == 'h');\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3576_2118)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "    Encode and decode UTF-8, UTF-16 and UTF-32 strings.\n\n    UTF character support is restricted to\n    $(D '\\u0000' &lt;= character &lt;= '\\U0010FFFF').\n\n    See_Also:\n        $(LINK2 http://en.wikipedia.org/wiki/Unicode, Wikipedia)<br>\n        $(LINK http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8)<br>\n        $(LINK http://anubis.dkuug.dk/JTC1/SC2/WG2/docs/n1335)\n    Macros:\n        WIKI = Phobos/StdUtf\n\n    Copyright: Copyright Digital Mars 2000 - 2012.\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std/_utf.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/stdint.d",
		"name": "std.stdint",
		"members": [],
		"comment": "\n    D constrains integral types to specific sizes. But efficiency\n    of different sizes varies from machine to machine,\n    pointer sizes vary, and the maximum integer size varies.\n    <b>stdint</b> offers a portable way of trading off size\n    vs efficiency, in a manner compatible with the <tt>stdint.h</tt>\n    definitions in C.\n\n    The exact aliases are types of exactly the specified number of bits.\n    The at least aliases are at least the specified number of bits\n    large, and can be larger.\n    The fast aliases are the fastest integral type supported by the\n    processor that is at least as wide as the specified number of bits.\n\n    The aliases are:\n\n    $(ATABLE $(TR\n    $(TH Exact Alias)\n    $(TH Description)\n    $(TH At Least Alias)\n    $(TH Description)\n    $(TH Fast Alias)\n    $(TH Description)\n    )$(TR\n    $(TD int8_t)\n    $(TD exactly 8 bits signed)\n    $(TD int_least8_t)\n    $(TD at least 8 bits signed)\n    $(TD int_fast8_t)\n    $(TD fast 8 bits signed)\n    )$(TR\n    $(TD uint8_t)\n    $(TD exactly 8 bits unsigned)\n    $(TD uint_least8_t)\n    $(TD at least 8 bits unsigned)\n    $(TD uint_fast8_t)\n    $(TD fast 8 bits unsigned)\n\n    )$(TR\n    $(TD int16_t)\n    $(TD exactly 16 bits signed)\n    $(TD int_least16_t)\n    $(TD at least 16 bits signed)\n    $(TD int_fast16_t)\n    $(TD fast 16 bits signed)\n    )$(TR\n    $(TD uint16_t)\n    $(TD exactly 16 bits unsigned)\n    $(TD uint_least16_t)\n    $(TD at least 16 bits unsigned)\n    $(TD uint_fast16_t)\n    $(TD fast 16 bits unsigned)\n\n    )$(TR\n    $(TD int32_t)\n    $(TD exactly 32 bits signed)\n    $(TD int_least32_t)\n    $(TD at least 32 bits signed)\n    $(TD int_fast32_t)\n    $(TD fast 32 bits signed)\n    )$(TR\n    $(TD uint32_t)\n    $(TD exactly 32 bits unsigned)\n    $(TD uint_least32_t)\n    $(TD at least 32 bits unsigned)\n    $(TD uint_fast32_t)\n    $(TD fast 32 bits unsigned)\n\n    )$(TR\n    $(TD int64_t)\n    $(TD exactly 64 bits signed)\n    $(TD int_least64_t)\n    $(TD at least 64 bits signed)\n    $(TD int_fast64_t)\n    $(TD fast 64 bits signed)\n    )$(TR\n    $(TD uint64_t)\n    $(TD exactly 64 bits unsigned)\n    $(TD uint_least64_t)\n    $(TD at least 64 bits unsigned)\n    $(TD uint_fast64_t)\n    $(TD fast 64 bits unsigned)\n    ))\n\n    The ptr aliases are integral types guaranteed to be large enough\n    to hold a pointer without losing bits:\n\n    $(ATABLE $(TR\n    $(TH Alias)\n    $(TH Description)\n    )$(TR\n    $(TD intptr_t)\n    $(TD signed integral type large enough to hold a pointer)\n    )$(TR\n    $(TD uintptr_t)\n    $(TD unsigned integral type large enough to hold a pointer)\n    ))\n\n    The max aliases are the largest integral types:\n\n    $(ATABLE $(TR\n    $(TH Alias)\n    $(TH Description)\n    )$(TR\n    $(TD intmax_t)\n    $(TD the largest signed integral type)\n    )$(TR\n    $(TD uintmax_t)\n    $(TD the largest unsigned integral type)\n    ))\n\n Macros:\n  WIKI=Phobos/StdStdint\n  ATABLE=<table border=\"1\" cellspacing=\"0\" cellpadding=\"5\">$0</table>\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_stdint.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/string.d",
		"name": "std.string",
		"members": [
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 205,
						"comment": "        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std6string15StringException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 211,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "StringException",
				"line": 196,
				"comment": "    Exception thrown on errors in std.string functions.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "fromStringz",
				"line": 226,
				"comment": "    Params:\n        cString = A null-terminated c-style string.\n\n    Returns: A D-style array of $(D char) referencing the same string.  The\n    returned array will retain the same type qualifiers as the input.\n\n    $(RED Important Note:) The returned array is a slice of the original buffer.\n    The original data is not changed and not copied.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL232_2119)\n---\nassert(fromStringz(null) == null);\nassert(fromStringz(\"foo\") == \"foo\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL232_2119)\n",
				"deco": "FNaNbNiPNgaZANga",
				"parameters": [
					{
						"name": "cString",
						"deco": "PNga"
					}
				],
				"endline": 229,
				"char": 15,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toStringz",
				"line": 253,
				"comment": "    Params:\n        s = A D-style string.\n\n    Returns: A C-style null-terminated string equivalent to $(D s). $(D s)\n    must not contain embedded $(D '\\0')'s as any C function will treat the\n    first $(D '\\0') that it sees as the end of the string. If $(D s.empty) is\n    $(D true), then a string containing only $(D '\\0') is returned.\n\n    $(RED Important Note:) When passing a $(D char*) to a C function, and the C\n    function keeps it around for any reason, make sure that you keep a\n    reference to it in your D code. Otherwise, it may become invalid during a\n    garbage collection cycle and cause a nasty bug when the C code tries to use\n    it.\n",
				"deco": "FNaNbNeAxaZPya",
				"parameters": [
					{
						"name": "s",
						"deco": "Axa"
					}
				],
				"endline": 295,
				"char": 18,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toStringz",
				"line": 298,
				"comment": " Ditto\n",
				"deco": "FNaNbNexAyaZPya",
				"parameters": [
					{
						"name": "s",
						"deco": "xAya"
					}
				],
				"endline": 315,
				"originalType": "pure nothrow @trusted immutable(char)*(in string s)",
				"char": 18,
				"kind": "function"
			},
			{
				"name": "CaseSensitive",
				"line": 355,
				"comment": "   Flag indicating whether a search is case-sensitive.\n",
				"deco": "E3std8typecons43__T4FlagVAyaa13_6361736553656e736974697665Z4Flag",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOf",
						"line": 380,
						"type": "ptrdiff_t(Range s, in dchar c, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "Range"
							},
							{
								"name": "c",
								"storageClass": [
									"in"
								],
								"deco": "w"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 504,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOf",
				"line": 380,
				"comment": "    Searches for character in range.\n\n    Params:\n        s = string or InputRange of characters to search in correct UTF format\n        c = character to search for\n        startIdx = starting index to a well-formed code point\n        cs = CaseSensitive.yes or CaseSensitive.no\n\n    Returns:\n        the index of the first occurrence of $(D c) in $(D s) with\n        respect to the start index $(D startIdx). If $(D c)\n        is not found, then $(D -1) is returned.\n        If $(D c) is found the value of the returned index is at least\n        $(D startIdx).\n        If the parameters are not valid UTF, the result will still\n        be in the range [-1 .. s.length], but will not be reliable otherwise.\n\n    Throws:\n        If the sequence starting at $(D startIdx) does not represent a well\n        formed codepoint, then a $(XREF utf,UTFException) may be thrown.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL542_2121)\n---\nstring s = \"Hello World\";\nassert(indexOf(s, 'W') == 6);\nassert(indexOf(s, 'Z') == -1);\nassert(indexOf(s, 'w', CaseSensitive.no) == 6);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL542_2121)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL551_2122)\n---\nstring s = \"Hello World\";\nassert(indexOf(s, 'W', 4) == 6);\nassert(indexOf(s, 'Z', 100) == -1);\nassert(indexOf(s, 'w', 3, CaseSensitive.no) == 6);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL551_2122)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOf",
						"line": 507,
						"type": "ptrdiff_t(Range s, in dchar c, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "Range"
							},
							{
								"name": "c",
								"storageClass": [
									"in"
								],
								"deco": "w"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 539,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOf",
				"line": 507,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOf",
						"line": 706,
						"type": "ptrdiff_t(Range s, const(Char)[] sub, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "Range"
							},
							{
								"name": "sub",
								"type": "const(Char)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 778,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOf",
				"line": 706,
				"comment": "    Searches for substring in $(D s).\n\n    Params:\n        s = string or ForwardRange of characters to search in correct UTF format\n        sub = substring to search for\n        startIdx = the index into s to start searching from\n        cs = CaseSensitive.yes or CaseSensitive.no\n\n    Returns:\n        the index of the first occurrence of $(D sub) in $(D s) with\n        respect to the start index $(D startIdx). If $(D sub) is not found,\n        then $(D -1) is returned.\n        If the arguments are not valid UTF, the result will still\n        be in the range [-1 .. s.length], but will not be reliable otherwise.\n        If $(D sub) is found the value of the returned index is at least\n        $(D startIdx).\n\n    Throws:\n        If the sequence starting at $(D startIdx) does not represent a well\n        formed codepoint, then a $(XREF utf,UTFException) may be thrown.\n\n    Bugs:\n        Does not work with case insensitive strings where the mapping of\n        tolower and toupper is not 1:1.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL797_2129)\n---\nstring s = \"Hello World\";\nassert(indexOf(s, \"Wo\", 4) == 6);\nassert(indexOf(s, \"Zo\", 100) == -1);\nassert(indexOf(s, \"wo\", 3, CaseSensitive.no) == 6);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL797_2129)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL806_2130)\n---\nstring s = \"Hello World\";\nassert(indexOf(s, \"Wo\") == 6);\nassert(indexOf(s, \"Zo\") == -1);\nassert(indexOf(s, \"wO\", CaseSensitive.no) == 6);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL806_2130)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) && isSomeChar!Char",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOf",
						"line": 781,
						"type": "@safe ptrdiff_t(const(Char1)[] s, const(Char2)[] sub, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "const(Char1)[]"
							},
							{
								"name": "sub",
								"type": "const(Char2)[]"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 794,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOf",
				"line": 781,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Char1",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char1 && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOf",
						"line": 976,
						"type": "pure @safe ptrdiff_t(const(Char)[] s, in dchar c, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "const(Char)[]"
							},
							{
								"name": "c",
								"storageClass": [
									"in"
								],
								"deco": "w"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1036,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOf",
				"line": 976,
				"comment": "    Params:\n        s = string to search\n        c = character to search for\n        startIdx = the index into s to start searching from\n        cs = CaseSensitive.yes or CaseSensitive.no\n\n    Returns:\n        The index of the last occurrence of $(D c) in $(D s). If $(D c) is not\n        found, then $(D -1) is returned. The $(D startIdx) slices $(D s) in\n        the following way $(D s[0 .. startIdx]). $(D startIdx) represents a\n        codeunit index in $(D s).\n\n    Throws:\n        If the sequence ending at $(D startIdx) does not represent a well\n        formed codepoint, then a $(XREF utf,UTFException) may be thrown.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1052_2135)\n---\nstring s = \"Hello World\";\nassert(lastIndexOf(s, 'l') == 9);\nassert(lastIndexOf(s, 'Z') == -1);\nassert(lastIndexOf(s, 'L', CaseSensitive.no) == 9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1052_2135)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1061_2136)\n---\nstring s = \"Hello World\";\nassert(lastIndexOf(s, 'l', 4) == 3);\nassert(lastIndexOf(s, 'Z', 1337) == -1);\nassert(lastIndexOf(s, 'L', 7, CaseSensitive.no) == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1061_2136)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOf",
						"line": 1039,
						"type": "pure @safe ptrdiff_t(const(Char)[] s, in dchar c, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "const(Char)[]"
							},
							{
								"name": "c",
								"storageClass": [
									"in"
								],
								"deco": "w"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1049,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOf",
				"line": 1039,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOf",
						"line": 1162,
						"type": "pure @safe ptrdiff_t(const(Char1)[] s, const(Char2)[] sub, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "const(Char1)[]"
							},
							{
								"name": "sub",
								"type": "const(Char2)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1237,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOf",
				"line": 1162,
				"comment": "    Params:\n        s = string to search\n        sub = substring to search for\n        startIdx = the index into s to start searching from\n        cs = CaseSensitive.yes or CaseSensitive.no\n\n    Returns:\n        the index of the last occurrence of $(D sub) in $(D s). If $(D sub) is\n        not found, then $(D -1) is returned. The $(D startIdx) slices $(D s)\n        in the following way $(D s[0 .. startIdx]). $(D startIdx) represents a\n        codeunit index in $(D s).\n\n    Throws:\n        If the sequence ending at $(D startIdx) does not represent a well\n        formed codepoint, then a $(XREF utf,UTFException) may be thrown.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1253_2141)\n---\nstring s = \"Hello World\";\nassert(lastIndexOf(s, \"ll\") == 2);\nassert(lastIndexOf(s, \"Zo\") == -1);\nassert(lastIndexOf(s, \"lL\", CaseSensitive.no) == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1253_2141)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1262_2142)\n---\nstring s = \"Hello World\";\nassert(lastIndexOf(s, \"ll\", 4) == 2);\nassert(lastIndexOf(s, \"Zo\", 128) == -1);\nassert(lastIndexOf(s, \"lL\", 3, CaseSensitive.no) == -1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1262_2142)\n",
				"parameters": [
					{
						"name": "Char1",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char1 && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOf",
						"line": 1240,
						"type": "pure @safe ptrdiff_t(const(Char1)[] s, const(Char2)[] sub, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "const(Char1)[]"
							},
							{
								"name": "sub",
								"type": "const(Char2)[]"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1250,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOf",
				"line": 1240,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Char1",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char1 && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOfAny",
						"line": 1549,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1554,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOfAny",
				"line": 1549,
				"comment": "    Returns the index of the first occurence of any of the elements in $(D\n    needles) in $(D haystack). If no element of $(D needles) is found,\n    then $(D -1) is returned. The $(D startIdx) slices $(D haystack) in the\n    following way $(D haystack[startIdx .. $]). $(D startIdx) represents a\n    codeunit index in $(D haystack). If the sequence ending at $(D startIdx)\n    does not represent a well formed codepoint, then a $(XREF utf,UTFException)\n    may be thrown.\n\n    Params:\n        haystack = String to search for needles in.\n        needles = Strings to search for in haystack.\n        startIdx = slices haystack like this $(D haystack[startIdx .. $]). If\n            the startIdx is greater equal the length of haystack the functions\n            returns $(D -1).\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1574_2147)\n---\nimport std.conv : to;\n\nptrdiff_t i = \"helloWorld\".indexOfAny(\"Wr\");\nassert(i == 5);\ni = \"öällo world\".indexOfAny(\"lo \");\nassert(i == 4, to!string(i));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1574_2147)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1584_2148)\n---\nimport std.conv : to;\n\nptrdiff_t i = \"helloWorld\".indexOfAny(\"Wr\", 4);\nassert(i == 5);\n\ni = \"Foo öällo world\".indexOfAny(\"lh\", 3);\nassert(i == 8, to!string(i));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1584_2148)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOfAny",
						"line": 1557,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1571,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOfAny",
				"line": 1557,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOfAny",
						"line": 1718,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1724,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOfAny",
				"line": 1718,
				"comment": "    Returns the index of the last occurence of any of the elements in $(D\n    needles) in $(D haystack). If no element of $(D needles) is found,\n    then $(D -1) is returned. The $(D stopIdx) slices $(D haystack) in the\n    following way $(D s[0 .. stopIdx]). $(D stopIdx) represents a codeunit\n    index in $(D haystack). If the sequence ending at $(D startIdx) does not\n    represent a well formed codepoint, then a $(XREF utf,UTFException) may be\n    thrown.\n\n    Params:\n        haystack = String to search for needles in.\n        needles = Strings to search for in haystack.\n        stopIdx = slices haystack like this $(D haystack[0 .. stopIdx]). If\n            the stopIdx is greater equal the length of haystack the functions\n            returns $(D -1).\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1741_2152)\n---\nptrdiff_t i = \"helloWorld\".lastIndexOfAny(\"Wlo\");\nassert(i == 8);\n\ni = \"Foo öäöllo world\".lastIndexOfAny(\"öF\");\nassert(i == 8);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1741_2152)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1751_2153)\n---\nimport std.conv : to;\n\nptrdiff_t i = \"helloWorld\".lastIndexOfAny(\"Wlo\", 4);\nassert(i == 3);\n\ni = \"Foo öäöllo world\".lastIndexOfAny(\"öF\", 3);\nassert(i == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1751_2153)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOfAny",
						"line": 1727,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in size_t stopIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "stopIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1738,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOfAny",
				"line": 1727,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOfNeither",
						"line": 1901,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1907,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOfNeither",
				"line": 1901,
				"comment": "    Returns the index of the first occurence of any character not an elements\n    in $(D needles) in $(D haystack). If all element of $(D haystack) are\n    element of $(D needles) $(D -1) is returned.\n\n    Params:\n        haystack = String to search for needles in.\n        needles = Strings to search for in haystack.\n        startIdx = slices haystack like this $(D haystack[startIdx .. $]). If\n            the startIdx is greater equal the length of haystack the functions\n            returns $(D -1).\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1929_2157)\n---\nassert(indexOfNeither(\"abba\", \"a\", 2) == 2);\nassert(indexOfNeither(\"def\", \"de\", 1) == 2);\nassert(indexOfNeither(\"dfefffg\", \"dfe\", 4) == 6);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1929_2157)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1937_2158)\n---\nassert(indexOfNeither(\"def\", \"a\") == 0);\nassert(indexOfNeither(\"def\", \"de\") == 2);\nassert(indexOfNeither(\"dfefffg\", \"dfe\") == 6);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1937_2158)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOfNeither",
						"line": 1910,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1926,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOfNeither",
				"line": 1910,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOfNeither",
						"line": 2065,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 2071,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOfNeither",
				"line": 2065,
				"comment": "    Returns the last index of the first occurence of any character that is not\n    an elements in $(D needles) in $(D haystack). If all element of\n    $(D haystack) are element of $(D needles) $(D -1) is returned.\n\n    Params:\n        haystack = String to search for needles in.\n        needles = Strings to search for in haystack.\n        stopIdx = slices haystack like this $(D haystack[0 .. stopIdx]) If\n        the stopIdx is greater equal the length of haystack the functions\n        returns $(D -1).\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2089_2162)\n---\nassert(lastIndexOfNeither(\"abba\", \"a\") == 2);\nassert(lastIndexOfNeither(\"def\", \"f\") == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2089_2162)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2096_2163)\n---\nassert(lastIndexOfNeither(\"def\", \"rsa\", 3) == -1);\nassert(lastIndexOfNeither(\"abba\", \"a\", 2) == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2096_2163)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOfNeither",
						"line": 2074,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in size_t stopIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "stopIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 2086,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOfNeither",
				"line": 2074,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "representation",
						"line": 2223,
						"type": "pure nothrow @nogc @safe (Char[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "Char[]"
							}
						],
						"endline": 2228,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "representation",
				"line": 2223,
				"comment": " Returns the _representation of a string, which has the same type\n as the string except the character type is replaced by $(D ubyte),\n $(D ushort), or $(D uint) depending on the character width.\n\n Params:\n     s = The string to return the _representation of.\n\n Returns:\n     The _representation of the passed string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2231_2167)\n---\nstring s = \"hello\";\nstatic assert(is(typeof(representation(s)) == immutable(ubyte)[]));\nassert(representation(s) is cast(immutable(ubyte)[]) s);\nassert(representation(s) == [0x68, 0x65, 0x6c, 0x6c, 0x6f]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2231_2167)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "capitalize",
						"line": 2283,
						"type": "pure @trusted S(S input)",
						"parameters": [
							{
								"name": "input",
								"type": "S"
							}
						],
						"endline": 2319,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "capitalize",
				"line": 2283,
				"comment": " Capitalize the first character of $(D s) and convert the rest of $(D s) to\n lowercase.\n\n Params:\n     input = The string to _capitalize.\n\n Returns:\n     The capitalized string.\n\n See_Also:\n      $(XREF uni, toCapitalized) for a lazy range version that doesn't allocate memory\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2322_2169)\n---\nassert(capitalize(\"hello\") == \"Hello\");\nassert(capitalize(\"World\") == \"World\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2322_2169)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"name": "KeepTerminator",
				"line": 2403,
				"comment": "    Split $(D s) into an array of lines according to the unicode standard using\n    $(D '\\r'), $(D '\\n'), $(D \"\\r\\n\"), $(XREF uni, lineSep),\n    $(XREF uni, paraSep), $(D U+0085) (NEL), $(D '\\v')  and $(D '\\f')\n    as delimiters. If $(D keepTerm) is set to $(D KeepTerminator.yes), then the\n    delimiter is included in the strings returned.\n\n    Does not throw on invalid UTF; such is simply passed unchanged\n    to the output.\n\n    Allocates memory; use $(LREF lineSplitter) for an alternative that\n    does not.\n\n    Adheres to $(WEB http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf, Unicode 7.0).\n\n  Params:\n    s = a string of $(D chars), $(D wchars), or $(D dchars), or any custom\n        type that casts to a $(D string) type\n    keepTerm = whether delimiter is included or not in the results\n  Returns:\n    array of strings, each element is a line that is a slice of $(D s)\n  See_Also:\n    $(LREF lineSplitter)\n    $(XREF algorithm, splitter)\n    $(XREF regex, splitter)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2490_2172)\n---\nstring s = \"Hello\\nmy\\rname\\nis\";\nassert(splitLines(s) == [\"Hello\", \"my\", \"name\", \"is\"]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2490_2172)\n",
				"deco": "E3std8typecons45__T4FlagVAyaa14_6b6565705465726d696e61746f72Z4Flag",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitLines",
						"line": 2406,
						"type": "pure @safe S[](S s, in KeepTerminator keepTerm = KeepTerminator.no)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "keepTerm",
								"type": "KeepTerminator",
								"storageClass": [
									"in"
								],
								"default": "KeepTerminator.no"
							}
						],
						"endline": 2487,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "splitLines",
				"line": 2406,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lineSplitter",
						"line": 2730,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 2736,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "lineSplitter",
				"line": 2730,
				"comment": "  Split an array or slicable range of characters into a range of lines\n    using $(D '\\r'), $(D '\\n'), $(D '\\v'), $(D '\\f'), $(D \"\\r\\n\"),\n    $(XREF uni, lineSep), $(XREF uni, paraSep) and $(D '\\u0085') (NEL)\n    as delimiters. If $(D keepTerm) is set to $(D KeepTerminator.yes), then the\n    delimiter is included in the slices returned.\n\n    Does not throw on invalid UTF; such is simply passed unchanged\n    to the output.\n\n    Adheres to $(WEB http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf, Unicode 7.0).\n\n    Does not allocate memory.\n\n  Params:\n    r = array of $(D chars), $(D wchars), or $(D dchars) or a slicable range\n    keepTerm = whether delimiter is included or not in the results\n  Returns:\n    range of slices of the input range $(D r)\n\n  See_Also:\n    $(LREF splitLines)\n    $(XREF algorithm, splitter)\n    $(XREF regex, splitter)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2739_2175)\n---\nimport std.array : array;\n\nstring s = \"Hello\\nmy\\rname\\nis\";\n\n/* notice the call to $(D array) to turn the lazy range created by\nlineSplitter comparable to the $(D string[]) created by splitLines.\n*/\nassert(lineSplitter(s).array == splitLines(s));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2739_2175)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2826_2177)\n---\nauto s = \"\\rpeter\\n\\rpaul\\r\\njerry\\u2028ice\\u2029cream\\n\\nsunday\\nmon\\u2030day\\n\";\nauto lines = s.lineSplitter();\nstatic immutable witness = [\"\", \"peter\", \"\", \"paul\", \"jerry\", \"ice\", \"cream\", \"\", \"sunday\", \"mon\\u2030day\"];\nuint i;\nforeach (line; lines)\n{\n    assert(line == witness[i++]);\n}\nassert(i == witness.length);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2826_2177)\n",
				"parameters": [
					{
						"name": "keepTerm",
						"defaultValue": "KeepTerminator.no",
						"deco": "E3std8typecons45__T4FlagVAyaa14_6b6565705465726d696e61746f72Z4Flag",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "(hasSlicing!Range && hasLength!Range && isSomeChar!(ElementType!Range) || isSomeString!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripLeft",
						"line": 2863,
						"type": "(Range input)",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							}
						],
						"endline": 2889,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "stripLeft",
				"line": 2863,
				"comment": "    Strips leading whitespace (as defined by $(XREF uni, isWhite)).\n\n    Params:\n        input = string or ForwardRange of characters\n\n    Returns: $(D input) stripped of leading whitespace.\n\n    Postconditions: $(D input) and the returned value\n    will share the same tail (see $(XREF array, sameTail)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2892_2179)\n---\nimport std.uni : lineSep, paraSep;\nassert(stripLeft(\"     hello world     \") ==\n       \"hello world     \");\nassert(stripLeft(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\\n\\t\\v\\r\");\nassert(stripLeft(\"hello world\") ==\n       \"hello world\");\nassert(stripLeft([lineSep] ~ \"hello world\" ~ lineSep) ==\n       \"hello world\" ~ [lineSep]);\nassert(stripLeft([paraSep] ~ \"hello world\" ~ paraSep) ==\n       \"hello world\" ~ [paraSep]);\n\nimport std.utf : byChar;\nimport std.array;\nassert(stripLeft(\"     hello world     \"w.byChar).array ==\n       \"hello world     \");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2892_2179)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripRight",
						"line": 2932,
						"type": "(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 3024,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "stripRight",
				"line": 2932,
				"comment": "    Strips trailing whitespace (as defined by $(XREF uni, isWhite)).\n\n    Params:\n        str = string or random access range of characters\n\n    Returns:\n        slice of $(D str) stripped of trailing whitespace.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3028_2181)\n---\nimport std.uni : lineSep, paraSep;\nassert(stripRight(\"     hello world     \") ==\n       \"     hello world\");\nassert(stripRight(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"\\n\\t\\v\\rhello world\");\nassert(stripRight(\"hello world\") ==\n       \"hello world\");\nassert(stripRight([lineSep] ~ \"hello world\" ~ lineSep) ==\n       [lineSep] ~ \"hello world\");\nassert(stripRight([paraSep] ~ \"hello world\" ~ paraSep) ==\n       [paraSep] ~ \"hello world\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3028_2181)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!Range || isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range && !isConvertibleToString!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strip",
						"line": 3089,
						"type": "(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 3096,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "strip",
				"line": 3089,
				"comment": "    Strips both leading and trailing whitespace (as defined by\n    $(XREF uni, isWhite)).\n\n    Params:\n        str = string or random access range of characters\n\n    Returns:\n        slice of $(D str) stripped of leading and trailing whitespace.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3099_2184)\n---\nimport std.uni : lineSep, paraSep;\nassert(strip(\"     hello world     \") ==\n       \"hello world\");\nassert(strip(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\");\nassert(strip(\"hello world\") ==\n       \"hello world\");\nassert(strip([lineSep] ~ \"hello world\" ~ [lineSep]) ==\n       \"hello world\");\nassert(strip([paraSep] ~ \"hello world\" ~ [paraSep]) ==\n       \"hello world\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3099_2184)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!Range || isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range && !isConvertibleToString!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chomp",
						"line": 3192,
						"type": "Range(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 3245,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "chomp",
				"line": 3192,
				"comment": "    If $(D str) ends with $(D delimiter), then $(D str) is returned without\n    $(D delimiter) on its end. If it $(D str) does $(I not) end with\n    $(D delimiter), then it is returned unchanged.\n\n    If no $(D delimiter) is given, then one trailing  $(D '\\r'), $(D '\\n'),\n    $(D \"\\r\\n\"), $(D '\\f'), $(D '\\v'), $(XREF uni, lineSep), $(XREF uni, paraSep), or $(XREF uni, nelSep)\n    is removed from the end of $(D str). If $(D str) does not end with any of those characters,\n    then it is returned unchanged.\n\n    Params:\n        str = string or indexable range of characters\n        delimiter = string of characters to be sliced off end of str[]\n\n    Returns:\n        slice of str\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3289_2188)\n---\nimport std.utf : decode;\nimport std.uni : lineSep, paraSep, nelSep;\nassert(chomp(\" hello world  \\n\\r\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\r\\n\") == \" hello world  \");\nassert(chomp(\" hello world  \\f\") == \" hello world  \");\nassert(chomp(\" hello world  \\v\") == \" hello world  \");\nassert(chomp(\" hello world  \\n\\n\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\n\\n \") == \" hello world  \\n\\n \");\nassert(chomp(\" hello world  \\n\\n\" ~ [lineSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world  \\n\\n\" ~ [paraSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world  \\n\\n\" ~ [ nelSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world\") == \" hello world\");\nassert(chomp(\"\") == \"\");\n\nassert(chomp(\" hello world\", \"orld\") == \" hello w\");\nassert(chomp(\" hello world\", \" he\") == \" hello world\");\nassert(chomp(\"\", \"hello\") == \"\");\n\n// Don't decode pointlessly\nassert(chomp(\"hello\\xFE\", \"\\r\") == \"hello\\xFE\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3289_2188)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!Range && isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) && !isConvertibleToString!Range",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chomp",
						"line": 3248,
						"type": "Range(Range str, const(C2)[] delimiter)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							},
							{
								"name": "delimiter",
								"type": "const(C2)[]"
							}
						],
						"endline": 3285,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "chomp",
				"line": 3248,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "(isBidirectionalRange!Range && isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) && !isConvertibleToString!Range && isSomeChar!C2",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chompPrefix",
						"line": 3404,
						"type": "Range(Range str, const(C2)[] delimiter)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							},
							{
								"name": "delimiter",
								"type": "const(C2)[]"
							}
						],
						"endline": 3438,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "chompPrefix",
				"line": 3404,
				"comment": "    If $(D str) starts with $(D delimiter), then the part of $(D str) following\n    $(D delimiter) is returned. If $(D str) does $(I not) start with\n\n    $(D delimiter), then it is returned unchanged.\n\n    Params:\n        str = string or forward range of characters\n        delimiter = string of characters to be sliced off front of str[]\n\n    Returns:\n        slice of str\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3441_2191)\n---\nassert(chompPrefix(\"hello world\", \"he\") == \"llo world\");\nassert(chompPrefix(\"hello world\", \"hello w\") == \"orld\");\nassert(chompPrefix(\"hello world\", \" world\") == \"hello world\");\nassert(chompPrefix(\"\", \"hello\") == \"\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3441_2191)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "(isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) && !isConvertibleToString!Range && isSomeChar!C2",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chop",
						"line": 3507,
						"type": "Range(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 3562,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "chop",
				"line": 3507,
				"comment": "    Returns $(D str) without its last character, if there is one. If $(D str)\n    ends with $(D \"\\r\\n\"), then both are removed. If $(D str) is empty, then\n    then it is returned unchanged.\n\n    Params:\n        str = string (must be valid UTF)\n    Returns:\n        slice of str\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3565_2194)\n---\nassert(chop(\"hello world\") == \"hello worl\");\nassert(chop(\"hello world\\n\") == \"hello world\");\nassert(chop(\"hello world\\r\") == \"hello world\");\nassert(chop(\"hello world\\n\\r\") == \"hello world\\n\");\nassert(chop(\"hello world\\r\\n\") == \"hello world\");\nassert(chop(\"Walter Bright\") == \"Walter Brigh\");\nassert(chop(\"\") == \"\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3565_2194)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "(isBidirectionalRange!Range && isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) && !isConvertibleToString!Range",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "leftJustify",
						"line": 3661,
						"type": "S(S s, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 3666,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "leftJustify",
				"line": 3661,
				"comment": "    Left justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n\n    Params:\n        s = string\n        width = minimum field width\n        fillChar = used to pad end up to $(D width) characters\n\n    Returns:\n        GC allocated string\n\n    See_Also:\n        $(LREF leftJustifier), which does not allocate\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3669_2198)\n---\nassert(leftJustify(\"hello\", 7, 'X') == \"helloXX\");\nassert(leftJustify(\"hello\", 2, 'X') == \"hello\");\nassert(leftJustify(\"hello\", 9, 'X') == \"helloXXXX\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3669_2198)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "leftJustifier",
						"line": 3693,
						"type": "(Range r, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 3759,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "leftJustifier",
				"line": 3693,
				"comment": "    Left justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n\n    Params:\n        r = string or range of characters\n        width = minimum field width\n        fillChar = used to pad end up to $(D width) characters\n\n    Returns:\n        a lazy range of the left justified result\n\n    See_Also:\n        $(LREF rightJustifier)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3763_2199)\n---\nimport std.algorithm : equal;\nimport std.utf : byChar;\nassert(leftJustifier(\"hello\", 2).equal(\"hello\".byChar));\nassert(leftJustifier(\"hello\", 7).equal(\"hello  \".byChar));\nassert(leftJustifier(\"hello\", 7, 'x').equal(\"helloxx\".byChar));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3763_2199)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rightJustify",
						"line": 3809,
						"type": "S(S s, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 3814,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "rightJustify",
				"line": 3809,
				"comment": "    Right justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n\n    Params:\n        s = string\n        width = minimum field width\n        fillChar = used to pad end up to $(D width) characters\n\n    Returns:\n        GC allocated string\n\n    See_Also:\n        $(LREF rightJustifier), which does not allocate\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3817_2202)\n---\nassert(rightJustify(\"hello\", 7, 'X') == \"XXhello\");\nassert(rightJustify(\"hello\", 2, 'X') == \"hello\");\nassert(rightJustify(\"hello\", 9, 'X') == \"XXXXhello\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3817_2202)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rightJustifier",
						"line": 3841,
						"type": "(Range r, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 3937,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "rightJustifier",
				"line": 3841,
				"comment": "    Right justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n\n    Params:\n        r = string or forward range of characters\n        width = minimum field width\n        fillChar = used to pad end up to $(D width) characters\n\n    Returns:\n        a lazy range of the right justified result\n\n    See_Also:\n        $(LREF leftJustifier)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3941_2203)\n---\nimport std.algorithm : equal;\nimport std.utf : byChar;\nassert(rightJustifier(\"hello\", 2).equal(\"hello\".byChar));\nassert(rightJustifier(\"hello\", 7).equal(\"  hello\".byChar));\nassert(rightJustifier(\"hello\", 7, 'x').equal(\"xxhello\".byChar));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3941_2203)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "center",
						"line": 3997,
						"type": "S(S s, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 4002,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "center",
				"line": 3997,
				"comment": "    Center $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n\n    Params:\n        s = The string to center\n        width = Width of the field to center `s` in\n        fillChar = The character to use for filling excess space in the field\n\n    Returns:\n        The resulting _center-justified string. The returned string is\n        GC-allocated. To avoid GC allocation, use $(LREF centerJustifier)\n        instead.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4005_2206)\n---\nassert(center(\"hello\", 7, 'X') == \"XhelloX\");\nassert(center(\"hello\", 2, 'X') == \"hello\");\nassert(center(\"hello\", 9, 'X') == \"XXhelloXX\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4005_2206)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "centerJustifier",
						"line": 4067,
						"type": "(Range r, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 4096,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "centerJustifier",
				"line": 4067,
				"comment": "    Center justify $(D r) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D r) doesn't fill.\n\n    Params:\n        r = string or forward range of characters\n        width = minimum field width\n        fillChar = used to pad end up to $(D width) characters\n\n    Returns:\n        a lazy range of the center justified result\n\n    See_Also:\n        $(LREF leftJustifier)\n        $(LREF rightJustifier)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4100_2208)\n---\nimport std.algorithm : equal;\nimport std.utf : byChar;\nassert(centerJustifier(\"hello\", 2).equal(\"hello\".byChar));\nassert(centerJustifier(\"hello\", 8).equal(\" hello  \".byChar));\nassert(centerJustifier(\"hello\", 7, 'x').equal(\"xhellox\".byChar));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4100_2208)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "detab",
						"line": 4170,
						"type": "pure (auto ref Range s, size_t tabSize = 8)",
						"parameters": [
							{
								"name": "s",
								"type": "Range",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "tabSize",
								"type": "size_t",
								"default": "8"
							}
						],
						"endline": 4176,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "detab",
				"line": 4170,
				"comment": "    Replace each tab character in $(D s) with the number of spaces necessary\n    to align the following character at the next tab stop.\n\n    Params:\n        s = string\n        tabSize = distance between tab stops\n\n    Returns:\n        GC allocated string with tabs replaced with spaces\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4179_2211)\n---\nimport std.array;\n\nassert(detab(\" \\n\\tx\", 9) == \" \\n         x\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4179_2211)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) || __traits(compiles, StringTypeOf!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "detabber",
						"line": 4222,
						"type": "(Range r, size_t tabSize = 8)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "tabSize",
								"type": "size_t",
								"default": "8"
							}
						],
						"endline": 4331,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "detabber",
				"line": 4222,
				"comment": "    Replace each tab character in $(D r) with the number of spaces\n    necessary to align the following character at the next tab stop.\n\n    Params:\n        r = string or forward range\n        tabSize = distance between tab stops\n\n    Returns:\n        lazy forward range with tabs replaced with spaces\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4334_2213)\n---\nimport std.array;\n\nassert(detabber(\" \\n\\tx\", 9).array == \" \\n         x\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4334_2213)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4385_2216)\n---\nimport std.utf;\nimport std.array;\n\nassert(detabber(\" \\u2029\\t\".byChar, 9).array == \" \\u2029         \");\nauto r = \"hel\\tx\".byWchar.detabber();\nassert(r.front == 'h' && r.front == 'h');\nauto s = r.save;\nr.popFront();\nr.popFront();\nassert(r.front == 'l');\nassert(s.front == 'h');\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4385_2216)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "entab",
						"line": 4415,
						"type": "(Range s, size_t tabSize = 8)",
						"parameters": [
							{
								"name": "s",
								"type": "Range"
							},
							{
								"name": "tabSize",
								"type": "size_t",
								"default": "8"
							}
						],
						"endline": 4420,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "entab",
				"line": 4415,
				"comment": "    Replaces spaces in $(D s) with the optimal number of tabs.\n    All spaces and tabs at the end of a line are removed.\n\n    Params:\n        s       = String to convert.\n        tabSize = Tab columns are $(D tabSize) spaces apart.\n\n    Returns:\n        GC allocated string with spaces replaced with tabs;\n        use $(LREF entabber) to not allocate.\n\n    See_Also:\n        $(LREF entabber)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4423_2217)\n---\nassert(entab(\"        x \\n\") == \"\\tx\\n\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4423_2217)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "entabber",
						"line": 4454,
						"type": "(Range r, size_t tabSize = 8)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "tabSize",
								"type": "size_t",
								"default": "8"
							}
						],
						"endline": 4671,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "entabber",
				"line": 4454,
				"comment": "    Replaces spaces in range $(D r) with the optimal number of tabs.\n    All spaces and tabs at the end of a line are removed.\n\n    Params:\n        r = string or forward range\n        tabSize = distance between tab stops\n\n    Returns:\n        lazy forward range with spaces replaced with tabs\n\n    See_Also:\n        $(LREF entab)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4674_2219)\n---\nimport std.array;\nassert(entabber(\"        x \\n\").array == \"\\tx\\n\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4674_2219)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && !isConvertibleToString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 4775,
						"type": "pure @safe C1[](C1[] str, in dchar[dchar] transTable, const(C2)[] toRemove = null)",
						"parameters": [
							{
								"name": "str",
								"type": "C1[]"
							},
							{
								"name": "transTable",
								"type": "dchar[dchar]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "const(C2)[]",
								"default": "null"
							}
						],
						"endline": 4784,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 4775,
				"comment": "    Replaces the characters in $(D str) which are keys in $(D transTable) with\n    their corresponding values in $(D transTable). $(D transTable) is an AA\n    where its keys are $(D dchar) and its values are either $(D dchar) or some\n    type of string. Also, if $(D toRemove) is given, the characters in it are\n    removed from $(D str) prior to translation. $(D str) itself is unaltered.\n    A copy with the changes is returned.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The AA indicating which characters to replace and what to\n                     replace them with.\n        toRemove   = The characters to remove from the string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4787_2223)\n---\ndchar[dchar] transTable1 = ['e' : '5', 'o' : '7', '5': 'q'];\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n\nstring[dchar] transTable2 = ['e' : \"5\", 'o' : \"orange\"];\nassert(translate(\"hello world\", transTable2) == \"h5llorange worangerld\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4787_2223)\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"defaultDeco": "ya",
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && isSomeChar!C2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 4855,
						"type": "pure @safe C1[](C1[] str, in S[dchar] transTable, const(C2)[] toRemove = null)",
						"parameters": [
							{
								"name": "str",
								"type": "C1[]"
							},
							{
								"name": "transTable",
								"type": "S[dchar]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "const(C2)[]",
								"default": "null"
							}
						],
						"endline": 4864,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 4855,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					},
					{
						"defaultDeco": "ya",
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && isSomeString!S && isSomeChar!C2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 4930,
						"type": "void(C1[] str, in dchar[dchar] transTable, const(C2)[] toRemove, Buffer buffer)",
						"parameters": [
							{
								"name": "str",
								"type": "C1[]"
							},
							{
								"name": "transTable",
								"type": "dchar[dchar]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "const(C2)[]"
							},
							{
								"name": "buffer",
								"type": "Buffer"
							}
						],
						"endline": 4937,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 4930,
				"comment": "    This is an overload of $(D translate) which takes an existing buffer to write the contents to.\n\n    Params:\n        str        = The original string.\n        transTable = The AA indicating which characters to replace and what to\n                     replace them with.\n        toRemove   = The characters to remove from the string.\n        buffer     = An output range to write the contents to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4940_2227)\n---\nimport std.array : appender;\ndchar[dchar] transTable1 = ['e' : '5', 'o' : '7', '5': 'q'];\nauto buffer = appender!(dchar[])();\ntranslate(\"hello world\", transTable1, null, buffer);\nassert(buffer.data == \"h5ll7 w7rld\");\n\nbuffer.clear();\ntranslate(\"hello world\", transTable1, \"low\", buffer);\nassert(buffer.data == \"h5 rd\");\n\nbuffer.clear();\nstring[dchar] transTable2 = ['e' : \"5\", 'o' : \"orange\"];\ntranslate(\"hello world\", transTable2, null, buffer);\nassert(buffer.data == \"h5llorange worangerld\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4940_2227)\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"defaultDeco": "ya",
						"name": "C2",
						"kind": "type"
					},
					{
						"name": "Buffer",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && isSomeChar!C2 && isOutputRange!(Buffer, C1)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 4977,
						"type": "void(C1[] str, in S[dchar] transTable, const(C2)[] toRemove, Buffer buffer)",
						"parameters": [
							{
								"name": "str",
								"type": "C1[]"
							},
							{
								"name": "transTable",
								"type": "S[dchar]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "const(C2)[]"
							},
							{
								"name": "buffer",
								"type": "Buffer"
							}
						],
						"endline": 4984,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 4977,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					},
					{
						"defaultDeco": "ya",
						"name": "C2",
						"kind": "type"
					},
					{
						"name": "Buffer",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && isSomeString!S && isSomeChar!C2 && isOutputRange!(Buffer, S)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 5043,
						"type": "pure nothrow @trusted C[](in char[] str, in char[] transTable, in char[] toRemove = null)",
						"parameters": [
							{
								"name": "str",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "transTable",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "char[]",
								"storageClass": [
									"in"
								],
								"default": "null"
							}
						],
						"endline": 5073,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 5043,
				"comment": "    This is an $(I $(RED ASCII-only)) overload of $(LREF _translate). It\n    will $(I not) work with Unicode. It exists as an optimization for the\n    cases where Unicode processing is not necessary.\n\n    Unlike the other overloads of $(LREF _translate), this one does not take\n    an AA. Rather, it takes a $(D string) generated by $(LREF makeTransTable).\n\n    The array generated by $(D makeTransTable) is $(D 256) elements long such that\n    the index is equal to the ASCII character being replaced and the value is\n    equal to the character that it's being replaced with. Note that translate\n    does not decode any of the characters, so you can actually pass it Extended\n    ASCII characters if you want to (ASCII only actually uses $(D 128)\n    characters), but be warned that Extended ASCII characters are not valid\n    Unicode and therefore will result in a $(D UTFException) being thrown from\n    most other Phobos functions.\n\n    Also, because no decoding occurs, it is possible to use this overload to\n    translate ASCII characters within a proper UTF-8 string without altering the\n    other, non-ASCII characters. It's replacing any code unit greater than\n    $(D 127) with another code unit or replacing any code unit with another code\n    unit greater than $(D 127) which will cause UTF validation issues.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The string indicating which characters to replace and what\n                     to replace them with. It is generated by $(LREF makeTransTable).\n        toRemove   = The characters to remove from the string.\n",
				"parameters": [
					{
						"defaultDeco": "ya",
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(Unqual!C == char)",
				"char": 5,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "makeTrans",
				"line": 5082,
				"comment": " Do same thing as $(LREF makeTransTable) but allocate the translation table\n on the GC heap.\n\n Use $(LREF makeTransTable) instead.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5088_2229)\n---\nauto transTable1 = makeTrans(\"eo5\", \"57q\");\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5088_2229)\n",
				"deco": "FNaNbNexAaxAaZAya",
				"parameters": [
					{
						"name": "from",
						"deco": "xAa"
					},
					{
						"name": "to",
						"deco": "xAa"
					}
				],
				"endline": 5085,
				"originalType": "pure nothrow @trusted string(in char[] from, in char[] to)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "makeTransTable",
				"line": 5107,
				"comment": " Construct 256 character translation table, where characters in from[] are replaced\n by corresponding characters in to[].\n\n Params:\n      from = array of chars, less than or equal to 256 in length\n      to = corresponding array of chars to translate to\n Returns:\n      translation array\n",
				"deco": "FNaNbNiNfxAaxAaZG256a",
				"parameters": [
					{
						"name": "from",
						"deco": "xAa"
					},
					{
						"name": "to",
						"deco": "xAa"
					}
				],
				"endline": 5127,
				"originalType": "pure nothrow @nogc @safe char[256](in char[] from, in char[] to)",
				"char": 11,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 5181,
						"type": "pure @trusted void(in char[] str, in char[] transTable, in char[] toRemove, Buffer buffer)",
						"parameters": [
							{
								"name": "str",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "transTable",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "buffer",
								"type": "Buffer"
							}
						],
						"endline": 5200,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 5181,
				"comment": "    This is an $(I $(RED ASCII-only)) overload of $(D translate) which takes an existing buffer to write the contents to.\n\n    Params:\n        str        = The original string.\n        transTable = The string indicating which characters to replace and what\n                     to replace them with. It is generated by $(LREF makeTransTable).\n        toRemove   = The characters to remove from the string.\n        buffer     = An output range to write the contents to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5203_2231)\n---\nimport std.array : appender;\nauto buffer = appender!(char[])();\nauto transTable1 = makeTransTable(\"eo5\", \"57q\");\ntranslate(\"hello world\", transTable1, null, buffer);\nassert(buffer.data == \"h5ll7 w7rld\");\n\nbuffer.clear();\ntranslate(\"hello world\", transTable1, \"low\", buffer);\nassert(buffer.data == \"h5 rd\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5203_2231)\n",
				"parameters": [
					{
						"defaultDeco": "ya",
						"name": "C",
						"kind": "type"
					},
					{
						"name": "Buffer",
						"kind": "type"
					}
				],
				"constraint": "is(Unqual!C == char) && isOutputRange!(Buffer, char)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "inPattern",
						"line": 5236,
						"type": "pure @nogc @safe bool(dchar c, in S pattern)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							},
							{
								"name": "pattern",
								"type": "S",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 5266,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "inPattern",
				"line": 5236,
				"comment": " See if character c is in the pattern.\n Patterns:\n\n  A <i>pattern</i> is an array of characters much like a <i>character\n  class</i> in regular expressions. A sequence of characters\n  can be given, such as \"abcde\". The '-' can represent a range\n  of characters, as \"a-e\" represents the same pattern as \"abcde\".\n  \"a-fA-F0-9\" represents all the hex characters.\n  If the first character of a pattern is '^', then the pattern\n  is negated, i.e. \"^0-9\" means any character except a digit.\n  The functions inPattern, <b>countchars</b>, <b>removeschars</b>,\n  and <b>squeeze</b>\n  use patterns.\n\n Note: In the future, the pattern syntax may be improved\n  to be more like regular expression character classes.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "inPattern",
						"line": 5305,
						"type": "pure @nogc @safe bool(dchar c, S[] patterns)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							},
							{
								"name": "patterns",
								"type": "S[]"
							}
						],
						"endline": 5315,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "inPattern",
				"line": 5305,
				"comment": " See if character c is in the intersection of the patterns.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "countchars",
						"line": 5322,
						"type": "pure @nogc @safe size_t(S s, in S1 pattern)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "pattern",
								"type": "S1",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 5330,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "countchars",
				"line": 5322,
				"comment": " Count characters in s that match pattern.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					},
					{
						"name": "S1",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S && isSomeString!S1",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "removechars",
						"line": 5351,
						"type": "pure @safe S(S s, in S pattern)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "pattern",
								"type": "S",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 5378,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "removechars",
				"line": 5351,
				"comment": " Return string that is s with all characters removed that match pattern.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "squeeze",
						"line": 5403,
						"type": "S(S s, in S pattern = null)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "pattern",
								"type": "S",
								"storageClass": [
									"in"
								],
								"default": "null"
							}
						],
						"endline": 5444,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "squeeze",
				"line": 5403,
				"comment": " Return string where sequences of a character in s[] from pattern[]\n are replaced with a single instance of that character.\n If pattern is null, it defaults to all characters.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "munch",
						"line": 5480,
						"type": "pure @nogc @safe S1(ref S1 s, S2 pattern)",
						"parameters": [
							{
								"name": "s",
								"type": "S1",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "pattern",
								"type": "S2"
							}
						],
						"endline": 5493,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "munch",
				"line": 5480,
				"comment": " Finds the position $(D_PARAM pos) of the first character in $(D_PARAM\n s) that does not match $(D_PARAM pattern) (in the terminology used by\n $(LINK2 std_string.html,inPattern)). Updates $(D_PARAM s =\n s[pos..$]). Returns the slice from the beginning of the original\n (before update) string up to, and excluding, $(D_PARAM pos).\n\nThe $(D_PARAM munch) function is mostly convenient for skipping\ncertain category of characters (e.g. whitespace) when parsing\nstrings. (In such cases, the return value is not used.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5496_2236)\n---\nstring s = \"123abc\";\nstring t = munch(s, \"0123456789\");\nassert(t == \"123\" && s == \"abc\");\nt = munch(s, \"0123456789\");\nassert(t == \"\" && s == \"abc\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5496_2236)\n",
				"parameters": [
					{
						"name": "S1",
						"kind": "type"
					},
					{
						"name": "S2",
						"kind": "type"
					}
				],
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "succ",
						"line": 5524,
						"type": "pure @safe S(S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 5568,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "succ",
				"line": 5524,
				"comment": " Return string that is the 'successor' to s[].\n If the rightmost character is a-zA-Z0-9, it is incremented within\n its case or digits. If it generates a carry, the process is\n repeated with the one to its immediate left.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5571_2238)\n---\nassert(succ(\"1\") == \"2\");\nassert(succ(\"9\") == \"10\");\nassert(succ(\"999\") == \"1000\");\nassert(succ(\"zz99\") == \"aaa00\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5571_2238)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "tr",
						"line": 5637,
						"type": "C1[](C1[] str, const(C2)[] from, const(C3)[] to, const(C4)[] modifiers = null)",
						"parameters": [
							{
								"name": "str",
								"type": "C1[]"
							},
							{
								"name": "from",
								"type": "const(C2)[]"
							},
							{
								"name": "to",
								"type": "const(C3)[]"
							},
							{
								"name": "modifiers",
								"type": "const(C4)[]",
								"default": "null"
							}
						],
						"endline": 5749,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "tr",
				"line": 5637,
				"comment": "    Replaces the characters in $(D str) which are in $(D from) with the\n    the corresponding characters in $(D to) and returns the resulting string.\n\n    $(D tr) is based on\n    $(WEB pubs.opengroup.org/onlinepubs/9699919799/utilities/_tr.html, Posix's tr),\n    though it doesn't do everything that the Posix utility does.\n\n    Params:\n        str       = The original string.\n        from      = The characters to replace.\n        to        = The characters to replace with.\n        modifiers = String containing modifiers.\n\n    Modifiers:\n        $(BOOKTABLE,\n        $(TR $(TD Modifier) $(TD Description))\n        $(TR $(TD $(D 'c')) $(TD Complement the list of characters in $(D from)))\n        $(TR $(TD $(D 'd')) $(TD Removes matching characters with no corresponding\n                              replacement in $(D to)))\n        $(TR $(TD $(D 's')) $(TD Removes adjacent duplicates in the replaced\n                              characters))\n        )\n\n    If the modifier $(D 'd') is present, then the number of characters in\n    $(D to) may be only $(D 0) or $(D 1).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is empty, then\n    $(D to) is taken to be the same as $(D from).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is shorter than\n    $(D from), then $(D to) is extended by replicating the last character in\n    $(D to).\n\n    Both $(D from) and $(D to) may contain ranges using the $(D '-') character\n    (e.g. $(D \"a-d\") is synonymous with $(D \"abcd\").) Neither accept a leading\n    $(D '^') as meaning the complement of the string (use the $(D 'c') modifier\n    for that).\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					},
					{
						"name": "C3",
						"kind": "type"
					},
					{
						"defaultDeco": "ya",
						"name": "C4",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "isNumeric",
				"line": 5817,
				"comment": " Takes a string $(D s) and determines if it represents a number. This function\n also takes an optional parameter, $(D bAllowSep), which will accept the\n separator characters $(D ',') and $(D '__') within the string. But these\n characters should be stripped from the string before using any\n of the conversion functions like $(D to!int()), $(D to!float()), and etc\n else an error will occur.\n\n Also please note, that no spaces are allowed within the string\n anywhere whether it's a leading, trailing, or embedded space(s),\n thus they too must be stripped from the string before using this\n function, or any of the conversion functions.\n\n Params:\n     s = the string to check\n     bAllowSep = accept separator characters or not\n\n Returns:\n     $(D bool)\nExample:\nInteger Whole Number: (byte, ubyte, short, ushort, int, uint, long, and ulong)\n ['+'|'-']digit(s)[U|L|UL]$(DDOX_UNITTEST_HEADER __unittestL5930_2247)\n---\nassert(isNumeric(\"123\"));\nassert(isNumeric(\"123UL\"));\nassert(isNumeric(\"123L\"));\nassert(isNumeric(\"+123U\"));\nassert(isNumeric(\"-123L\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5930_2247)\nExample:\nFloating-Point Number: (float, double, real, ifloat, idouble, and ireal)\n ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]]\n      or [nan|nani|inf|-inf]$(DDOX_UNITTEST_HEADER __unittestL5944_2248)\n---\nassert(isNumeric(\"+123\"));\nassert(isNumeric(\"-123.01\"));\nassert(isNumeric(\"123.3e-10f\"));\nassert(isNumeric(\"123.3e-10fi\"));\nassert(isNumeric(\"123.3e-10L\"));\n\nassert(isNumeric(\"nan\"));\nassert(isNumeric(\"nani\"));\nassert(isNumeric(\"-inf\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5944_2248)\nExample:\nFloating-Point Number: (cfloat, cdouble, and creal)\n ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][+]\n         [digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]]\n      or [nan|nani|nan+nani|inf|-inf]$(DDOX_UNITTEST_HEADER __unittestL5963_2249)\n---\nassert(isNumeric(\"-123e-1+456.9e-10Li\"));\nassert(isNumeric(\"+123e+10+456i\"));\nassert(isNumeric(\"123+456\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5963_2249)\n",
				"deco": "FNaNfAxaxbZb",
				"parameters": [
					{
						"name": "s",
						"deco": "Axa"
					},
					{
						"name": "bAllowSep",
						"deco": "xb",
						"default": "false"
					}
				],
				"endline": 5924,
				"originalType": "pure @safe bool(const(char)[] s, in bool bAllowSep = false)",
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "soundexer",
						"line": 6068,
						"type": "char[4](Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 6122,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "soundexer",
				"line": 6068,
				"comment": " Soundex algorithm.\n\n The Soundex algorithm converts a word into 4 characters\n based on how the word sounds phonetically. The idea is that\n two spellings that sound alike will have the same Soundex\n value, which means that Soundex can be used for fuzzy matching\n of names.\n\n Params:\n  str = String or InputRange to convert to Soundex representation.\n\n Returns:\n  The four character array with the Soundex result in it.\n  The array has zero's in it if there is no Soundex representation for the string.\n\n See_Also:\n  $(LINK2 http://en.wikipedia.org/wiki/Soundex, Wikipedia),\n  $(LUCKY The Soundex Indexing System)\n  $(LREF soundex)\n\n Bugs:\n  Only works well with English names.\n  There are other arguably better Soundex algorithms,\n  but this one is the standard one.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range) && !isConvertibleToString!Range",
				"char": 9,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "soundex",
				"line": 6145,
				"comment": " Like $(LREF soundexer), but with different parameters\n and return value.\n\n Params:\n  str = String to convert to Soundex representation.\n  buffer = Optional 4 char array to put the resulting Soundex\n      characters into. If null, the return value\n      buffer will be allocated on the heap.\n Returns:\n  The four character array with the Soundex result in it.\n  Returns null if there is no Soundex representation for the string.\n See_Also:\n  $(LREF soundexer)\n",
				"deco": "FNaNbNfAxaAaZAa",
				"parameters": [
					{
						"name": "str",
						"deco": "Axa"
					},
					{
						"name": "buffer",
						"deco": "Aa",
						"default": "null"
					}
				],
				"endline": 6170,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "abbrev",
				"line": 6266,
				"comment": " Construct an associative array consisting of all\n abbreviations that uniquely map to the strings in values.\n\n This is useful in cases where the user is expected to type\n in one of a known set of strings, and the program will helpfully\n autocomplete the string once sufficient characters have been\n entered that uniquely identify it.\n Example:\n ---\n import std.stdio;\n import std.string;\n\n void main()\n {\n    static string[] list = [ \"food\", \"foxy\" ];\n\n    auto abbrevs = std.string.abbrev(list);\n\n    foreach (key, value; abbrevs)\n    {\n       writefln(\"%s => %s\", key, value);\n    }\n }\n ---\n produces the output:\n <pre>\n fox =&gt; foxy\n food =&gt; food\n foxy =&gt; foxy\n foo =&gt; food\n </pre>\n",
				"deco": "FNaNfAAyaZHAyaAya",
				"parameters": [
					{
						"name": "values",
						"deco": "AAya"
					}
				],
				"endline": 6311,
				"char": 16,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "column",
						"line": 6366,
						"type": "size_t(Range str, in size_t tabsize = 8)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							},
							{
								"name": "tabsize",
								"type": "size_t",
								"storageClass": [
									"in"
								],
								"default": "8"
							}
						],
						"endline": 6408,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "column",
				"line": 6366,
				"comment": " Compute _column number at the end of the printed form of the string,\n assuming the string starts in the leftmost _column, which is numbered\n starting from 0.\n\n Tab characters are expanded into enough spaces to bring the _column number\n to the next multiple of tabsize.\n If there are multiple lines in the string, the _column number of the last\n line is returned.\n\n Params:\n    str = string or InputRange to be analyzed\n    tabsize = number of columns a tab character represents\n\n Returns:\n    column number\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6411_2255)\n---\nimport std.utf : byChar, byWchar, byDchar;\n\nassert(column(\"1234 \") == 5);\nassert(column(\"1234 \"w) == 5);\nassert(column(\"1234 \"d) == 5);\n\nassert(column(\"1234 \".byChar()) == 5);\nassert(column(\"1234 \"w.byWchar()) == 5);\nassert(column(\"1234 \"d.byDchar()) == 5);\n\n// Tab stops are set at 8 spaces by default; tab characters insert enough\n// spaces to bring the column position to the next multiple of 8.\nassert(column(\"\\t\") == 8);\nassert(column(\"1\\t\") == 8);\nassert(column(\"\\t1\") == 9);\nassert(column(\"123\\t\") == 8);\n\n// Other tab widths are possible by specifying it explicitly:\nassert(column(\"\\t\", 4) == 4);\nassert(column(\"1\\t\", 4) == 4);\nassert(column(\"\\t1\", 4) == 5);\nassert(column(\"123\\t\", 4) == 4);\n\n// New lines reset the column number.\nassert(column(\"abc\\n\") == 0);\nassert(column(\"abc\\n1\") == 1);\nassert(column(\"abcdefg\\r1234\") == 4);\nassert(column(\"abc\\u20281\") == 1);\nassert(column(\"abc\\u20291\") == 1);\nassert(column(\"abc\\u00851\") == 1);\nassert(column(\"abc\\u00861\") == 5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6411_2255)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "(isInputRange!Range && isSomeChar!(Unqual!(ElementEncodingType!Range)) || isNarrowString!Range) && !isConvertibleToString!Range",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "wrap",
						"line": 6492,
						"type": "S(S s, in size_t columns = 80, S firstindent = null, S indent = null, in size_t tabsize = 8)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "columns",
								"type": "size_t",
								"storageClass": [
									"in"
								],
								"default": "80"
							},
							{
								"name": "firstindent",
								"type": "S",
								"default": "null"
							},
							{
								"name": "indent",
								"type": "S",
								"default": "null"
							},
							{
								"name": "tabsize",
								"type": "size_t",
								"storageClass": [
									"in"
								],
								"default": "8"
							}
						],
						"endline": 6556,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "wrap",
				"line": 6492,
				"comment": " Wrap text into a paragraph.\n\n The input text string s is formed into a paragraph\n by breaking it up into a sequence of lines, delineated\n by \\n, such that the number of columns is not exceeded\n on each line.\n The last line is terminated with a \\n.\n Params:\n  s = text string to be wrapped\n  columns = maximum number of _columns in the paragraph\n  firstindent = string used to _indent first line of the paragraph\n  indent = string to use to _indent following lines of the paragraph\n  tabsize = column spacing of tabs in firstindent[] and indent[]\n Returns:\n  resulting paragraph as an allocated string\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6559_2258)\n---\nassert(wrap(\"a short string\", 7) == \"a short\\nstring\\n\");\n\n// wrap will not break inside of a word, but at the next space\nassert(wrap(\"a short string\", 4) == \"a\\nshort\\nstring\\n\");\n\nassert(wrap(\"a short string\", 7, \"\\t\") == \"\\ta\\nshort\\nstring\\n\");\nassert(wrap(\"a short string\", 7, \"\\t\", \"    \") == \"\\ta\\n    short\\n    string\\n\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6559_2258)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "outdent",
						"line": 6609,
						"type": "pure @safe S(S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S"
							}
						],
						"endline": 6612,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "outdent",
				"line": 6609,
				"comment": " Removes one level of indentation from a multi-line string.\n\n This uniformly outdents the text as much as possible.\n Whitespace-only lines are always converted to blank lines.\n\n Does not allocate memory if it does not throw.\n\n Params:\n     str = multi-line string\n\n Returns:\n      outdented string\n\n Throws:\n     StringException if indentation is done with different sequences\n     of whitespace characters.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6615_2260)\n---\nenum pretty = q{\n   import std.stdio;\n   void main() {\n       writeln(\"Hello\");\n   }\n}.outdent();\n\nenum ugly = q{\nimport std.stdio;\nvoid main() {\nwriteln(\"Hello\");\n}\n};\n\nassert(pretty == ugly);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6615_2260)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "outdent",
						"line": 6651,
						"type": "pure @safe S[](S[] lines)",
						"parameters": [
							{
								"name": "lines",
								"type": "S[]"
							}
						],
						"endline": 6708,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "outdent",
				"line": 6651,
				"comment": " Removes one level of indentation from an array of single-line strings.\n\n This uniformly outdents the text as much as possible.\n Whitespace-only lines are always converted to blank lines.\n\n Params:\n     lines = array of single-line strings\n\n Returns:\n      lines[] is rewritten in place with outdented lines\n\n Throws:\n     StringException if indentation is done with different sequences\n     of whitespace characters.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeUTF",
						"line": 6819,
						"type": "pure (T[] arr)",
						"parameters": [
							{
								"name": "arr",
								"type": "T[]"
							}
						],
						"endline": 6827,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "assumeUTF",
				"line": 6819,
				"comment": " Assume the given array of integers $(D arr) is a well-formed UTF string and\nreturn it typed as a UTF string.\n\n$(D ubyte) becomes $(D char), $(D ushort) becomes $(D wchar) and $(D uint)\nbecomes $(D dchar). Type qualifiers are preserved.\n\nParams:\n    arr = array of bytes, ubytes, shorts, ushorts, ints, or uints\n\nReturns:\n    arr retyped as an array of chars, wchars, or dchars\n\nSee_Also: $(LREF representation)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6830_2262)\n---\nstring a = \"Hölo World\";\nimmutable(ubyte)[] b = a.representation;\nstring c = b.assumeUTF;\n\nassert(a == c);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6830_2262)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "staticIndexOf!(Unqual!T, ubyte, ushort, uint) != -1",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "String handling functions.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions) )\n$(TR $(TDNW Searching)\n    $(TD\n         $(MYREF column)\n         $(MYREF inPattern)\n         $(MYREF indexOf)\n         $(MYREF indexOfAny)\n         $(MYREF indexOfNeither)\n         $(MYREF lastIndexOf)\n         $(MYREF lastIndexOfAny)\n         $(MYREF lastIndexOfNeither)\n    )\n)\n$(TR $(TDNW Comparison)\n    $(TD\n         $(MYREF countchars)\n         $(MYREF isNumeric)\n    )\n)\n$(TR $(TDNW Mutation)\n    $(TD\n         $(MYREF capitalize)\n         $(MYREF munch)\n         $(MYREF removechars)\n         $(MYREF squeeze)\n    )\n)\n$(TR $(TDNW Pruning and Filling)\n    $(TD\n         $(MYREF center)\n         $(MYREF chomp)\n         $(MYREF chompPrefix)\n         $(MYREF chop)\n         $(MYREF detabber)\n         $(MYREF detab)\n         $(MYREF entab)\n         $(MYREF leftJustify)\n         $(MYREF outdent)\n         $(MYREF rightJustify)\n         $(MYREF strip)\n         $(MYREF stripLeft)\n         $(MYREF stripRight)\n         $(MYREF wrap)\n    )\n)\n$(TR $(TDNW Substitution)\n    $(TD\n         $(MYREF abbrev)\n         $(MYREF soundex)\n         $(MYREF soundexer)\n         $(MYREF succ)\n         $(MYREF tr)\n         $(MYREF translate)\n    )\n)\n$(TR $(TDNW Miscellaneous)\n    $(TD\n         $(MYREF assumeUTF)\n         $(MYREF fromStringz)\n         $(MYREF lineSplitter)\n         $(MYREF representation)\n         $(MYREF splitLines)\n         $(MYREF toStringz)\n    )\n)))\n\nObjects of types $(D _string), $(D wstring), and $(D dstring) are value types\nand cannot be mutated element-by-element. For using mutation during building\nstrings, use $(D char[]), $(D wchar[]), or $(D dchar[]). The $(D xxxstring)\ntypes are preferable because they don't exhibit undesired aliasing, thus\nmaking code more robust.\n\nThe following functions are publicly imported:\n\n$(BOOKTABLE ,\n$(TR $(TH Module) $(TH Functions) )\n$(LEADINGROW Publicly imported functions)\n    $(TR $(TD std.algorithm)\n        $(TD\n         $(SHORTXREF_PACK algorithm,comparison,cmp)\n         $(SHORTXREF_PACK algorithm,searching,count)\n         $(SHORTXREF_PACK algorithm,searching,endsWith)\n         $(SHORTXREF_PACK algorithm,searching,startsWith)\n    ))\n    $(TR $(TD std.array)\n        $(TD\n         $(SHORTXREF array, join)\n         $(SHORTXREF array, replace)\n         $(SHORTXREF array, replaceInPlace)\n         $(SHORTXREF array, split)\n    ))\n    $(TR $(TD std.format)\n        $(TD\n         $(SHORTXREF format, format)\n         $(SHORTXREF format, sformat)\n    ))\n    $(TR $(TD std.uni)\n        $(TD\n         $(SHORTXREF uni, icmp)\n         $(SHORTXREF uni, toLower)\n         $(SHORTXREF uni, toLowerInPlace)\n         $(SHORTXREF uni, toUpper)\n         $(SHORTXREF uni, toUpperInPlace)\n    ))\n)\n\nThere is a rich set of functions for _string handling defined in other modules.\nFunctions related to Unicode and ASCII are found in $(LINK2 std_uni.html, std.uni)\nand $(LINK2 std_ascii.html, std.ascii), respectively. Other functions that have a\nwider generality than just strings can be found in $(LINK2 std_algorithm.html,\nstd.algorithm) and $(LINK2 std_range.html, std.range).\n\nSee_Also:\n    $(LIST\n    $(LINK2 std_algorithm.html, std.algorithm) and\n    $(LINK2 std_range.html, std.range)\n    for generic range algorithms\n    ,\n    $(LINK2 std_ascii.html, std.ascii)\n    for functions that work with ASCII strings\n    ,\n    $(LINK2 std_uni.html, std.uni)\n    for functions that work with unicode strings\n    )\n\nMacros: WIKI = Phobos/StdString\n        SHORTXREF=$(XREF2 $1, $2, $(TT $2))\n        SHORTXREF_PACK=$(XREF_PACK_NAMED $1,$2,$3, $(TT $3))\n\nCopyright: Copyright Digital Mars 2007-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB digitalmars.com, Walter Bright),\n         $(WEB erdani.org, Andrei Alexandrescu),\n        Jonathan M Davis,\n        and David L. 'SpottedTiger' Davis\n\nSource:    $(PHOBOSSRC std/_string.d)\n\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/signals.d",
		"name": "std.signals",
		"members": [
			{
				"members": [
					{
						"name": "slot_t",
						"line": 154,
						"comment": " A slot is implemented as a delegate.\n The slot_t is the type of the delegate.\n The delegate must be to an instance of a class or an interface\n to a class instance.\n Delegates to struct instances or nested functions must not be\n used as slots.\n",
						"type": "void delegate(T1)",
						"char": 5,
						"kind": "alias"
					},
					{
						"endchar": 5,
						"name": "emit",
						"line": 159,
						"comment": " Call each of the connected slots, passing the argument(s) i to them.\n",
						"type": "void(T1 i)",
						"parameters": [
							{
								"name": "i",
								"type": "T1"
							}
						],
						"endline": 165,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "connect",
						"line": 170,
						"comment": " Add a slot to the list of slots to be called when emit() is called.\n",
						"type": "void(slot_t slot)",
						"parameters": [
							{
								"name": "slot",
								"type": "slot_t"
							}
						],
						"endline": 202,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "disconnect",
						"line": 207,
						"comment": " Remove a slot from the list of slots to be called when emit() is called.\n",
						"type": "void(slot_t slot)",
						"parameters": [
							{
								"name": "slot",
								"type": "slot_t"
							}
						],
						"endline": 223,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					}
				],
				"name": "Signal",
				"line": 142,
				"comment": " Mixin to create a signal within a class object.\n\n Different signals can be added to a class by naming the mixins.\n\n Example:\n---\nimport std.signals;\nimport std.stdio;\n\nclass Observer\n{   // our slot\n    void watch(string msg, int i)\n    {\n        writefln(\"Observed msg '%s' and value %s\", msg, i);\n    }\n}\n\nclass Foo\n{\n    int value() { return _value; }\n\n    int value(int v)\n    {\n        if (v != _value)\n        {   _value = v;\n            // call all the connected slots with the two parameters\n            emit(\"setting new value\", v);\n        }\n        return v;\n    }\n\n    // Mix in all the code we need to make Foo into a signal\n    mixin Signal!(string, int);\n\n  private :\n    int _value;\n}\n\nvoid main()\n{\n    Foo a = new Foo;\n    Observer o = new Observer;\n\n    a.value = 3;                // should not call o.watch()\n    a.connect(&o.watch);        // o.watch is the slot\n    a.value = 4;                // should call o.watch()\n    a.disconnect(&o.watch);     // o.watch is no longer a slot\n    a.value = 5;                // so should not call o.watch()\n    a.connect(&o.watch);        // connect again\n    a.value = 6;                // should call o.watch()\n    destroy(o);                 // destroying o should automatically disconnect it\n    a.value = 7;                // should not call o.watch()\n}\n---\n which should print:\n <pre>\n Observed msg 'setting new value' and value 4\n Observed msg 'setting new value' and value 6\n </pre>\n\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "tuple"
					}
				],
				"char": 7,
				"kind": "template"
			}
		],
		"comment": " Signals and Slots are an implementation of the Observer Pattern.\n Essentially, when a Signal is emitted, a list of connected Observers\n (called slots) are called.\n\n There have been several D implementations of Signals and Slots.\n This version makes use of several new features in D, which make\n using it simpler and less error prone. In particular, it is no\n longer necessary to instrument the slots.\n\n References:\n      $(LUCKY A Deeper Look at Signals and Slots)$(BR)\n      $(LINK2 http://en.wikipedia.org/wiki/Observer_pattern, Observer pattern)$(BR)\n      $(LINK2 http://en.wikipedia.org/wiki/Signals_and_slots, Wikipedia)$(BR)\n      $(LINK2 http://boost.org/doc/html/$(SIGNALS).html, Boost Signals)$(BR)\n      $(LINK2 http://qt-project.org/doc/qt-5/signalsandslots.html, Qt)$(BR)\n\n      There has been a great deal of discussion in the D newsgroups\n      over this, and several implementations:\n\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html, signal slots library)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/Signals_and_Slots_in_D_42387.html, Signals and Slots in D)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/Dynamic_binding_--_Qt_s_Signals_and_Slots_vs_Objective-C_42260.html, Dynamic binding -- Qt's Signals and Slots vs Objective-C)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/Dissecting_the_SS_42377.html, Dissecting the SS)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/dwt/about_harmonia_454.html, about harmonia)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/announce/1502.html, Another event handling module)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/41825.html, Suggestion: signal/slot mechanism)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/13251.html, Signals and slots?)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/10714.html, Signals and slots ready for evaluation)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/1393.html, Signals &amp; Slots for Walter)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/28456.html, Signal/Slot mechanism?)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/19470.html, Modern Features?)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/16592.html, Delegates vs interfaces)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/16583.html, The importance of component programming (properties$(COMMA) signals and slots$(COMMA) etc))$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/16368.html, signals and slots)$(BR)\n\n Bugs:\n      Slots can only be delegates formed from class objects or\n      interfaces to class objects. If a delegate to something else\n      is passed to connect(), such as a struct member function,\n      a nested function or a COM interface, undefined behavior\n      will result.\n\n      Not safe for multiple threads operating on the same signals\n      or slots.\n Macros:\n      WIKI = Phobos/StdSignals\n      SIGNALS=signals\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_signals.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/variant.d",
		"name": "std.variant",
		"members": [
			{
				"members": [],
				"name": "maxSize",
				"line": 77,
				"comment": "    Gives the $(D sizeof) the largest type given.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "VariantN",
						"line": 122,
						"members": [
							{
								"name": "AllowedTypes",
								"line": 127,
								"comment": "    The list of allowed types. If empty, any type is allowed.\n",
								"type": "This2Variant!(VariantN, AllowedTypesParam)",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"name": "allowed",
										"line": 144,
										"deco": "b",
										"init": "is(T == VariantN) || (AllowedTypes.length == 0 || staticIndexOf!(T, AllowedTypes) >= 0)",
										"char": 19,
										"kind": "variable",
										"storageClass": [
											"enum"
										]
									}
								],
								"name": "allowed",
								"line": 142,
								"comment": " Tells whether a type $(D T) is statically allowed for\n storage inside a $(D VariantN) object by looking\n $(D T) up in $(D AllowedTypes).\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 544,
										"type": "(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 549,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 544,
								"comment": " Constructs a $(D VariantN) value given an argument of a\n generic type. Statically rejects disallowed types.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 552,
										"type": "(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 556,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 552,
								"comment": "Allows assignment from a subset algebraic type\n",
								"parameters": [
									{
										"name": "T",
										"type": "VariantN!(tsize, Types)",
										"kind": "type"
									},
									{
										"name": "tsize",
										"type": "size_t",
										"kind": "value"
									},
									{
										"name": "Types",
										"kind": "tuple"
									}
								],
								"constraint": "!is(T : VariantN) && Types.length > 0 && allSatisfy!(allowed, Types)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 577,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 635,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 577,
								"comment": " Assigns a $(D VariantN) from a generic\n argument. Statically rejects disallowed types.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "hasValue",
								"line": 665,
								"comment": " Returns true if and only if the $(D VariantN) object\n holds a valid value (has been initialized with, or assigned\n from, a valid value).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL672_2267)\n---\nVariant a;\nassert(!a.hasValue);\nVariant b;\na = b;\nassert(!a.hasValue); // still no value\na = 5;\nassert(a.hasValue);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL672_2267)\n",
								"type": "const pure nothrow @property bool()",
								"endline": 669,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "peek",
										"line": 690,
										"type": "inout @property inout(T)*()",
										"endline": 701,
										"char": 25,
										"kind": "function"
									}
								],
								"name": "peek",
								"line": 690,
								"comment": " If the $(D VariantN) object holds a value of the\n $(I exact) type $(D T), returns a pointer to that\n value. Otherwise, returns $(D null). In cases\n where $(D T) is statically disallowed, $(D\n peek) will not compile.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL704_2268)\n---\nVariant a = 5;\nauto b = a.peek!(int);\nassert(b !is null);\n*b = 6;\nassert(a == 6);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL704_2268)\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 25,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "type",
								"line": 717,
								"comment": " Returns the $(D typeid) of the currently held value.\n",
								"type": "const nothrow @property @trusted TypeInfo()",
								"endline": 724,
								"char": 24,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "convertsTo",
										"line": 733,
										"type": "const @property bool()",
										"endline": 737,
										"char": 20,
										"kind": "function"
									}
								],
								"name": "convertsTo",
								"line": 733,
								"comment": " Returns $(D true) if and only if the $(D VariantN)\n object holds an object implicitly convertible to type $(D\n U). Implicit convertibility is defined as per\n $(LINK2 std_traits.html#ImplicitConversionTargets,ImplicitConversionTargets).\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 20,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "get",
										"line": 750,
										"type": "inout @property inout(T)()",
										"endline": 763,
										"char": 24,
										"kind": "function"
									}
								],
								"name": "get",
								"line": 750,
								"comment": "    Returns the value stored in the `VariantN` object, either by specifying the\n    needed type or the index in the list of allowed types. The latter overload\n    only applies to bounded variants (e.g. $(LREF Algebraic)).\n\n    Params:\n    T = The requested type. The currently stored value must implicitly convert\n    to the requested type, in fact `DecayStaticToDynamicArray!T`. If an\n    implicit conversion is not possible, throws a `VariantException`.\n    index = The index of the type among `AllowedTypesParam`, zero-based.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 24,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "get",
										"line": 766,
										"type": "inout @property ()",
										"endline": 774,
										"char": 20,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "get",
								"line": 766,
								"comment": "Ditto\n",
								"parameters": [
									{
										"name": "index",
										"deco": "k",
										"kind": "value"
									}
								],
								"constraint": "index < AllowedTypes.length",
								"char": 20,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "coerce",
										"line": 786,
										"type": "@property T()",
										"endline": 828,
										"char": 17,
										"kind": "function"
									}
								],
								"name": "coerce",
								"line": 786,
								"comment": " Returns the value stored in the $(D VariantN) object,\n explicitly converted (coerced) to the requested type $(D\n T). If $(D T) is a string type, the value is formatted as\n a string. If the $(D VariantN) object is a string, a\n parse of the string to type $(D T) is attempted. If a\n conversion is not possible, throws a $(D\n VariantException).\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 17,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 834,
								"comment": " Formats the stored value as a string.\n",
								"type": "string()",
								"endline": 839,
								"char": 12,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opEquals",
										"line": 846,
										"type": "const bool(auto ref T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 854,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opEquals",
								"line": 846,
								"comment": " Comparison for equality used by the \"==\" and \"!=\"  operators.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opCmp",
										"line": 868,
										"type": "int(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 882,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "opCmp",
								"line": 868,
								"comment": " Ordering comparison used by the \"<\", \"<=\", \">\", and \">=\"\n operators. In case comparison is not sensible between the held\n value and $(D rhs), an exception is thrown.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 9,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "toHash",
								"line": 888,
								"comment": " Computes the hash of the held value.\n",
								"type": "const nothrow @safe size_t()",
								"endline": 891,
								"char": 12,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opAdd",
										"line": 977,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 977,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAdd",
								"line": 977,
								"comment": " Arithmetic between $(D VariantN) objects and numeric\n values. All arithmetic operations return a $(D VariantN)\n object typed depending on the types of both values\n involved. The conversion rules mimic D's built-in rules for\n arithmetic conversions.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opSub",
										"line": 979,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 979,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opSub",
								"line": 979,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opMul",
										"line": 990,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 990,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opMul",
								"line": 990,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opDiv",
										"line": 992,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 992,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opDiv",
								"line": 992,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opMod",
										"line": 999,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 999,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opMod",
								"line": 999,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 62,
										"name": "opAnd",
										"line": 1006,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1006,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAnd",
								"line": 1006,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 61,
										"name": "opOr",
										"line": 1008,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1008,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opOr",
								"line": 1008,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 62,
										"name": "opXor",
										"line": 1010,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1010,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opXor",
								"line": 1010,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 63,
										"name": "opShl",
										"line": 1012,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1012,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opShl",
								"line": 1012,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 63,
										"name": "opShr",
										"line": 1019,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1019,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opShr",
								"line": 1019,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opUShr",
										"line": 1026,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1026,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opUShr",
								"line": 1026,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opCat",
										"line": 1033,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1038,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opCat",
								"line": 1033,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opAddAssign",
										"line": 1048,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1048,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAddAssign",
								"line": 1048,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opSubAssign",
										"line": 1050,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1050,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opSubAssign",
								"line": 1050,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opMulAssign",
										"line": 1052,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1052,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opMulAssign",
								"line": 1052,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opDivAssign",
										"line": 1054,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1054,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opDivAssign",
								"line": 1054,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opModAssign",
										"line": 1056,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1056,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opModAssign",
								"line": 1056,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opAndAssign",
										"line": 1058,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1058,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAndAssign",
								"line": 1058,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opOrAssign",
										"line": 1060,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1060,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opOrAssign",
								"line": 1060,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opXorAssign",
										"line": 1062,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1062,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opXorAssign",
								"line": 1062,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 66,
										"name": "opShlAssign",
										"line": 1064,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1064,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opShlAssign",
								"line": 1064,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 66,
										"name": "opShrAssign",
										"line": 1066,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1066,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opShrAssign",
								"line": 1066,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opUShrAssign",
										"line": 1068,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1068,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opUShrAssign",
								"line": 1068,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opCatAssign",
										"line": 1070,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1075,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opCatAssign",
								"line": 1070,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndex",
										"line": 1082,
										"type": "Variant(K i)",
										"parameters": [
											{
												"name": "i",
												"type": "K"
											}
										],
										"endline": 1087,
										"char": 13,
										"kind": "function"
									}
								],
								"name": "opIndex",
								"line": 1082,
								"comment": " Array and associative array operations. If a $(D\n VariantN) contains an (associative) array, it can be indexed\n into. Otherwise, an exception is thrown.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1090_2269)\n---\nauto a = Variant(new int[10]);\na[5] = 42;\nassert(a[5] == 42);\nint[int] hash = [ 42:24 ];\na = hash;\nassert(a[42] == 24);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1090_2269)\nExample:\nCaveat:\n    Due to limitations in current language, read-modify-write\n    operations $(D op=) will not work properly:$(DDOX_UNITTEST_HEADER __unittestL1104_2270)\n---\nVariant a = new int[10];\na[5] = 42;\na[5] += 8;\n//assert(a[5] == 50); // will fail, a[5] is still 42\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1104_2270)\n",
								"parameters": [
									{
										"name": "K",
										"kind": "type"
									}
								],
								"char": 13,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndexAssign",
										"line": 1122,
										"type": "Variant(T value, N i)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											},
											{
												"name": "i",
												"type": "N"
											}
										],
										"endline": 1127,
										"char": 13,
										"kind": "function"
									}
								],
								"name": "opIndexAssign",
								"line": 1122,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									},
									{
										"name": "N",
										"kind": "type"
									}
								],
								"char": 13,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 1133,
								"comment": " If the $(D VariantN) contains an (associative) array,\n returns the length of that array. Otherwise, throws an\n exception.\n",
								"type": "@property size_t()",
								"endline": 1136,
								"char": 22,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opApply",
										"line": 1142,
										"type": "int(scope Delegate dg)",
										"parameters": [
											{
												"name": "dg",
												"type": "Delegate",
												"storageClass": [
													"scope"
												]
											}
										],
										"endline": 1172,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "opApply",
								"line": 1142,
								"comment": "       If the $(D VariantN) contains an array, applies $(D dg) to each\n       element of the array in turn. Otherwise, throws an exception.\n",
								"parameters": [
									{
										"name": "Delegate",
										"kind": "type"
									}
								],
								"constraint": "is(Delegate == delegate)",
								"char": 9,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "VariantN",
				"line": 122,
				"comment": " $(D VariantN) is a back-end type seldom used directly by user\n code. Two commonly-used types using $(D VariantN) as\n back-end are:\n\n $(OL $(LI $(B Algebraic): A closed discriminated union with a\n limited type universe (e.g., $(D Algebraic!(int, double,\n string)) only accepts these three types and rejects anything\n else).) $(LI $(B Variant): An open discriminated union allowing an\n unbounded set of types. If any of the types in the $(D Variant)\n are larger than the largest built-in type, they will automatically\n be boxed. This means that even large types will only be the size\n of a pointer within the $(D Variant), but this also implies some\n overhead. $(D Variant) can accommodate all primitive types and\n all user-defined types.))\n\n Both $(D Algebraic) and $(D Variant) share $(D\n VariantN)'s interface. (See their respective documentations below.)\n\n $(D VariantN) is a discriminated union type parameterized\n with the largest size of the types stored ($(D maxDataSize))\n and with the list of allowed types ($(D AllowedTypes)). If\n the list is empty, then any type up of size up to $(D\n maxDataSize) (rounded up for alignment) can be stored in a\n $(D VariantN) object without being boxed (types larger\n than this will be boxed).\n\n",
				"parameters": [
					{
						"name": "maxDataSize",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "AllowedTypesParam",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Algebraic",
						"line": 1342,
						"type": "VariantN!(maxSize!T, T)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Algebraic",
				"line": 1340,
				"comment": "Algebraic data type restricted to a closed set of possible\ntypes. It's an alias for a $(LREF VariantN) with an\nappropriately-constructed maximum size. `Algebraic` is\nuseful when it is desirable to restrict what a discriminated type\ncould hold to the end of defining simpler and more efficient\nmanipulation.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1346_2285)\n---\nauto v = Algebraic!(int, double, string)(5);\nassert(v.peek!(int));\nv = 3.14;\nassert(v.peek!(double));\n// auto x = v.peek!(long); // won't compile, type long not allowed\n// v = '1'; // won't compile, type char not allowed\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1346_2285)\nExample:\n$(H4 Self-Referential Types)\n\nA useful and popular use of algebraic data structures is for defining $(LUCKY\nself-referential data structures), i.e. structures that embed references to\nvalues of their own type within.\n\nThis is achieved with `Algebraic` by using `This` as a placeholder whenever a\nreference to the type being defined is needed. The `Algebraic` instantiation\nwill perform $(LUCKY alpha renaming) on its constituent types, replacing `This`\nwith the self-referenced type. The structure of the type involving `This` may\nbe arbitrarily complex.$(DDOX_UNITTEST_HEADER __unittestL1369_2286)\n---\n// A tree is either a leaf or a branch of two other trees\nalias Tree(Leaf) = Algebraic!(Leaf, Tuple!(This*, This*));\nTree!int tree = tuple(new Tree!int(42), new Tree!int(43));\nTree!int* right = tree.get!1[1];\nassert(*right == 43);\n\n// An object is a double, a string, or a hash of objects\nalias Obj = Algebraic!(double, string, This[string]);\nObj obj = \"hello\";\nassert(obj.get!1 == \"hello\");\nobj = 42.0;\nassert(obj.get!0 == 42);\nobj = [\"customer\": Obj(\"John\"), \"paid\": Obj(23.95)];\nassert(obj.get!2[\"customer\"] == \"John\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1369_2286)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "Variant",
				"line": 1395,
				"comment": "`Variant` is an alias for `VariantN` instantiated with the largest of `creal`,\n`char[]`, and `void delegate()`. This ensures that `Variant` is large enough\nto hold all of D's predefined types unboxed, including all numeric types,\npointers, delegates, and class references.  You may want to use\n$(D VariantN) directly with a different maximum size either for\nstoring larger types unboxed, or for saving memory.\n",
				"deco": "S3std7variant18__T8VariantNVmi32Z8VariantN",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "variantArray",
						"line": 1404,
						"type": "Variant[](T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 1412,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "variantArray",
				"line": 1404,
				"comment": " Returns an array of variants constructed from $(D args).\n\n This is by design. During construction the $(D Variant) needs\n static type information about the type being held, so as to store a\n pointer to function for fast retrieval.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1415_2287)\n---\nauto a = variantArray(1, 3.14, \"Hi!\");\nassert(a[1] == 3.14);\nauto b = Variant(a); // variant array as variant\nassert(b[1] == 3.14);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1415_2287)\nExample:\nCode that needs functionality similar to the $(D boxArray)\nfunction in the $(D std.boxer) module can achieve it like this:$(DDOX_UNITTEST_HEADER __unittestL1426_2288)\n---\nVariant[] fun(T...)(T args)\n{\n    // ...\n    return variantArray(args);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1426_2288)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "source",
						"line": 1452,
						"comment": "The source type in the conversion or comparison\n",
						"deco": "C8TypeInfo",
						"originalType": "TypeInfo",
						"char": 14,
						"kind": "variable"
					},
					{
						"offset": 80,
						"name": "target",
						"line": 1454,
						"comment": "The target type in the conversion or comparison\n",
						"deco": "C8TypeInfo",
						"originalType": "TypeInfo",
						"char": 14,
						"kind": "variable"
					}
				],
				"name": "VariantException",
				"line": 1449,
				"comment": "\n/**\n Thrown in three cases:\n\n $(OL $(LI An uninitialized Variant is used in any way except\n assignment and $(D hasValue);) $(LI A $(D get) or\n $(D coerce) is attempted with an incompatible target type;)\n $(LI A comparison between $(D Variant) objects of\n incompatible types is attempted.))\n\n",
				"base": "object.Exception",
				"char": 8,
				"kind": "class"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "visit",
								"line": 1988,
								"type": "(VariantType variant)",
								"parameters": [
									{
										"name": "variant",
										"type": "VariantType"
									}
								],
								"endline": 1992,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "visit",
						"line": 1988,
						"parameters": [
							{
								"name": "VariantType",
								"kind": "type"
							}
						],
						"constraint": "isAlgebraic!VariantType",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "visit",
				"line": 1985,
				"comment": " Applies a delegate or function to the given Algebraic depending on the held type,\n ensuring that all types are handled by the visiting functions.\n\n The delegate or function having the currently held value as parameter is called\n with $(D variant)'s current value. Visiting handlers are passed\n in the template parameter list.\n It is statically ensured that all types of\n $(D variant) are handled across all handlers.\n $(D visit) allows delegates and static functions to be passed\n as parameters.\n\n If a function without parameters is specified, this function is called\n when variant doesn't hold a value. Exactly one parameter-less function\n is allowed.\n\n Duplicate overloads matching the same type in one of the visitors are disallowed.\n\n Returns: The return type of visit is deduced from the visiting functions and must be\n the same across all overloads.\n Throws: If no parameter-less, error function is specified:\n $(D VariantException) if $(D variant) doesn't hold a value.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1996_2310)\n---\nAlgebraic!(int, string) variant;\n\nvariant = 10;\nassert(variant.visit!((string s) => cast(int)s.length,\n                      (int i)    => i)()\n                      == 10);\nvariant = \"string\";\nassert(variant.visit!((int i) => i,\n                      (string s) => cast(int)s.length)()\n                      == 6);\n\n// Error function usage\nAlgebraic!(int, string) emptyVar;\nauto rslt = emptyVar.visit!((string s) => cast(int)s.length,\n                      (int i)    => i,\n                      () => -1)();\nassert(rslt == -1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1996_2310)\n",
				"parameters": [
					{
						"name": "Handler",
						"kind": "tuple"
					}
				],
				"constraint": "Handler.length > 0",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "tryVisit",
								"line": 2094,
								"type": "(VariantType variant)",
								"parameters": [
									{
										"name": "variant",
										"type": "VariantType"
									}
								],
								"endline": 2098,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "tryVisit",
						"line": 2094,
						"parameters": [
							{
								"name": "VariantType",
								"kind": "type"
							}
						],
						"constraint": "isAlgebraic!VariantType",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "tryVisit",
				"line": 2091,
				"comment": " Behaves as $(D visit) but doesn't enforce that all types are handled\n by the visiting functions.\n\n If a parameter-less function is specified it is called when\n either $(D variant) doesn't hold a value or holds a type\n which isn't handled by the visiting functions.\n\n Returns: The return type of tryVisit is deduced from the visiting functions and must be\n the same across all overloads.\n Throws: If no parameter-less, error function is specified: $(D VariantException) if\n         $(D variant) doesn't hold a value or\n         if $(D variant) holds a value which isn't handled by the visiting\n         functions.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2102_2313)\n---\nAlgebraic!(int, string) variant;\n\nvariant = 10;\nauto which = -1;\nvariant.tryVisit!((int i) { which = 0; })();\nassert(which == 0);\n\n// Error function usage\nvariant = \"test\";\nvariant.tryVisit!((int i) { which = 0; },\n                  ()      { which = -100; })();\nassert(which == -100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2102_2313)\n",
				"parameters": [
					{
						"name": "Handler",
						"kind": "tuple"
					}
				],
				"constraint": "Handler.length > 0",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module implements a\n$(WEB erdani.org/publications/cuj-04-2002.html,discriminated union)\ntype (a.k.a.\n$(WEB en.wikipedia.org/wiki/Tagged_union,tagged union),\n$(WEB en.wikipedia.org/wiki/Algebraic_data_type,algebraic type)).\nSuch types are useful\nfor type-uniform binary interfaces, interfacing with scripting\nlanguages, and comfortable exploratory programming.\n\nMacros:\n WIKI = Phobos/StdVariant\n\nSynopsis:\n----\nVariant a; // Must assign before use, otherwise exception ensues\n// Initialize with an integer; make the type int\nVariant b = 42;\nassert(b.type == typeid(int));\n// Peek at the value\nassert(b.peek!(int) !is null && *b.peek!(int) == 42);\n// Automatically convert per language rules\nauto x = b.get!(real);\n// Assign any other type, including other variants\na = b;\na = 3.14;\nassert(a.type == typeid(double));\n// Implicit conversions work just as with built-in types\nassert(a < b);\n// Check for convertibility\nassert(!a.convertsTo!(int)); // double not convertible to int\n// Strings and all other arrays are supported\na = \"now I'm a string\";\nassert(a == \"now I'm a string\");\na = new int[42]; // can also assign arrays\nassert(a.length == 42);\na[5] = 7;\nassert(a[5] == 7);\n// Can also assign class values\nclass Foo {}\nauto foo = new Foo;\na = foo;\nassert(*a.peek!(Foo) == foo); // and full type information is preserved\n----\n\nA $(LREF Variant) object can hold a value of any type, with very few\nrestrictions (such as `shared` types and noncopyable types). Setting the value\nis as immediate as assigning to the `Variant` object. To read back the value of\nthe appropriate type `T`, use the $(LREF get!T) call. To query whether a\n`Variant` currently holds a value of type `T`, use $(LREF peek!T). To fetch the\nexact type currently held, call $(LREF type), which returns the `TypeInfo` of\nthe current value.\n\nIn addition to $(LREF Variant), this module also defines the $(LREF Algebraic)\ntype constructor. Unlike `Variant`, `Algebraic` only allows a finite set of\ntypes, which are specified in the instantiation (e.g. $(D Algebraic!(int,\nstring)) may only hold an `int` or a `string`).\n\nCredits: Reviewed by Brad Roberts. Daniel Keep provided a detailed code review\nprompting the following improvements: (1) better support for arrays; (2) support\nfor associative arrays; (3) friendlier behavior towards the garbage collector.\nCopyright: Copyright Andrei Alexandrescu 2007 - 2015.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\nSource:    $(PHOBOSSRC std/_variant.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/md.d",
		"name": "std.digest.md",
		"members": [
			{
				"name": "MD5",
				"line": 98,
				"comment": " Template API MD5 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL405_2330)\n---\n//Simple example, hashing a string using md5Of helper function\nubyte[16] hash = md5Of(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"900150983CD24FB0D6963F7D28E17F72\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL405_2330)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL414_2331)\n---\n//Using the basic API\nMD5 hash;\nhash.start();\nubyte[1024] data;\n//Initialize data here...\nhash.put(data);\nubyte[16] result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL414_2331)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL426_2332)\n---\n//Let's use the template features:\nvoid doSomething(T)(ref T hash) if(isDigest!T)\n{\n    hash.put(cast(ubyte)0);\n}\nMD5 md5;\nmd5.start();\ndoSomething(md5);\nassert(toHexString(md5.finish()) == \"93B885ADFE0DA089CDF634904FD59F71\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL426_2332)\n",
				"members": [
					{
						"endchar": 9,
						"name": "put",
						"line": 303,
						"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\n\n Example:\n ----\n MD5 dig;\n dig.put(cast(ubyte)0); //single ubyte\n dig.put(cast(ubyte)0, cast(ubyte)0); //variadic\n ubyte[10] buf;\n dig.put(buf); //buffer\n ----\n",
						"deco": "FNaNbNiNeMAxhXv",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "Axh"
							}
						],
						"endline": 337,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "start",
						"line": 355,
						"comment": " Used to (re)initialize the MD5 digest.\n\n Note:\n For this MD5 Digest implementation calling start after default construction\n is not necessary. Calling start is only necessary to reset the Digest.\n\n Generic code which deals with different Digest types should always call start though.\n\n Example:\n --------\n MD5 digest;\n //digest.start(); //Not necessary\n digest.put(0);\n --------\n",
						"deco": "FNaNbNiNfZv",
						"endline": 358,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "finish",
						"line": 364,
						"comment": " Returns the finished MD5 hash. This also calls $(LREF start) to\n reset the internal state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL394_2329)\n---\n//Simple example\nMD5 hash;\nhash.start();\nhash.put(cast(ubyte)0);\nubyte[16] result = hash.finish();\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL394_2329)\n",
						"deco": "FNaNbNiNeZG16h",
						"endline": 392,
						"char": 19,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "md5Of",
						"line": 499,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 502,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "md5Of",
				"line": 499,
				"comment": " This is a convenience alias for $(XREF_PACK digest,digest,digest) using the\n MD5 implementation.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL505_2335)\n---\nubyte[16] hash = md5Of(\"abc\");\nassert(hash == digest!MD5(\"abc\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL505_2335)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"name": "MD5Digest",
				"line": 518,
				"comment": " OOP API MD5 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\n\n This is an alias for $(D $(XREF_PACK digest,digest,WrapperDigest)!MD5), see\n there for more information.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL521_2336)\n---\n//Simple example, hashing a string using Digest.digest helper function\nauto md5 = new MD5Digest();\nubyte[] hash = md5.digest(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"900150983CD24FB0D6963F7D28E17F72\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL521_2336)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL531_2337)\n---\n//Let's use the OOP features:\nvoid test(Digest dig)\n{\n dig.put(cast(ubyte)0);\n}\nauto md5 = new MD5Digest();\ntest(md5);\n\n//Let's use a custom buffer:\nubyte[16] buf;\nubyte[] result = md5.finish(buf[]);\nassert(toHexString(result) == \"93B885ADFE0DA089CDF634904FD59F71\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL531_2337)\n",
				"deco": "C3std6digest6digest39__T13WrapperDigestTS3std6digest2md3MD5Z13WrapperDigest",
				"char": 1,
				"kind": "alias"
			}
		],
		"comment": " Computes MD5 hashes of arbitrary data. MD5 hashes are 16 byte quantities that are like a\n checksum or CRC, but are more robust.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Template API) $(TD $(MYREF MD5)\n)\n)\n$(TR $(TDNW OOP API) $(TD $(MYREF MD5Digest))\n)\n$(TR $(TDNW Helpers) $(TD $(MYREF md5Of))\n)\n)\n)\n\n This module conforms to the APIs defined in $(D std.digest.digest). To understand the\n differences between the template and the OOP API, see $(D std.digest.digest).\n\n This module publicly imports $(D std.digest.digest) and can be used as a stand-alone\n module.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n CTFE:\n Digests do not work in CTFE\n\n Authors:\n Piotr Szturmaj, Kai Nacke, Johannes Pfau $(BR)\n The routines and algorithms are derived from the $(I RSA Data Security, Inc. MD5 Message-Digest Algorithm).\n\n References:\n      $(LINK2 http://en.wikipedia.org/wiki/Md5, Wikipedia on MD5)\n\n Source: $(PHOBOSSRC std/digest/_md.d)\n\n Macros:\n WIKI = Phobos/StdMd5\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL53_2327)\n---\n//Template API\nimport std.digest.md;\n\n//Feeding data\nubyte[1024] data;\nMD5 md5;\nmd5.start();\nmd5.put(data[]);\nmd5.start(); //Start again\nmd5.put(data[]);\nauto hash = md5.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL53_2327)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL69_2328)\n---\n//OOP API\nimport std.digest.md;\n\nauto md5 = new MD5Digest();\nubyte[] hash = md5.digest(\"abc\");\nassert(toHexString(hash) == \"900150983CD24FB0D6963F7D28E17F72\");\n\n//Feeding data\nubyte[1024] data;\nmd5.put(data[]);\nmd5.reset(); //Start again\nmd5.put(data[]);\nhash = md5.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL69_2328)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/digest.d",
		"name": "std.digest.digest",
		"members": [
			{
				"name": "ExampleDigest",
				"line": 202,
				"comment": " This documents the general structure of a Digest in the template API.\n All digest implementations should implement the following members and therefore pass\n the $(LREF isDigest) test.\n\n Note:\n $(UL\n $(LI A digest must be a struct (value type) to pass the $(LREF isDigest) test.)\n $(LI A digest passing the $(LREF isDigest) test is always an $(D OutputRange))\n )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL256_2343)\n---\n//Using the OutputRange feature\nimport std.algorithm : copy;\nimport std.range : repeat;\nimport std.digest.md;\n\nauto oneMillionRange = repeat!ubyte(cast(ubyte)'a', 1000000);\nauto ctx = makeDigest!MD5();\ncopy(oneMillionRange, &ctx); //Note: You must pass a pointer to copy!\nassert(ctx.finish().toHexString() == \"7707D6AE4E027C70EEA2A935C2296F21\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL256_2343)\n",
				"members": [
					{
						"endchar": 13,
						"name": "put",
						"line": 220,
						"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\n The following usages of $(D put) must work for any type which\n passes $(LREF isDigest):\n Example:\n ----\n ExampleDigest dig;\n dig.put(cast(ubyte)0); //single ubyte\n dig.put(cast(ubyte)0, cast(ubyte)0); //variadic\n ubyte[10] buf;\n dig.put(buf); //buffer\n ----\n",
						"deco": "FNeMAxhXv",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "Axh"
							}
						],
						"endline": 223,
						"char": 27,
						"kind": "function"
					},
					{
						"endchar": 13,
						"name": "start",
						"line": 230,
						"comment": " This function is used to (re)initialize the digest.\n It must be called before using the digest and it also works as a 'reset' function\n if the digest has already processed data.\n",
						"deco": "FNeZv",
						"endline": 233,
						"char": 27,
						"kind": "function"
					},
					{
						"endchar": 13,
						"name": "finish",
						"line": 248,
						"comment": " The finish function returns the final hash sum and resets the Digest.\n\n Note:\n The actual type returned by finish depends on the digest implementation.\n $(D ubyte[16]) is just used as an example. It is guaranteed that the type is a\n static array of ubytes.\n\n $(UL\n $(LI Use $(LREF DigestType) to obtain the actual return type.)\n $(LI Use $(LREF digestLength) to obtain the length of the ubyte array.)\n )\n",
						"deco": "FNeZG16h",
						"endline": 251,
						"char": 32,
						"kind": "function"
					}
				],
				"char": 5,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "isDigest",
						"line": 285,
						"deco": "b",
						"init": "isOutputRange!(T, const(ubyte)[]) && isOutputRange!(T, ubyte) && is(T == struct) && is(typeof(()\n{\nT dig = void;\ndig.put(cast(ubyte)0, cast(ubyte)0);\ndig.start();\nauto value = dig.finish();\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isDigest",
				"line": 282,
				"comment": " Use this to check if a type is a digest. See $(LREF ExampleDigest) to see what\n a type must provide to pass this check.\n\n Note:\n This is very useful as a template constraint (see examples)\n\n BUGS:\n $(UL\n $(LI Does not yet verify that put takes scope parameters.)\n $(LI Should check that finish() returns a ubyte[num] array)\n )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL297_2344)\n---\nimport std.digest.crc;\nstatic assert(isDigest!CRC32);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL297_2344)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL303_2345)\n---\nimport std.digest.crc;\nvoid myFunction(T)() if(isDigest!T)\n{\n    T dig;\n    dig.start();\n    auto result = dig.finish();\n}\nmyFunction!CRC32();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL303_2345)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "DigestType",
				"line": 318,
				"comment": " Use this template to get the type which is returned by a digest's $(LREF finish) method.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL334_2346)\n---\nimport std.digest.crc;\nassert(is(DigestType!(CRC32) == ubyte[4]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL334_2346)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL340_2347)\n---\nimport std.digest.crc;\nCRC32 dig;\ndig.start();\nDigestType!CRC32 result = dig.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL340_2347)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasPeek",
						"line": 361,
						"deco": "b",
						"init": "isDigest!T && is(typeof(()\n{\nT dig = void;\nDigestType!T val = dig.peek();\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasPeek",
				"line": 359,
				"comment": " Used to check if a digest supports the $(D peek) method.\n Peek has exactly the same function signatures as finish, but it doesn't reset\n the digest's internal state.\n\n Note:\n $(UL\n $(LI This is very useful as a template constraint (see examples))\n $(LI This also checks if T passes $(LREF isDigest))\n )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL370_2348)\n---\nimport std.digest.crc, std.digest.md;\nassert(!hasPeek!(MD5));\nassert(hasPeek!CRC32);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL370_2348)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL377_2349)\n---\nimport std.digest.crc;\nvoid myFunction(T)() if(hasPeek!T)\n{\n    T dig;\n    dig.start();\n    auto result = dig.peek();\n}\nmyFunction!CRC32();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL377_2349)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasBlockSize",
						"line": 397,
						"deco": "b",
						"init": "__traits(compiles, ()\n{\nsize_t blockSize = T.blockSize;\n}\n)",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasBlockSize",
				"line": 394,
				"comment": " Checks whether the digest has a $(D blockSize) member, which contains the\n digest's internal block size in bits. It is primarily used by $(XREF digest.hmac, HMAC).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL401_2350)\n---\nimport std.digest.md, std.digest.hmac;\nstatic assert(hasBlockSize!MD5        && MD5.blockSize      == 512);\nstatic assert(hasBlockSize!(HMAC!MD5) && HMAC!MD5.blockSize == 512);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL401_2350)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isDigest!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "digest",
						"line": 427,
						"type": "DigestType!Hash(auto ref Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 435,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "digest",
				"line": 427,
				"comment": " This is a convenience function to calculate a hash using the template API.\n Every digest passing the $(LREF isDigest) test can be used with this function.\n\n Params:\n  range= an $(D InputRange) with $(D ElementType) $(D ubyte), $(D ubyte[]) or $(D ubyte[num])\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL438_2351)\n---\nimport std.digest.md;\nimport std.range : repeat;\nauto testRange = repeat!ubyte(cast(ubyte)'a', 100);\nauto md5 = digest!MD5(testRange);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL438_2351)\n",
				"parameters": [
					{
						"name": "Hash",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "!isArray!Range && isDigestibleRange!Range",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "digest",
						"line": 452,
						"type": "DigestType!Hash(scope const T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T",
								"storageClass": [
									"scope",
									"const"
								]
							}
						],
						"endline": 459,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "digest",
				"line": 452,
				"comment": " This overload of the digest function handles arrays.\n\n Params:\n  data= one or more arrays of any type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL462_2352)\n---\nimport std.digest.md, std.digest.sha, std.digest.crc;\nauto md5   = digest!MD5(  \"The quick brown fox jumps over the lazy dog\");\nauto sha1  = digest!SHA1( \"The quick brown fox jumps over the lazy dog\");\nauto crc32 = digest!CRC32(\"The quick brown fox jumps over the lazy dog\");\nassert(toHexString(crc32) == \"39A34F41\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL462_2352)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL472_2353)\n---\nimport std.digest.crc;\nauto crc32 = digest!CRC32(\"The quick \", \"brown \", \"fox jumps over the lazy dog\");\nassert(toHexString(crc32) == \"39A34F41\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL472_2353)\n",
				"parameters": [
					{
						"name": "Hash",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isArray, typeof(data))",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "hexDigest",
						"line": 488,
						"type": "char[digestLength!Hash * 2](ref Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 492,
						"char": 29,
						"kind": "function"
					}
				],
				"name": "hexDigest",
				"line": 488,
				"comment": " This is a convenience function similar to $(LREF digest), but it returns the string\n representation of the hash. Every digest passing the $(LREF isDigest) test can be used with this\n function.\n\n Params:\n  order= the order in which the bytes are processed (see $(LREF toHexString))\n  range= an $(D InputRange) with $(D ElementType) $(D ubyte), $(D ubyte[]) or $(D ubyte[num])\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL495_2354)\n---\nimport std.digest.md;\nimport std.range : repeat;\nauto testRange = repeat!ubyte(cast(ubyte)'a', 100);\nassert(hexDigest!MD5(testRange) == \"36A92CC94A9E0FA21F625F8BFB007ADF\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL495_2354)\n",
				"parameters": [
					{
						"name": "Hash",
						"kind": "type"
					},
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "!isArray!Range && isDigestibleRange!Range",
				"char": 29,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "hexDigest",
						"line": 510,
						"type": "char[digestLength!Hash * 2](scope const T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T",
								"storageClass": [
									"scope",
									"const"
								]
							}
						],
						"endline": 514,
						"char": 29,
						"kind": "function"
					}
				],
				"name": "hexDigest",
				"line": 510,
				"comment": " This overload of the hexDigest function handles arrays.\n\n Params:\n  order= the order in which the bytes are processed (see $(LREF toHexString))\n  data= one or more arrays of any type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL517_2355)\n---\nimport std.digest.crc;\nassert(hexDigest!(CRC32, Order.decreasing)(\"The quick brown fox jumps over the lazy dog\") == \"414FA339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL517_2355)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL523_2356)\n---\nimport std.digest.crc;\nassert(hexDigest!(CRC32, Order.decreasing)(\"The quick \", \"brown \", \"fox jumps over the lazy dog\") == \"414FA339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL523_2356)\n",
				"parameters": [
					{
						"name": "Hash",
						"kind": "type"
					},
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isArray, typeof(data))",
				"char": 29,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeDigest",
						"line": 533,
						"type": "Hash()",
						"endline": 538,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "makeDigest",
				"line": 533,
				"comment": " This is a convenience function which returns an initialized digest, so it's not necessary to call\n start manually.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL541_2357)\n---\nimport std.digest.md;\nauto md5 = makeDigest!MD5();\nmd5.put(0);\nassert(toHexString(md5.finish()) == \"93B885ADFE0DA089CDF634904FD59F71\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL541_2357)\n",
				"parameters": [
					{
						"name": "Hash",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"name": "Digest",
				"line": 560,
				"comment": " This describes the OOP API. To understand when to use the template API and when to use the OOP API,\n see the module documentation at the top of this page.\n\n The Digest interface is the base interface which is implemented by all digests.\n\n Note:\n A Digest implementation is always an $(D OutputRange)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL621_2358)\n---\n//Using the OutputRange feature\nimport std.algorithm : copy;\nimport std.range : repeat;\nimport std.digest.md;\n\nauto oneMillionRange = repeat!ubyte(cast(ubyte)'a', 1000000);\nauto ctx = new MD5Digest();\ncopy(oneMillionRange, ctx);\nassert(ctx.finish().toHexString() == \"7707D6AE4E027C70EEA2A935C2296F21\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL621_2358)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL635_2359)\n---\nimport std.digest.md, std.digest.sha, std.digest.crc;\nubyte[] md5   = (new MD5Digest()).digest(\"The quick brown fox jumps over the lazy dog\");\nubyte[] sha1  = (new SHA1Digest()).digest(\"The quick brown fox jumps over the lazy dog\");\nubyte[] crc32 = (new CRC32Digest()).digest(\"The quick brown fox jumps over the lazy dog\");\nassert(crcHexString(crc32) == \"414FA339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL635_2359)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL645_2360)\n---\nimport std.digest.crc;\nubyte[] crc32 = (new CRC32Digest()).digest(\"The quick \", \"brown \", \"fox jumps over the lazy dog\");\nassert(crcHexString(crc32) == \"414FA339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL645_2360)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL660_2362)\n---\nvoid test(Digest dig)\n{\n    dig.put(cast(ubyte)0); //single ubyte\n    dig.put(cast(ubyte)0, cast(ubyte)0); //variadic\n    ubyte[10] buf;\n    dig.put(buf); //buffer\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL660_2362)\n",
				"members": [
					{
						"name": "put",
						"line": 579,
						"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\n\n Example:\n ----\n void test(Digest dig)\n {\n     dig.put(cast(ubyte)0); //single ubyte\n     dig.put(cast(ubyte)0, cast(ubyte)0); //variadic\n     ubyte[10] buf;\n     dig.put(buf); //buffer\n }\n ----\n",
						"deco": "FNbNeMAxhXv",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "Axh"
							}
						],
						"char": 31,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "reset",
						"line": 587,
						"comment": " Resets the internal state of the digest.\n Note:\n $(LREF finish) calls this internally, so it's not necessary to call\n $(D reset) manually after a call to $(LREF finish).\n",
						"deco": "FNbNeZv",
						"char": 31,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "length",
						"line": 593,
						"comment": " This is the length in bytes of the hash value which is returned by $(LREF finish).\n It's also the required size of a buffer passed to $(LREF finish).\n",
						"deco": "xFNbNdNeZm",
						"originalType": "const nothrow @property @trusted size_t()",
						"char": 43,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "finish",
						"line": 599,
						"comment": " The finish function returns the hash value. It takes an optional buffer to copy the data\n into. If a buffer is passed, it must be at least $(LREF length) bytes big.\n",
						"deco": "FNbNeZAh",
						"char": 34,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "finish",
						"line": 601,
						"comment": "ditto\n",
						"deco": "FNbMAhZAh",
						"parameters": [
							{
								"name": "buf",
								"storageClass": [
									"scope"
								],
								"deco": "Ah"
							}
						],
						"char": 25,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"endchar": 9,
						"name": "digest",
						"line": 611,
						"comment": " This is a convenience function to calculate the hash of a value using the OOP API.\n",
						"deco": "FNbNeMAxAvXAh",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "AxAv"
							}
						],
						"endline": 617,
						"char": 40,
						"kind": "function",
						"storageClass": [
							"final",
							"abstract"
						]
					}
				],
				"char": 1,
				"kind": "interface"
			},
			{
				"members": [
					{
						"name": "increasing",
						"line": 678,
						"value": "false",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "decreasing",
						"line": 679,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Order",
				"line": 676,
				"comment": " See $(LREF toHexString)\n",
				"baseDeco": "b",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toHexString",
						"line": 700,
						"type": "char[num * 2](in ubyte[num] digest)",
						"parameters": [
							{
								"name": "digest",
								"type": "ubyte[num]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 735,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "toHexString",
				"line": 700,
				"comment": " Used to convert a hash value (a static or dynamic array of ubytes) to a string.\n Can be used with the OOP and with the template API.\n\n The additional order parameter can be used to specify the order of the input data.\n By default the data is processed in increasing order, starting at index 0. To process it in the\n opposite order, pass Order.decreasing as a parameter.\n\n The additional letterCase parameter can be used to specify the case of the output data.\n By default the output is in upper case. To change it to the lower case\n pass LetterCase.lower as a parameter.\n\n Note:\n The function overloads returning a string allocate their return values\n using the GC. The versions returning static arrays use pass-by-value for\n the return value, effectively avoiding dynamic allocation.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL789_2363)\n---\nimport std.digest.crc;\n//Test with template API:\nauto crc32 = digest!CRC32(\"The quick \", \"brown \", \"fox jumps over the lazy dog\");\n//Lower case variant:\nassert(toHexString!(LetterCase.lower)(crc32) == \"39a34f41\");\n//Usually CRCs are printed in this order, though:\nassert(toHexString!(Order.decreasing)(crc32) == \"414FA339\");\nassert(toHexString!(LetterCase.lower, Order.decreasing)(crc32) == \"414fa339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL789_2363)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL802_2364)\n---\nimport std.digest.crc;\n// With OOP API\nauto crc32 = (new CRC32Digest()).digest(\"The quick \", \"brown \", \"fox jumps over the lazy dog\");\n//Usually CRCs are printed in this order, though:\nassert(toHexString!(Order.decreasing)(crc32) == \"414FA339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL802_2364)\n",
				"parameters": [
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					},
					{
						"name": "num",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "letterCase",
						"defaultValue": "LetterCase.upper",
						"deco": "E3std5ascii10LetterCase",
						"kind": "value"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toHexString",
						"line": 738,
						"type": "char[num * 2](in ubyte[num] digest)",
						"parameters": [
							{
								"name": "digest",
								"type": "ubyte[num]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 741,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "toHexString",
				"line": 738,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "letterCase",
						"deco": "E3std5ascii10LetterCase",
						"kind": "value"
					},
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					},
					{
						"name": "num",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toHexString",
						"line": 744,
						"type": "string(in ubyte[] digest)",
						"parameters": [
							{
								"name": "digest",
								"type": "ubyte[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 778,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "toHexString",
				"line": 744,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					},
					{
						"name": "letterCase",
						"defaultValue": "LetterCase.upper",
						"deco": "E3std5ascii10LetterCase",
						"kind": "value"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toHexString",
						"line": 781,
						"type": "string(in ubyte[] digest)",
						"parameters": [
							{
								"name": "digest",
								"type": "ubyte[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 784,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "toHexString",
				"line": 781,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "letterCase",
						"deco": "E3std5ascii10LetterCase",
						"kind": "value"
					},
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "digestLength",
						"line": 843,
						"type": "size_t",
						"init": "(ReturnType!(T.finish)).length",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "digestLength",
				"line": 841,
				"comment": " This helper is used internally in the WrapperDigest template, but it might be\n useful for other purposes as well. It returns the length (in bytes) of the hash value\n produced by T.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isDigest!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "WrapperDigest",
						"line": 851,
						"members": [
							{
								"endchar": 9,
								"name": "this",
								"line": 860,
								"comment": " Initializes the digest.\n",
								"type": "()",
								"endline": 863,
								"char": 9,
								"kind": "constructor"
							},
							{
								"endchar": 9,
								"name": "put",
								"line": 870,
								"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\n",
								"type": "nothrow @trusted void(scope const(ubyte)[] data...)",
								"parameters": [
									{
										"name": "data",
										"type": "const(ubyte)[]",
										"storageClass": [
											"scope"
										]
									}
								],
								"endline": 873,
								"char": 31,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "reset",
								"line": 881,
								"comment": " Resets the internal state of the digest.\n Note:\n $(LREF finish) calls this internally, so it's not necessary to call\n $(D reset) manually after a call to $(LREF finish).\n",
								"type": "nothrow @trusted void()",
								"endline": 884,
								"char": 31,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "length",
								"line": 890,
								"comment": " This is the length in bytes of the hash value which is returned by $(LREF finish).\n It's also the required size of a buffer passed to $(LREF finish).\n",
								"type": "const pure nothrow @property @trusted size_t()",
								"endline": 893,
								"char": 43,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "finish",
								"line": 912,
								"comment": " The finish function returns the hash value. It takes an optional buffer to copy the data\n into. If a buffer is passed, it must have a length at least $(LREF length) bytes.\n\n Example:\n --------\n\n import std.digest.md;\n ubyte[16] buf;\n auto hash = new WrapperDigest!MD5();\n hash.put(cast(ubyte)0);\n auto result = hash.finish(buf[]);\n //The result is now in result (and in buf). If you pass a buffer which is bigger than\n //necessary, result will have the correct length, but buf will still have it's original\n //length\n --------\n",
								"type": "nothrow ubyte[](scope ubyte[] buf)",
								"parameters": [
									{
										"name": "buf",
										"type": "ubyte[]",
										"storageClass": [
											"scope"
										]
									}
								],
								"endline": 923,
								"char": 25,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "finish",
								"line": 926,
								"comment": "ditto\n",
								"type": "nothrow @trusted ubyte[]()",
								"endline": 932,
								"char": 34,
								"kind": "function"
							},
							{
								"name": "peek",
								"line": 942,
								"comment": " Works like $(D finish) but does not reset the internal state, so it's possible\n to continue putting data into this WrapperDigest after a call to peek.\n\n These functions are only available if $(D hasPeek!T) is true.\n",
								"type": "const @trusted ubyte[](scope ubyte[] buf)",
								"parameters": [
									{
										"name": "buf",
										"type": "ubyte[]",
										"storageClass": [
											"scope"
										]
									}
								],
								"char": 30,
								"kind": "function"
							},
							{
								"name": "peek",
								"line": 944,
								"comment": "ditto\n",
								"type": "const @trusted ubyte[]()",
								"char": 30,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "WrapperDigest",
				"line": 851,
				"comment": " Wraps a template API hash struct into a Digest interface.\n Modules providing digest implementations will usually provide\n an alias for this template (e.g. MD5Digest, SHA1Digest, ...).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL972_2366)\n---\nimport std.digest.md;\n//Simple example\nauto hash = new WrapperDigest!MD5();\nhash.put(cast(ubyte)0);\nauto result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL972_2366)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL982_2367)\n---\n//using a supplied buffer\nimport std.digest.md;\nubyte[16] buf;\nauto hash = new WrapperDigest!MD5();\nhash.put(cast(ubyte)0);\nauto result = hash.finish(buf[]);\n//The result is now in result (and in buf). If you pass a buffer which is bigger than\n//necessary, result will have the correct length, but buf will still have it's original\n//length\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL982_2367)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isDigest!T",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": " This module describes the _digest APIs used in Phobos. All digests follow\n these APIs. Additionally, this module contains useful helper methods which\n can be used with every _digest type.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Template API) $(TD $(MYREF isDigest) $(MYREF DigestType) $(MYREF hasPeek)\n  $(MYREF hasBlockSize)\n  $(MYREF ExampleDigest) $(MYREF _digest) $(MYREF hexDigest) $(MYREF makeDigest)\n)\n)\n$(TR $(TDNW OOP API) $(TD $(MYREF Digest)\n)\n)\n$(TR $(TDNW Helper functions) $(TD $(MYREF toHexString))\n)\n$(TR $(TDNW Implementation helpers) $(TD $(MYREF digestLength) $(MYREF WrapperDigest))\n)\n)\n)\n\n APIs:\n There are two APIs for digests: The template API and the OOP API. The template API uses structs\n and template helpers like $(LREF isDigest). The OOP API implements digests as classes inheriting\n the $(LREF Digest) interface. All digests are named so that the template API struct is called \"$(B x)\"\n and the OOP API class is called \"$(B x)Digest\". For example we have $(D MD5) <--> $(D MD5Digest),\n $(D CRC32) <--> $(D CRC32Digest), etc.\n\n The template API is slightly more efficient. It does not have to allocate memory dynamically,\n all memory is allocated on the stack. The OOP API has to allocate in the finish method if no\n buffer was provided. If you provide a buffer to the OOP APIs finish function, it doesn't allocate,\n but the $(LREF Digest) classes still have to be created using $(D new) which allocates them using the GC.\n\n The OOP API is useful to change the _digest function and/or _digest backend at 'runtime'. The benefit here\n is that switching e.g. Phobos MD5Digest and an OpenSSLMD5Digest implementation is ABI compatible.\n\n If just one specific _digest type and backend is needed, the template API is usually a good fit.\n In this simplest case, the template API can even be used without templates: Just use the \"$(B x)\" structs\n directly.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:\n Johannes Pfau\n\n Source:    $(PHOBOSSRC std/_digest/_digest.d)\n\n CTFE:\n Digests do not work in CTFE\n\n TODO:\n Digesting single bits (as opposed to bytes) is not implemented. This will be done as another\n template constraint helper (hasBitDigesting!T) and an additional interface (BitDigest)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL72_2339)\n---\nimport std.digest.crc;\n\n//Simple example\nchar[8] hexHash = hexDigest!CRC32(\"The quick brown fox jumps over the lazy dog\");\nassert(hexHash == \"39A34F41\");\n\n//Simple example, using the API manually\nCRC32 context = makeDigest!CRC32();\ncontext.put(cast(ubyte[])\"The quick brown fox jumps over the lazy dog\");\nubyte[4] hash = context.finish();\nassert(toHexString(hash) == \"39A34F41\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL72_2339)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL88_2340)\n---\n//Generating the hashes of a file, idiomatic D way\nimport std.digest.crc, std.digest.sha, std.digest.md;\nimport std.stdio;\n\n// Digests a file and prints the result.\nvoid digestFile(Hash)(string filename) if(isDigest!Hash)\n{\n    auto file = File(filename);\n    auto result = digest!Hash(file.byChunk(4096 * 1024));\n    writefln(\"%s (%s) = %s\", Hash.stringof, filename, toHexString(result));\n}\n\nvoid main(string[] args)\n{\n    foreach (name; args[1 .. $])\n    {\n        digestFile!MD5(name);\n        digestFile!SHA1(name);\n        digestFile!CRC32(name);\n    }\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL88_2340)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL113_2341)\n---\n//Generating the hashes of a file using the template API\nimport std.digest.crc, std.digest.sha, std.digest.md;\nimport std.stdio;\n// Digests a file and prints the result.\nvoid digestFile(Hash)(ref Hash hash, string filename) if(isDigest!Hash)\n{\n    File file = File(filename);\n\n    //As digests imlement OutputRange, we could use std.algorithm.copy\n    //Let's do it manually for now\n    foreach (buffer; file.byChunk(4096 * 1024))\n        hash.put(buffer);\n\n    auto result = hash.finish();\n    writefln(\"%s (%s) = %s\", Hash.stringof, filename, toHexString(result));\n}\n\nvoid uMain(string[] args)\n{\n    MD5 md5;\n    SHA1 sha1;\n    CRC32 crc32;\n\n    md5.start();\n    sha1.start();\n    crc32.start();\n\n    foreach (arg; args[1 .. $])\n    {\n        digestFile(md5, arg);\n        digestFile(sha1, arg);\n        digestFile(crc32, arg);\n    }\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL113_2341)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL152_2342)\n---\nimport std.digest.crc, std.digest.sha, std.digest.md;\nimport std.stdio;\n\n// Digests a file and prints the result.\nvoid digestFile(Digest hash, string filename)\n{\n    File file = File(filename);\n\n    //As digests implement OutputRange, we could use std.algorithm.copy\n    //Let's do it manually for now\n    foreach (buffer; file.byChunk(4096 * 1024))\n      hash.put(buffer);\n\n    ubyte[] result = hash.finish();\n    writefln(\"%s (%s) = %s\", typeid(hash).toString(), filename, toHexString(result));\n}\n\nvoid umain(string[] args)\n{\n    auto md5 = new MD5Digest();\n    auto sha1 = new SHA1Digest();\n    auto crc32 = new CRC32Digest();\n\n    foreach (arg; args[1 .. $])\n    {\n      digestFile(md5, arg);\n      digestFile(sha1, arg);\n      digestFile(crc32, arg);\n    }\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL152_2342)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/hmac.d",
		"name": "std.digest.hmac",
		"members": [
			{
				"members": [
					{
						"name": "HMAC",
						"line": 60,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 72,
								"comment": " Constructs the HMAC digest using the specified secret.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL93_2369)\n---\nimport std.digest.sha, std.digest.hmac;\nimport std.string : representation;\nauto hmac = HMAC!SHA1(\"My s3cR3T keY\".representation);\nhmac.put(\"Hello, world\".representation);\nstatic immutable expected = [130, 32, 235, 44, 208, 141, 150, 232, 211, 214, 162, 195, 188, 127, 52, 89, 100, 68, 90, 216];\nassert(hmac.finish() == expected);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL93_2369)\n",
								"type": "(scope const(ubyte)[] secret)",
								"parameters": [
									{
										"name": "secret",
										"type": "const(ubyte)[]",
										"storageClass": [
											"scope"
										]
									}
								],
								"endline": 90,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "start",
								"line": 114,
								"comment": " Reinitializes the digest, making it ready for reuse.\n\n Note:\n The constructor leaves the digest in an initialized state, so that this\n method only needs to be called if an unfinished digest is to be reused.\n\n Returns:\n A reference to the digest for convenient chaining.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL127_2370)\n---\nimport std.digest.sha, std.digest.hmac;\nimport std.string : representation;\nstring data1 = \"Hello, world\", data2 = \"Hola mundo\";\nauto hmac = HMAC!SHA1(\"My s3cR3T keY\".representation);\nhmac.put(data1.representation);\nhmac.start();                   // reset digest\nhmac.put(data2.representation); // start over\nstatic immutable expected = [122, 151, 232, 240, 249, 80, 19, 178, 186, 77, 110, 23, 208, 52, 11, 88, 34, 151, 192, 255];\nassert(hmac.finish() == expected);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL127_2370)\n",
								"type": "ref return HMAC!(H, blockSize)()",
								"endline": 124,
								"char": 29,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "put",
								"line": 148,
								"comment": " Feeds a piece of data into the hash computation. This method allows the\n type to be used as an $(XREF range, OutputRange).\n\n Returns:\n A reference to the digest for convenient chaining.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL155_2371)\n---\nimport std.digest.sha, std.digest.hmac;\nimport std.string : representation;\nstring data1 = \"Hello, world\", data2 = \"Hola mundo\";\nauto hmac = HMAC!SHA1(\"My s3cR3T keY\".representation);\nhmac.put(data1.representation)\n    .put(data2.representation);\nstatic immutable expected = [197, 57, 52, 3, 13, 194, 13, 36, 117, 228, 8, 11, 111, 51, 165, 3, 123, 31, 251, 113];\nassert(hmac.finish() == expected);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL155_2371)\n",
								"type": "ref return HMAC!(H, blockSize)(in ubyte[] data...)",
								"parameters": [
									{
										"name": "data",
										"type": "ubyte[]",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 152,
								"char": 29,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "finish",
								"line": 171,
								"comment": " Resets the digest and returns the finished hash.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL188_2372)\n---\nimport std.digest.sha, std.digest.hmac;\nimport std.string : representation;\nstring data1 = \"Hello, world\", data2 = \"Hola mundo\";\nauto hmac = HMAC!SHA1(\"My s3cR3T keY\".representation);\nauto digest = hmac.put(data1.representation)\n                  .put(data2.representation)\n                  .finish();\nstatic immutable expected = [197, 57, 52, 3, 13, 194, 13, 36, 117, 228, 8, 11, 111, 51, 165, 3, 123, 31, 251, 113];\nassert(digest == expected);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL188_2372)\n",
								"type": "DigestType!H()",
								"endline": 185,
								"char": 18,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "HMAC",
				"line": 60,
				"comment": " Overload of HMAC to be used if H doesn't provide information about its\n block size.\n",
				"parameters": [
					{
						"name": "H",
						"kind": "type"
					},
					{
						"name": "hashBlockSize",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "hashBlockSize % 8 == 0",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This package implements the hash-based message authentication code (_HMAC)\nalgorithm as defined in $(WEB tools.ietf.org/html/rfc2104, RFC2104). See also\nthe corresponding $(WEB en.wikipedia.org/wiki/Hash-based_message_authentication_code, Wikipedia article).\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\nMacros:\nWIKI = Phobos/StdDigestHMAC\nSUBMODULE = $(LINK2 std_digest_$1.html, std.digest.$1)\nSUBREF = $(LINK2 std_digest_$1.html#.$2, $(TT $2))$(NBSP)\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nSource: $(PHOBOSSRC std/digest/_hmac.d)\nExample:\nComputes an HMAC over data read from stdin.\n\n Template API HMAC implementation.\n\n This implements an _HMAC over the digest H. If H doesn't provide\n information about the block size, it can be supplied explicitly using\n the second overload.\n\n This type conforms to $(XREF digest.digest, isDigest).$(DDOX_UNITTEST_HEADER __unittestL37_2368)\n---\nimport std.stdio, std.digest.hmac, std.digest.sha;\nimport std.string : representation;\n\nauto secret = \"secret\".representation;\nstdin.byChunk(4096)\n     .hmac!SHA1(secret)\n     .toHexString!(LetterCase.lower)\n     .writeln;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL37_2368)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/sha.d",
		"name": "std.digest.sha",
		"members": [
			{
				"members": [
					{
						"name": "SHA",
						"line": 203,
						"members": [
							{
								"endchar": 9,
								"name": "start",
								"line": 685,
								"comment": " SHA initialization. Begins an SHA1/SHA2 operation.\n\n Note:\n For this SHA Digest implementation calling start after default construction\n is not necessary. Calling start is only necessary to reset the Digest.\n\n Generic code which deals with different Digest types should always call start though.\n\n Example:\n --------\n SHA1 digest;\n //digest.start(); //Not necessary\n digest.put(0);\n --------\n",
								"type": "pure nothrow @nogc @safe void()",
								"endline": 688,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "put",
								"line": 695,
								"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL739_2380)\n---\ntypeof(this) dig;\ndig.put(cast(ubyte)0); //single ubyte\ndig.put(cast(ubyte)0, cast(ubyte)0); //variadic\nubyte[10] buf;\ndig.put(buf); //buffer\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL739_2380)\n",
								"type": "pure nothrow @nogc @trusted void(scope const(ubyte)[] input...)",
								"parameters": [
									{
										"name": "input",
										"type": "const(ubyte)[]",
										"storageClass": [
											"scope"
										]
									}
								],
								"endline": 737,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "finish",
								"line": 753,
								"comment": " Returns the finished SHA hash. This also calls $(LREF start) to\n reset the internal state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL809_2381)\n---\n//Simple example\nSHA1 hash;\nhash.start();\nhash.put(cast(ubyte)0);\nubyte[20] result = hash.finish();\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL809_2381)\n",
								"type": "pure nothrow @nogc @trusted ubyte[digestSize / 8]()",
								"endline": 807,
								"char": 29,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SHA",
				"line": 203,
				"comment": " Template API SHA1/SHA2 implementation. Supports: SHA-1, SHA-224, SHA-256,\n SHA-384, SHA-512, SHA-512/224 and SHA-512/256.\n\n The hashBlockSize and digestSize are in bits. However, it's likely easier to\n simply use the convenience aliases: SHA1, SHA224, SHA256, SHA384, SHA512,\n SHA512_224 and SHA512_256.\n\n See $(D std.digest.digest) for differences between template and OOP API.\n",
				"parameters": [
					{
						"name": "hashBlockSize",
						"deco": "k",
						"kind": "value"
					},
					{
						"name": "digestSize",
						"deco": "k",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "SHA1",
				"line": 819,
				"comment": "SHA alias for SHA-1, hash is ubyte[20]\n",
				"deco": "S3std6digest3sha20__T3SHAVki512Vki160Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA224",
				"line": 820,
				"comment": "SHA alias for SHA-224, hash is ubyte[28]\n",
				"deco": "S3std6digest3sha20__T3SHAVki512Vki224Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA256",
				"line": 821,
				"comment": "SHA alias for SHA-256, hash is ubyte[32]\n",
				"deco": "S3std6digest3sha20__T3SHAVki512Vki256Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA384",
				"line": 822,
				"comment": "SHA alias for SHA-384, hash is ubyte[48]\n",
				"deco": "S3std6digest3sha21__T3SHAVki1024Vki384Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512",
				"line": 823,
				"comment": "SHA alias for SHA-512, hash is ubyte[64]\n",
				"deco": "S3std6digest3sha21__T3SHAVki1024Vki512Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512_224",
				"line": 824,
				"comment": "SHA alias for SHA-512/224, hash is ubyte[28]\n",
				"deco": "S3std6digest3sha21__T3SHAVki1024Vki224Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512_256",
				"line": 825,
				"comment": "SHA alias for SHA-512/256, hash is ubyte[32]\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL828_2382)\n---\n//Simple example, hashing a string using sha1Of helper function\nubyte[20] hash = sha1Of(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\n//The same, but using SHA-224\nubyte[28] hash224 = sha224Of(\"abc\");\nassert(toHexString(hash224) == \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL828_2382)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL841_2383)\n---\n//Using the basic API\nSHA1 hash;\nhash.start();\nubyte[1024] data;\n//Initialize data here...\nhash.put(data);\nubyte[20] result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL841_2383)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL853_2384)\n---\n//Let's use the template features:\n//Note: When passing a SHA1 to a function, it must be passed by reference!\nvoid doSomething(T)(ref T hash) if(isDigest!T)\n{\n  hash.put(cast(ubyte)0);\n}\nSHA1 sha;\nsha.start();\ndoSomething(sha);\nassert(toHexString(sha.finish()) == \"5BA93C9DB0CFF93F52B521D7420E43F6EDA2784F\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL853_2384)\n",
				"deco": "S3std6digest3sha21__T3SHAVki1024Vki256Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha1Of",
						"line": 1101,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1104,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha1Of",
				"line": 1101,
				"comment": " These are convenience aliases for $(XREF_PACK digest,digest,digest) using the\n SHA implementation.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1137_2387)\n---\nubyte[20] hash = sha1Of(\"abc\");\nassert(hash == digest!SHA1(\"abc\"));\n\nubyte[28] hash224 = sha224Of(\"abc\");\nassert(hash224 == digest!SHA224(\"abc\"));\n\nubyte[32] hash256 = sha256Of(\"abc\");\nassert(hash256 == digest!SHA256(\"abc\"));\n\nubyte[48] hash384 = sha384Of(\"abc\");\nassert(hash384 == digest!SHA384(\"abc\"));\n\nubyte[64] hash512 = sha512Of(\"abc\");\nassert(hash512 == digest!SHA512(\"abc\"));\n\nubyte[28] hash512_224 = sha512_224Of(\"abc\");\nassert(hash512_224 == digest!SHA512_224(\"abc\"));\n\nubyte[32] hash512_256 = sha512_256Of(\"abc\");\nassert(hash512_256 == digest!SHA512_256(\"abc\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1137_2387)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha224Of",
						"line": 1106,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1109,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha224Of",
				"line": 1106,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha256Of",
						"line": 1111,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1114,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha256Of",
				"line": 1111,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha384Of",
						"line": 1116,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1119,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha384Of",
				"line": 1116,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha512Of",
						"line": 1121,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1124,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha512Of",
				"line": 1121,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha512_224Of",
						"line": 1126,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1129,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha512_224Of",
				"line": 1126,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha512_256Of",
						"line": 1131,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1134,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha512_256Of",
				"line": 1131,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"name": "SHA1Digest",
				"line": 1179,
				"comment": " OOP API SHA1 and SHA2 implementations.\n See $(D std.digest.digest) for differences between template and OOP API.\n\n This is an alias for $(D $(XREF_PACK digest,digest,WrapperDigest)!SHA1), see\n there for more information.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1188_2389)\n---\n//Simple example, hashing a string using Digest.digest helper function\nauto sha = new SHA1Digest();\nubyte[] hash = sha.digest(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\n//The same, but using SHA-224\nauto sha224 = new SHA224Digest();\nubyte[] hash224 = sha224.digest(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash224) == \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1188_2389)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1204_2390)\n---\n//Let's use the OOP features:\nvoid test(Digest dig)\n{\n  dig.put(cast(ubyte)0);\n}\nauto sha = new SHA1Digest();\ntest(sha);\n\n//Let's use a custom buffer:\nubyte[20] buf;\nubyte[] result = sha.finish(buf[]);\nassert(toHexString(result) == \"5BA93C9DB0CFF93F52B521D7420E43F6EDA2784F\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1204_2390)\n",
				"deco": "C3std6digest6digest62__T13WrapperDigestTS3std6digest3sha20__T3SHAVki512Vki160Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA224Digest",
				"line": 1180,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest62__T13WrapperDigestTS3std6digest3sha20__T3SHAVki512Vki224Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA256Digest",
				"line": 1181,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest62__T13WrapperDigestTS3std6digest3sha20__T3SHAVki512Vki256Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA384Digest",
				"line": 1182,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest63__T13WrapperDigestTS3std6digest3sha21__T3SHAVki1024Vki384Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512Digest",
				"line": 1183,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest63__T13WrapperDigestTS3std6digest3sha21__T3SHAVki1024Vki512Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512_224Digest",
				"line": 1184,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest63__T13WrapperDigestTS3std6digest3sha21__T3SHAVki1024Vki224Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512_256Digest",
				"line": 1185,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest63__T13WrapperDigestTS3std6digest3sha21__T3SHAVki1024Vki256Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			}
		],
		"comment": " Computes SHA1 and SHA2 hashes of arbitrary data. SHA hashes are 20 to 64 byte\n quantities (depending on the SHA algorithm) that are like a checksum or CRC,\n but are more robust.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Template API) $(TD $(MYREF SHA1)\n)\n)\n$(TR $(TDNW OOP API) $(TD $(MYREF SHA1Digest))\n)\n$(TR $(TDNW Helpers) $(TD $(MYREF sha1Of))\n)\n)\n)\n\n SHA2 comes in several different versions, all supported by this module:\n SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256.\n\n This module conforms to the APIs defined in $(D std.digest.digest). To understand the\n differences between the template and the OOP API, see $(D std.digest.digest).\n\n This module publicly imports $(D std.digest.digest) and can be used as a stand-alone\n module.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n CTFE:\n Digests do not work in CTFE\n\n Authors:\n The routines and algorithms are derived from the\n $(I Secure Hash Signature Standard (SHS) (FIPS PUB 180-2)). $(BR )\n Kai Nacke, Johannes Pfau, Nick Sabalausky\n\n References:\n $(UL\n $(LI $(LINK2 http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf, FIPS PUB180-2))\n $(LI $(LINK2 http://software.intel.com/en-us/articles/improving-the-performance-of-the-secure-hash-algorithm-1/, Fast implementation of SHA1))\n $(LI $(LINK2 http://en.wikipedia.org/wiki/Secure_Hash_Algorithm, Wikipedia article about SHA))\n )\n\n Source: $(PHOBOSSRC std/digest/_sha.d)\n\n Macros:\n      WIKI = Phobos/StdSha1\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL63_2378)\n---\n//Template API\nimport std.digest.sha;\n\nubyte[20] hash1 = sha1Of(\"abc\");\nassert(toHexString(hash1) == \"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\nubyte[28] hash224 = sha224Of(\"abc\");\nassert(toHexString(hash224) == \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n//Feeding data\nubyte[1024] data;\nSHA1 sha1;\nsha1.start();\nsha1.put(data[]);\nsha1.start(); //Start again\nsha1.put(data[]);\nhash1 = sha1.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL63_2378)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL85_2379)\n---\n//OOP API\nimport std.digest.sha;\n\nauto sha1 = new SHA1Digest();\nubyte[] hash1 = sha1.digest(\"abc\");\nassert(toHexString(hash1) == \"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\nauto sha224 = new SHA224Digest();\nubyte[] hash224 = sha224.digest(\"abc\");\nassert(toHexString(hash224) == \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n//Feeding data\nubyte[1024] data;\nsha1.put(data[]);\nsha1.reset(); //Start again\nsha1.put(data[]);\nhash1 = sha1.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL85_2379)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/crc.d",
		"name": "std.digest.crc",
		"members": [
			{
				"name": "CRC32",
				"line": 151,
				"comment": " Template API CRC32 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL231_2397)\n---\n//Simple example, hashing a string using crc32Of helper function\nubyte[4] hash = crc32Of(\"abc\");\n//Let's get a hash string\nassert(crcHexString(hash) == \"352441C2\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL231_2397)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL240_2398)\n---\n//Using the basic API\nCRC32 hash;\nubyte[1024] data;\n//Initialize data here...\nhash.put(data);\nubyte[4] result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL240_2398)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL251_2399)\n---\n//Let's use the template features:\n//Note: When passing a CRC32 to a function, it must be passed by reference!\nvoid doSomething(T)(ref T hash) if(isDigest!T)\n{\n  hash.put(cast(ubyte)0);\n}\nCRC32 crc;\ncrc.start();\ndoSomething(crc);\nassert(crcHexString(crc.finish()) == \"D202EF8D\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL251_2399)\n",
				"members": [
					{
						"endchar": 9,
						"name": "put",
						"line": 163,
						"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL169_2394)\n---\nCRC32 dig;\ndig.put(cast(ubyte)0); //single ubyte\ndig.put(cast(ubyte)0, cast(ubyte)0); //variadic\nubyte[10] buf;\ndig.put(buf); //buffer\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL169_2394)\n",
						"deco": "FNaNbNiNeMAxhXv",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "Axh"
							}
						],
						"endline": 167,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "start",
						"line": 187,
						"comment": " Used to initialize the CRC32 digest.\n\n Note:\n For this CRC32 Digest implementation calling start after default construction\n is not necessary. Calling start is only necessary to reset the Digest.\n\n Generic code which deals with different Digest types should always call start though.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL192_2395)\n---\nCRC32 digest;\n//digest.start(); //Not necessary\ndigest.put(0);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL192_2395)\n",
						"deco": "FNaNbNiNfZv",
						"endline": 190,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "finish",
						"line": 203,
						"comment": " Returns the finished CRC32 hash. This also calls $(LREF start) to\n reset the internal state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL210_2396)\n---\n//Simple example\nCRC32 hash;\nhash.put(cast(ubyte)0);\nubyte[4] result = hash.finish();\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL210_2396)\n",
						"deco": "FNaNbNiNfZG4h",
						"endline": 208,
						"char": 18,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "peek",
						"line": 222,
						"comment": " Works like $(D finish) but does not reset the internal state, so it's possible\n to continue putting data into this CRC32 after a call to peek.\n",
						"deco": "xFNaNbNiNfZG4h",
						"endline": 227,
						"char": 18,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "crc32Of",
						"line": 322,
						"type": "ubyte[4](T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 325,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "crc32Of",
				"line": 322,
				"comment": " This is a convenience alias for $(XREF_PACK digest,digest,digest) using the\n CRC32 implementation.\n\n Params:\n      data = $(D InputRange) of $(D ElementType) implicitly convertible to\n             $(D ubyte), $(D ubyte[]) or $(D ubyte[num]) or one or more arrays\n             of any type.\n\n Returns:\n      CRC32 of data\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL328_2402)\n---\nubyte[] data = [4,5,7,25];\nassert(data.crc32Of == [167, 180, 199, 131]);\n\nimport std.utf : byChar;\nassert(\"hello\"d.byChar.crc32Of == [134, 166, 16, 54]);\n\nubyte[4] hash = \"abc\".crc32Of();\nassert(hash == digest!CRC32(\"ab\", \"c\"));\n\nimport std.range : iota;\nenum ubyte S = 5, F = 66;\nassert(iota(S, F).crc32Of == [59, 140, 234, 154]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL328_2402)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 10,
				"kind": "template"
			},
			{
				"name": "crcHexString",
				"line": 348,
				"comment": " This is a convenience alias for $(XREF_PACK digest,digest,toHexString)\n producing the usual CRC32 string output.\n",
				"char": 8,
				"kind": "alias"
			},
			{
				"name": "crcHexString",
				"line": 350,
				"comment": "ditto\n",
				"char": 8,
				"kind": "alias"
			},
			{
				"name": "CRC32Digest",
				"line": 360,
				"comment": " OOP API CRC32 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\n\n This is an alias for $(D $(XREF_PACK digest,digest,WrapperDigest)!CRC32), see\n there for more information.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL363_2403)\n---\n//Simple example, hashing a string using Digest.digest helper function\nauto crc = new CRC32Digest();\nubyte[] hash = crc.digest(\"abc\");\n//Let's get a hash string\nassert(crcHexString(hash) == \"352441C2\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL363_2403)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL373_2404)\n---\n//Let's use the OOP features:\nvoid test(Digest dig)\n{\n dig.put(cast(ubyte)0);\n}\nauto crc = new CRC32Digest();\ntest(crc);\n\n//Let's use a custom buffer:\nubyte[4] buf;\nubyte[] result = crc.finish(buf[]);\nassert(crcHexString(result) == \"D202EF8D\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL373_2404)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL390_2405)\n---\n//Simple example\nauto hash = new CRC32Digest();\nhash.put(cast(ubyte)0);\nubyte[] result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL390_2405)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL399_2406)\n---\n//using a supplied buffer\nubyte[4] buf;\nauto hash = new CRC32Digest();\nhash.put(cast(ubyte)0);\nubyte[] result = hash.finish(buf[]);\n//The result is now in result (and in buf. If you pass a buffer which is bigger than\n//necessary, result will have the correct length, but buf will still have it's original\n//length)\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL399_2406)\n",
				"deco": "C3std6digest6digest42__T13WrapperDigestTS3std6digest3crc5CRC32Z13WrapperDigest",
				"char": 1,
				"kind": "alias"
			}
		],
		"comment": "Cyclic Redundancy Check (32-bit) implementation.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Template API) $(TD $(MYREF CRC32)\n)\n)\n$(TR $(TDNW OOP API) $(TD $(MYREF CRC32Digest))\n)\n$(TR $(TDNW Helpers) $(TD $(MYREF crcHexString) $(MYREF crc32Of))\n)\n)\n)\n\n\n This module conforms to the APIs defined in $(D std.digest.digest). To understand the\n differences between the template and the OOP API, see $(D std.digest.digest).\n\n This module publicly imports $(D std.digest.digest) and can be used as a stand-alone\n module.\n\n Note:\n CRCs are usually printed with the MSB first. When using\n $(XREF_PACK digest,digest,toHexString) the result will be in an unexpected\n order. Use $(XREF_PACK digest,digest,toHexString)'s optional order parameter\n to specify decreasing order for the correct result. The $(LREF crcHexString)\n alias can also be used for this purpose.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n Authors:   Pavel \"EvilOne\" Minayev, Alex Rønne Petersen, Johannes Pfau\n\n References:\n      $(LINK2 http://en.wikipedia.org/wiki/Cyclic_redundancy_check, Wikipedia on CRC)\n\n Source: $(PHOBOSSRC std/digest/_crc.d)\n\n Macros:\n WIKI = Phobos/StdUtilDigestCRC32\n\n Standards:\n Implements the 'common' IEEE CRC32 variant\n (LSB-first order, Initial value uint.max, complement result)\n\n CTFE:\n Digests do not work in CTFE\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL71_2392)\n---\n//Template API\nimport std.digest.crc;\n\nubyte[4] hash = crc32Of(\"The quick brown fox jumps over the lazy dog\");\nassert(crcHexString(hash) == \"414FA339\");\n\n//Feeding data\nubyte[1024] data;\nCRC32 crc;\ncrc.put(data[]);\ncrc.start(); //Start again\ncrc.put(data[]);\nhash = crc.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL71_2392)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL89_2393)\n---\n//OOP API\nimport std.digest.crc;\n\nauto crc = new CRC32Digest();\nubyte[] hash = crc.digest(\"The quick brown fox jumps over the lazy dog\");\nassert(crcHexString(hash) == \"414FA339\"); //352441c2\n\n//Feeding data\nubyte[1024] data;\ncrc.put(data[]);\ncrc.reset(); //Start again\ncrc.put(data[]);\nhash = crc.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL89_2393)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/ripemd.d",
		"name": "std.digest.ripemd",
		"members": [
			{
				"name": "RIPEMD160",
				"line": 102,
				"comment": " Template API RIPEMD160 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL563_2410)\n---\n//Simple example, hashing a string using ripemd160Of helper function\nubyte[20] hash = ripemd160Of(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"8EB208F7E05D987A9B044A8E98C6B087F15A0BFC\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL563_2410)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL572_2411)\n---\n//Using the basic API\nRIPEMD160 hash;\nhash.start();\nubyte[1024] data;\n//Initialize data here...\nhash.put(data);\nubyte[20] result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL572_2411)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL584_2412)\n---\n//Let's use the template features:\nvoid doSomething(T)(ref T hash) if(isDigest!T)\n{\n    hash.put(cast(ubyte)0);\n}\nRIPEMD160 md;\nmd.start();\ndoSomething(md);\nassert(toHexString(md.finish()) == \"C81B94933420221A7AC004A90242D8B1D3E5070D\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL584_2412)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL598_2413)\n---\n//Simple example\nRIPEMD160 hash;\nhash.start();\nhash.put(cast(ubyte)0);\nubyte[20] result = hash.finish();\nassert(toHexString(result) == \"C81B94933420221A7AC004A90242D8B1D3E5070D\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL598_2413)\n",
				"members": [
					{
						"endchar": 9,
						"name": "put",
						"line": 459,
						"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\n\n Example:\n ----\n RIPEMD160 dig;\n dig.put(cast(ubyte)0); //single ubyte\n dig.put(cast(ubyte)0, cast(ubyte)0); //variadic\n ubyte[10] buf;\n dig.put(buf); //buffer\n ----\n",
						"deco": "FNaNbNiNeMAxhXv",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "Axh"
							}
						],
						"endline": 493,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "start",
						"line": 511,
						"comment": " Used to (re)initialize the RIPEMD160 digest.\n\n Note:\n For this RIPEMD160 Digest implementation calling start after default construction\n is not necessary. Calling start is only necessary to reset the Digest.\n\n Generic code which deals with different Digest types should always call start though.\n\n Example:\n --------\n RIPEMD160 digest;\n //digest.start(); //Not necessary\n digest.put(0);\n --------\n",
						"deco": "FNaNbNiNfZv",
						"endline": 514,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "finish",
						"line": 530,
						"comment": " Returns the finished RIPEMD160 hash. This also calls $(LREF start) to\n reset the internal state.\n\n Example:\n --------\n //Simple example\n RIPEMD160 hash;\n hash.start();\n hash.put(cast(ubyte)0);\n ubyte[20] result = hash.finish();\n assert(toHexString(result) == \"C81B94933420221A7AC004A90242D8B1D3E5070D\");\n --------\n",
						"deco": "FNaNbNiNeZG20h",
						"endline": 559,
						"char": 19,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ripemd160Of",
						"line": 668,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 671,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "ripemd160Of",
				"line": 668,
				"comment": " This is a convenience alias for $(XREF_PACK digest,digest,digest) using the\n RIPEMD160 implementation.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL674_2416)\n---\nubyte[20] hash = ripemd160Of(\"abc\");\nassert(hash == digest!RIPEMD160(\"abc\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL674_2416)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"name": "RIPEMD160Digest",
				"line": 687,
				"comment": " OOP API RIPEMD160 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\n\n This is an alias for $(D $(XREF_PACK digest,digest,WrapperDigest)!RIPEMD160),\n see there for more information.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL690_2417)\n---\n//Simple example, hashing a string using Digest.digest helper function\nauto md = new RIPEMD160Digest();\nubyte[] hash = md.digest(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"8EB208F7E05D987A9B044A8E98C6B087F15A0BFC\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL690_2417)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL700_2418)\n---\n//Let's use the OOP features:\nvoid test(Digest dig)\n{\n  dig.put(cast(ubyte)0);\n}\nauto md = new RIPEMD160Digest();\ntest(md);\n\n//Let's use a custom buffer:\nubyte[20] buf;\nubyte[] result = md.finish(buf[]);\nassert(toHexString(result) == \"C81B94933420221A7AC004A90242D8B1D3E5070D\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL700_2418)\n",
				"deco": "C3std6digest6digest49__T13WrapperDigestTS3std6digest6ripemd9RIPEMD160Z13WrapperDigest",
				"char": 1,
				"kind": "alias"
			}
		],
		"comment": " Computes RIPEMD-160 hashes of arbitrary data. RIPEMD-160 hashes are 20 byte quantities\n that are like a checksum or CRC, but are more robust.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Template API) $(TD $(MYREF RIPEMD160)\n)\n)\n$(TR $(TDNW OOP API) $(TD $(MYREF RIPEMD160Digest))\n)\n$(TR $(TDNW Helpers) $(TD $(MYREF ripemd160Of))\n)\n)\n)\n\n This module conforms to the APIs defined in $(D std.digest.digest). To understand the\n differences between the template and the OOP API, see $(D std.digest.digest).\n\n This module publicly imports $(D std.digest.digest) and can be used as a stand-alone\n module.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n CTFE:\n Digests do not work in CTFE\n\n Authors:\n Kai Nacke $(BR)\n The algorithm was designed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel. $(BR)\n The D implementation is a direct translation of the ANSI C implementation by Antoon Bosselaers.\n\n References:\n $(UL\n $(LI $(LINK2 http://homes.esat.kuleuven.be/~bosselae/ripemd160.html, The hash function RIPEMD-160))\n $(LI $(LINK2 http://en.wikipedia.org/wiki/RIPEMD-160, Wikipedia on RIPEMD-160))\n )\n\n Source: $(PHOBOSSRC std/digest/_ripemd.d)\n\n Macros:\n WIKI = Phobos/StdRipemd\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL54_2408)\n---\n//Template API\nimport std.digest.md;\n\nubyte[20] hash = ripemd160Of(\"abc\");\nassert(toHexString(hash) == \"8EB208F7E05D987A9B044A8E98C6B087F15A0BFC\");\n\n//Feeding data\nubyte[1024] data;\nRIPEMD160 md;\nmd.start();\nmd.put(data[]);\nmd.start(); //Start again\nmd.put(data[]);\nhash = md.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL54_2408)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL73_2409)\n---\n//OOP API\nimport std.digest.md;\n\nauto md = new RIPEMD160Digest();\nubyte[] hash = md.digest(\"abc\");\nassert(toHexString(hash) == \"8EB208F7E05D987A9B044A8E98C6B087F15A0BFC\");\n\n//Feeding data\nubyte[1024] data;\nmd.put(data[]);\nmd.reset(); //Start again\nmd.put(data[]);\nhash = md.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL73_2409)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/random.d",
		"name": "std.random",
		"members": [
			{
				"members": [
					{
						"name": "isUniformRNG",
						"line": 135,
						"deco": "b",
						"init": "isInputRange!Rng && is(typeof(Rng.front) == ElementType) && is(typeof(()\n{\nstatic assert(Rng.isUniformRandom);\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isUniformRNG",
				"line": 133,
				"comment": " Test if Rng is a random-number generator. The overload\n taking a ElementType also makes sure that the Rng generates\n values of that type.\n\n A random-number generator has at least the following features:\n $(UL\n   $(LI it's an InputRange)\n   $(LI it has a 'bool isUniformRandom' field readable in CTFE)\n )\n",
				"parameters": [
					{
						"name": "Rng",
						"kind": "type"
					},
					{
						"name": "ElementType",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isUniformRNG",
						"line": 148,
						"deco": "b",
						"init": "isInputRange!Rng && is(typeof(()\n{\nstatic assert(Rng.isUniformRandom);\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isUniformRNG",
				"line": 146,
				"comment": " ditto\n",
				"parameters": [
					{
						"name": "Rng",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSeedable",
						"line": 166,
						"deco": "b",
						"init": "isUniformRNG!Rng && is(typeof(()\n{\nRng r = void;\nr.seed(SeedType.init);\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSeedable",
				"line": 164,
				"comment": " Test if Rng is seedable. The overload\n taking a SeedType also makes sure that the Rng can be seeded with SeedType.\n\n A seedable random-number generator has the following additional features:\n $(UL\n   $(LI it has a 'seed(ElementType)' function)\n )\n",
				"parameters": [
					{
						"name": "Rng",
						"kind": "type"
					},
					{
						"name": "SeedType",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSeedable",
						"line": 177,
						"deco": "b",
						"init": "isUniformRNG!Rng && is(typeof(()\n{\nRng r = void;\nr.seed((typeof(r.front)).init);\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSeedable",
				"line": 175,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Rng",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "LinearCongruentialEngine",
						"line": 253,
						"members": [
							{
								"name": "isUniformRandom",
								"line": 257,
								"comment": "Mark this as a Rng\n",
								"deco": "b",
								"init": "true",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "hasFixedRange",
								"line": 259,
								"comment": "Does this generator have a fixed range? ($(D_PARAM true)).\n",
								"deco": "b",
								"init": "true",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "min",
								"line": 261,
								"comment": "Lowest generated value ($(D 1) if $(D c == 0), $(D 0) otherwise).\n",
								"type": "UIntType",
								"init": "c == 0 ? 1 : 0",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "max",
								"line": 263,
								"comment": "Highest generated value ($(D modulus - 1)).\n",
								"type": "UIntType",
								"init": "m - 1",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "multiplier",
								"line": 268,
								"comment": "The parameters of this distribution. The random number is $(D_PARAM x\n= (x * multipler + increment) % modulus).\n",
								"type": "UIntType",
								"init": "a",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "increment",
								"line": 270,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "c",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "modulus",
								"line": 272,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "m",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 354,
								"comment": "Constructs a $(D_PARAM LinearCongruentialEngine) generator seeded with\n$(D x0).\n",
								"type": "pure @safe (UIntType x0)",
								"parameters": [
									{
										"name": "x0",
										"type": "UIntType"
									}
								],
								"endline": 357,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "seed",
								"line": 362,
								"comment": "   (Re)seeds the generator.\n",
								"type": "pure @safe void(UIntType x0 = 1)",
								"parameters": [
									{
										"name": "x0",
										"type": "UIntType",
										"default": "1"
									}
								],
								"endline": 372,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 377,
								"comment": "   Advances the random sequence.\n",
								"type": "pure nothrow @safe void()",
								"endline": 408,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 413,
								"comment": "   Returns the current number in the random sequence.\n",
								"type": "const pure nothrow @property @safe UIntType()",
								"endline": 416,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 419,
								"comment": "\n",
								"type": "pure nothrow @property @safe typeof(this)()",
								"endline": 422,
								"char": 28,
								"kind": "function"
							},
							{
								"name": "empty",
								"line": 427,
								"comment": "Always $(D false) (random generators are infinite ranges).\n",
								"deco": "b",
								"init": "false",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 432,
								"comment": "   Compares against $(D_PARAM rhs) for equality.\n",
								"type": "const pure nothrow @safe bool(ref const LinearCongruentialEngine rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "LinearCongruentialEngine",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 435,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "LinearCongruentialEngine",
				"line": 253,
				"comment": "Linear Congruential generator.\n",
				"parameters": [
					{
						"name": "UIntType",
						"kind": "type"
					},
					{
						"name": "a",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "c",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "m",
						"type": "UIntType",
						"kind": "value"
					}
				],
				"constraint": "isUnsigned!UIntType",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "MinstdRand0",
				"line": 449,
				"comment": "Define $(D_PARAM LinearCongruentialEngine) generators with well-chosen\nparameters. $(D MinstdRand0) implements Park and Miller's \"minimal\nstandard\" $(WEB\nwikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator,\ngenerator) that uses 16807 for the multiplier. $(D MinstdRand)\nimplements a variant that has slightly better spectral behavior by\nusing the multiplier 48271. Both generators are rather simplistic.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL454_2422)\n---\n// seed with a constant\nauto rnd0 = MinstdRand0(1);\nauto n = rnd0.front; // same for each run\n// Seed with an unpredictable value\nrnd0.seed(unpredictableSeed);\nn = rnd0.front; // different across runs\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL454_2422)\n",
				"deco": "S3std6random57__T24LinearCongruentialEngineTkVki16807Vki0Vki2147483647Z24LinearCongruentialEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "MinstdRand",
				"line": 451,
				"comment": "ditto\n",
				"deco": "S3std6random57__T24LinearCongruentialEngineTkVki48271Vki0Vki2147483647Z24LinearCongruentialEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "MersenneTwisterEngine",
						"line": 532,
						"members": [
							{
								"name": "isUniformRandom",
								"line": 545,
								"comment": "Mark this as a Rng\n",
								"deco": "b",
								"init": "true",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "wordSize",
								"line": 550,
								"comment": "Parameters for the generator.\n",
								"type": "size_t",
								"init": "w",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "stateSize",
								"line": 551,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "n",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "shiftSize",
								"line": 552,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "m",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "maskBits",
								"line": 553,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "r",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "xorMask",
								"line": 554,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "a",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingU",
								"line": 555,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "u",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingS",
								"line": 556,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "s",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingB",
								"line": 557,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "b",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingT",
								"line": 558,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "t",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingC",
								"line": 559,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "c",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingL",
								"line": 560,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "l",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "min",
								"line": 563,
								"comment": "Smallest generated value (0).\n",
								"type": "UIntType",
								"init": "0",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "max",
								"line": 565,
								"comment": "Largest generated value.\n",
								"type": "UIntType",
								"init": "UIntType.max >> UIntType.sizeof * 8u - w",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "defaultSeed",
								"line": 568,
								"comment": "The default seed value.\n",
								"type": "UIntType",
								"init": "5489u",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 573,
								"comment": "   Constructs a MersenneTwisterEngine object.\n",
								"type": "pure nothrow @safe (UIntType value)",
								"parameters": [
									{
										"name": "value",
										"type": "UIntType"
									}
								],
								"endline": 576,
								"char": 5,
								"kind": "constructor"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "seed",
										"line": 584,
										"type": "pure nothrow @safe void(UIntType value = defaultSeed)",
										"parameters": [
											{
												"name": "value",
												"type": "UIntType",
												"default": "defaultSeed"
											}
										],
										"endline": 608,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "seed",
								"line": 584,
								"comment": "   Seeds a MersenneTwisterEngine object.\n   Note:\n   This seed function gives 2^32 starting points. To allow the RNG to be started in any one of its\n   internal states use the seed overload taking an InputRange.\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "seed",
										"line": 617,
										"type": "void(T range)",
										"parameters": [
											{
												"name": "range",
												"type": "T"
											}
										],
										"endline": 637,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "seed",
								"line": 617,
								"comment": "   Seeds a MersenneTwisterEngine object using an InputRange.\n\n   Throws:\n   $(D Exception) if the InputRange didn't provide enough elements to seed the generator.\n   The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL640_2425)\n---\nimport std.algorithm.iteration : map;\nimport std.range : repeat;\n\nMt19937 gen;\ngen.seed(map!((a) => unpredictableSeed)(repeat(0)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL640_2425)\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!T && is(Unqual!(ElementType!T) == UIntType)",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 652,
								"comment": "   Advances the generator.\n",
								"type": "pure nothrow @safe void()",
								"endline": 698,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 703,
								"comment": "   Returns the current random value.\n",
								"type": "pure nothrow @property @safe UIntType()",
								"endline": 707,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 710,
								"comment": "\n",
								"type": "pure nothrow @property @safe typeof(this)()",
								"endline": 713,
								"char": 28,
								"kind": "function"
							},
							{
								"name": "empty",
								"line": 718,
								"comment": "Always $(D false).\n",
								"deco": "b",
								"init": "false",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "MersenneTwisterEngine",
				"line": 532,
				"comment": "The $(LUCKY Mersenne Twister) generator.\n",
				"parameters": [
					{
						"name": "UIntType",
						"kind": "type"
					},
					{
						"name": "w",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "n",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "m",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "r",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "a",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "u",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "s",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "b",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "t",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "c",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "l",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "isUnsigned!UIntType",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "Mt19937",
				"line": 733,
				"comment": "A $(D MersenneTwisterEngine) instantiated with the parameters of the\noriginal engine $(WEB math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html,\nMT19937), generating uniformly-distributed 32-bit numbers with a\nperiod of 2 to the power of 19937. Recommended for random number\ngeneration unless memory is severely restricted, in which case a $(D\nLinearCongruentialEngine) would be the generator of choice.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL739_2426)\n---\n// seed with a constant\nMt19937 gen;\nauto n = gen.front; // same for each run\n// Seed with an unpredictable value\ngen.seed(unpredictableSeed);\nn = gen.front; // different across runs\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL739_2426)\n",
				"deco": "S3std6random109__T21MersenneTwisterEngineTkVmi32Vmi624Vmi397Vmi31Vki2567483615Vmi11Vmi7Vki2636928640Vmi15Vki4022730752Vmi18Z21MersenneTwisterEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "XorshiftEngine",
						"line": 836,
						"members": [
							{
								"name": "isUniformRandom",
								"line": 845,
								"comment": "Mark this as a Rng\n",
								"deco": "b",
								"init": "true",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "empty",
								"line": 847,
								"comment": "Always $(D false) (random generators are infinite ranges).\n",
								"init": "false",
								"char": 10,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "min",
								"line": 849,
								"comment": "Smallest generated value.\n",
								"type": "UIntType",
								"init": "0",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "max",
								"line": 851,
								"comment": "Largest generated value.\n",
								"type": "UIntType",
								"init": "UIntType.max",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 884,
								"comment": " Constructs a $(D XorshiftEngine) generator seeded with $(D_PARAM x0).\n",
								"type": "pure nothrow @safe (UIntType x0)",
								"parameters": [
									{
										"name": "x0",
										"type": "UIntType"
									}
								],
								"endline": 887,
								"char": 13,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "seed",
								"line": 894,
								"comment": " (Re)seeds the generator.\n",
								"type": "pure nothrow @safe void(UIntType x0)",
								"parameters": [
									{
										"name": "x0",
										"type": "UIntType"
									}
								],
								"endline": 904,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 911,
								"comment": " Returns the current number in the random sequence.\n",
								"type": "const pure nothrow @property @safe UIntType()",
								"endline": 917,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 924,
								"comment": " Advances the random sequence.\n",
								"type": "pure nothrow @safe void()",
								"endline": 979,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 986,
								"comment": " Captures a range state.\n",
								"type": "pure nothrow @property @safe typeof(this)()",
								"endline": 989,
								"char": 26,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 996,
								"comment": " Compares against $(D_PARAM rhs) for equality.\n",
								"type": "const pure nothrow @safe bool(ref const XorshiftEngine rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "XorshiftEngine",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 999,
								"char": 18,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "XorshiftEngine",
				"line": 836,
				"comment": " Xorshift generator using 32bit algorithm.\n\n Implemented according to $(WEB www.jstatsoft.org/v08/i14/paper, Xorshift RNGs).\n\n $(BOOKTABLE $(TEXTWITHCOMMAS Supporting bits are below, $(D bits) means second parameter of XorshiftEngine.),\n  $(TR $(TH bits) $(TH period))\n  $(TR $(TD 32)   $(TD 2^32 - 1))\n  $(TR $(TD 64)   $(TD 2^64 - 1))\n  $(TR $(TD 96)   $(TD 2^96 - 1))\n  $(TR $(TD 128)  $(TD 2^128 - 1))\n  $(TR $(TD 160)  $(TD 2^160 - 1))\n  $(TR $(TD 192)  $(TD 2^192 - 2^32))\n )\n",
				"parameters": [
					{
						"name": "UIntType",
						"kind": "type"
					},
					{
						"name": "bits",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "a",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "b",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "c",
						"type": "UIntType",
						"kind": "value"
					}
				],
				"constraint": "isUnsigned!UIntType",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "Xorshift32",
				"line": 1032,
				"comment": " Define $(D XorshiftEngine) generators with well-chosen parameters. See each bits examples of \"Xorshift RNGs\".\n $(D Xorshift) is a Xorshift128's alias because 128bits implementation is mostly used.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1041_2437)\n---\n// Seed with a constant\nauto rnd = Xorshift(1);\nauto num = rnd.front;  // same for each run\n\n// Seed with an unpredictable value\nrnd.seed(unpredictableSeed);\nnum = rnd.front; // different across rnd\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1041_2437)\n",
				"deco": "S3std6random42__T14XorshiftEngineTkVki32Vki13Vki17Vki15Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift64",
				"line": 1033,
				"comment": "ditto\n",
				"deco": "S3std6random42__T14XorshiftEngineTkVki64Vki10Vki13Vki10Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift96",
				"line": 1034,
				"comment": "ditto\n",
				"deco": "S3std6random41__T14XorshiftEngineTkVki96Vki10Vki5Vki26Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift128",
				"line": 1035,
				"comment": "ditto\n",
				"deco": "S3std6random42__T14XorshiftEngineTkVki128Vki11Vki8Vki19Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift160",
				"line": 1036,
				"comment": "ditto\n",
				"deco": "S3std6random40__T14XorshiftEngineTkVki160Vki2Vki1Vki4Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift192",
				"line": 1037,
				"comment": "ditto\n",
				"deco": "S3std6random40__T14XorshiftEngineTkVki192Vki2Vki1Vki4Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift",
				"line": 1038,
				"comment": "ditto\n",
				"deco": "S3std6random42__T14XorshiftEngineTkVki128Vki11Vki8Vki19Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "unpredictableSeed",
				"line": 1120,
				"comment": "A \"good\" seed for initializing random number engines. Initializing\nwith $(D_PARAM unpredictableSeed) makes engines generate different\nrandom number sequences every run.\n\nReturns:\nA single unsigned integer seed value, different on each successive call\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1136_2440)\n---\nauto rnd = Random(unpredictableSeed);\nauto n = rnd.front;\nstatic assert(is(typeof(n) == uint));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1136_2440)\n",
				"deco": "FNdNeZk",
				"endline": 1133,
				"char": 16,
				"kind": "function"
			},
			{
				"name": "Random",
				"line": 1151,
				"comment": "The \"default\", \"favorite\", \"suggested\" random number generator type on\nthe current platform. It is an alias for one of the previously-defined\ngenerators. You may want to use it if (1) you need to generate some\nnice random numbers, and (2) you don't care for the minutiae of the\nmethod being used.\n",
				"deco": "S3std6random109__T21MersenneTwisterEngineTkVmi32Vmi624Vmi397Vmi31Vki2567483615Vmi11Vmi7Vki2636928640Vmi15Vki4022730752Vmi18Z21MersenneTwisterEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "rndGen",
				"line": 1169,
				"comment": "Global random number generator used by various functions in this\nmodule whenever no generator is specified. It is allocated per-thread\nand initialized to an unpredictable value for each thread.\n\nReturns:\nA singleton instance of the default random number generator\n",
				"deco": "FNcNdNfZS3std6random109__T21MersenneTwisterEngineTkVmi32Vmi624Vmi397Vmi31Vki2567483615Vmi11Vmi7Vki2636928640Vmi15Vki4022730752Vmi18Z21MersenneTwisterEngine",
				"endline": 1185,
				"originalType": "@property ref @safe Random()",
				"char": 22,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1206,
						"type": "(T1 a, T2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "T1"
							},
							{
								"name": "b",
								"type": "T2"
							}
						],
						"endline": 1210,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1206,
				"comment": "Generates a number between $(D a) and $(D b). The $(D boundaries)\nparameter controls the shape of the interval (open vs. closed on\neither side). Valid values for $(D boundaries) are $(D \"[]\"), $(D\n\"$(LPAREN)]\"), $(D \"[$(RPAREN)\"), and $(D \"()\"). The default interval\nis closed to the left and open to the right. The version that does not\ntake $(D urng) uses the default generator $(D rndGen).\n\nParams:\n    a = lower bound of the _uniform distribution\n    b = upper bound of the _uniform distribution\n    urng = (optional) random number generator to use;\n           if not specified, defaults to $(D rndGen)\n\nReturns:\n    A single random variate drawn from the _uniform distribution\n    between $(D a) and $(D b), whose type is the common type of\n    these parameters\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1213_2444)\n---\nauto gen = Random(unpredictableSeed);\n// Generate an integer in [0, 1023]\nauto a = uniform(0, 1024, gen);\n// Generate a float in [0, 1)\nauto b = uniform(0.0f, 1.0f, gen);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1213_2444)\n",
				"parameters": [
					{
						"name": "boundaries",
						"defaultValue": "\"[)\"",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"constraint": "!is(CommonType!(T1, T2) == void)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1253,
						"type": "(T1 a, T2 b, ref UniformRandomNumberGenerator urng)",
						"parameters": [
							{
								"name": "a",
								"type": "T1"
							},
							{
								"name": "b",
								"type": "T2"
							},
							{
								"name": "urng",
								"type": "UniformRandomNumberGenerator",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1287,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1253,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "boundaries",
						"defaultValue": "\"[)\"",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					},
					{
						"name": "UniformRandomNumberGenerator",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!(CommonType!(T1, T2)) && isUniformRNG!UniformRandomNumberGenerator",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1562,
						"type": "(ref UniformRandomNumberGenerator urng)",
						"parameters": [
							{
								"name": "urng",
								"type": "UniformRandomNumberGenerator",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1589,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1562,
				"comment": "Generates a uniformly-distributed number in the range $(D [T.min,\nT.max]) for any integral or character type $(D T). If no random\nnumber generator is passed, uses the default $(D rndGen).\n\nParams:\n    urng = (optional) random number generator to use;\n           if not specified, defaults to $(D rndGen)\n\nReturns:\n    Random variate drawn from the _uniform distribution across all\n    possible values of the integral or character type $(D T).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "UniformRandomNumberGenerator",
						"kind": "type"
					}
				],
				"constraint": "!is(T == enum) && (isIntegral!T || isSomeChar!T) && isUniformRNG!UniformRandomNumberGenerator",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1592,
						"type": "()",
						"endline": 1596,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1592,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!is(T == enum) && (isIntegral!T || isSomeChar!T)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1630,
						"type": "(ref UniformRandomNumberGenerator urng)",
						"parameters": [
							{
								"name": "urng",
								"type": "UniformRandomNumberGenerator",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1636,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1630,
				"comment": "Returns a uniformly selected member of enum $(D E). If no random number\ngenerator is passed, uses the default $(D rndGen).\n\nParams:\n    urng = (optional) random number generator to use;\n           if not specified, defaults to $(D rndGen)\n\nReturns:\n    Random variate drawn with equal probability from any\n    of the possible values of the enum $(D E).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1646_2448)\n---\nenum Fruit { apple, mango, pear }\nauto randFruit = uniform!Fruit();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1646_2448)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "UniformRandomNumberGenerator",
						"kind": "type"
					}
				],
				"constraint": "is(E == enum) && isUniformRNG!UniformRandomNumberGenerator",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1639,
						"type": "()",
						"endline": 1643,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1639,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "is(E == enum)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform01",
						"line": 1683,
						"type": "T()",
						"endline": 1687,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "uniform01",
				"line": 1683,
				"comment": " Generates a uniformly-distributed floating point number of type\n $(D T) in the range [0, 1$(RPAREN).  If no random number generator is\n specified, the default RNG $(D rndGen) will be used as the source\n of randomness.\n\n $(D uniform01) offers a faster generation of random variates than\n the equivalent $(D uniform!\"[$(RPAREN)\"(0.0, 1.0)) and so may be preferred\n for some applications.\n\n Params:\n     rng = (optional) random number generator to use;\n           if not specified, defaults to $(D rndGen)\n\n Returns:\n     Floating-point random variate of type $(D T) drawn from the _uniform\n     distribution across the half-open interval [0, 1$(RPAREN).\n\n",
				"parameters": [
					{
						"defaultDeco": "d",
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform01",
						"line": 1690,
						"type": "T(ref UniformRNG rng)",
						"parameters": [
							{
								"name": "rng",
								"type": "UniformRNG",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1743,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "uniform01",
				"line": 1690,
				"comment": "ditto\n",
				"parameters": [
					{
						"defaultDeco": "d",
						"name": "T",
						"kind": "type"
					},
					{
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T && isUniformRNG!UniformRNG",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniformDistribution",
						"line": 1785,
						"type": "F[](size_t n, F[] useThis = null)",
						"parameters": [
							{
								"name": "n",
								"type": "size_t"
							},
							{
								"name": "useThis",
								"type": "F[]",
								"default": "null"
							}
						],
						"endline": 1796,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "uniformDistribution",
				"line": 1785,
				"comment": "Generates a uniform probability distribution of size $(D n), i.e., an\narray of size $(D n) of positive numbers of type $(D F) that sum to\n$(D 1). If $(D useThis) is provided, it is used as storage.\n",
				"parameters": [
					{
						"defaultDeco": "d",
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!F",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomShuffle",
						"line": 1822,
						"type": "void(Range r, ref RandomGen gen)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "gen",
								"type": "RandomGen",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1826,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "randomShuffle",
				"line": 1822,
				"comment": "Shuffles elements of $(D r) using $(D gen) as a shuffler. $(D r) must be\na random-access range with length.  If no RNG is specified, $(D rndGen)\nwill be used.\n\nParams:\n    r = random-access range whose elements are to be shuffled\n    gen = (optional) random number generator to use; if not\n          specified, defaults to $(D rndGen)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RandomGen",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isUniformRNG!RandomGen",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomShuffle",
						"line": 1829,
						"type": "void(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1833,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "randomShuffle",
				"line": 1829,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "partialShuffle",
						"line": 1871,
						"type": "void(Range r, in size_t n, ref RandomGen gen)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "gen",
								"type": "RandomGen",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1881,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "partialShuffle",
				"line": 1871,
				"comment": "Partially shuffles the elements of $(D r) such that upon returning $(D r[0..n])\nis a random subset of $(D r) and is randomly ordered.  $(D r[n..r.length])\nwill contain the elements not in $(D r[0..n]).  These will be in an undefined\norder, but will not be random in the sense that their order after\n$(D partialShuffle) returns will not be independent of their order before\n$(D partialShuffle) was called.\n\n$(D r) must be a random-access range with length.  $(D n) must be less than\nor equal to $(D r.length).  If no RNG is specified, $(D rndGen) will be used.\n\nParams:\n    r = random-access range whose elements are to be shuffled\n    n = number of elements of $(D r) to shuffle (counting from the beginning);\n        must be less than $(D r.length)\n    gen = (optional) random number generator to use; if not\n          specified, defaults to $(D rndGen)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RandomGen",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isUniformRNG!RandomGen",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "partialShuffle",
						"line": 1884,
						"type": "void(Range r, in size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1888,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "partialShuffle",
				"line": 1884,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dice",
						"line": 1948,
						"type": "size_t(ref Rng rnd, Num[] proportions...)",
						"parameters": [
							{
								"name": "rnd",
								"type": "Rng",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "proportions",
								"type": "Num[]"
							}
						],
						"endline": 1952,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "dice",
				"line": 1948,
				"comment": "Rolls a dice with relative probabilities stored in $(D\nproportions). Returns the index in $(D proportions) that was chosen.\n\nParams:\n    rnd = (optional) random number generator to use; if not\n          specified, defaults to $(D rndGen)\n    proportions = forward range or list of individual values\n                  whose elements correspond to the probabilities\n                  with which to choose the corresponding index\n                  value\n\nReturns:\n    Random variate drawn from the index values\n    [0, ... $(D proportions.length) - 1], with the probability\n    of getting an individual index value $(D i) being proportional to\n    $(D proportions[i]).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1976_2454)\n---\nauto x = dice(0.5, 0.5);   // x is 0 or 1 in equal proportions\nauto y = dice(50, 50);     // y is 0 or 1 in equal proportions\nauto z = dice(70, 20, 10); // z is 0 70% of the time, 1 20% of the time,\n                           // and 2 10% of the time\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1976_2454)\n",
				"parameters": [
					{
						"name": "Rng",
						"kind": "type"
					},
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "isNumeric!Num && isForwardRange!Rng",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dice",
						"line": 1955,
						"type": "size_t(ref R rnd, Range proportions)",
						"parameters": [
							{
								"name": "rnd",
								"type": "R",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "proportions",
								"type": "Range"
							}
						],
						"endline": 1959,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "dice",
				"line": 1955,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isNumeric!(ElementType!Range) && !isArray!Range",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dice",
						"line": 1962,
						"type": "size_t(Range proportions)",
						"parameters": [
							{
								"name": "proportions",
								"type": "Range"
							}
						],
						"endline": 1966,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "dice",
				"line": 1962,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isNumeric!(ElementType!Range) && !isArray!Range",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dice",
						"line": 1969,
						"type": "size_t(Num[] proportions...)",
						"parameters": [
							{
								"name": "proportions",
								"type": "Num[]"
							}
						],
						"endline": 1973,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "dice",
				"line": 1969,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "isNumeric!Num",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RandomCover",
						"line": 2078,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "RandomCover",
				"line": 2078,
				"comment": "Covers a given range $(D r) in a random manner, i.e. goes through each\nelement of $(D r) once and only once, just in a random order. $(D r)\nmust be a random-access range with length.\n\nIf no random number generator is passed to $(D randomCover), the\nthread-global RNG rndGen will be used internally.\n\nParams:\n    r = random-access range to cover\n    rng = (optional) random number generator to use;\n          if not specified, defaults to $(D rndGen)\n\nReturns:\n    Range whose elements consist of the elements of $(D r),\n    in random order.  Will be a forward range if both $(D r) and\n    $(D rng) are forward ranges, an input range otherwise.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\nforeach (e; randomCover(a))\n{\n    writeln(e);\n}\n----\n\n$(B WARNING:) If an alternative RNG is desired, it is essential for this\nto be a $(I new) RNG seeded in an unpredictable manner. Passing it a RNG\nused elsewhere in the program will result in unintended correlations,\ndue to the current implementation of RNGs as value types.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\nforeach (e; randomCover(a, Random(unpredictableSeed)))  // correct!\n{\n    writeln(e);\n}\n\nforeach (e; randomCover(a, rndGen))  // DANGEROUS!! rndGen gets copied by value\n{\n    writeln(e);\n}\n\nforeach (e; randomCover(a, rndGen))  // ... so this second random cover\n{                                    // will output the same sequence as\n    writeln(e);                      // the previous one.\n}\n----\n\nThese issues will be resolved in a second-generation std.random that\nre-implements random number generators as reference types.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"defaultDeco": "v",
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && (isUniformRNG!UniformRNG || is(UniformRNG == void))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomCover",
						"line": 2193,
						"type": "(Range r, auto ref UniformRNG rng)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "rng",
								"type": "UniformRNG",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 2197,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomCover",
				"line": 2193,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isUniformRNG!UniformRNG",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomCover",
						"line": 2200,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 2204,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomCover",
				"line": 2200,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RandomSample",
						"line": 2334,
						"members": [
							{
								"endchar": 5,
								"name": "empty",
								"line": 2436,
								"comment": "   Range primitives.\n",
								"type": "const @property bool()",
								"endline": 2439,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 2442,
								"comment": "Ditto\n",
								"type": "@property ref ()",
								"endline": 2454,
								"char": 24,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 2457,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 2471,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 2486,
								"comment": "Ditto\n",
								"type": "@property size_t()",
								"endline": 2489,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "index",
								"line": 2494,
								"comment": "Returns the index of the visited record.\n",
								"type": "@property size_t()",
								"endline": 2501,
								"char": 22,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "RandomSample",
				"line": 2334,
				"comment": "Selects a random subsample out of $(D r), containing exactly $(D n)\nelements. The order of elements is the same as in the original\nrange. The total length of $(D r) must be known. If $(D total) is\npassed in, the total number of sample is considered to be $(D\ntotal). Otherwise, $(D RandomSample) uses $(D r.length).\n\nParams:\n    r = range to sample from\n    n = number of elements to include in the sample;\n        must be less than or equal to the total number\n        of elements in $(D r) and/or the parameter\n        $(D total) (if provided)\n    total = (semi-optional) number of elements of $(D r)\n            from which to select the sample (counting from\n            the beginning); must be less than or equal to\n            the total number of elements in $(D r) itself.\n            May be omitted if $(D r) has the $(D .length)\n            property and the sample is to be drawn from\n            all elements of $(D r).\n    rng = (optional) random number generator to use;\n          if not specified, defaults to $(D rndGen)\n\nReturns:\n    Range whose elements consist of a randomly selected subset of\n    the elements of $(D r), in the same order as these elements\n    appear in $(D r) itself.  Will be a forward range if both $(D r)\n    and $(D rng) are forward ranges, an input range otherwise.\n\n$(D RandomSample) implements Jeffrey Scott Vitter's Algorithm D\n(see Vitter $(WEB dx.doi.org/10.1145/358105.893, 1984), $(WEB\ndx.doi.org/10.1145/23002.23003, 1987)), which selects a sample\nof size $(D n) in O(n) steps and requiring O(n) random variates,\nregardless of the size of the data being sampled.  The exception\nto this is if traversing k elements on the input range is itself\nan O(k) operation (e.g. when sampling lines from an input file),\nin which case the sampling calculation will inevitably be of\nO(total).\n\nRandomSample will throw an exception if $(D total) is verifiably\nless than the total number of elements available in the input,\nor if $(D n > total).\n\nIf no random number generator is passed to $(D randomSample), the\nthread-global RNG rndGen will be used internally.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\n// Print 5 random elements picked off from a\nforeach (e; randomSample(a, 5))\n{\n    writeln(e);\n}\n----\n\n$(B WARNING:) If an alternative RNG is desired, it is essential for this\nto be a $(I new) RNG seeded in an unpredictable manner. Passing it a RNG\nused elsewhere in the program will result in unintended correlations,\ndue to the current implementation of RNGs as value types.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\nforeach (e; randomSample(a, 5, Random(unpredictableSeed)))  // correct!\n{\n    writeln(e);\n}\n\nforeach (e; randomSample(a, 5, rndGen))  // DANGEROUS!! rndGen gets\n{                                        // copied by value\n    writeln(e);\n}\n\nforeach (e; randomSample(a, 5, rndGen))  // ... so this second random\n{                                        // sample will select the same\n    writeln(e);                          // values as the previous one.\n}\n----\n\nThese issues will be resolved in a second-generation std.random that\nre-implements random number generators as reference types.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"defaultDeco": "v",
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && (isUniformRNG!UniformRNG || is(UniformRNG == void))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomSample",
						"line": 2722,
						"type": "(Range r, size_t n, size_t total)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							},
							{
								"name": "total",
								"type": "size_t"
							}
						],
						"endline": 2726,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomSample",
				"line": 2722,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomSample",
						"line": 2729,
						"type": "(Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2733,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomSample",
				"line": 2729,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && hasLength!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomSample",
						"line": 2736,
						"type": "(Range r, size_t n, size_t total, auto ref UniformRNG rng)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							},
							{
								"name": "total",
								"type": "size_t"
							},
							{
								"name": "rng",
								"type": "UniformRNG",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 2740,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomSample",
				"line": 2736,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isUniformRNG!UniformRNG",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomSample",
						"line": 2743,
						"type": "(Range r, size_t n, auto ref UniformRNG rng)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							},
							{
								"name": "rng",
								"type": "UniformRNG",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 2747,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomSample",
				"line": 2743,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && hasLength!Range && isUniformRNG!UniformRNG",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "Facilities for random number generation.\n\nThe new-style generator objects hold their own state so they are\nimmune of threading issues. The generators feature a number of\nwell-known and well-documented methods of generating random\nnumbers. An overall fast and reliable means to generate random numbers\nis the $(D_PARAM Mt19937) generator, which derives its name from\n\"$(LUCKY Mersenne Twister) with a period of 2 to the power of\n19937\". In memory-constrained situations, $(LUCKY linear congruential)\ngenerators such as $(D MinstdRand0) and $(D MinstdRand) might be\nuseful. The standard library provides an alias $(D_PARAM Random) for\nwhichever generator it considers the most fit for the target\nenvironment.\n\nExample:\n\n----\n// Generate a uniformly-distributed integer in the range [0, 14]\nauto i = uniform(0, 15);\n// Generate a uniformly-distributed real in the range [0, 100$(RPAREN)\n// using a specific random generator\nRandom gen;\nauto r = uniform(0.0L, 100.0L, gen);\n----\n\nIn addition to random number generators, this module features\ndistributions, which skew a generator's output statistical\ndistribution in various ways. So far the uniform distribution for\nintegers and real numbers have been implemented.\n\nUpgrading:\n        $(WEB digitalmars.com/d/1.0/phobos/std_random.html#rand, Phobos D1 $(D rand())) can\n        be replaced with $(D uniform!uint()).\n\nSource:    $(PHOBOSSRC std/_random.d)\n\nMacros:\n\nWIKI = Phobos/StdRandom\n\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009, Joseph Rushton Wakeling 2012.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\n           Masahiro Nakagawa (Xorshift random generator)\n           $(WEB braingam.es, Joseph Rushton Wakeling) (Algorithm D for random sampling)\nCredits:   The entire random number library architecture is derived from the\n           excellent $(WEB open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf, C++0X)\n           random number facility proposed by Jens Maurer and contributed to by\n           researchers at the Fermi laboratory (excluding Xorshift).\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/outbuffer.d",
		"name": "std.outbuffer",
		"members": [
			{
				"name": "OutBuffer",
				"line": 38,
				"comment": " OutBuffer provides a way to build up an array of bytes out\n of raw data. It is useful for things like preparing an\n array of bytes to write out to a file.\n OutBuffer's byte order is the format native to the computer.\n To control the byte order (endianness), use a class derived\n from OutBuffer.\n OutBuffer's internal buffer is allocated with the GC. Pointers\n stored into the buffer are scanned by the GC, but you have to\n ensure proper alignment, e.g. by using alignSize((void*).sizeof).\n",
				"members": [
					{
						"endchar": 51,
						"name": "toBytes",
						"line": 60,
						"comment": " Convert to array of bytes.\n",
						"deco": "FNaNbNfZAh",
						"endline": 60,
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 9,
						"in": {
							"endchar": 9,
							"name": "__require",
							"line": 73,
							"deco": "FNaNbNeZv",
							"endline": 73,
							"char": 9,
							"kind": "function"
						},
						"name": "reserve",
						"line": 71,
						"comment": " Preallocate nbytes more to the size of the internal buffer.\n\n This is a\n speed optimization, a good guess at the maximum size of the resulting\n buffer will improve performance by eliminating reallocations and copying.\n",
						"deco": "FNaNbNemZv",
						"parameters": [
							{
								"name": "nbytes",
								"deco": "m"
							}
						],
						"endline": 89,
						"originalType": "pure nothrow @trusted void(size_t nbytes)",
						"char": 10,
						"kind": "function",
						"out": {
							"endchar": 9,
							"name": "__ensure",
							"line": 77,
							"deco": "FNaNbNeZv",
							"endline": 77,
							"char": 9,
							"kind": "function"
						}
					},
					{
						"name": "put",
						"line": 94,
						"comment": " put enables OutBuffer to be used as an OutputRange.\n",
						"char": 5,
						"kind": "alias"
					},
					{
						"endchar": 9,
						"name": "write",
						"line": 100,
						"comment": " Append data to the internal buffer.\n",
						"deco": "FNaNbNfAxhZv",
						"parameters": [
							{
								"name": "bytes",
								"deco": "Axh"
							}
						],
						"endline": 105,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 47,
						"name": "write",
						"line": 124,
						"comment": "ditto\n",
						"deco": "FNaNbNfgZv",
						"parameters": [
							{
								"name": "b",
								"deco": "g"
							}
						],
						"endline": 124,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 47,
						"name": "write",
						"line": 125,
						"comment": "ditto\n",
						"deco": "FNaNbNfaZv",
						"parameters": [
							{
								"name": "c",
								"deco": "a"
							}
						],
						"endline": 125,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 47,
						"name": "write",
						"line": 126,
						"comment": "ditto\n",
						"deco": "FNaNbNfwZv",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 126,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 49,
						"name": "write",
						"line": 135,
						"comment": "ditto\n",
						"deco": "FNaNbNfsZv",
						"parameters": [
							{
								"name": "s",
								"deco": "s"
							}
						],
						"endline": 135,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 45,
						"name": "write",
						"line": 151,
						"comment": "ditto\n",
						"deco": "FNaNbNfiZv",
						"parameters": [
							{
								"name": "i",
								"deco": "i"
							}
						],
						"endline": 151,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 47,
						"name": "write",
						"line": 160,
						"comment": "ditto\n",
						"deco": "FNaNbNflZv",
						"parameters": [
							{
								"name": "l",
								"deco": "l"
							}
						],
						"endline": 160,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fill0",
						"line": 197,
						"comment": " Append nbytes of 0 to the internal buffer.\n",
						"deco": "FNaNbNfmZv",
						"parameters": [
							{
								"name": "nbytes",
								"deco": "m"
							}
						],
						"endline": 202,
						"originalType": "pure nothrow @safe void(size_t nbytes)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 210,
							"deco": "FNaNbNfZv",
							"endline": 210,
							"char": 5,
							"kind": "function"
						},
						"name": "alignSize",
						"line": 208,
						"comment": " 0-fill to align on power of 2 boundary.\n",
						"deco": "FNaNbNfmZv",
						"parameters": [
							{
								"name": "alignsize",
								"deco": "m"
							}
						],
						"endline": 222,
						"originalType": "pure nothrow @safe void(size_t alignsize)",
						"char": 10,
						"kind": "function",
						"out": {
							"endchar": 5,
							"name": "__ensure",
							"line": 214,
							"deco": "FNaNbNfZv",
							"endline": 214,
							"char": 5,
							"kind": "function"
						}
					},
					{
						"endchar": 5,
						"name": "align2",
						"line": 228,
						"comment": " Optimize common special case alignSize(2)\n",
						"deco": "FNaNbNfZv",
						"endline": 232,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "align4",
						"line": 238,
						"comment": " Optimize common special case alignSize(4)\n",
						"deco": "FNaNbNfZv",
						"endline": 244,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 250,
						"comment": " Convert internal buffer to array of chars.\n",
						"deco": "xFNaNbNfZAya",
						"endline": 254,
						"char": 21,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "vprintf",
						"line": 261,
						"comment": " Append output of C's vprintf() to internal buffer.\n",
						"deco": "FNbNeAyaPS4core4stdc6stdarg13__va_list_tagZv",
						"parameters": [
							{
								"name": "format",
								"deco": "Aya"
							},
							{
								"name": "args",
								"deco": "PS4core4stdc6stdarg13__va_list_tag"
							}
						],
						"endline": 310,
						"originalType": "nothrow @trusted void(string format, va_list args)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "printf",
						"line": 316,
						"comment": " Append output of C's printf() to internal buffer.\n",
						"deco": "FNeAyaYv",
						"parameters": [
							{
								"name": "format",
								"deco": "Aya"
							}
						],
						"endline": 322,
						"char": 10,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "writef",
								"line": 335,
								"type": "void(in Char[] fmt, A args)",
								"parameters": [
									{
										"name": "fmt",
										"type": "Char[]",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "args",
										"type": "A"
									}
								],
								"endline": 339,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "writef",
						"line": 335,
						"comment": " Formats and writes its arguments in text format to the OutBuffer.\n\n Params:\n  fmt = format string as described in $(XREF format, formattedWrite)\n  args = arguments to be formatted\n\n See_Also:\n  $(XREF stdio, _writef);\n  $(XREF format, formattedWrite);\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL342_2460)\n---\nOutBuffer b = new OutBuffer();\nb.writef(\"a%sb\", 16);\nassert(b.toString() == \"a16b\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL342_2460)\n",
						"parameters": [
							{
								"name": "Char",
								"kind": "type"
							},
							{
								"name": "A",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "writefln",
								"line": 361,
								"type": "void(in Char[] fmt, A args)",
								"parameters": [
									{
										"name": "fmt",
										"type": "Char[]",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "args",
										"type": "A"
									}
								],
								"endline": 366,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "writefln",
						"line": 361,
						"comment": " Formats and writes its arguments in text format to the OutBuffer,\n followed by a newline.\n\n Params:\n  fmt = format string as described in $(XREF format, formattedWrite)\n  args = arguments to be formatted\n\n See_Also:\n  $(XREF stdio, _writefln);\n  $(XREF format, formattedWrite);\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL369_2461)\n---\nOutBuffer b = new OutBuffer();\nb.writefln(\"a%sb\", 16);\nassert(b.toString() == \"a16b\\n\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL369_2461)\n",
						"parameters": [
							{
								"name": "Char",
								"kind": "type"
							},
							{
								"name": "A",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 9,
						"in": {
							"endchar": 9,
							"name": "__require",
							"line": 383,
							"deco": "FNaNbNfZv",
							"endline": 383,
							"char": 9,
							"kind": "function"
						},
						"name": "spread",
						"line": 381,
						"comment": " At offset index into buffer, create nbytes of space by shifting upwards\n all data past index.\n",
						"deco": "FNaNbNfmmZv",
						"parameters": [
							{
								"name": "index",
								"deco": "m"
							},
							{
								"name": "nbytes",
								"deco": "m"
							}
						],
						"endline": 397,
						"originalType": "pure nothrow @safe void(size_t index, size_t nbytes)",
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": "Serialize data to $(D ubyte) arrays.\n\n Macros:\n      WIKI = Phobos/StdOutbuffer\n\n Copyright: Copyright Digital Mars 2000 - 2015.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_outbuffer.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/logger/package.d",
		"name": "std.experimental.logger",
		"members": [],
		"comment": "Implements logging facilities.\n\nCopyright: Copyright Robert \"burner\" Schadek 2013 --\nLicense: <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\nAuthors: $(WEB http://www.svs.informatik.uni-oldenburg.de/60865.html, Robert burner Schadek)\n\n$(H3 Basic Logging)\n\nMessage logging is a common approach to expose runtime information of a\nprogram. Logging should be easy, but also flexible and powerful, therefore\n$(D D) provides a standard interface for logging.\n\nThe easiest way to create a log message is to write:\n-------------\nimport std.experimental.logger;\n\nvoid main() {\n    log(\"Hello World\");\n}\n-------------\nThis will print a message to the $(D stderr) device. The message will contain\nthe filename, the linenumber, the name of the surrounding function, the time\nand the message.\n\nMore complex log call can go along the lines like:\n-------------\nlog(\"Logging to the sharedLog with its default LogLevel\");\nlogf(LogLevel.info, 5 < 6, \"%s to the sharedLog with its LogLevel.info\", \"Logging\");\ninfo(\"Logging to the sharedLog with its info LogLevel\");\nwarning(5 < 6, \"Logging to the sharedLog with its LogLevel.warning if 5 is less than 6\");\nerror(\"Logging to the sharedLog with its error LogLevel\");\nerrorf(\"Logging %s the sharedLog %s its error LogLevel\", \"to\", \"with\");\ncritical(\"Logging to the\",\" sharedLog with its error LogLevel\");\nfatal(\"Logging to the sharedLog with its fatal LogLevel\");\n\nauto fLogger = new FileLogger(\"NameOfTheLogFile\");\nfLogger.log(\"Logging to the fileLogger with its default LogLevel\");\nfLogger.info(\"Logging to the fileLogger with its default LogLevel\");\nfLogger.warning(5 < 6, \"Logging to the fileLogger with its LogLevel.warning if 5 is less than 6\");\nfLogger.warningf(5 < 6, \"Logging to the fileLogger with its LogLevel.warning if %s is %s than 6\", 5, \"less\");\nfLogger.critical(\"Logging to the fileLogger with its info LogLevel\");\nfLogger.log(LogLevel.trace, 5 < 6, \"Logging to the fileLogger\",\" with its default LogLevel if 5 is less than 6\");\nfLogger.fatal(\"Logging to the fileLogger with its warning LogLevel\");\n-------------\nAdditionally, this example shows how a new $(D FileLogger) is created.\nIndividual $(D Logger) and the global log functions share commonly named\nfunctions to log data.\n\nThe names of the functions are as follows:\n$(LI $(D log))\n$(LI $(D trace))\n$(LI $(D info))\n$(LI $(D warning))\n$(LI $(D critical))\n$(LI $(D fatal))\nThe default $(D Logger) will by default log to $(D stderr) and has a default\n$(D LogLevel) of $(D LogLevel.all). The default Logger can be accessed by\nusing the property called $(D sharedLog). This property a reference to the\ncurrent default $(D Logger). This reference can be used to assign a new\ndefault $(D Logger).\n-------------\nsharedLog = new FileLogger(\"New_Default_Log_File.log\");\n-------------\n\nAdditional $(D Logger) can be created by creating a new instance of the\nrequired $(D Logger).\n\n$(H3 Logging Fundamentals)\n$(H4 LogLevel)\nThe $(D LogLevel) of a log call can be defined in two ways. The first is by\ncalling $(D log) and passing the $(D LogLevel) explicit as the first argument.\nThe second way of setting the $(D LogLevel) of a\nlog call, is by calling either $(D trace), $(D info), $(D warning),\n$(D critical), or $(D fatal). The log call will than have the respective\n$(D LogLevel). If no $(D LogLevel) is defined the log call will use the\ncurrent $(D LogLevel) of the used $(D Logger). If data is logged with\n$(D LogLevel) $(D fatal) by default an $(D Error) will be thrown.\nThis behaviour can be modified by using the member $(D fatalHandler) to\nassign a custom delegate to handle log call with $(D LogLevel) $(D fatal).\n\n$(H4 Conditional Logging)\nConditional logging can be achieved be passing a $(D bool) as first\nargument to a log function. If conditional logging is used the condition must\nbe $(D true) in order to have the log message logged.\n\nIn order to combine an explicit $(D LogLevel) passing with conditional\nlogging, the $(D LogLevel) has to be passed as first argument followed by the\n$(D bool).\n\n$(H4 Filtering Log Messages)\nMessages are logged if the $(D LogLevel) of the log message is greater than or\nequal to than the $(D LogLevel) of the used $(D Logger) and additionally if the\n$(D LogLevel) of the log message is greater equal to the global $(D LogLevel).\nIf a condition is passed into the log call, this condition must be true.\n\nThe global $(D LogLevel) is accessible by using $(D globalLogLevel).\nTo assign the $(D LogLevel) of a $(D Logger) use the $(D logLevel) property of\nthe logger.\n\n$(H4 Printf Style Logging)\nIf $(D printf)-style logging is needed add a $(B f) to the logging call, such as\n$(D myLogger.infof(\"Hello %s\", \"world\");) or $(D fatalf(\"errno %d\", 1337)).\nThe additional $(B f) appended to the function name enables $(D printf)-style\nlogging for all combinations of explicit $(D LogLevel) and conditional\nlogging functions and methods.\n\n$(H4 Thread Local Redirection)\nCalls to the free standing log functions are not directly forwarded to the\nglobal $(D Logger) $(D sharedLog). Actually, a thread local $(D Logger) of\ntype $(D StdForwardLogger) process the log call and then, by default, forward\nthe created $(D Logger.LogEntry) to the $(D sharedLog) $(D Logger).\nThe thread local $(D Logger) is accessable by the $(D stdThreadLocalLog)\nproperty. This property allows to assign user defined $(D Logger). The default\n$(D LogLevel) of the $(D stdThreadLocalLog) $(D Logger) is $(D LogLevel.all)\nand it will therefore forward all messaged to the $(D sharedLog) $(D Logger).\nThe $(D LogLevel) of the $(D stdThreadLocalLog) can be used to filter log\ncalls before they reach the $(D sharedLog) $(D Logger).\n\n$(H3 User Defined Logger)\nTo customize the $(D Logger) behavior, create a new $(D class) that inherits from\nthe abstract $(D Logger) $(D class), and implements the $(D writeLogMsg)\nmethod.\n-------------\nclass MyCustomLogger : Logger\n{\n    this(LogLevel lv) @safe\n    {\n        super(lv);\n    }\n\n    override void writeLogMsg(ref LogEntry payload)\n    {\n        // log message in my custom way\n    }\n}\n\nauto logger = new MyCustomLogger(LogLevel.info);\nlogger.log(\"Awesome log message with LogLevel.info\");\n-------------\n\nTo gain more precise control over the logging process, additionally to\noverwriting the $(D writeLogMsg) method the methods $(D beginLogMsg),\n$(D logMsgPart) and $(D finishLogMsg) can be overwritten.\n\n$(H3 Compile Time Disabling of $(D Logger))\nIn order to disable logging at compile time, pass $(D StdLoggerDisableLogging) as a\nversion argument to the $(D D) compiler when compiling your program code.\nThis will disable all logging functionality.\nSpecific $(D LogLevel) can be disabled at compile time as well.\nIn order to disable logging with the $(D trace) $(D LogLevel) pass\n$(D StdLoggerDisableTrace) as a version.\nThe following table shows which version statement disables which\n$(D LogLevel).\n$(TABLE\n    $(TR $(TD $(D LogLevel.trace) ) $(TD StdLoggerDisableTrace))\n    $(TR $(TD $(D LogLevel.info) ) $(TD StdLoggerDisableInfo))\n    $(TR $(TD $(D LogLevel.warning) ) $(TD StdLoggerDisableWarning))\n    $(TR $(TD $(D LogLevel.error) ) $(TD StdLoggerDisableError))\n    $(TR $(TD $(D LogLevel.critical) ) $(TD StdLoggerDisableCritical))\n    $(TR $(TD $(D LogLevel.fatal) ) $(TD StdLoggerDisableFatal))\n)\nSuch a version statement will only disable logging in the associated compile\nunit.\n\n$(H3 Provided Logger)\nBy default four $(D Logger) implementations are given. The $(D FileLogger)\nlogs data to files. It can also be used to log to $(D stdout) and $(D stderr)\nas these devices are files as well. A $(D Logger) that logs to $(D stdout) can\ntherefore be created by $(D new FileLogger(stdout)).\nThe $(D MultiLogger) is basically an associative array of $(D string)s to\n$(D Logger). It propagates log calls to its stored $(D Logger). The\n$(D ArrayLogger) contains an array of $(D Logger) and also propagates log\ncalls to its stored $(D Logger). The $(D NullLogger) does not do anything. It\nwill never log a message and will never throw on a log call with $(D LogLevel)\n$(D error).\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/ndslice/slice.d",
		"name": "std.experimental.ndslice.slice",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "sliced",
						"line": 41,
						"type": "(Range range, Lengths lengths)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "lengths",
								"type": "Lengths"
							}
						],
						"endline": 46,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sliced",
				"line": 41,
				"comment": "Creates an n-dimensional slice-shell over a `range`.\nParams:\n    range = a random access range or an array; only index operator\n        `auto opIndex(size_t index)` is required for ranges. The length of the\n        range must be greater than or equal to the sum of shift and the product of\n        lengths.\n    lengths = list of lengths for each dimension\n    shift = index of the first element of a `range`.\n        The first `shift` elements of range are ignored.\n    Names = names of elements in a slice tuple.\n        Slice tuple is a slice, which holds single set of lengths and strides\n        for a number of ranges.\nReturns:\n    n-dimensional slice\nExample:\nCreates a slice from an array.$(DDOX_UNITTEST_HEADER __unittestL180_2498)\n---\nauto slice = new int [1000].sliced(5, 6, 7);\nassert(slice.length == 5);\nassert(slice.elementsCount == 5 * 6 * 7);\nstatic assert(is(typeof(slice) == Slice!(3, int*)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL180_2498)\nExample:\nCreates a slice using shift parameter.$(DDOX_UNITTEST_HEADER __unittestL189_2499)\n---\nimport std.range: iota;\nauto slice = 1000.iota.sliced([5, 6, 7], 9);\nassert(slice.length == 5);\nassert(slice.elementsCount == 5 * 6 * 7);\nassert(slice[0, 0, 0] == 9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL189_2499)\nExample:\n$(LINK2 https://en.wikipedia.org/wiki/Vandermonde_matrix, Vandermonde matrix)$(DDOX_UNITTEST_HEADER __unittestL199_2500)\n---\npure nothrow\nSlice!(2, double*) vandermondeMatrix(Slice!(1, double*) x)\n{\n    auto ret = new double[x.length ^^ 2]\n        .sliced(x.length, x.length);\n    foreach (i; 0 .. x.length)\n    foreach (j; 0 .. x.length)\n        ret[i, j] = x[i] ^^ j;\n    return ret;\n}\n\nauto x = [1.0, 2, 3, 4, 5].sliced(5);\nauto v = vandermondeMatrix(x);\nassert(v ==\n    [[  1.0,   1,   1,   1,   1],\n     [  1.0,   2,   4,   8,  16],\n     [  1.0,   3,   9,  27,  81],\n     [  1.0,   4,  16,  64, 256],\n     [  1.0,   5,  25, 125, 625]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL199_2500)\nExample:\nCreates a slice composed of named elements, each one of which corresponds\nto a given argument. See also $(LREF assumeSameStructure).$(DDOX_UNITTEST_HEADER __unittestL226_2501)\n---\nimport std.algorithm.comparison: equal;\nimport std.experimental.ndslice.selection: byElement;\nimport std.range: iota;\n\nauto alpha = 12.iota;\nauto beta = new int[12];\n\nauto m = sliced!(\"a\", \"b\")(alpha, beta, 4, 3);\nforeach (r; m)\n    foreach (e; r)\n        e.b = e.a;\nassert(equal(alpha, beta));\n\nbeta[] = 0;\nforeach (e; m.byElement)\n    e.b = e.a;\nassert(equal(alpha, beta));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL226_2501)\nExample:\nCreates an array and an n-dimensional slice over it.$(DDOX_UNITTEST_HEADER __unittestL250_2502)\n---\nauto createSlice(T, Lengths...)(Lengths lengths)\n{\n    return createSlice2!(T, Lengths.length)(cast(size_t[Lengths.length])[lengths]);\n}\n\n///ditto\nauto createSlice2(T, size_t N)(auto ref size_t[N] lengths)\n{\n    size_t length = lengths[0];\n    foreach (len; lengths[1 .. N])\n            length *= len;\n    return new T[length].sliced(lengths);\n}\n\nauto slice = createSlice!int(5, 6, 7);\nassert(slice.length == 5);\nassert(slice.elementsCount == 5 * 6 * 7);\nstatic assert(is(typeof(slice) == Slice!(3, int*)));\n\nauto duplicate = createSlice2!int(slice.shape);\nduplicate[] = slice;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL250_2502)\nExample:\nCreates a common n-dimensional array.$(DDOX_UNITTEST_HEADER __unittestL278_2504)\n---\nauto ndarray(size_t N, Range)(auto ref Slice!(N, Range) slice)\n{\n    import std.array: array;\n    static if (N == 1)\n    {\n        return slice.array;\n    }\n    else\n    {\n        import std.algorithm.iteration: map;\n        return slice.map!(a => ndarray(a)).array;\n    }\n}\n\nimport std.range: iota;\nauto ar = ndarray(100.iota.sliced(3, 4));\nstatic assert(is(typeof(ar) == int[][]));\nassert(ar == [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL278_2504)\nExample:\nAllocates an array through a specified allocator and creates an n-dimensional slice over it.\nSee also $(LINK2 std_experimental_allocator.html, std.experimental.allocator).$(DDOX_UNITTEST_HEADER __unittestL304_2505)\n---\nimport std.experimental.allocator;\n\n\n// `theAllocator.makeSlice(3, 4)` allocates an array with length equal to `12`\n// and returns this array and a `2`-dimensional slice-shell over it.\nauto makeSlice(T, Allocator, Lengths...)(auto ref Allocator alloc, Lengths lengths)\n{\n    enum N = Lengths.length;\n    struct Result { T[] array; Slice!(N, T*) slice; }\n    size_t length = lengths[0];\n    foreach (len; lengths[1 .. N])\n            length *= len;\n    T[] a = alloc.makeArray!T(length);\n    return Result(a, a.sliced(lengths));\n}\n\nauto tup = makeSlice!int(theAllocator, 2, 3, 4);\n\nstatic assert(is(typeof(tup.array) == int[]));\nstatic assert(is(typeof(tup.slice) == Slice!(3, int*)));\n\nassert(tup.array.length           == 24);\nassert(tup.slice.elementsCount    == 24);\nassert(tup.array.ptr == &tup.slice[0, 0, 0]);\n\ntheAllocator.dispose(tup.array);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL304_2505)\nExample:\nInput range primitives for slices over user defined types$(DDOX_UNITTEST_HEADER __unittestL335_2506)\n---\nstruct MyIota\n{\n    //`[index]` operator overloading\n    auto opIndex(size_t index)\n    {\n        return index;\n    }\n}\n\nalias S = Slice!(3, MyIota);\nauto slice = MyIota().sliced(20, 10);\n\nimport std.range.primitives;\nstatic assert(hasLength!S);\nstatic assert(isInputRange!S);\nstatic assert(isForwardRange!S == false);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL335_2506)\nExample:\nRandom access range primitives for slices over user defined types$(DDOX_UNITTEST_HEADER __unittestL356_2507)\n---\nstruct MyIota\n{\n    //`[index]` operator overloading\n    auto opIndex(size_t index)\n    {\n        return index;\n    }\n    // `save` property to allow a slice to be a forward range\n    auto save() @property\n    {\n        return this;\n    }\n}\n\nalias S = Slice!(3, MyIota);\nauto slice = MyIota().sliced(20, 10);\n\nimport std.range.primitives;\nstatic assert(hasLength!S);\nstatic assert(hasSlicing!S);\nstatic assert(isForwardRange!S);\nstatic assert(isBidirectionalRange!S);\nstatic assert(isRandomAccessRange!S);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL356_2507)\n",
				"parameters": [
					{
						"name": "mod",
						"defaultValue": "ReplaceArrayWithPointer.yes",
						"deco": "E3std8typecons63__T4FlagVAyaa23_7265706c616365417272617957697468506f696e746572Z4Flag",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Lengths",
						"kind": "tuple"
					}
				],
				"constraint": "!isStaticArray!Range && !isNarrowString!Range && allSatisfy!(isIndex, Lengths) && Lengths.length",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sliced",
						"line": 49,
						"type": "(Range range, auto ref size_t[N] lengths, size_t shift = 0)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "lengths",
								"type": "size_t[N]",
								"storageClass": [
									"auto",
									"in",
									"ref"
								]
							},
							{
								"name": "shift",
								"type": "size_t",
								"default": "0"
							}
						],
						"endline": 115,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sliced",
				"line": 49,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "mod",
						"defaultValue": "ReplaceArrayWithPointer.yes",
						"deco": "E3std8typecons63__T4FlagVAyaa23_7265706c616365417272617957697468506f696e746572Z4Flag",
						"kind": "value"
					},
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "!isStaticArray!Range && !isNarrowString!Range && N",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [],
				"name": "sliced",
				"line": 120,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Names",
						"kind": "tuple"
					}
				],
				"constraint": "Names.length && !anySatisfy!(isType, Names) && allSatisfy!(isStringValue, Names)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "assumeSameStructure",
				"line": 456,
				"comment": "Groups slices into a slice tuple. The slices must have identical structure.\nSlice tuple is a slice, which holds single set of lengths and strides\nfor a number of ranges.\nParams:\n    Names = names of elements in a slice tuple\nReturns:\n    n-dimensional slice\nSee_also: $(LREF .Slice.structure).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL499_2509)\n---\nimport std.algorithm.comparison: equal;\nimport std.experimental.ndslice.selection: byElement;\nimport std.range: iota;\n\nauto alpha = 12.iota   .sliced(4, 3);\nauto beta = new int[12].sliced(4, 3);\n\nauto m = assumeSameStructure!(\"a\", \"b\")(alpha, beta);\nforeach (r; m)\n    foreach (e; r)\n        e.b = e.a;\nassert(alpha == beta);\n\nbeta[] = 0;\nforeach (e; m.byElement)\n    e.b = e.a;\nassert(alpha == beta);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL499_2509)\n",
				"parameters": [
					{
						"name": "Names",
						"kind": "tuple"
					}
				],
				"constraint": "Names.length && !anySatisfy!(isType, Names) && allSatisfy!(isStringValue, Names)",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "ReplaceArrayWithPointer",
				"line": 524,
				"comment": "If `yes`, the array will be replaced with its pointer to improve performance.\nUse `no` for compile time function evaluation.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL527_2510)\n---\nimport std.algorithm.iteration: map, sum, reduce;\nimport std.algorithm.comparison: max;\nimport std.experimental.ndslice.iteration: transposed;\n/// Returns maximal column average.\nauto maxAvg(S)(S matrix) {\n    return matrix.transposed.map!sum.reduce!max\n         / matrix.length;\n}\nenum matrix = [1, 2,\n               3, 4].sliced!(ReplaceArrayWithPointer.no)(2, 2);\n///Сompile time function evaluation\nstatic assert(maxAvg(matrix) == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL527_2510)\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "DeepElementType",
						"line": 547,
						"type": "S.DeepElemType",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "DeepElementType",
				"line": 547,
				"comment": "Returns the element type of the `Slice` type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL550_2511)\n---\nimport std.range: iota;\nstatic assert(is(DeepElementType!(Slice!(4, const(int)[]))     == const(int)));\nstatic assert(is(DeepElementType!(Slice!(4, immutable(int)*))  == immutable(int)));\nstatic assert(is(DeepElementType!(Slice!(4, typeof(100.iota))) == int));\n//packed slice\nstatic assert(is(DeepElementType!(Slice!(2, Slice!(5, int*)))  == Slice!(4, int*)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL550_2511)\n",
				"parameters": [
					{
						"name": "S",
						"type": "Slice!(N, Range)",
						"kind": "type"
					},
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Structure",
						"line": 563,
						"members": [
							{
								"name": "lengths",
								"line": 566,
								"comment": "\n",
								"type": "size_t[N]",
								"char": 15,
								"kind": "variable"
							},
							{
								"name": "strides",
								"line": 568,
								"comment": "\n",
								"type": "sizediff_t[N]",
								"char": 19,
								"kind": "variable"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Structure",
				"line": 563,
				"comment": "Presents $(LREF .Slice.structure).\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Slice",
						"line": 761,
						"members": [
							{
								"endchar": 5,
								"name": "shape",
								"line": 895,
								"comment": "    Returns: static array of lengths\n    See_also: $(LREF .Slice.structure)\n",
								"type": "const @property size_t[N]()",
								"endline": 899,
								"char": 15,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "structure",
								"line": 927,
								"comment": "    Returns: static array of lengths and static array of strides\n    See_also: $(LREF .Slice.shape)\n",
								"type": "const @property Structure!N()",
								"endline": 931,
								"char": 17,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "length",
										"line": 1005,
										"type": "const @property size_t()",
										"endline": 1010,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "length",
								"line": 1005,
								"comment": "    Multidimensional `length` property.\n    Returns: length of the corresponding dimension\n    See_also: $(LREF .Slice.shape), $(LREF .Slice.structure)\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "stride",
										"line": 1031,
										"type": "const @property size_t()",
										"endline": 1035,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "stride",
								"line": 1031,
								"comment": "        Multidimensional `stride` property.\n        Returns: stride of the corresponding dimension\n        See_also: $(LREF .Slice.structure)\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "empty",
										"line": 1066,
										"type": "const @property bool()",
										"endline": 1072,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "empty",
								"line": 1066,
								"comment": "    Multidimensional input range primitive.\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "front",
										"line": 1075,
										"type": "@property ref ()",
										"endline": 1105,
										"char": 14,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "front",
								"line": 1075,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "back",
										"line": 1122,
										"type": "@property ref ()",
										"endline": 1149,
										"char": 14,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "back",
								"line": 1122,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "popFront",
										"line": 1163,
										"type": "void()",
										"endline": 1170,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "popFront",
								"line": 1163,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "popBack",
										"line": 1173,
										"type": "void()",
										"endline": 1179,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "popBack",
								"line": 1173,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "popFrontExactly",
										"line": 1182,
										"type": "void(size_t n)",
										"parameters": [
											{
												"name": "n",
												"type": "size_t"
											}
										],
										"endline": 1189,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "popFrontExactly",
								"line": 1182,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "popBackExactly",
										"line": 1192,
										"type": "void(size_t n)",
										"parameters": [
											{
												"name": "n",
												"type": "size_t"
											}
										],
										"endline": 1198,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "popBackExactly",
								"line": 1192,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "popFrontN",
										"line": 1201,
										"type": "void(size_t n)",
										"parameters": [
											{
												"name": "n",
												"type": "size_t"
											}
										],
										"endline": 1207,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "popFrontN",
								"line": 1201,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "popBackN",
										"line": 1210,
										"type": "void(size_t n)",
										"parameters": [
											{
												"name": "n",
												"type": "size_t"
											}
										],
										"endline": 1216,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "popBackN",
								"line": 1210,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "dimension",
										"type": "size_t",
										"defaultValue": "0",
										"kind": "value"
									}
								],
								"constraint": "dimension < N",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "elementsCount",
								"line": 1303,
								"comment": "    Returns: total number of elements in a slice\n",
								"type": "const size_t()",
								"endline": 1309,
								"char": 12,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opEquals",
										"line": 1336,
										"type": "bool(auto ref Slice!(NR, RangeR) rslice)",
										"parameters": [
											{
												"name": "rslice",
												"type": "Slice!(NR, RangeR)",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 1351,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opEquals",
								"line": 1336,
								"comment": "    Overloading `==` and `!=`\n",
								"parameters": [
									{
										"name": "NR",
										"type": "size_t",
										"kind": "value"
									},
									{
										"name": "RangeR",
										"kind": "type"
									}
								],
								"constraint": "Slice!(NR, RangeR).PureN == PureN",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opEquals",
										"line": 1354,
										"type": "bool(T[] rarrary)",
										"parameters": [
											{
												"name": "rarrary",
												"type": "T[]"
											}
										],
										"endline": 1362,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opEquals",
								"line": 1354,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndex",
										"line": 1398,
										"type": "ref (Indexes _indexes)",
										"parameters": [
											{
												"name": "_indexes",
												"type": "Indexes"
											}
										],
										"endline": 1405,
										"char": 14,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "opIndex",
								"line": 1398,
								"comment": "    $(BLUE Fully defined index).\n",
								"parameters": [
									{
										"name": "Indexes",
										"kind": "tuple"
									}
								],
								"constraint": "isFullPureIndex!Indexes",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndex",
										"line": 1424,
										"type": "(Slices slices)",
										"parameters": [
											{
												"name": "slices",
												"type": "Slices"
											}
										],
										"endline": 1465,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "opIndex",
								"line": 1424,
								"comment": "    $(BLUE Partially or fully defined slice).\n",
								"parameters": [
									{
										"name": "Slices",
										"kind": "tuple"
									}
								],
								"constraint": "isPureSlice!Slices",
								"char": 10,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Slice",
				"line": 761,
				"comment": "Presents an n-dimensional view over a range.\n\n$(H3 Definitions)\n\nIn order to change data in a slice using\noverloaded operators such as `=`, `+=`, `++`,\na syntactic structure of type\n`<slice to change>[<index and interval sequence...>]` must be used.\nIt is worth noting that just like for regular arrays, operations `a = b`\nand `a[] = b` have different meanings.\nIn the first case, after the operation is carried out, `a` simply points at the same data as `b`\ndoes, and the data which `a` previously pointed at remains unmodified.\nHere, `а` and `b` must be of the same type.\nIn the second case, `a` points at the same data as before,\nbut the data itself will be changed. In this instance, the number of dimensions of `b`\nmay be less than the number of dimensions of `а`; and `b` can be a Slice,\na regular multidimensional array, or simply a value (e.g. a number).\n\nIn the following table you will find the definitions you might come across\nin comments on operator overloading.\n\n$(BOOKTABLE\n$(TR $(TH Definition) $(TH Examples at `N == 3`))\n$(TR $(TD An $(BLUE interval) is a part of a sequence of type `i .. j`.)\n    $(STD `2..$-3`, `0..4`))\n$(TR $(TD An $(BLUE index) is a part of a sequence of type `i`.)\n    $(STD `3`, `$-1`))\n$(TR $(TD A $(BLUE partially defined slice) is a sequence composed of\n    $(BLUE intervals) and $(BLUE indexes) with an overall length strictly less than `N`.)\n    $(STD `[3]`, `[0..$]`, `[3, 3]`, `[0..$,0..3]`, `[0..$,2]`))\n$(TR $(TD A $(BLUE fully defined index) is a sequence\n    composed only of $(BLUE indexes) with an overall length equal to `N`.)\n    $(STD `[2,3,1]`))\n$(TR $(TD A $(BLUE fully defined slice) is an empty sequence\n    or a sequence composed of $(BLUE indexes) and at least one\n    $(BLUE interval) with an overall length equal to `N`.)\n    $(STD `[]`, `[3..$,0..3,0..$-1]`, `[2,0..$,1]`))\n)\n\n$(H3 Internal Binary Representation)\n\nMultidimensional Slice is a structure that consists of lengths, strides, and a pointer.\nFor ranges, a shell is used instead of a pointer.\nThis shell contains a shift of the current initial element of a multidimensional slice\nand the range itself. With the exception of overloaded operators, no functions in this\npackage change or copy data. The operations are only carried out on lengths, strides,\nand pointers. If a slice is defined over a range, only the shift of the initial element\nchanges instead of the pointer.\n\n$(H4 Internal Representation for Pointers)\n\nType definition\n\n-------\nSlice!(N, T*)\n-------\n\nSchema\n\n-------\nSlice!(N, T*)\n    size_t[N]     lengths\n    sizediff_t[N] strides\n    T*            ptr\n-------\n\nExample:\n\nDefinitions\n\n-------\nimport std.experimental.ndslice;\nauto a = new double[24];\nSlice!(3, double*) s = a.sliced(2, 3, 4);\nSlice!(3, double*) t = s.transposed!(1, 2, 0);\nSlice!(3, double*) r = r.reversed!1;\n-------\n\nRepresentation\n\n-------\ns________________________\n    lengths[0] ::=  2\n    lengths[1] ::=  3\n    lengths[2] ::=  4\n\n    strides[0] ::= 12\n    strides[1] ::=  4\n    strides[2] ::=  1\n\n    ptr        ::= &a[0]\n\nt____transposed!(1, 2, 0)\n    lengths[0] ::=  3\n    lengths[1] ::=  4\n    lengths[2] ::=  2\n\n    strides[0] ::=  4\n    strides[1] ::=  1\n    strides[2] ::= 12\n\n    ptr        ::= &a[0]\n\nr______________reversed!1\n    lengths[0] ::=  2\n    lengths[1] ::=  3\n    lengths[2] ::=  4\n\n    strides[0] ::= 12\n    strides[1] ::= -4\n    strides[2] ::=  1\n\n    ptr        ::= &a[8] // (old_strides[1] * (lengths[1] - 1)) = 8\n-------\n\n$(H4 Internal Representation for Ranges)\n\nType definition\n\n-------\nSlice!(N, Range)\n-------\n\nRepresentation\n\n-------\nSlice!(N, Range)\n    size_t[N]     lengths\n    sizediff_t[N] strides\n    PtrShell!T    ptr\n        sizediff_t shift\n        Range      range\n-------\n\n\nExample:\n\nDefinitions\n\n-------\nimport std.experimental.ndslice;\nimport std.range: iota;\nauto a = iota(24);\nalias A = typeof(a);\nSlice!(3, A) s = a.sliced(2, 3, 4);\nSlice!(3, A) t = s.transposed!(1, 2, 0);\nSlice!(3, A) r = r.reversed!1;\n-------\n\nRepresentation\n\n-------\ns________________________\n    lengths[0] ::=  2\n    lengths[1] ::=  3\n    lengths[2] ::=  4\n\n    strides[0] ::= 12\n    strides[1] ::=  4\n    strides[2] ::=  1\n\n        shift  ::=  0\n        range  ::=  a\n\nt____transposed!(1, 2, 0)\n    lengths[0] ::=  3\n    lengths[1] ::=  4\n    lengths[2] ::=  2\n\n    strides[0] ::=  4\n    strides[1] ::=  1\n    strides[2] ::= 12\n\n        shift  ::=  0\n        range  ::=  a\n\nr______________reversed!1\n    lengths[0] ::=  2\n    lengths[1] ::=  3\n    lengths[2] ::=  4\n\n    strides[0] ::= 12\n    strides[1] ::= -4\n    strides[2] ::=  1\n\n        shift  ::=  8 // (old_strides[1] * (lengths[1] - 1)) = 8\n        range  ::=  a\n-------\nExample:\nSlicing, indexing, and arithmetic operations.$(DDOX_UNITTEST_HEADER __unittestL2012_2549)\n---\nimport std.array: array;\nimport std.range: iota;\nimport std.experimental.ndslice.iteration: transposed;\n\nauto tensor = 60.iota.array.sliced(3, 4, 5);\n\nassert(tensor[1, 2] == tensor[1][2]);\nassert(tensor[1, 2, 3] == tensor[1][2][3]);\n\nassert( tensor[0..$, 0..$, 4] == tensor.transposed!2[4]);\nassert(&tensor[0..$, 0..$, 4][1, 2] is &tensor[1, 2, 4]);\n\ntensor[1, 2, 3]++; //`opIndex` returns value by reference.\n--tensor[1, 2, 3]; //`opUnary`\n\n++tensor[];\ntensor[] -= 1;\n\n// `opIndexAssing` accepts only fully defined indexes and slices.\n// Use an additional empty slice `[]`.\nstatic assert(!__traits(compiles), tensor[0 .. 2] *= 2);\n\ntensor[0 .. 2][] *= 2;          //OK, empty slice\ntensor[0 .. 2, 3, 0..$] /= 2; //OK, 3 index or slice positions are defined.\n\n//fully defined index may be replaced by a static array\nsize_t[3] index = [1, 2, 3];\nassert(tensor[index] == tensor[1, 2, 3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2012_2549)\nExample:\nOperations with rvalue slices.$(DDOX_UNITTEST_HEADER __unittestL2047_2550)\n---\nimport std.experimental.ndslice.iteration: transposed, everted;\n\nauto tensor = new int[60].sliced(3, 4, 5);\nauto matrix = new int[12].sliced(3, 4);\nauto vector = new int[ 3].sliced(3);\n\nforeach (i; 0..3)\n    vector[i] = i;\n\n// fills matrix columns\nmatrix.transposed[] = vector;\n\n// fills tensor with vector\n// transposed tensor shape is (4, 5, 3)\n//            vector shape is (      3)\ntensor.transposed!(1, 2)[] = vector;\n\n\n// transposed tensor shape is (5, 3, 4)\n//            matrix shape is (   3, 4)\ntensor.transposed!2[] += matrix;\n\n// transposed tensor shape is (5, 4, 3)\n// transposed matrix shape is (   4, 3)\ntensor.everted[] ^= matrix.transposed; // XOR\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2047_2550)\nExample:\nCreating a slice from text.\nSee also $(LINK2 std_format.html, std.format).$(DDOX_UNITTEST_HEADER __unittestL2080_2552)\n---\nimport std.algorithm,  std.conv, std.exception, std.format,\n    std.functional, std.string, std.range;\n\nSlice!(2, int*) toMatrix(string str)\n{\n    string[][] data = str.lineSplitter.filter!(not!empty).map!split.array;\n\n    size_t rows    = data   .length.enforce(\"empty input\");\n    size_t columns = data[0].length.enforce(\"empty first row\");\n\n    data.each!(a => enforce(a.length == columns, \"rows have different lengths\"));\n\n    auto slice = new int[rows * columns].sliced(rows, columns);\n    foreach (i, line; data)\n        foreach (j, num; line)\n            slice[i, j] = num.to!int;\n    return slice;\n}\n\nauto input = \"\\r1 2  3\\r\\n 4 5 6\\n\";\n\nauto matrix = toMatrix(input);\nassert(matrix == [[1, 2, 3], [4, 5, 6]]);\n\n// back to text\nauto text2 = format(\"%(%(%s %)\\n%)\\n\", matrix);\nassert(text2 == \"1 2 3\\n4 5 6\\n\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2080_2552)\n",
				"parameters": [
					{
						"name": "_N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "_Range",
						"kind": "type"
					}
				],
				"constraint": "_N && _N < 256LU && (!is(Unqual!_Range : Slice!(N0, Range0), size_t N0, Range0) && (isPointer!_Range || is(typeof(_Range.init[size_t.init]))) || is(_Range == Slice!(N1, Range1), size_t N1, Range1))",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_experimental_ndslice.html, std.experimental.ndslice).\n\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   Ilya Yaroshenko\n\nSource:    $(PHOBOSSRC std/_experimental/_ndslice/_slice.d)\n\nMacros:\nSUBMODULE = $(LINK2 std_experimental_ndslice_$1.html, std.experimental.ndslice.$1)\nSUBREF = $(LINK2 std_experimental_ndslice_$1.html#.$2, $(TT $2))$(NBSP)\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\nT4=$(TR $(TDNW $(LREF $1)) $(TD $2) $(TD $3) $(TD $4))\nSTD = $(TD $(SMALL $0))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/ndslice/iteration.d",
		"name": "std.experimental.ndslice.iteration",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "swapped",
								"line": 126,
								"type": "(Slice!(N, Range) slice)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)"
									}
								],
								"endline": 139,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "swapped",
						"line": 126,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "swapped",
				"line": 124,
				"comment": "Swaps two dimensions.\n\nParams:\n    slice = input slice\n    dimensionA = first dimension\n    dimensionB = second dimension\nReturns:\n    n-dimensional slice of the same type\nSee_also: $(LREF everted), $(LREF transposed)\nExample:\nTemplate$(DDOX_UNITTEST_HEADER __unittestL167_2570)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nassert(10000.iota\n    .sliced(3, 4, 5, 6)\n    .swapped!(3, 1)\n    .shape == cast(size_t[4])[3, 6, 5, 4]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL167_2570)\nExample:\nFunction$(DDOX_UNITTEST_HEADER __unittestL178_2571)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nassert(10000.iota\n    .sliced(3, 4, 5, 6)\n    .swapped(1, 3)\n    .shape == cast(size_t[4])[3, 6, 5, 4]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL178_2571)\nExample:\n2D$(DDOX_UNITTEST_HEADER __unittestL189_2572)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nassert(10000.iota\n    .sliced(3, 4)\n    .swapped\n    .shape == cast(size_t[2])[4, 3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL189_2572)\n",
				"parameters": [
					{
						"name": "dimensionA",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "dimensionB",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "swapped",
						"line": 143,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t dimensionA, size_t dimensionB)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimensionA",
								"type": "size_t"
							},
							{
								"name": "dimensionB",
								"type": "size_t"
							}
						],
						"endline": 157,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "swapped",
				"line": 143,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "swapped",
						"line": 160,
						"type": "Slice!(2, Range)(Slice!(2, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(2, Range)"
							}
						],
						"endline": 164,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "swapped",
				"line": 160,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "rotated",
								"line": 238,
								"type": "(Slice!(N, Range) slice, sizediff_t k = 1)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)"
									},
									{
										"name": "k",
										"type": "sizediff_t",
										"default": "1"
									}
								],
								"endline": 251,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "rotated",
						"line": 238,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "rotated",
				"line": 236,
				"comment": "Rotates two selected dimensions by `k*90` degrees.\nThe order of dimensions is important.\nIf the slice has two dimensions, the default direction is counterclockwise.\n\nParams:\n    slice = input slice\n    dimensionA = first dimension\n    dimensionB = second dimension\n    k = rotation counter, can be negative\nReturns:\n    n-dimensional slice of the same type\nExample:\nTemplate$(DDOX_UNITTEST_HEADER __unittestL279_2573)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nauto slice = 10.iota.sliced(2, 3);\n\nauto a = [[0, 1, 2],\n          [3, 4, 5]];\n\nauto b = [[2, 5],\n          [1, 4],\n          [0, 3]];\n\nauto c = [[5, 4, 3],\n          [2, 1, 0]];\n\nauto d = [[3, 0],\n          [4, 1],\n          [5, 2]];\n\nassert(slice.rotated       ( 4) == a);\nassert(slice.rotated!(0, 1)(-4) == a);\nassert(slice.rotated (1, 0,  8) == a);\n\nassert(slice.rotated            == b);\nassert(slice.rotated!(0, 1)(-3) == b);\nassert(slice.rotated (1, 0,  3) == b);\n\nassert(slice.rotated       ( 6) == c);\nassert(slice.rotated!(0, 1)( 2) == c);\nassert(slice.rotated (0, 1, -2) == c);\n\nassert(slice.rotated       ( 7) == d);\nassert(slice.rotated!(0, 1)( 3) == d);\nassert(slice.rotated (1, 0,   ) == d);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL279_2573)\n",
				"parameters": [
					{
						"name": "dimensionA",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "dimensionB",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rotated",
						"line": 255,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t dimensionA, size_t dimensionB, sizediff_t k = 1)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimensionA",
								"type": "size_t"
							},
							{
								"name": "dimensionB",
								"type": "size_t"
							},
							{
								"name": "k",
								"type": "sizediff_t",
								"default": "1"
							}
						],
						"endline": 269,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "rotated",
				"line": 255,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rotated",
						"line": 272,
						"type": "Slice!(2, Range)(Slice!(2, Range) slice, sizediff_t k = 1)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(2, Range)"
							},
							{
								"name": "k",
								"type": "sizediff_t",
								"default": "1"
							}
						],
						"endline": 276,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "rotated",
				"line": 272,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "everted",
						"line": 325,
						"type": "Slice!(N, Range)(auto ref Slice!(N, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 343,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "everted",
				"line": 325,
				"comment": "Reverses the order of dimensions.\n\nParams:\n    slice = input slice\nReturns:\n    n-dimensional slice of the same type\nSee_also: $(LREF swapped), $(LREF transposed)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL346_2574)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nassert(1000.iota\n    .sliced(3, 4, 5)\n    .everted\n    .shape == cast(size_t[3])[5, 4, 3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL346_2574)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "transposed",
								"line": 407,
								"type": "Slice!(N, Range)(auto ref Slice!(N, Range) slice)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 418,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "transposed",
						"line": 407,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 22,
						"kind": "template"
					}
				],
				"name": "transposed",
				"line": 404,
				"comment": "N-dimensional transpose operator.\nBrings selected dimensions to the first position.\nParams:\n    slice = input slice\n    Dimensions = indexes of dimensions to be brought to the first position\n    dimensions = indexes of dimensions to be brought to the first position\n    dimension = index of dimension to be brought to the first position\nReturns:\n    n-dimensional slice of the same type\nSee_also: $(LREF swapped), $(LREF everted)\nExample:\nTemplate$(DDOX_UNITTEST_HEADER __unittestL461_2575)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nassert(100000.iota\n    .sliced(3, 4, 5, 6, 7)\n    .transposed!(4, 1, 0)\n    .shape == cast(size_t[5])[7, 4, 3, 5, 6]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL461_2575)\nExample:\nFunction$(DDOX_UNITTEST_HEADER __unittestL472_2576)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nassert(100000.iota\n    .sliced(3, 4, 5, 6, 7)\n    .transposed(4, 1, 0)\n    .shape == cast(size_t[5])[7, 4, 3, 5, 6]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL472_2576)\nExample:\nSingle-argument function$(DDOX_UNITTEST_HEADER __unittestL483_2577)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nassert(100000.iota\n    .sliced(3, 4, 5, 6, 7)\n    .transposed(4)\n    .shape == cast(size_t[5])[7, 3, 4, 5, 6]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL483_2577)\nExample:\n`2`-dimensional transpose$(DDOX_UNITTEST_HEADER __unittestL494_2578)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nassert(100.iota\n    .sliced(3, 4)\n    .transposed\n    .shape == cast(size_t[2])[4, 3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL494_2578)\n",
				"parameters": [
					{
						"name": "Dimensions",
						"kind": "tuple"
					}
				],
				"constraint": "Dimensions.length",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "transposed",
						"line": 422,
						"type": "Slice!(N, Range)(auto ref Slice!(N, Range) slice, size_t dimension)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "dimension",
								"type": "size_t"
							}
						],
						"endline": 434,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "transposed",
				"line": 422,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "transposed",
						"line": 437,
						"type": "Slice!(N, Range)(auto ref Slice!(N, Range) slice, in size_t[] dimensions...)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "dimensions",
								"type": "size_t[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 452,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "transposed",
				"line": 437,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "transposed",
						"line": 455,
						"type": "Slice!(2, Range)(auto ref Slice!(2, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(2, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 458,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "transposed",
				"line": 455,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allReversed",
						"line": 520,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							}
						],
						"endline": 527,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "allReversed",
				"line": 520,
				"comment": "Reverses the direction of iteration for all dimensions.\nParams:\n    slice = input slice\nReturns:\n    n-dimensional slice of the same type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL530_2579)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota, retro;\nauto a = 20.iota.sliced(4, 5).allReversed;\nauto b = 20.iota.retro.sliced(4, 5);\nassert(a == b);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL530_2579)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "reversed",
								"line": 553,
								"type": "(Slice!(N, Range) slice)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)"
									}
								],
								"endline": 561,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "reversed",
						"line": 553,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "reversed",
				"line": 550,
				"comment": "Reverses the direction of iteration for selected dimensions.\n\nParams:\n    slice = input slice\n    Dimensions = indexes of dimensions to reverse order of iteration\n    dimensions = indexes of dimensions to reverse order of iteration\n    dimension = index of dimension to reverse order of iteration\nReturns:\n    n-dimensional slice of the same type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL591_2580)\n---\nimport std.experimental.ndslice.slice;\nauto slice = [1, 2, 3, 4].sliced(2, 2);\nassert(slice                    == [[1, 2], [3, 4]]);\n\n// Template\nassert(slice.reversed! 0        == [[3, 4], [1, 2]]);\nassert(slice.reversed! 1        == [[2, 1], [4, 3]]);\nassert(slice.reversed!(0, 1)    == [[4, 3], [2, 1]]);\nassert(slice.reversed!(1, 0)    == [[4, 3], [2, 1]]);\nassert(slice.reversed!(1, 1)    == [[1, 2], [3, 4]]);\nassert(slice.reversed!(0, 0, 0) == [[3, 4], [1, 2]]);\n\n// Function\nassert(slice.reversed (0)       == [[3, 4], [1, 2]]);\nassert(slice.reversed (1)       == [[2, 1], [4, 3]]);\nassert(slice.reversed (0, 1)    == [[4, 3], [2, 1]]);\nassert(slice.reversed (1, 0)    == [[4, 3], [2, 1]]);\nassert(slice.reversed (1, 1)    == [[1, 2], [3, 4]]);\nassert(slice.reversed (0, 0, 0) == [[3, 4], [1, 2]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL591_2580)\n",
				"parameters": [
					{
						"name": "Dimensions",
						"kind": "tuple"
					}
				],
				"constraint": "Dimensions.length",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reversed",
						"line": 565,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t dimension)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimension",
								"type": "size_t"
							}
						],
						"endline": 574,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "reversed",
				"line": 565,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reversed",
						"line": 577,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, in size_t[] dimensions...)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimensions",
								"type": "size_t[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 588,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "reversed",
				"line": 577,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "strided",
								"line": 667,
								"type": "(Slice!(N, Range) slice, Repeat!(size_t, Dimensions.length) factors)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)"
									},
									{
										"name": "factors",
										"type": "Repeat!(size_t, Dimensions.length)"
									}
								],
								"endline": 677,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "strided",
						"line": 667,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "strided",
				"line": 664,
				"comment": "Multiplies the stride of the selected dimension by the factor.\n\nParams:\n    slice = input slice\n    Dimensions = indexes of dimensions to be strided\n    dimensions = indexes of dimensions to be strided\n    factors = list of step extension factors\n    factor = step extension factors\nReturns:\n    n-dimensional slice of the same type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL693_2582)\n---\nimport std.experimental.ndslice.slice;\nauto slice\n     = [0,1,2,3,    4,5,6,7,   8,9,10,11].sliced(3, 4);\n\nassert(slice\n    == [[0,1,2,3], [4,5,6,7], [8,9,10,11]]);\n\n// Template\nassert(slice.strided!0(2)\n    == [[0,1,2,3],            [8,9,10,11]]);\n\nassert(slice.strided!1(3)\n    == [[0,    3], [4,    7], [8,     11]]);\n\nassert(slice.strided!(0, 1)(2, 3)\n    == [[0,    3],            [8,     11]]);\n\n// Function\nassert(slice.strided(0, 2)\n    == [[0,1,2,3],            [8,9,10,11]]);\n\nassert(slice.strided(1, 3)\n    == [[0,    3], [4,    7], [8,     11]]);\n\nassert(slice.strided(0, 2).strided(1, 3)\n    == [[0,    3],            [8,     11]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL693_2582)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL724_2583)\n---\nimport std.range: iota;\nstatic assert(1000.iota.sliced(13, 40).strided!(0, 1)(2, 5).shape == [7, 8]);\nstatic assert(100.iota.sliced(93).strided!(0, 0)(7, 3).shape == [5]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL724_2583)\n",
				"parameters": [
					{
						"name": "Dimensions",
						"kind": "tuple"
					}
				],
				"constraint": "Dimensions.length",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strided",
						"line": 681,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t dimension, size_t factor)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimension",
								"type": "size_t"
							},
							{
								"name": "factor",
								"type": "size_t"
							}
						],
						"endline": 690,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "strided",
				"line": 681,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allDropOne",
						"line": 762,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							}
						],
						"endline": 767,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "allDropOne",
				"line": 762,
				"comment": "Convenience function which calls `slice.popFront!dimension()` for each dimension and returns the slice.\n\n`allDropBackOne` provides the same functionality but calls `slice.popBack!dimension()` instead.\n\nParams:\n    slice = input slice\nReturns:\n    n-dimensional slice of the same type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL778_2585)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota, retro;\nauto a = 20.iota.sliced(4, 5);\n\nassert(a.allDropOne[0, 0] == 6);\nassert(a.allDropOne.shape == cast(size_t[2])[3, 4]);\nassert(a.allDropBackOne[$ - 1, $ - 1] == 13);\nassert(a.allDropBackOne.shape == cast(size_t[2])[3, 4]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL778_2585)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allDropBackOne",
						"line": 770,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							}
						],
						"endline": 775,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "allDropBackOne",
				"line": 770,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allDropExactly",
						"line": 807,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t n)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 812,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "allDropExactly",
				"line": 807,
				"comment": "These functions are similar to `allDrop` and `allDropBack` but they call\n`slice.popFrontExactly!dimension(n)` and `slice.popBackExactly!dimension(n)` instead.\n\nNote:\nUnlike `allDrop`, `allDropExactly(n)` assume that the slice holds\na multi-dimensional cube with a size of at least n.\nThis makes `allDropExactly` faster than `allDrop`.\nOnly use `allDropExactly` when it is guaranteed that the slice holds\na multi-dimensional cube with a size of at least n.\n\nParams:\n    slice = input slice\n    n = number of elements to drop\nReturns:\n    n-dimensional slice of the same type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL823_2586)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota, retro;\nauto a = 20.iota.sliced(4, 5);\n\nassert(a.allDropExactly(2)[0, 0] == 12);\nassert(a.allDropExactly(2).shape == cast(size_t[2])[2, 3]);\nassert(a.allDropBackExactly(2)[$ - 1, $ - 1] == 7);\nassert(a.allDropBackExactly(2).shape == cast(size_t[2])[2, 3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL823_2586)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allDropBackExactly",
						"line": 815,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t n)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 820,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "allDropBackExactly",
				"line": 815,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allDrop",
						"line": 849,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t n)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 854,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "allDrop",
				"line": 849,
				"comment": "Convenience function which calls `slice.popFrontN!dimension(n)` for each dimension and returns the slice.\n\n`allDropBack` provides the same functionality but calls `slice.popBackN!dimension(n)` instead.\n\nNote:\n`allDrop` and `allDropBack` remove up to n elements and stop when the slice is empty.\n\nParams:\n    slice = input slice\n    n = number of elements to drop\nReturns:\n    n-dimensional slice of the same type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL865_2587)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota, retro;\nauto a = 20.iota.sliced(4, 5);\n\nassert(a.allDrop(2)[0, 0] == 12);\nassert(a.allDrop(2).shape == cast(size_t[2])[2, 3]);\nassert(a.allDropBack(2)[$ - 1, $ - 1] == 7);\nassert(a.allDropBack(2).shape == cast(size_t[2])[2, 3]);\n\nassert(a.allDrop    (5).shape == cast(size_t[2])[0, 0]);\nassert(a.allDropBack(5).shape == cast(size_t[2])[0, 0]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL865_2587)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allDropBack",
						"line": 857,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t n)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 862,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "allDropBack",
				"line": 857,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "dropOne",
								"line": 893,
								"type": "Slice!(N, Range)(Slice!(N, Range) slice)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)"
									}
								],
								"endline": 901,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "dropOne",
						"line": 893,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 22,
						"kind": "template"
					}
				],
				"name": "dropOne",
				"line": 890,
				"comment": "Convenience function which calls `slice.popFront!dimension()` for selected dimensions and returns the slice.\n\n`dropBackOne` provides the same functionality but calls `slice.popBack!dimension()` instead.\n\nParams:\n    slice = input slice\nReturns:\n    n-dimensional slice of the same type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL973_2588)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota, retro;\nauto a = 20.iota.sliced(4, 5);\n\nassert(a.dropOne!(1, 0)[0, 0] == 6);\nassert(a.dropOne (1, 0)[0, 0] == 6);\nassert(a.dropOne!(1, 0).shape == cast(size_t[2])[3, 4]);\nassert(a.dropOne (1, 0).shape == cast(size_t[2])[3, 4]);\nassert(a.dropBackOne!(1, 0)[$ - 1, $ - 1] == 13);\nassert(a.dropBackOne (1, 0)[$ - 1, $ - 1] == 13);\nassert(a.dropBackOne!(1, 0).shape == cast(size_t[2])[3, 4]);\nassert(a.dropBackOne (1, 0).shape == cast(size_t[2])[3, 4]);\n\nassert(a.dropOne!(0, 0)[0, 0] == 10);\nassert(a.dropOne (0, 0)[0, 0] == 10);\nassert(a.dropOne!(0, 0).shape == cast(size_t[2])[2, 5]);\nassert(a.dropOne (0, 0).shape == cast(size_t[2])[2, 5]);\nassert(a.dropBackOne!(1, 1)[$ - 1, $ - 1] == 17);\nassert(a.dropBackOne (1, 1)[$ - 1, $ - 1] == 17);\nassert(a.dropBackOne!(1, 1).shape == cast(size_t[2])[4, 3]);\nassert(a.dropBackOne (1, 1).shape == cast(size_t[2])[4, 3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL973_2588)\n",
				"parameters": [
					{
						"name": "Dimensions",
						"kind": "tuple"
					}
				],
				"constraint": "Dimensions.length",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropOne",
						"line": 905,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t dimension)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimension",
								"type": "size_t"
							}
						],
						"endline": 914,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "dropOne",
				"line": 905,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropOne",
						"line": 917,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, in size_t[] dimensions...)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimensions",
								"type": "size_t[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 928,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "dropOne",
				"line": 917,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "dropBackOne",
								"line": 934,
								"type": "Slice!(N, Range)(Slice!(N, Range) slice)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)"
									}
								],
								"endline": 942,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "dropBackOne",
						"line": 934,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 22,
						"kind": "template"
					}
				],
				"name": "dropBackOne",
				"line": 931,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Dimensions",
						"kind": "tuple"
					}
				],
				"constraint": "Dimensions.length",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropBackOne",
						"line": 946,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t dimension)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimension",
								"type": "size_t"
							}
						],
						"endline": 955,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "dropBackOne",
				"line": 946,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropBackOne",
						"line": 958,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, in size_t[] dimensions...)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimensions",
								"type": "size_t[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 969,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "dropBackOne",
				"line": 958,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "dropExactly",
								"line": 1030,
								"type": "Slice!(N, Range)(Slice!(N, Range) slice, Repeat!(size_t, Dimensions.length) ns)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)"
									},
									{
										"name": "ns",
										"type": "Repeat!(size_t, Dimensions.length)"
									}
								],
								"endline": 1039,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "dropExactly",
						"line": 1030,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 22,
						"kind": "template"
					}
				],
				"name": "dropExactly",
				"line": 1027,
				"comment": "These functions are similar to `drop` and `dropBack` but they call\n`slice.popFrontExactly!dimension(n)` and `slice.popBackExactly!dimension(n)` instead.\n\nNote:\nUnlike `drop`, `dropExactly` assumes that the slice holds enough elements in\nthe selected dimension.\nThis makes `dropExactly` faster than `drop`.\n\nParams:\n    slice = input slice\n    ns = list of numbers of elements to drop\n    n = number of elements to drop\nReturns:\n    n-dimensional slice of the same type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1083_2590)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota, retro;\nauto a = 20.iota.sliced(4, 5);\n\nassert(a.dropExactly    !(1, 0)(2, 3)[0, 0] == 17);\nassert(a.dropExactly    !(1, 0)(2, 3).shape == cast(size_t[2])[1, 3]);\nassert(a.dropBackExactly!(0, 1)(2, 3)[$ - 1, $ - 1] == 6);\nassert(a.dropBackExactly!(0, 1)(2, 3).shape == cast(size_t[2])[2, 2]);\n\nassert(a.dropExactly(1, 2).dropExactly(0, 3)[0, 0] == 17);\nassert(a.dropExactly(1, 2).dropExactly(0, 3).shape == cast(size_t[2])[1, 3]);\nassert(a.dropBackExactly(0, 2).dropBackExactly(1, 3)[$ - 1, $ - 1] == 6);\nassert(a.dropBackExactly(0, 2).dropBackExactly(1, 3).shape == cast(size_t[2])[2, 2]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1083_2590)\n",
				"parameters": [
					{
						"name": "Dimensions",
						"kind": "tuple"
					}
				],
				"constraint": "Dimensions.length",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropExactly",
						"line": 1043,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t dimension, size_t n)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimension",
								"type": "size_t"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1052,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "dropExactly",
				"line": 1043,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "dropBackExactly",
								"line": 1058,
								"type": "Slice!(N, Range)(Slice!(N, Range) slice, Repeat!(size_t, Dimensions.length) ns)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)"
									},
									{
										"name": "ns",
										"type": "Repeat!(size_t, Dimensions.length)"
									}
								],
								"endline": 1067,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "dropBackExactly",
						"line": 1058,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 22,
						"kind": "template"
					}
				],
				"name": "dropBackExactly",
				"line": 1055,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Dimensions",
						"kind": "tuple"
					}
				],
				"constraint": "Dimensions.length",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropBackExactly",
						"line": 1071,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t dimension, size_t n)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimension",
								"type": "size_t"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1080,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "dropBackExactly",
				"line": 1071,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "drop",
								"line": 1119,
								"type": "Slice!(N, Range)(Slice!(N, Range) slice, Repeat!(size_t, Dimensions.length) ns)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)"
									},
									{
										"name": "ns",
										"type": "Repeat!(size_t, Dimensions.length)"
									}
								],
								"endline": 1128,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "drop",
						"line": 1119,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 22,
						"kind": "template"
					}
				],
				"name": "drop",
				"line": 1116,
				"comment": "Convenience function which calls `slice.popFrontN!dimension(n)` for the selected\ndimension and returns the slice.\n\n`dropBack` provides the same functionality but calls `slice.popBackN!dimension(n)` instead.\n\nNote:\n`drop` and `dropBack` remove up to n elements and stop when the slice is empty.\n\nParams:\n    slice = input slice\n    ns = list of numbers of elements to drop\n    n = number of elements to drop\nReturns:\n    n-dimensional slice of the same type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1173_2591)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota, retro;\nauto a = 20.iota.sliced(4, 5);\n\nassert(a.drop    !(1, 0)(2, 3)[0, 0] == 17);\nassert(a.drop    !(1, 0)(2, 3).shape == cast(size_t[2])[1, 3]);\nassert(a.dropBack!(0, 1)(2, 3)[$ - 1, $ - 1] == 6);\nassert(a.dropBack!(0, 1)(2, 3).shape == cast(size_t[2])[2, 2]);\nassert(a.dropBack!(0, 1)(5, 5).shape == cast(size_t[2])[0, 0]);\n\n\nassert(a.drop(1, 2).drop(0, 3)[0, 0] == 17);\nassert(a.drop(1, 2).drop(0, 3).shape == cast(size_t[2])[1, 3]);\nassert(a.dropBack(0, 2).dropBack(1, 3)[$ - 1, $ - 1] == 6);\nassert(a.dropBack(0, 2).dropBack(1, 3).shape == cast(size_t[2])[2, 2]);\nassert(a.dropBack(0, 5).dropBack(1, 5).shape == cast(size_t[2])[0, 0]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1173_2591)\n",
				"parameters": [
					{
						"name": "Dimensions",
						"kind": "tuple"
					}
				],
				"constraint": "Dimensions.length",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "drop",
						"line": 1132,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t dimension, size_t n)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimension",
								"type": "size_t"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1141,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "drop",
				"line": 1132,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "dropBack",
								"line": 1147,
								"type": "Slice!(N, Range)(Slice!(N, Range) slice, Repeat!(size_t, Dimensions.length) ns)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)"
									},
									{
										"name": "ns",
										"type": "Repeat!(size_t, Dimensions.length)"
									}
								],
								"endline": 1156,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "dropBack",
						"line": 1147,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 22,
						"kind": "template"
					}
				],
				"name": "dropBack",
				"line": 1144,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Dimensions",
						"kind": "tuple"
					}
				],
				"constraint": "Dimensions.length",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropBack",
						"line": 1160,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice, size_t dimension, size_t n)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							},
							{
								"name": "dimension",
								"type": "size_t"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1169,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "dropBack",
				"line": 1160,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropToHypercube",
						"line": 1201,
						"type": "Slice!(N, Range)(Slice!(N, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)"
							}
						],
						"endline": 1211,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "dropToHypercube",
				"line": 1201,
				"comment": "Returns maximal multidimensional cube.\n\nParams:\n    slice = input slice\nReturns:\n    n-dimensional slice of the same type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1214_2592)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota, retro;\nassert(1000.iota\n    .sliced(5, 3, 6, 7)\n    .dropToHypercube\n    .shape == cast(size_t[4])[3, 3, 3, 3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1214_2592)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			}
		],
		"comment": "$(SCRIPT inhibitQuickIndex = 1;)\n\nThis is a submodule of $(LINK2 std_experimental_ndslice.html, std.experimental.ndslice).\n\nOperators only change strides and lengths of a slice.\nThe range of a slice remains unmodified.\nAll operators return slice of the same type as the type of the argument.\n\n$(BOOKTABLE $(H2 Transpose operators),\n\n$(TR $(TH Function Name) $(TH Descriprottion))\n$(T2 transposed, `100000.iota.sliced(3, 4, 5, 6, 7).transposed!(4, 0, 1).shape` returns `[7, 3, 4, 5, 6]`.)\n$(T2 swapped, `1000.iota.sliced(3, 4, 5).swapped!(1, 2).shape` returns `[3, 5, 4]`.)\n$(T2 everted, `1000.iota.sliced(3, 4, 5).everted.shape` returns `[5, 4, 3]`.)\n)\nSee also $(SUBREF selection, evertPack).\n\n$(BOOKTABLE $(H2 Iteration operators),\n\n$(TR $(TH Function Name) $(TH Description))\n$(T2 strided, `1000.iota.sliced(13, 40).strided!(0, 1)(2, 5).shape` equals to `[7, 8]`.)\n$(T2 reversed, `slice.reversed!0` returns the slice with reversed direction of iteration for top level dimension.)\n$(T2 allReversed, `20.iota.sliced(4, 5).allReversed` equals to `20.iota.retro.sliced(4, 5)`.)\n)\n\n$(BOOKTABLE $(H2 Other operators),\n$(TR $(TH Function Name) $(TH Description))\n$(T2 rotated, `10.iota.sliced(2, 3).rotated` equals to `[[2, 5], [1, 4], [0, 3]]`.)\n)\n\n$(H4 Drop operators)\n\n$(LREF dropToHypercube)\n$(LREF drop) $(LREF dropBack)\n$(LREF dropOne) $(LREF dropBackOne)\n$(LREF dropExactly) $(LREF dropBackExactly)\n$(LREF allDrop) $(LREF allDropBack)\n$(LREF allDropOne) $(LREF allDropBackOne)\n$(LREF allDropExactly) $(LREF allDropBackExactly)\n\n$(GRAMMAR\n$(GNAME DropOperatorName):\n    $(D dropToHypercube)\n    $(GLINK DropRoot)\n    $(GLINK DropRoot) $(GLINK DropSuffix)\n    $(GLINK DropRoot) $(D Back)\n    $(GLINK DropRoot) $(D Back) $(GLINK DropSuffix)\n$(GNAME DropRoot):\n    $(D drop)\n    $(D allDrop)\n$(GNAME DropSuffix):\n    $(D One)\n    $(D Exactly)\n)\n\n$(H2 Bifacial operators)\n\nSome operators are bifacial,\ni.e. they have two versions: one with template parameters, and another one\nwith function parameters. Versions with template parameters are preferable\nbecause they allow compile time checks and can be optimized better.\n\n$(BOOKTABLE ,\n\n$(TR $(TH Function Name) $(TH Variadic) $(TH Template) $(TH Function))\n$(T4 swapped, No, `slice.swapped!(2, 3)`, `slice.swapped(2, 3)`)\n$(T4 rotated, No, `slice.rotated!(2, 3)(-1)`, `slice.rotated(2, 3, -1)`)\n$(T4 strided, Yes/No, `slice.strided!(1, 2)(20, 40)`, `slice.strided(1, 20).strided(2, 40)`)\n$(T4 transposed, Yes, `slice.transposed!(1, 4, 3)`, `slice.transposed(1, 4, 3)`)\n$(T4 reversed, Yes, `slice.reversed!(0, 2)`, `slice.reversed(0, 2)`)\n)\n\nBifacial interface of $(LREF drop), $(LREF dropBack)\n$(LREF dropExactly), and $(LREF dropBackExactly)\nis identical to that of $(LREF strided).\n\nBifacial interface of $(LREF dropOne) and $(LREF dropBackOne)\nis identical to that of $(LREF reversed).\n\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   Ilya Yaroshenko\n\nSource:    $(PHOBOSSRC std/_experimental/_ndslice/_iteration.d)\n\nMacros:\nSUBMODULE = $(LINK2 std_experimental_ndslice_$1.html, std.experimental.ndslice.$1)\nSUBREF = $(LINK2 std_experimental_ndslice_$1.html#.$2, $(TT $2))$(NBSP)\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\nT4=$(TR $(TDNW $(LREF $1)) $(TD $2) $(TD $3) $(TD $4))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/ndslice/package.d",
		"name": "std.experimental.ndslice",
		"members": [],
		"comment": "$(H1 Multidimensional Random Access Ranges)\n\nThe package provides a multidimensional array implementation.\nIt would be well suited to creating machine learning and image\nprocessing algorithms, but should also be general enough for use anywhere with\nhomogeneously-typed multidimensional data.\nIn addition, it includes various functions for iteration, accessing, and manipulation.\n\nQuick_Start:\n$(SUBREF slice, sliced) is a function designed to create\na multidimensional view over a range.\nMultidimensional view is presented by $(SUBREF slice, Slice) type.\n------\nauto matrix = new double[12].sliced(3, 4);\nmatrix[] = 0;\n------\n\nNote:\nIn many examples $(LINK2 std_range.html#iota, std.range.iota) is used\ninstead of a regular array, which makes it\npossible to carry out tests without memory allocation.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Submodule) $(TH Declarations)\n)\n$(TR $(TDNW Basic Level\n        $(BR) $(SMALL $(SUBREF slice, Slice), its properties, operator overloading))\n     $(TDNW $(SUBMODULE slice))\n     $(TD\n        $(SUBREF slice, sliced)\n        $(SUBREF slice, Slice)\n        $(SUBREF slice, assumeSameStructure)\n        $(SUBREF slice, ReplaceArrayWithPointer)\n        $(SUBREF slice, DeepElementType)\n    )\n)\n$(TR $(TDNW Middle Level\n        $(BR) $(SMALL Various iteration operators))\n     $(TDNW $(SUBMODULE iteration))\n     $(TD\n        $(SUBREF iteration, transposed)\n        $(SUBREF iteration, strided)\n        $(SUBREF iteration, reversed)\n        $(SUBREF iteration, rotated)\n        $(SUBREF iteration, everted)\n        $(SUBREF iteration, swapped)\n        $(SUBREF iteration, allReversed)\n        $(SUBREF iteration, dropToHypercube) and other `drop` primitives\n    )\n)\n$(TR $(TDNW Advanced Level $(BR)\n        $(SMALL Abstract operators for loop free programming\n            $(BR) Take `movingWindowByChannel` as an example))\n     $(TDNW $(SUBMODULE selection))\n     $(TD\n        $(SUBREF selection, blocks)\n        $(SUBREF selection, windows)\n        $(SUBREF selection, diagonal)\n        $(SUBREF selection, reshape)\n        $(SUBREF selection, byElement)\n        $(SUBREF selection, byElementInStandardSimplex)\n        $(SUBREF selection, indexSlice)\n        $(SUBREF selection, pack)\n        $(SUBREF selection, evertPack)\n        $(SUBREF selection, unpack)\n    )\n)\n))\n\n$(H2 Example: Image Processing)\n\nA median filter is implemented as an example. The function\n`movingWindowByChannel` can also be used with other filters that use a sliding\nwindow as the argument, in particular with convolution matrices such as the\n$(LINK2 https://en.wikipedia.org/wiki/Sobel_operator, Sobel operator).\n\n`movingWindowByChannel` iterates over an image in sliding window mode.\nEach window is transferred to a `filter`, which calculates the value of the\npixel that corresponds to the given window.\n\nThis function does not calculate border cases in which a window overlaps\nthe image partially. However, the function can still be used to carry out such\ncalculations. That can be done by creating an amplified image, with the edges\nreflected from the original image, and then applying the given function to the\nnew file.\n\nNote: You can find the example at\n$(LINK2 https://github.com/DlangScience/examples/tree/master/image_processing/median-filter, GitHub).\n\n-------\n/++\nParams:\n    filter = unary function. Dimension window 2D is the argument.\n    image = image dimensions `(h, w, c)`,\n        where с is the number of channels in the image\n    nr = number of rows in the window\n    nс = number of columns in the window\n\nReturns:\n    image dimensions `(h - nr + 1, w - nc + 1, c)`,\n        where с is the number of channels in the image.\n        Dense data layout is guaranteed.\n+/\n\nSlice!(3, C*) movingWindowByChannel(alias filter, C)\n(Slice!(3, C*) image, size_t nr, size_t nc)\n{\n    import std.algorithm.iteration: map;\n    import std.array: array;\n\n        // 0. 3D\n        // The last dimension represents the color channel.\n    auto wnds = image\n        // 1. 2D composed of 1D\n        // Packs the last dimension.\n        .pack!1\n        // 2. 2D composed of 2D composed of 1D\n        // Splits image into overlapping windows.\n        .windows(nr, nc)\n        // 3. 5D\n        // Unpacks the windows.\n        .unpack\n        // 4. 5D\n        // Brings the color channel dimension to the third position.\n        .transposed!(0, 1, 4)\n        // 5. 3D Composed of 2D\n        // Packs the last two dimensions.\n        .pack!2;\n\n    return wnds\n        // 6. Range composed of 2D\n        // Gathers all windows in the range.\n        .byElement\n        // 7. Range composed of pixels\n        // 2D to pixel lazy conversion.\n        .map!filter\n        // 8. `C[]`\n        // The only memory allocation in this function.\n        .array\n        // 9. 3D\n        // Returns slice with corresponding shape.\n        .sliced(wnds.shape);\n}\n-------\n\nA function that calculates the value of iterator median is also necessary.\n\n-------\n/++\n\nParams:\n    r = input range\n    buf = buffer with length no less than the number of elements in `r`\nReturns:\n    median value over the range `r`\n+/\nT median(Range, T)(Range r, T[] buf)\n{\n    import std.algorithm.sorting: sort;\n    size_t n;\n    foreach (e; r)\n        buf[n++] = e;\n    buf[0 .. n].sort();\n    immutable m = n >> 1;\n    return n & 1 ? buf[m] : cast(T)((buf[m - 1] + buf[m]) / 2);\n}\n-------\n\nThe `main` function:\n\n-------\nvoid main(string[] args)\n{\n    import std.conv: to;\n    import std.getopt: getopt, defaultGetoptPrinter;\n    import std.path: stripExtension;\n\n    uint nr, nc, def = 3;\n    auto helpInformation = args.getopt(\n        \"nr\", \"number of rows in window, default value is \" ~ def.to!string, &nr,\n        \"nc\", \"number of columns in window, default value is equal to nr\", &nc);\n    if (helpInformation.helpWanted)\n    {\n        defaultGetoptPrinter(\n            \"Usage: median-filter [<options...>] [<file_names...>]\\noptions:\",\n            helpInformation.options);\n        return;\n    }\n    if (!nr) nr = def;\n    if (!nc) nc = nr;\n\n    auto buf = new ubyte[nr * nc];\n\n    foreach (name; args[1 .. $])\n    {\n        import imageformats; // can be found at code.dlang.org\n\n        IFImage image = read_image(name);\n\n        auto ret = image.pixels\n            .sliced(cast(size_t)image.h, cast(size_t)image.w, cast(size_t)image.c)\n            .movingWindowByChannel\n                !(window => median(window.byElement, buf))\n                 (nr, nc);\n\n        write_image(\n            name.stripExtension ~ \"_filtered.png\",\n            ret.length!1,\n            ret.length!0,\n            (&ret[0, 0, 0])[0 .. ret.elementsCount]);\n    }\n}\n-------\n\nThis program works both with color and grayscale images.\n\n-------\n$ median-filter --help\nUsage: median-filter [<options...>] [<file_names...>]\noptions:\n     --nr number of rows in window, default value is 3\n     --nc number of columns in window default value equals to nr\n-h --help This help information.\n-------\n\n$(H2 Compared with `numpy.ndarray`)\n\nnumpy is undoubtedly one of the most effective software packages that has\nfacilitated the work of many engineers and scientists. However, due to the\nspecifics of implementation of Python, a programmer who wishes to use the\nfunctions not represented in numpy may find that the built-in functions\nimplemented specifically for numpy are not enough, and their Python\nimplementations work at a very low speed. Extending numpy can be done, but\nis somewhat laborious as even the most basic numpy functions that refer\ndirectly to `ndarray` data must be implemented in C for reasonable performance.\n\nAt the same time, while working with `ndslice`, an engineer has access to the\nwhole set of standard D library, so the functions he creates will be as\nefficient as if they were written in C.\n\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   Ilya Yaroshenko\n\nAcknowledgements:   John Loughran Colvin\n\nSource:    $(PHOBOSSRC std/_experimental/_ndslice/_package.d)\n\nMacros:\nSUBMODULE = $(LINK2 std_experimental_ndslice_$1.html, std.experimental.ndslice.$1)\nSUBREF = $(LINK2 std_experimental_ndslice_$1.html#.$2, $(TT $2))$(NBSP)\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\nT4=$(TR $(TDNW $(LREF $1)) $(TD $2) $(TD $3) $(TD $4))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/ndslice/selection.d",
		"name": "std.experimental.ndslice.selection",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "pack",
								"line": 75,
								"type": "(auto ref Slice!(N, Range) slice)",
								"parameters": [
									{
										"name": "slice",
										"type": "Slice!(N, Range)",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 95,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "pack",
						"line": 75,
						"parameters": [
							{
								"name": "N",
								"type": "size_t",
								"kind": "value"
							},
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "pack",
				"line": 73,
				"comment": "Creates a packed slice, i.e. slice of slices.\nThe function does not carry out any calculations, it simply returns the same\nbinary data presented differently.\n\nParams:\n    K = sizes of dimension packs\nReturns:\n    `pack!K` returns `Slice!(N-K, Slice!(K+1, Range))`;\n    `slice.pack!(K1, K2, ..., Kn)` is the same as `slice.pacKed!K1.pacKed!K2. ... pacKed!Kn`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL99_2602)\n---\nimport std.experimental.ndslice.slice;\nimport std.range.primitives: ElementType;\nimport std.range: iota;\nimport std.algorithm.comparison: equal;\nauto r = 100000000.iota;\nauto a = r.sliced(3, 4, 5, 6, 7, 8, 9, 10, 11);\nauto b = a.pack!(2, 3); // same as `a.pack!2.pack!3`\nauto c = b[1, 2, 3, 4];\nauto d = c[5, 6, 7];\nauto e = d[8, 9];\nauto g = a[1, 2, 3, 4, 5, 6, 7, 8, 9];\nassert(e == g);\nassert(a == b);\nassert(c == a[1, 2, 3, 4]);\nalias R = typeof(r);\nstatic assert(is(typeof(b) == typeof(a.pack!2.pack!3)));\nstatic assert(is(typeof(b) == Slice!(4, Slice!(4, Slice!(3, R)))));\nstatic assert(is(typeof(c) == Slice!(3, Slice!(3, R))));\nstatic assert(is(typeof(d) == Slice!(2, R)));\nstatic assert(is(typeof(e) == ElementType!R));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL99_2602)\n",
				"parameters": [
					{
						"name": "K",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "unpack",
						"line": 156,
						"type": "Slice!(N, Range).PureThis(auto ref Slice!(N, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 159,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "unpack",
				"line": 156,
				"comment": "Unpacks a packed slice.\n\nThe function does not carry out any calculations, it simply returns the same\nbinary data presented differently.\n\nParams:\n    slice = packed slice\nReturns:\n    unpacked slice\n\nSee_also: $(LREF pack), $(LREF evertPack)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL162_2604)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nimport std.algorithm.comparison: equal;\nauto r = 100000000.iota;\nauto a = r.sliced(3, 4, 5, 6, 7, 8, 9, 10, 11);\nauto b = a.pack!(2, 3).unpack();\nstatic assert(is(typeof(a) == typeof(b)));\nassert(a == b);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL162_2604)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "evertPack",
						"line": 186,
						"type": "SliceFromSeq!(Slice!(N, Range).PureRange, NSeqEvert!(Slice!(N, Range).NSeq))(auto ref Slice!(N, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 205,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "evertPack",
				"line": 186,
				"comment": "Reverses the order of dimension packs.\nThis function is used in a functional pipeline with other selectors.\n\nParams:\n    slice = packed slice\nReturns:\n    packed slice\n\nSee_also: $(LREF pack), $(LREF unpack)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL208_2605)\n---\nimport std.experimental.ndslice.slice;\nimport std.experimental.ndslice.iteration: transposed;\nimport std.range: iota;\nauto slice = 100000000.iota.sliced(3, 4, 5, 6, 7, 8, 9, 10, 11);\nassert(slice\n    .pack!2\n    .evertPack\n    .unpack\n         == slice.transposed!(\n            slice.shape.length-2,\n            slice.shape.length-1));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL208_2605)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL224_2606)\n---\nimport std.experimental.ndslice.slice;\nimport std.experimental.ndslice.iteration: transposed;\nimport std.range.primitives: ElementType;\nimport std.range: iota;\nimport std.algorithm.comparison: equal;\nauto r = 100000000.iota;\nauto a = r.sliced(3, 4, 5, 6, 7, 8, 9, 10, 11);\nauto b = a\n    .pack!(2, 3)\n    .evertPack;\nauto c = b[8, 9];\nauto d = c[5, 6, 7];\nauto e = d[1, 2, 3, 4];\nauto g = a[1, 2, 3, 4, 5, 6, 7, 8, 9];\nassert(e == g);\nassert(a == b.evertPack);\nassert(c == a.transposed!(7, 8, 4, 5, 6)[8, 9]);\nalias R = typeof(r);\nstatic assert(is(typeof(b) == Slice!(2, Slice!(4, Slice!(5, R)))));\nstatic assert(is(typeof(c) == Slice!(3, Slice!(5, R))));\nstatic assert(is(typeof(d) == Slice!(4, R)));\nstatic assert(is(typeof(e) == ElementType!R));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL224_2606)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "diagonal",
						"line": 286,
						"type": "Slice!(1, Range)(auto ref Slice!(N, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 305,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "diagonal",
				"line": 286,
				"comment": "Returns a 1-dimensional slice over the main diagonal of an n-dimensional slice.\n`diagonal` can be generalized with other selectors such as\n$(LREF blocks) (diagonal blocks) and $(LREF windows) (multi-diagonal slice).\n\nParams:\n    N = dimension count\n    slice = input slice\nReturns:\n    packed `1`-dimensional composed of `N`-dimensional slices\nExample:\nMatrix, main diagonal$(DDOX_UNITTEST_HEADER __unittestL308_2608)\n---\nimport std.experimental.ndslice.slice;\nimport std.algorithm.comparison: equal;\nimport std.range: iota, only;\n\n//  -------\n// | 0 1 2 |\n// | 3 4 5 |\n//  -------\n//->\n// | 0 4 |\nassert(10.iota\n    .sliced(2, 3)\n    .diagonal\n    .equal(only(0, 4)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL308_2608)\nExample:\nditto$(DDOX_UNITTEST_HEADER __unittestL327_2609)\n---\nimport std.experimental.ndslice.slice;\n\nauto slice = new int[9].sliced(3, 3);\nint i;\nforeach (ref e; slice.diagonal)\n    e = ++i;\nassert(slice == [\n    [1, 0, 0],\n    [0, 2, 0],\n    [0, 0, 3]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL327_2609)\nExample:\nMatrix, subdiagonal$(DDOX_UNITTEST_HEADER __unittestL342_2610)\n---\nimport std.experimental.ndslice.slice;\nimport std.experimental.ndslice.iteration: dropOne;\nimport std.algorithm.comparison: equal;\nimport std.range: iota, only;\n//  -------\n// | 0 1 2 |\n// | 3 4 5 |\n//  -------\n//->\n// | 1 5 |\nassert(10.iota\n    .sliced(2, 3)\n    .dropOne!1\n    .diagonal\n    .equal(only(1, 5)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL342_2610)\nExample:\nMatrix, antidiagonal$(DDOX_UNITTEST_HEADER __unittestL362_2611)\n---\nimport std.experimental.ndslice.slice;\nimport std.experimental.ndslice.iteration: dropToHypercube, reversed;\nimport std.algorithm.comparison: equal;\nimport std.range: iota, only;\n//  -------\n// | 0 1 2 |\n// | 3 4 5 |\n//  -------\n//->\n// | 1 3 |\nassert(10.iota\n    .sliced(2, 3)\n    .dropToHypercube\n    .reversed!1\n    .diagonal\n    .equal(only(1, 3)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL362_2611)\nExample:\n3D, main diagonal$(DDOX_UNITTEST_HEADER __unittestL383_2612)\n---\nimport std.experimental.ndslice.slice;\nimport std.algorithm.comparison: equal;\nimport std.range: iota, only;\n//  -----------\n// |  0   1  2 |\n// |  3   4  5 |\n//  - - - - - -\n// |  6   7  8 |\n// |  9  10 11 |\n//  -----------\n//->\n// | 0 10 |\nassert(100.iota\n    .sliced(2, 2, 3)\n    .diagonal\n    .equal(only(0, 10)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL383_2612)\nExample:\n3D, subdiagonal$(DDOX_UNITTEST_HEADER __unittestL404_2613)\n---\nimport std.experimental.ndslice.slice;\nimport std.experimental.ndslice.iteration: dropOne;\nimport std.algorithm.comparison: equal;\nimport std.range: iota, only;\n//  -----------\n// |  0   1  2 |\n// |  3   4  5 |\n//  - - - - - -\n// |  6   7  8 |\n// |  9  10 11 |\n//  -----------\n//->\n// | 1 11 |\nassert(100.iota\n    .sliced(2, 2, 3)\n    .dropOne!2\n    .diagonal\n    .equal(only(1, 11)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL404_2613)\nExample:\n3D, diagonal plain$(DDOX_UNITTEST_HEADER __unittestL427_2614)\n---\nimport std.experimental.ndslice.slice;\nimport std.experimental.ndslice.iteration: dropOne;\nimport std.algorithm.comparison: equal;\nimport std.range: iota;\n//  -----------\n// |  0   1  2 |\n// |  3   4  5 |\n// |  6   7  8 |\n//  - - - - - -\n// |  9  10 11 |\n// | 12  13 14 |\n// | 15  16 17 |\n//  - - - - - -\n// | 18  20 21 |\n// | 22  23 24 |\n// | 24  25 26 |\n//  -----------\n//->\n//  -----------\n// |  0   4  8 |\n// |  9  13 17 |\n// | 18  23 26 |\n//  -----------\nauto slice = 100.iota\n    .sliced(3, 3, 3)\n    .pack!2\n    .evertPack\n    .diagonal\n    .evertPack;\nassert(slice ==\n    [[ 0,  4,  8],\n     [ 9, 13, 17],\n     [18, 22, 26]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL427_2614)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "blocks",
						"line": 476,
						"type": "Slice!(N, Slice!(N + 1, Range))(auto ref Slice!(N, Range) slice, Lengths lengths)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "lengths",
								"type": "Lengths"
							}
						],
						"endline": 503,
						"char": 31,
						"kind": "function"
					}
				],
				"name": "blocks",
				"line": 476,
				"comment": "Returns an n-dimensional slice of n-dimensional non-overlapping blocks.\n`blocks` can be generalized with other selectors.\nFor example, `blocks` in combination with $(LREF diagonal) can be used to get a slice of diagonal blocks.\n\nParams:\n    N = dimension count\n    slice = slice to be split into blocks\n    lengths = dimensions of block, residual blocks are ignored\nReturns:\n    packed `N`-dimensional slice composed of `N`-dimensional slices\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL506_2615)\n---\nimport std.experimental.ndslice.slice;\nauto slice = new int[1000].sliced(5, 8);\nauto blocks = slice.blocks(2, 3);\nint i;\nforeach (block; blocks.byElement)\n    block[] = ++i;\n\nassert(blocks ==\n    [[[[1, 1, 1], [1, 1, 1]],\n      [[2, 2, 2], [2, 2, 2]]],\n     [[[3, 3, 3], [3, 3, 3]],\n      [[4, 4, 4], [4, 4, 4]]]]);\n\nassert(    slice ==\n    [[1, 1, 1,  2, 2, 2,  0, 0],\n     [1, 1, 1,  2, 2, 2,  0, 0],\n\n     [3, 3, 3,  4, 4, 4,  0, 0],\n     [3, 3, 3,  4, 4, 4,  0, 0],\n\n     [0, 0, 0,  0, 0, 0,  0, 0]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL506_2615)\nExample:\nDiagonal blocks$(DDOX_UNITTEST_HEADER __unittestL532_2616)\n---\nimport std.experimental.ndslice.slice;\nauto slice = new int[1000].sliced(5, 8);\nauto blocks = slice.blocks(2, 3);\nauto diagonalBlocks = blocks.diagonal.unpack;\n\ndiagonalBlocks[0][] = 1;\ndiagonalBlocks[1][] = 2;\n\nassert(diagonalBlocks ==\n    [[[1, 1, 1], [1, 1, 1]],\n     [[2, 2, 2], [2, 2, 2]]]);\n\nassert(blocks ==\n    [[[[1, 1, 1], [1, 1, 1]],\n      [[0, 0, 0], [0, 0, 0]]],\n     [[[0, 0, 0], [0, 0, 0]],\n      [[2, 2, 2], [2, 2, 2]]]]);\n\nassert(slice ==\n    [[1, 1, 1,  0, 0, 0,  0, 0],\n     [1, 1, 1,  0, 0, 0,  0, 0],\n\n     [0, 0, 0,  2, 2, 2,  0, 0],\n     [0, 0, 0,  2, 2, 2,  0, 0],\n\n     [0, 0, 0, 0, 0, 0, 0, 0]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL532_2616)\nExample:\nMatrix divided into vertical blocks$(DDOX_UNITTEST_HEADER __unittestL563_2617)\n---\nimport std.experimental.ndslice.slice;\nauto slice = new int[1000].sliced(5, 13);\nauto blocks = slice\n    .pack!1\n    .evertPack\n    .blocks(3)\n    .unpack\n    .pack!2;\n\nint i;\nforeach (block; blocks.byElement)\n    block[] = ++i;\n\nassert(slice ==\n    [[1, 1, 1,  2, 2, 2,  3, 3, 3,  4, 4, 4,  0],\n     [1, 1, 1,  2, 2, 2,  3, 3, 3,  4, 4, 4,  0],\n     [1, 1, 1,  2, 2, 2,  3, 3, 3,  4, 4, 4,  0],\n     [1, 1, 1,  2, 2, 2,  3, 3, 3,  4, 4, 4,  0],\n     [1, 1, 1,  2, 2, 2,  3, 3, 3,  4, 4, 4,  0]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL563_2617)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Lengths",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isIndex, Lengths) && Lengths.length == N",
				"char": 31,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "windows",
						"line": 598,
						"type": "Slice!(N, Slice!(N + 1, Range))(auto ref Slice!(N, Range) slice, Lengths lengths)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "lengths",
								"type": "Lengths"
							}
						],
						"endline": 624,
						"char": 31,
						"kind": "function"
					}
				],
				"name": "windows",
				"line": 598,
				"comment": "Returns an n-dimensional slice of n-dimensional overlapping windows.\n`windows` can be generalized with other selectors.\nFor example, `windows` in combination with $(LREF diagonal) can be used to get a multi-diagonal slice.\n\nParams:\n    N = dimension count\n    slice = slice to be iterated\n    lengths = dimensions of windows\nReturns:\n    packed `N`-dimensional slice composed of `N`-dimensional slices\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL627_2618)\n---\nimport std.experimental.ndslice.slice;\nauto slice = new int[1000].sliced(5, 8);\nauto windows = slice.windows(2, 3);\nforeach (window; windows.byElement)\n    window[] += 1;\n\nassert(slice ==\n    [[1,  2,  3, 3, 3, 3,  2,  1],\n\n     [2,  4,  6, 6, 6, 6,  4,  2],\n     [2,  4,  6, 6, 6, 6,  4,  2],\n     [2,  4,  6, 6, 6, 6,  4,  2],\n\n     [1,  2,  3, 3, 3, 3,  2,  1]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL627_2618)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL646_2619)\n---\nimport std.experimental.ndslice.slice;\nauto slice = new int[1000].sliced(5, 8);\nauto windows = slice.windows(2, 3);\nwindows[1, 2][] = 1;\nwindows[1, 2][0, 1] += 1;\nwindows.unpack[1, 2, 0, 1] += 1;\n\nassert(slice ==\n    [[0, 0,  0, 0, 0,  0, 0, 0],\n\n     [0, 0,  1, 3, 1,  0, 0, 0],\n     [0, 0,  1, 1, 1,  0, 0, 0],\n\n     [0, 0,  0, 0, 0,  0, 0, 0],\n     [0, 0,  0, 0, 0,  0, 0, 0]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL646_2619)\nExample:\nMulti-diagonal matrix$(DDOX_UNITTEST_HEADER __unittestL666_2620)\n---\nimport std.experimental.ndslice.slice;\nauto slice = new int[1000].sliced(8, 8);\nauto windows = slice.windows(3, 3);\n\nauto multidiagonal = windows\n    .diagonal\n    .unpack;\nforeach (window; multidiagonal)\n    window[] += 1;\n\nassert(slice ==\n    [[ 1, 1, 1,  0, 0, 0, 0, 0],\n     [ 1, 2, 2, 1,  0, 0, 0, 0],\n     [ 1, 2, 3, 2, 1,  0, 0, 0],\n     [0,  1, 2, 3, 2, 1,  0, 0],\n     [0, 0,  1, 2, 3, 2, 1,  0],\n     [0, 0, 0,  1, 2, 3, 2, 1],\n     [0, 0, 0, 0,  1, 2, 2, 1],\n     [0, 0, 0, 0, 0,  1, 1, 1]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL666_2620)\nExample:\nSliding window over matrix columns$(DDOX_UNITTEST_HEADER __unittestL690_2621)\n---\nimport std.experimental.ndslice.slice;\nauto slice = new int[1000].sliced(5, 8);\nauto windows = slice\n    .pack!1\n    .evertPack\n    .windows(3)\n    .unpack\n    .pack!2;\n\n\nforeach (window; windows.byElement)\n    window[] += 1;\n\nassert(slice ==\n    [[1,  2,  3, 3, 3, 3,  2,  1],\n     [1,  2,  3, 3, 3, 3,  2,  1],\n     [1,  2,  3, 3, 3, 3,  2,  1],\n     [1,  2,  3, 3, 3, 3,  2,  1],\n     [1,  2,  3, 3, 3, 3,  2,  1]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL690_2621)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Lengths",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isIndex, Lengths) && Lengths.length == N",
				"char": 31,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reshape",
						"line": 726,
						"type": "Slice!(Lengths.length, Range)(auto ref Slice!(N, Range) slice, Lengths lengths)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "lengths",
								"type": "Lengths"
							}
						],
						"endline": 802,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "reshape",
				"line": 726,
				"comment": "Returns a new slice for the same data.\n\nParams:\n    slice = slice to be reshaped\n    lengths = list of new dimensions. One of the lengths can be set to `-1`.\n        In this case, the corresponding dimension is inferable.\nReturns:\n    reshaped slice\nThrows:\n    $(LREF ReshapeException) if the slice cannot be reshaped with the input lengths.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL805_2622)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nimport std.experimental.ndslice.iteration: allReversed;\nauto slice = 100.iota\n    .sliced(3, 4)\n    .allReversed\n    .reshape(-1, 3);\nassert(slice ==\n    [[11, 10, 9],\n     [ 8,  7, 6],\n     [ 5,  4, 3],\n     [ 2,  1, 0]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL805_2622)\nExample:\nReshaping with memory allocation$(DDOX_UNITTEST_HEADER __unittestL822_2623)\n---\nimport std.experimental.ndslice.slice;\nimport std.experimental.ndslice.iteration: reversed;\nimport std.array: array;\n\nauto reshape2(S, L...)(S slice, L lengths)\n{\n    // Tries to reshape without allocation\n    try return slice.reshape(lengths);\n    catch(ReshapeException e)\n        //allocates the elements and creates a slice\n        //Note: -1 length is not supported by reshape2\n        return slice.byElement.array.sliced(lengths);\n}\n\nauto slice =\n    [0, 1,  2,  3,\n     4, 5,  6,  7,\n     8, 9, 10, 11]\n    .sliced(3, 4)\n    .reversed!0;\n\nassert(reshape2(slice, 4, 3) ==\n    [[ 8, 9, 10],\n     [11, 4,  5],\n     [ 6, 7,  0],\n     [ 1, 2,  3]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL822_2623)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Lengths",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isIndex, Lengths) && Lengths.length",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "lengths",
						"line": 870,
						"comment": "Old lengths\n",
						"deco": "Am",
						"originalType": "size_t[]",
						"char": 14,
						"kind": "variable"
					},
					{
						"offset": 88,
						"name": "strides",
						"line": 872,
						"comment": "Old strides\n",
						"deco": "Al",
						"originalType": "sizediff_t[]",
						"char": 18,
						"kind": "variable"
					},
					{
						"offset": 104,
						"name": "newLengths",
						"line": 874,
						"comment": "New lengths\n",
						"deco": "Am",
						"originalType": "size_t[]",
						"char": 14,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 876,
						"comment": "\n",
						"deco": "FNaNbNiNfAmAlAmAyaAyakC6object9ThrowableZC3std12experimental7ndslice9selection16ReshapeException",
						"parameters": [
							{
								"name": "lengths",
								"deco": "Am"
							},
							{
								"name": "strides",
								"deco": "Al"
							},
							{
								"name": "newLengths",
								"deco": "Am"
							},
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "k",
								"default": "882u"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 890,
						"originalType": "pure nothrow @nogc @safe (size_t[] lengths, sizediff_t[] strides, size_t[] newLengths, string msg, string file = __FILE__, uint line = cast(uint)882, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "ReshapeException",
				"line": 867,
				"comment": "See_also: $(LREF reshape)\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byElement",
						"line": 904,
						"type": "(auto ref Slice!(N, Range) slice)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 1104,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byElement",
				"line": 904,
				"comment": "Returns a random access range of all elements of a slice.\nThe order of elements is preserved.\n`byElement` can be generalized with other selectors.\n\nParams:\n    N = dimension count\n    slice = slice to be iterated\nReturns:\n    random access range composed of elements of the `slice`\nExample:\nRegular slice$(DDOX_UNITTEST_HEADER __unittestL1107_2625)\n---\nimport std.experimental.ndslice.slice;\nimport std.algorithm.comparison: equal;\nimport std.range: iota;\nassert(100.iota\n    .sliced(4, 5)\n    .byElement\n    .equal(20.iota));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1107_2625)\nExample:\nPacked slice$(DDOX_UNITTEST_HEADER __unittestL1119_2626)\n---\nimport std.experimental.ndslice.slice;\nimport std.experimental.ndslice.iteration;\nimport std.range: iota, drop;\nimport std.algorithm.comparison: equal;\nassert(100000.iota\n    .sliced(3, 4, 5, 6, 7)\n    .pack!2\n    .byElement()\n    .drop(1)\n    .front\n    .byElement\n    .equal(iota(6 * 7, 6 * 7 * 2)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1119_2626)\nExample:\nProperties$(DDOX_UNITTEST_HEADER __unittestL1136_2627)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nauto elems = 12.iota.sliced(3, 4).byElement;\nelems.popFrontExactly(2);\nassert(elems.front == 2);\nassert(elems.index == [0, 2]);\nelems.popBackExactly(2);\nassert(elems.back == 9);\nassert(elems.length == 8);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1136_2627)\nExample:\nIndex property$(DDOX_UNITTEST_HEADER __unittestL1150_2628)\n---\nimport std.experimental.ndslice.slice;\nauto slice = new long[20].sliced(5, 4);\n\nfor(auto elems = slice.byElement; !elems.empty; elems.popFront)\n{\n    size_t[2] index = elems.index;\n    elems.front = index[0] * 10 + index[1] * 3;\n}\nassert(slice ==\n    [[ 0,  3,  6,  9],\n     [10, 13, 16, 19],\n     [20, 23, 26, 29],\n     [30, 33, 36, 39],\n     [40, 43, 46, 49]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1150_2628)\nExample:\nRandom access and slicing$(DDOX_UNITTEST_HEADER __unittestL1171_2629)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nauto elems = 100.iota.sliced(4, 5).byElement;\n\nelems = elems[11 .. $ - 2];\n\nassert(elems.length == 7);\nassert(elems.front == 11);\nassert(elems.back == 17);\n\nforeach (i; 0 .. 7)\n    assert(elems[i] == i + 11);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1171_2629)\nExample:\nForward access works faster than random access or backward access.\nUse $(SUBREF iteration, allReversed) in pipeline before\n`byElement` to achieve fast backward access.$(DDOX_UNITTEST_HEADER __unittestL1192_2630)\n---\nimport std.range: retro, iota;\nimport std.experimental.ndslice.iteration: allReversed;\n\nauto slice = 100.iota.sliced(3, 4, 5);\n\n/// Slow backward iteration #1\nforeach (ref e; slice.byElement.retro)\n{\n    //...\n}\n\n/// Slow backward iteration #2\nforeach_reverse (ref e; slice.byElement)\n{\n    //...\n}\n\n/// Fast backward iteration\nforeach (ref e; slice.allReversed.byElement)\n{\n    //...\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1192_2630)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byElementInStandardSimplex",
						"line": 1299,
						"type": "(auto ref Slice!(N, Range) slice, size_t maxCobeLength = size_t.max)",
						"parameters": [
							{
								"name": "slice",
								"type": "Slice!(N, Range)",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "maxCobeLength",
								"type": "size_t",
								"default": "size_t.max"
							}
						],
						"endline": 1389,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byElementInStandardSimplex",
				"line": 1299,
				"comment": "Returns an forward range of all elements of standard simplex of a slice.\nIn case the slice has two dimensions, it is composed of elements of upper left triangular matrix.\nThe order of elements is preserved.\n`byElementInStandardSimplex` can be generalized with other selectors.\n\nParams:\n    N = dimension count\n    slice = slice to be iterated\nReturns:\n    forward range composed of all elements of standard simplex of the `slice`\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1392_2634)\n---\nimport std.experimental.ndslice.slice;\nauto slice = new int[20].sliced(4, 5);\nauto elems = slice\n    .byElementInStandardSimplex;\nint i;\nforeach (ref e; elems)\n    e = ++i;\nassert(slice ==\n    [[ 1, 2, 3, 4, 0],\n     [ 5, 6, 7, 0, 0],\n     [ 8, 9, 0, 0, 0],\n     [10, 0, 0, 0, 0]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1392_2634)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1409_2635)\n---\nimport std.experimental.ndslice.slice;\nimport std.experimental.ndslice.iteration;\nauto slice = new int[20].sliced(4, 5);\nauto elems = slice\n    .transposed\n    .allReversed\n    .byElementInStandardSimplex;\nint i;\nforeach (ref e; elems)\n    e = ++i;\nassert(slice ==\n    [[0,  0, 0, 0, 4],\n     [0,  0, 0, 7, 3],\n     [0,  0, 9, 6, 2],\n     [0, 10, 8, 5, 1]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1409_2635)\nExample:\nProperties$(DDOX_UNITTEST_HEADER __unittestL1429_2636)\n---\nimport std.experimental.ndslice.slice;\nimport std.range: iota;\nauto elems = 12.iota.sliced(3, 4).byElementInStandardSimplex;\nelems.popFront;\nassert(elems.front == 1);\nassert(elems.index == cast(size_t[2])[0, 1]);\nimport std.range: popFrontN;\nelems.popFrontN(3);\nassert(elems.front == 5);\nassert(elems.index == cast(size_t[2])[1, 1]);\nassert(elems.length == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1429_2636)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexSlice",
						"line": 1454,
						"type": "IndexSlice!(Lengths.length)(Lengths lengths)",
						"parameters": [
							{
								"name": "lengths",
								"type": "Lengths"
							}
						],
						"endline": 1458,
						"char": 29,
						"kind": "function"
					}
				],
				"name": "indexSlice",
				"line": 1454,
				"comment": "Returns a slice, the elements of which are equal to the initial index value.\n\nParams:\n    N = dimension count\n    lengths = list of dimension lengths\nReturns:\n    `N`-dimensional slice composed of indexes\nSee_also: $(LREF IndexSlice)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1468_2637)\n---\nauto im = indexSlice(7, 9);\n\nassert(im[2, 1] == cast(size_t[2])[2, 1]);\n\nfor (auto elems = im.byElement; !elems.empty; elems.popFront)\n    assert(elems.front == elems.index);\n\n//slicing works correctly\nauto cm = im[1 .. $ - 3, 4 .. $ - 1];\nassert(cm[2, 1] == cast(size_t[2])[3, 5]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1468_2637)\n",
				"parameters": [
					{
						"name": "Lengths",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isIndex, Lengths)",
				"char": 29,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexSlice",
						"line": 1461,
						"type": "IndexSlice!N(auto ref size_t[N] lengths)",
						"parameters": [
							{
								"name": "lengths",
								"type": "size_t[N]",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 1465,
						"char": 14,
						"kind": "function"
					}
				],
				"name": "indexSlice",
				"line": 1461,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 14,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "IndexSlice",
						"line": 1511,
						"type": "Slice!(N, IndexMap)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "IndexSlice",
				"line": 1486,
				"comment": "Slice composed of indexes.\nSee_also: $(LREF indexSlice)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1515_2638)\n---\nalias IS4 = IndexSlice!4;\nstatic assert(is(IS4 == Slice!(4, Range), Range));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1515_2638)\n",
				"parameters": [
					{
						"name": "N",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "N",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "$(SCRIPT inhibitQuickIndex = 1;)\n\nThis is a submodule of $(LINK2 std_experimental_ndslice.html, std.experimental.ndslice).\n\nSelectors create new views and iteration patterns over the same data, without copying.\n\n$(H2 Subspace selectors)\n\nSubspace selectors serve to generalize and combine other selectors easily.\nFor a slice of `Slice!(N, Range)` type `slice.pack!K` creates a slice of\nslices of `Slice!(N-K, Slice!(K+1, Range))` type by packing\nthe last `K` dimensions of the top dimension pack,\nand the type of element of `slice.byElement` is `Slice!(K, Range)`.\nAnother way to use $(LREF pack) is transposition of dimension packs using\n$(LREF evertPack). Examples of use of subspace selectors are available for selectors,\n$(SUBREF slice, Slice.shape), and $(SUBREF slice, Slice.elementsCount).\n\n$(BOOKTABLE ,\n\n$(TR $(TH Function Name) $(TH Description))\n$(T2 pack     , returns slice of slices)\n$(T2 unpack   , merges all dimension packs)\n$(T2 evertPack, reverses dimension packs)\n)\n\n$(BOOKTABLE $(H2 Selectors),\n\n$(TR $(TH Function Name) $(TH Description))\n$(T2 byElement, a random access range of all elements with `index` property)\n$(T2 byElementInStandardSimplex, an input range of all elements in standard simplex of hypercube with `index` property.\n    If the slice has two dimensions, it is a range of all elements of upper left triangular matrix.)\n$(T2 indexSlice, returns a slice with elements equal to the initial index)\n$(T2 reshape, returns a new slice for the same data)\n$(T2 diagonal, 1-dimensional slice composed of diagonal elements)\n$(T2 blocks, n-dimensional slice composed of n-dimensional non-overlapping blocks.\n    If the slice has two dimensions, it is a block matrix.)\n$(T2 windows, n-dimensional slice of n-dimensional overlapping windows.\n    If the slice has two dimensions, it is a sliding window.)\n)\n\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   Ilya Yaroshenko\n\nSource:    $(PHOBOSSRC std/_experimental/_ndslice/_selection.d)\n\nMacros:\nSUBMODULE = $(LINK2 std_experimental_ndslice_$1.html, std.experimental.ndslice.$1)\nSUBREF = $(LINK2 std_experimental_ndslice_$1.html#.$2, $(TT $2))$(NBSP)\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\nT4=$(TR $(TDNW $(LREF $1)) $(TD $2) $(TD $3) $(TD $4))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/allocator/building_blocks/stats_collector.d",
		"name": "std.experimental.allocator.building_blocks.stats_collector",
		"members": [
			{
				"members": [
					{
						"name": "numOwns",
						"line": 27,
						"value": "1LU",
						"comment": "    Counts the number of calls to $(D owns).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "numAllocate",
						"line": 32,
						"value": "2LU",
						"comment": "    Counts the number of calls to $(D allocate). All calls are counted,\n    including requests for zero bytes or failed requests.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "numAllocateOK",
						"line": 38,
						"value": "4LU",
						"comment": "    Counts the number of calls to $(D allocate) that succeeded, i.e. they\n    returned a block as large as requested. (N.B. requests for zero bytes count\n    as successful.)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "numExpand",
						"line": 43,
						"value": "8LU",
						"comment": "    Counts the number of calls to $(D expand), regardless of arguments or\n    result.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "numExpandOK",
						"line": 48,
						"value": "16LU",
						"comment": "    Counts the number of calls to $(D expand) that resulted in a successful\n    expansion.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "numReallocate",
						"line": 53,
						"value": "32LU",
						"comment": "    Counts the number of calls to $(D reallocate), regardless of arguments or\n    result.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "numReallocateOK",
						"line": 58,
						"value": "64LU",
						"comment": "    Counts the number of calls to $(D reallocate) that succeeded.\n    (Reallocations to zero bytes count as successful.)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "numReallocateInPlace",
						"line": 67,
						"value": "128LU",
						"comment": "    Counts the number of calls to $(D reallocate) that resulted in an in-place\n    reallocation (no memory moved). If this number is close to the total number\n    of reallocations, that indicates the allocator finds room at the current\n    block's end in a large fraction of the cases, but also that internal\n    fragmentation may be high (the size of the unit of allocation is large\n    compared to the typical allocation size of the application).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "numDeallocate",
						"line": 71,
						"value": "256LU",
						"comment": "    Counts the number of calls to $(D deallocate).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "numDeallocateAll",
						"line": 75,
						"value": "512LU",
						"comment": "    Counts the number of calls to $(D deallocateAll).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "numAll",
						"line": 79,
						"value": "1023LU",
						"comment": "    Chooses all $(D numXxx) flags.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bytesUsed",
						"line": 85,
						"value": "1024LU",
						"comment": "    Tracks bytes currently allocated by this allocator. This number goes up\n    and down as memory is allocated and deallocated, and is zero if the\n    allocator currently has no active allocation.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bytesAllocated",
						"line": 92,
						"value": "2048LU",
						"comment": "    Tracks total cumulative bytes allocated by means of $(D allocate),\n    $(D expand), and $(D reallocate) (when resulting in an expansion). This\n    number always grows and indicates allocation traffic. To compute bytes\n    deallocated cumulatively, subtract $(D bytesUsed) from $(D bytesAllocated).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bytesExpanded",
						"line": 97,
						"value": "4096LU",
						"comment": "    Tracks the sum of all $(D delta) values in calls of the form\n    $(D expand(b, delta)) that succeed (return $(D true)).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bytesContracted",
						"line": 104,
						"value": "8192LU",
						"comment": "    Tracks the sum of all $(D b.length - s) with $(D b.length > s) in calls of\n    the form $(D realloc(b, s)) that succeed (return $(D true)). In per-call\n    statistics, also unambiguously counts the bytes deallocated with\n    $(D deallocate).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bytesMoved",
						"line": 111,
						"value": "16384LU",
						"comment": "    Tracks the sum of all bytes moved as a result of calls to $(D realloc) that\n    were unable to reallocate in place. A large number (relative to $(D\n    bytesAllocated)) indicates that the application should use larger\n    preallocations.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bytesNotMoved",
						"line": 120,
						"value": "32768LU",
						"comment": "    Tracks the sum of all bytes NOT moved as result of calls to $(D realloc)\n    that managed to reallocate in place. A large number (relative to $(D\n    bytesAllocated)) indicates that the application is expansion-intensive and\n    is saving a good amount of moves. However, if this number is relatively\n    small and $(D bytesSlack) is high, it means the application is\n    overallocating for little benefit.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bytesSlack",
						"line": 126,
						"value": "65536LU",
						"comment": "    Measures the sum of extra bytes allocated beyond the bytes requested, i.e.\n    the $(WEB goo.gl/YoKffF, internal fragmentation). This is the current\n    effective number of slack bytes, and it goes up and down with time.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bytesHighTide",
						"line": 131,
						"value": "131072LU",
						"comment": "    Measures the maximum bytes allocated over the time. This is useful for\n    dimensioning allocators.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bytesAll",
						"line": 135,
						"value": "261120LU",
						"comment": "    Chooses all $(D byteXxx) flags.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 139,
						"value": "262143LU",
						"comment": "    Combines all flags above.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Options",
				"line": 22,
				"comment": "_Options for $(D StatsCollector) defined below. Each enables during\ncompilation one specific counter, statistic, or other piece of information.\n",
				"baseDeco": "m",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "StatsCollector",
						"line": 157,
						"members": [
							{
								"name": "numOwns",
								"line": 207,
								"comment": "        Read-only properties enabled by the homonym $(D flags) chosen by the\n        user.\n\n        Example:\n        ----\n        StatsCollector!(Mallocator,\n            Options.bytesUsed | Options.bytesAllocated) a;\n        auto d1 = a.allocate(10);\n        auto d2 = a.allocate(11);\n        a.deallocate(d1);\n        assert(a.bytesAllocated == 21);\n        assert(a.bytesUsed == 11);\n        a.deallocate(d2);\n        assert(a.bytesAllocated == 21);\n        assert(a.bytesUsed == 0);\n        ----\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "numAllocate",
								"line": 209,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "numAllocateOK",
								"line": 211,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "numExpand",
								"line": 213,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "numExpandOK",
								"line": 215,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "numReallocate",
								"line": 217,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "numReallocateOK",
								"line": 219,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "numReallocateInPlace",
								"line": 221,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "numDeallocate",
								"line": 223,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "numDeallocateAll",
								"line": 225,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "bytesUsed",
								"line": 227,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "bytesAllocated",
								"line": 229,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "bytesExpanded",
								"line": 231,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "bytesContracted",
								"line": 233,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "bytesMoved",
								"line": 235,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "bytesNotMoved",
								"line": 237,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "bytesSlack",
								"line": 239,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "bytesHighTide",
								"line": 241,
								"comment": "Ditto\n",
								"type": "const @property ulong()",
								"char": 25,
								"kind": "function"
							},
							{
								"name": "alignment",
								"line": 279,
								"comment": "Alignment offered is equal to $(D Allocator.alignment).\n",
								"type": "Allocator.alignment",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "reportStatistics",
										"line": 529,
										"type": "void(auto ref R output)",
										"parameters": [
											{
												"name": "output",
												"type": "R",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 539,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "reportStatistics",
								"line": 529,
								"comment": "    Reports per instance statistics to $(D output) (e.g. $(D stdout)). The\n    format is simple: one kind and value per line, separated by a colon, e.g.\n    $(D bytesAllocated:7395404)\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "StatsCollector",
				"line": 157,
				"comment": "\nAllocator that collects extra data about allocations. Since each piece of\ninformation adds size and time overhead, statistics can be individually enabled\nor disabled through compile-time $(D flags).\n\nAll stats of the form $(D numXxx) record counts of events occurring, such as\ncalls to functions and specific results. The stats of the form $(D bytesXxx)\ncollect cumulative sizes.\n\nIn addition, the data $(D callerSize), $(D callerModule), $(D callerFile), $(D\ncallerLine), and $(D callerTime) is associated with each specific allocation.\nThis data prefixes each allocation.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL656_2657)\n---\nimport std.experimental.allocator.gc_allocator : GCAllocator;\nimport std.experimental.allocator.building_blocks.free_list : FreeList;\nalias Allocator = StatsCollector!(GCAllocator, Options.all, Options.all);\n\nAllocator alloc;\nauto b = alloc.allocate(10);\nalloc.reallocate(b, 20);\nalloc.deallocate(b);\n\nimport std.stdio : File;\nimport std.range : walkLength;\nversion(Posix)\n    auto f = \"/tmp/dlang.std.experimental.allocator.stats_collector.txt\";\nversion(Windows)\n{\n    import std.process: environment;\n    auto f = environment.get(\"temp\") ~ r\"\\dlang.std.experimental.allocator.stats_collector.txt\";\n}\nAllocator.reportPerCallStatistics(File(f, \"w\"));\nalloc.reportStatistics(File(f, \"a\"));\nassert(File(f).byLine.walkLength == 22);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL656_2657)\n",
				"parameters": [
					{
						"name": "Allocator",
						"kind": "type"
					},
					{
						"name": "flags",
						"defaultValue": "Options.all",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "perCallFlags",
						"defaultValue": "0",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "Allocator that collects useful statistics about allocations, both global and per\ncalling point. The statistics collected can be configured statically by choosing\ncombinations of `Options` appropriately.\n\nExample:\n----\nimport std.experimental.allocator.gc_allocator : GCAllocator;\nimport std.experimental.allocator.building_blocks.free_list : FreeList;\nalias Allocator = StatsCollector!(GCAllocator, Options.bytesUsed);\n----\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/allocator/building_blocks/package.d",
		"name": "std.experimental.allocator.building_blocks",
		"members": [],
		"comment": "$(H2 Assembling Your Own Allocator)\n\nIn addition to defining the interfaces above, this package also implements\nuntyped composable memory allocators. They are $(I untyped) because they deal\nexclusively in $(D void[]) and have no notion of what type the memory allocated\nwould be destined for. They are $(I composable) because the included allocators\nare building blocks that can be assembled in complex nontrivial allocators.\n\n$(P Unlike the allocators for the C and C++ programming languages, which manage\nthe allocated size internally, these allocators require that the client\nmaintains (or knows $(I a priori)) the allocation size for each piece of memory\nallocated. Put simply, the client must pass the allocated size upon\ndeallocation. Storing the size in the _allocator has significant negative\nperformance implications, and is virtually always redundant because client code\nneeds knowledge of the allocated size in order to avoid buffer overruns. (See\nmore discussion in a $(WEB open-\nstd.org/JTC1/SC22/WG21/docs/papers/2013/n3536.html, proposal) for sized\ndeallocation in C++.) For this reason, allocators herein traffic in $(D void[])\nas opposed to $(D void*).)\n\n$(P In order to be usable as an _allocator, a type should implement the\nfollowing methods with their respective semantics. Only $(D alignment) and  $(D\nallocate) are required. If any of the other methods is missing, the _allocator\nis assumed to not have that capability (for example some allocators do not offer\nmanual deallocation of memory). Allocators should NOT implement\nunsupported methods to always fail. For example, an allocator that lacks the\ncapability to implement `alignedAllocate` should not define it at all (as\nopposed to defining it to always return `null` or throw an exception). The\nmissing implementation statically informs other components about the\nallocator's capabilities and allows them to make design decisions accordingly.)\n\n$(BOOKTABLE ,\n$(TR $(TH Method name) $(TH Semantics))\n\n$(TR $(TDC uint alignment;, $(POST $(RES) > 0)) $(TD Returns the minimum\nalignment of all data returned by the allocator. An allocator may implement $(D\nalignment) as a statically-known $(D enum) value only. Applications that need\ndynamically-chosen alignment values should use the $(D alignedAllocate) and $(D\nalignedReallocate) APIs.))\n\n$(TR $(TDC size_t goodAllocSize(size_t n);, $(POST $(RES) >= n)) $(TD Allocators\ncustomarily allocate memory in discretely-sized chunks. Therefore, a request for\n$(D n) bytes may result in a larger allocation. The extra memory allocated goes\nunused and adds to the so-called $(WEB goo.gl/YoKffF,internal fragmentation).\nThe function $(D goodAllocSize(n)) returns the actual number of bytes that would\nbe allocated upon a request for $(D n) bytes. This module defines a default\nimplementation that returns $(D n) rounded up to a multiple of the allocator's\nalignment.))\n\n$(TR $(TDC void[] allocate(size_t s);, $(POST $(RES) is null || $(RES).length ==\ns)) $(TD If $(D s == 0), the call may return any empty slice (including $(D\nnull)). Otherwise, the call allocates $(D s) bytes of memory and returns the\nallocated block, or $(D null) if the request could not be satisfied.))\n\n$(TR $(TDC void[] alignedAllocate(size_t s, uint a);, $(POST $(RES) is null ||\n$(RES).length == s)) $(TD Similar to `allocate`, with the additional\nguarantee that the memory returned is aligned to at least `a` bytes. `a`\nmust be a power of 2.))\n\n$(TR $(TDC void[] allocateAll();) $(TD Offers all of allocator's memory to the\ncaller, so it's usually defined by fixed-size allocators. If the allocator is\ncurrently NOT managing any memory, then $(D allocateAll()) shall allocate and\nreturn all memory available to the allocator, and subsequent calls to all\nallocation primitives should not succeed (e..g $(D allocate) shall return $(D\nnull) etc). Otherwise, $(D allocateAll) only works on a best-effort basis, and\nthe allocator is allowed to return $(D null) even if does have available memory.\nMemory allocated with $(D allocateAll) is not otherwise special (e.g. can be\nreallocated or deallocated with the usual primitives, if defined).))\n\n$(TR $(TDC bool expand(ref void[] b, size_t delta);, $(POST !$(RES) || b.length\n== $(I old)(b).length + delta)) $(TD Expands $(D b) by $(D delta) bytes. If $(D\ndelta == 0), succeeds without changing $(D b). If $(D b is null), the call\nevaluates $(D b = allocate(delta)) and returns $(D b !is null). Otherwise, $(D\nb) must be a buffer previously allocated with the same allocator. If expansion\nwas successful, $(D expand) changes $(D b)'s length to $(D b.length + delta) and\nreturns $(D true). Upon failure, the call effects no change upon the allocator\nobject, leaves $(D b) unchanged, and returns $(D false).))\n\n$(TR $(TDC bool reallocate(ref void[] b, size_t s);, $(POST !$(RES) || b.length\n== s)) $(TD Reallocates $(D b) to size $(D s), possibly moving memory around.\n$(D b) must be $(D null) or a buffer allocated with the same allocator. If\nreallocation was successful, $(D reallocate) changes $(D b) appropriately and\nreturns $(D true). Upon failure, the call effects no change upon the allocator\nobject, leaves $(D b) unchanged, and returns $(D false). An allocator should\nimplement $(D reallocate) if it can derive some advantage from doing so;\notherwise, this module defines a $(D reallocate) free function implemented in\nterms of $(D expand), $(D allocate), and $(D deallocate).))\n\n$(TR $(TDC bool alignedReallocate(ref void[] b,$(BR) size_t s, uint a);, $(POST\n!$(RES) || b.length == s)) $(TD Similar to $(D reallocate), but guarantees the\nreallocated memory is aligned at $(D a) bytes. The buffer must have been\noriginated with a call to $(D alignedAllocate). $(D a) must be a power of 2\ngreater than $(D (void*).sizeof). An allocator should implement $(D\nalignedReallocate) if it can derive some advantage from doing so; otherwise,\nthis module defines a $(D alignedReallocate) free function implemented in terms\nof $(D expand), $(D alignedAllocate), and $(D deallocate).))\n\n$(TR $(TDC Ternary owns(void[] b);) $(TD Returns `Ternary.yes` if `b` has been\nallocated with this allocator. An allocator should define this method only if it\ncan decide on ownership precisely and fast (in constant time, logarithmic time,\nor linear time with a low multiplication factor). Traditional allocators such as\nthe C heap do not define such functionality. If $(D b is null), the allocator\nshall return `Ternary.no`, i.e. no allocator owns the `null` slice.))\n\n$(TR $(TDC void[] resolveInternalPointer(void* p);) $(TD If $(D p) is a pointer\nsomewhere inside a block allocated with this allocator, returns a pointer to the\nbeginning of the allocated block. Otherwise, returns $(D null). If the pointer\npoints immediately after an allocated block, the result is implementation\ndefined.))\n\n$(TR $(TDC bool deallocate(void[] b);) $(TD If $(D b is null), does\nnothing and returns `true`. Otherwise, deallocates memory previously allocated\nwith this allocator and returns `true` if successful, `false` otherwise. An\nimplementation that would not support deallocation (i.e. would always return\n`false` should not define this primitive at all.)))\n\n$(TR $(TDC bool deallocateAll();, $(POST empty)) $(TD Deallocates all memory\nallocated with this allocator. If an allocator implements this method, it must\nspecify whether its destructor calls it, too.))\n\n$(TR $(TDC Ternary empty();) $(TD Returns `Ternary.yes` if and only if the\nallocator holds no memory (i.e. no allocation has occurred, or all allocations\nhave been deallocated).))\n\n$(TR $(TDC static Allocator instance;, $(POST instance $(I is a valid)\nAllocator $(I object))) $(TD Some allocators are $(I monostate), i.e. have only\nan instance and hold only global state. (Notable examples are C's own\n`malloc`-based allocator and D's garbage-collected heap.) Such allocators must\ndefine a static $(D instance) instance that serves as the symbolic placeholder\nfor the global instance of the allocator. An allocator should not hold state\nand define `instance` simultaneously. Depending on whether the allocator is\nthread-safe or not, this instance may be $(D shared).))\n)\n\n$(H2 Sample Assembly)\n\nThe example below features an _allocator modeled after $(WEB goo.gl/m7329l,\njemalloc), which uses a battery of free-list allocators spaced so as to keep\ninternal fragmentation to a minimum. The $(D FList) definitions specify no\nbounds for the freelist because the $(D Segregator) does all size selection in\nadvance.\n\nSizes through 3584 bytes are handled via freelists of staggered sizes. Sizes\nfrom 3585 bytes through 4072 KB are handled by a $(D BitmappedBlock) with a\nblock size of 4 KB. Sizes above that are passed direct to the $(D Mallocator).\n\n----\n    alias FList = FreeList!(GCAllocator, 0, unbounded);\n    alias A = Segregator!(\n        8, FreeList!(GCAllocator, 0, 8),\n        128, Bucketizer!(FList, 1, 128, 16),\n        256, Bucketizer!(FList, 129, 256, 32),\n        512, Bucketizer!(FList, 257, 512, 64),\n        1024, Bucketizer!(FList, 513, 1024, 128),\n        2048, Bucketizer!(FList, 1025, 2048, 256),\n        3584, Bucketizer!(FList, 2049, 3584, 512),\n        4072 * 1024, AllocatorList!(\n            () => BitmappedBlock!(GCAllocator, 4096)(4072 * 1024)),\n        GCAllocator\n    );\n    A tuMalloc;\n    auto b = tuMalloc.allocate(500);\n    assert(b.length == 500);\n    auto c = tuMalloc.allocate(113);\n    assert(c.length == 113);\n    assert(tuMalloc.expand(c, 14));\n    tuMalloc.deallocate(b);\n    tuMalloc.deallocate(c);\n----\n\n$(H2 Allocating memory for sharing across threads)\n\nOne allocation pattern used in multithreaded applications is to share memory\nacross threads, and to deallocate blocks in a different thread than the one that\nallocated it.\n\nAll allocators in this module accept and return $(D void[]) (as opposed to\n$(D shared void[])). This is because at the time of allocation, deallocation, or\nreallocation, the memory is effectively not $(D shared) (if it were, it would\nreveal a bug at the application level).\n\nThe issue remains of calling $(D a.deallocate(b)) from a different thread than\nthe one that allocated $(D b). It follows that both threads must have access to\nthe same instance $(D a) of the respective allocator type. By definition of D,\nthis is possible only if $(D a) has the $(D shared) qualifier. It follows that\nthe allocator type must implement $(D allocate) and $(D deallocate) as $(D\nshared) methods. That way, the allocator commits to allowing usable $(D shared)\ninstances.\n\nConversely, allocating memory with one non-$(D shared) allocator, passing it\nacross threads (by casting the obtained buffer to $(D shared)), and later\ndeallocating it in a different thread (either with a different allocator object\nor with the same allocator object after casting it to $(D shared)) is illegal.\n\n$(H2 Building Blocks)\n\n$(P The table below gives a synopsis of predefined allocator building blocks,\nwith their respective modules. Either `import` the needed modules individually,\nor `import` `std.experimental.building_blocks`, which imports them all\n`public`ly. The building blocks can be assembled in unbounded ways and also\ncombined with your own. For a collection of typical and useful preassembled\nallocators and for inspiration in defining more such assemblies, refer to\n$(LINK2 std_experimental_allocator_showcase.html,\n`std.experimental.allocator.building_blocks.showcase`).)\n\n$(BOOKTABLE,\n$(TR $(TH Allocator$(BR)) $(TH Description))\n\n$(TR $(TDC2 NullAllocator, null_allocator) $(TD Very good at doing absolutely nothing. A good\nstarting point for defining other allocators or for studying the API.))\n\n$(TR $(TDC3 GCAllocator, gc_allocator) $(TD The system-provided garbage-collector allocator.\nThis should be the default fallback allocator tapping into system memory. It\noffers manual $(D free) and dutifully collects litter.))\n\n$(TR $(TDC3 Mallocator, mallocator) $(TD The C heap _allocator, a.k.a. $(D\nmalloc)/$(D realloc)/$(D free). Use sparingly and only for code that is unlikely\nto leak.))\n\n$(TR $(TDC3 AlignedMallocator, mallocator) $(TD Interface to OS-specific _allocators that\nsupport specifying alignment:\n$(WEB man7.org/linux/man-pages/man3/posix_memalign.3.html, $(D posix_memalign))\non Posix and $(WEB msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx,\n$(D __aligned_xxx)) on Windows.))\n\n$(TR $(TDC2 AffixAllocator, affix_allocator) $(TD Allocator that allows and manages allocating\nextra prefix and/or a suffix bytes for each block allocated.))\n\n$(TR $(TDC2 BitmappedBlock, bitmapped_block) $(TD Organizes one contiguous chunk of memory in\nequal-size blocks and tracks allocation status at the cost of one bit per\nblock.))\n\n$(TR $(TDC2 FallbackAllocator, fallback_allocator) $(TD Allocator that combines two other allocators\n - primary and fallback. Allocation requests are first tried with primary, and\n upon failure are passed to the fallback. Useful for small and fast allocators\n fronting general-purpose ones.))\n\n$(TR $(TDC2 FreeList, free_list) $(TD Allocator that implements a $(WEB\nwikipedia.org/wiki/Free_list, free list) on top of any other allocator. The\npreferred size, tolerance, and maximum elements are configurable at compile- and\nrun time.))\n\n$(TR $(TDC2 SharedFreeList, free_list) $(TD Same features as $(D FreeList), but packaged as\na $(D shared) structure that is accessible to several threads.))\n\n$(TR $(TDC2 FreeTree, free_tree) $(TD Allocator similar to $(D FreeList) that uses a\nbinary search tree to adaptively store not one, but many free lists.))\n\n$(TR $(TDC2 Region, region) $(TD Region allocator organizes a chunk of memory as a\nsimple bump-the-pointer allocator.))\n\n$(TR $(TDC2 InSituRegion, region) $(TD Region holding its own allocation, most often on\nthe stack. Has statically-determined size.))\n\n$(TR $(TDC2 SbrkRegion, region) $(TD Region using $(D $(LUCKY sbrk)) for allocating\nmemory.))\n\n$(TR $(TDC3 MmapAllocator, mmap_allocator) $(TD Allocator using $(D $(LUCKY mmap)) directly.))\n\n$(TR $(TDC2 StatsCollector, stats_collector) $(TD Collect statistics about any other\nallocator.))\n\n$(TR $(TDC2 Quantizer, quantizer) $(TD Allocates in coarse-grained quantas, thus\nimproving performance of reallocations by often reallocating in place. The drawback is higher memory consumption because of allocated and unused memory.))\n\n$(TR $(TDC2 AllocatorList, allocator_list) $(TD Given an allocator factory, lazily creates as\nmany allocators as needed to satisfy allocation requests. The allocators are\nstored in a linked list. Requests for allocation are satisfied by searching the\nlist in a linear manner.))\n\n$(TR $(TDC2 Segregator, segregator) $(TD Segregates allocation requests by size\nand dispatches them to distinct allocators.))\n\n$(TR $(TDC2 Bucketizer, bucketizer) $(TD Divides allocation sizes in discrete buckets and\nuses an array of allocators, one per bucket, to satisfy requests.))\n\n$(COMMENT $(TR $(TDC2 InternalPointersTree) $(TD Adds support for resolving internal\npointers on top of another allocator.)))\n)\n\nMacros:\nMYREF = $(LINK2 std_experimental_allocator_building_blocks_$2.html, $1)&nbsp;\nMYREF2 = $(LINK2 std_experimental_allocator_building_blocks_$2.html#$1, $1)&nbsp;\nMYREF3 = $(LINK2 std_experimental_allocator_$2.html#$1, $1)&nbsp;\nTDC = $(TDNW $(D $1)$+)\nTDC2 = $(TDNW $(D $(MYREF2 $1,$+))$(BR)$(SMALL\n$(D std.experimental.allocator.building_blocks.$2)))\nTDC3 = $(TDNW $(D $(MYREF3 $1,$+))$(BR)$(SMALL\n$(D std.experimental.allocator.$2)))\nRES = $(I result)\nPOST = $(BR)$(SMALL $(I Post:) $(BLUE $(D $0)))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/allocator/typed.d",
		"name": "std.experimental.allocator.typed",
		"members": [
			{
				"members": [
					{
						"name": "fixedSize",
						"line": 39,
						"value": "1u",
						"comment": "    Fixed-size allocation (unlikely to get reallocated later). Examples: `int`,\n    `double`, any `struct` or `class` type. By default it is assumed that the\n    allocation is variable-size, i.e. susceptible to later reallocation\n    (for example all array types). This flag is advisory, i.e. in-place resizing\n    may be attempted for `fixedSize` allocations and may succeed. The flag is\n    just a hint to the compiler it may use allocation strategies that work well\n    with objects of fixed size.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "hasNoIndirections",
						"line": 47,
						"value": "4u",
						"comment": "    The type being allocated embeds no pointers. Examples: `int`, `int[]`, $(D\n    Tuple!(int, float)). The implicit conservative assumption is that the type\n    has members with indirections so it needs to be scanned if garbage\n    collected. Example of types with pointers: `int*[]`, $(D Tuple!(int,\n    string)).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "immutableShared",
						"line": 57,
						"value": "8u",
						"comment": "    By default it is conservatively assumed that allocated memory may be `cast`\n    to `shared`, passed across threads, and deallocated in a different thread\n    than the one that allocated it. If that's not the case, there are two\n    options. First, `immutableShared` means the memory is allocated for\n    `immutable` data and will be deallocated in the same thread it was\n    allocated in. Second, `threadLocal` means the memory is not to be shared\n    across threads at all. The two flags cannot be simultaneously present.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "threadLocal",
						"line": 59,
						"value": "16u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "AllocFlag",
				"line": 27,
				"comment": "Allocation-related flags dictated by type characteristics. `TypedAllocator`\ndeduces these flags from the type being allocated and uses the appropriate\nallocator accordingly.\n",
				"baseDeco": "k",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "TypedAllocator",
						"line": 124,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "allocatorFor",
										"line": 188,
										"type": "ref ()",
										"endline": 209,
										"char": 14,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "allocatorFor",
								"line": 188,
								"comment": "    Given `flags` as a combination of `AllocFlag` values, or a type `T`, returns\n    the allocator that's a closest fit in capabilities.\n",
								"parameters": [
									{
										"name": "flags",
										"deco": "k",
										"kind": "value"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "allocatorFor",
										"line": 212,
										"type": "ref ()",
										"endline": 222,
										"char": 14,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "allocatorFor",
								"line": 212,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "type2flags",
										"line": 228,
										"type": "uint()",
										"endline": 241,
										"char": 17,
										"kind": "function"
									}
								],
								"name": "type2flags",
								"line": 228,
								"comment": "    Given a type `T`, returns its allocation-related flags as a combination of\n    `AllocFlag` values.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 17,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "make",
										"line": 264,
										"type": "(auto ref A args)",
										"parameters": [
											{
												"name": "args",
												"type": "A",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 267,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "make",
								"line": 264,
								"comment": "    Dynamically allocates (using the appropriate allocator chosen with\n    `allocatorFor!T`) and then creates in the memory allocated an object of\n    type `T`, using `args` (if any) for its initialization. Initialization\n    occurs in the memory allocated and is otherwise semantically the same as\n    `T(args)`. (Note that using `make!(T[])` creates a pointer to an\n    (empty) array of `T`s, not an array. To allocate and initialize an\n    array, use `makeArray!T` described below.)\n\n    Params:\n    T = Type of the object being created.\n    args = Optional arguments used for initializing the created object. If not\n    present, the object is default constructed.\n\n    Returns: If `T` is a class type, returns a reference to the created `T`\n    object. Otherwise, returns a `T*` pointing to the created object. In all\n    cases, returns `null` if allocation failed.\n\n    Throws: If `T`'s constructor throws, deallocates the allocated memory and\n    propagates the exception.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									},
									{
										"name": "A",
										"kind": "tuple"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "makeArray",
										"line": 288,
										"type": "T[](size_t length)",
										"parameters": [
											{
												"name": "length",
												"type": "size_t"
											}
										],
										"endline": 291,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "makeArray",
								"line": 288,
								"comment": "    Create an array of `T` with `length` elements. The array is either\n    default-initialized, filled with copies of `init`, or initialized with\n    values fetched from `range`.\n\n    Params:\n    T = element type of the array being created\n    length = length of the newly created array\n    init = element used for filling the array\n    range = range used for initializing the array elements\n\n    Returns:\n    The newly-created array, or `null` if either `length` was `0` or\n    allocation failed.\n\n    Throws:\n    The first two overloads throw only if the used allocator's primitives do.\n    The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 9,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "makeArray",
										"line": 294,
										"type": "T[](size_t length, auto ref T init)",
										"parameters": [
											{
												"name": "length",
												"type": "size_t"
											},
											{
												"name": "init",
												"type": "T",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 297,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "makeArray",
								"line": 294,
								"comment": "Ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 9,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "makeArray",
										"line": 300,
										"type": "T[](R range)",
										"parameters": [
											{
												"name": "range",
												"type": "R"
											}
										],
										"endline": 304,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "makeArray",
								"line": 300,
								"comment": "Ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									},
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!R",
								"char": 9,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "expandArray",
										"line": 329,
										"type": "bool(ref T[] array, size_t delta)",
										"parameters": [
											{
												"name": "array",
												"type": "T[]",
												"storageClass": [
													"ref"
												]
											},
											{
												"name": "delta",
												"type": "size_t"
											}
										],
										"endline": 332,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "expandArray",
								"line": 329,
								"comment": "    Grows `array` by appending `delta` more elements. The needed memory is\n    allocated using the same allocator that was used for the array type. The\n    extra elements added are either default-initialized, filled with copies of\n    `init`, or initialized with values fetched from `range`.\n\n    Params:\n    T = element type of the array being created\n    array = a reference to the array being grown\n    delta = number of elements to add (upon success the new length of `array`\n    is $(D array.length + delta))\n    init = element used for filling the array\n    range = range used for initializing the array elements\n\n    Returns:\n    `true` upon success, `false` if memory could not be allocated. In the\n    latter case `array` is left unaffected.\n\n    Throws:\n    The first two overloads throw only if the used allocator's primitives do.\n    The overloads that involve copy initialization deallocate memory and\n    propagate the exception if the copy operation throws.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "expandArray",
										"line": 334,
										"type": "bool(T[] array, size_t delta, auto ref T init)",
										"parameters": [
											{
												"name": "array",
												"type": "T[]"
											},
											{
												"name": "delta",
												"type": "size_t"
											},
											{
												"name": "init",
												"type": "T",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 337,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "expandArray",
								"line": 334,
								"comment": "Ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "expandArray",
										"line": 339,
										"type": "bool(ref T[] array, R range)",
										"parameters": [
											{
												"name": "array",
												"type": "T[]",
												"storageClass": [
													"ref"
												]
											},
											{
												"name": "range",
												"type": "R"
											}
										],
										"endline": 343,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "expandArray",
								"line": 339,
								"comment": "Ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									},
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!R",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "shrinkArray",
										"line": 369,
										"type": "bool(ref T[] arr, size_t delta)",
										"parameters": [
											{
												"name": "arr",
												"type": "T[]",
												"storageClass": [
													"ref"
												]
											},
											{
												"name": "delta",
												"type": "size_t"
											}
										],
										"endline": 372,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "shrinkArray",
								"line": 369,
								"comment": "    Shrinks an array by `delta` elements using `allocatorFor!(T[])`.\n\n    If $(D arr.length < delta), does nothing and returns `false`. Otherwise,\n    destroys the last $(D arr.length - delta) elements in the array and then\n    reallocates the array's buffer. If reallocation fails, fills the array with\n    default-initialized data.\n\n    Params:\n    T = element type of the array being created\n    arr = a reference to the array being shrunk\n    delta = number of elements to remove (upon success the new length of\n    `arr` is $(D arr.length - delta))\n\n    Returns:\n    `true` upon success, `false` if memory could not be reallocated. In the\n    latter case $(D arr[$ - delta .. $]) is left with default-initialized\n    elements.\n\n    Throws:\n    The first two overloads throw only if the used allocator's primitives do.\n    The overloads that involve copy initialization deallocate memory and\n    propagate the exception if the copy operation throws.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "dispose",
										"line": 380,
										"type": "void(T* p)",
										"parameters": [
											{
												"name": "p",
												"type": "T*"
											}
										],
										"endline": 383,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "dispose",
								"line": 380,
								"comment": "    Destroys and then deallocates (using `allocatorFor!T`) the object pointed\n    to by a pointer, the class object referred to by a `class` or `interface`\n    reference, or an entire array. It is assumed the respective entities had\n    been allocated with the same allocator.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "dispose",
										"line": 385,
										"type": "void(T p)",
										"parameters": [
											{
												"name": "p",
												"type": "T"
											}
										],
										"endline": 389,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "dispose",
								"line": 385,
								"comment": "Ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "is(T == class) || is(T == interface)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "dispose",
										"line": 391,
										"type": "void(T[] array)",
										"parameters": [
											{
												"name": "array",
												"type": "T[]"
											}
										],
										"endline": 394,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "dispose",
								"line": 391,
								"comment": "Ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "TypedAllocator",
				"line": 124,
				"comment": "`TypedAllocator` acts like a chassis on which several specialized allocators\ncan be assembled. To let the system make a choice about a particular kind of\nallocation, use `Default` for the respective parameters.\n\nThere is a hierarchy of allocation kinds. When an allocator is implemented for\na given combination of flags, it is used. Otherwise, the next down the list is\nchosen.\n\n$(BOOKTABLE ,\n\n$(TR $(TH `AllocFlag` combination) $(TH Description))\n\n$(T2 AllocFlag.threadLocal |$(NBSP)AllocFlag.hasNoIndirections\n|$(NBSP)AllocFlag.fixedSize,\nThis is the most specific allocation policy: the memory being allocated is\nthread local, has no indirections at all, and will not be reallocated. Examples\nof types fitting this description: `int`, `double`, $(D Tuple!(int, long)), but\nnot $(D Tuple!(int, string)), which contains an indirection.)\n\n$(T2 AllocFlag.threadLocal |$(NBSP)AllocFlag.hasNoIndirections,\nAs above, but may be reallocated later. Examples of types fitting this\ndescription are $(D int[]), $(D double[]), $(D Tuple!(int, long)[]), but not\n$(D Tuple!(int, string)[]), which contains an indirection.)\n\n$(T2 AllocFlag.threadLocal,\nAs above, but may embed indirections. Examples of types fitting this\ndescription are $(D int*[]), $(D Object[]), $(D Tuple!(int, string)[]).)\n\n$(T2 AllocFlag.immutableShared |$(NBSP)AllocFlag.hasNoIndirections\n|$(NBSP)AllocFlag.fixedSize,\nThe type being allocated is `immutable` and has no pointers. The thread that\nallocated it must also deallocate it. Example: `immutable(int)`.)\n\n$(T2 AllocFlag.immutableShared |$(NBSP)AllocFlag.hasNoIndirections,\nAs above, but the type may be appended to in the future. Example: `string`.)\n\n$(T2 AllocFlag.immutableShared,\nAs above, but the type may embed references. Example: `immutable(Object)[]`.)\n\n$(T2 AllocFlag.hasNoIndirections |$(NBSP)AllocFlag.fixedSize,\nThe type being allocated may be shared across threads, embeds no indirections,\nand has fixed size.)\n\n$(T2 AllocFlag.hasNoIndirections,\nThe type being allocated may be shared across threads, may embed indirections,\nand has variable size.)\n\n$(T2 AllocFlag.fixedSize,\nThe type being allocated may be shared across threads, may embed indirections,\nand has fixed size.)\n\n$(T2 0, The most conservative/general allocation: memory may be shared,\ndeallocated in a different thread, may or may not be resized, and may embed\nreferences.)\n)\n\nParams:\nPrimaryAllocator = The default allocator.\nPolicies = Zero or more pairs consisting of an `AllocFlag` and an allocator\ntype.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL398_2717)\n---\nimport std.experimental.allocator.gc_allocator : GCAllocator;\nimport std.experimental.allocator.mallocator : Mallocator;\nimport std.experimental.allocator.mmap_allocator : MmapAllocator;\nalias MyAllocator = TypedAllocator!(GCAllocator,\n    AllocFlag.fixedSize | AllocFlag.threadLocal, Mallocator,\n    AllocFlag.fixedSize | AllocFlag.threadLocal\n            | AllocFlag.hasNoIndirections,\n        MmapAllocator,\n);\nMyAllocator a;\nauto b = &a.allocatorFor!0();\nstatic assert(is(typeof(*b) == shared GCAllocator));\nenum f1 = AllocFlag.fixedSize | AllocFlag.threadLocal;\nauto c = &a.allocatorFor!f1();\nstatic assert(is(typeof(*c) == Mallocator));\nenum f2 = AllocFlag.fixedSize | AllocFlag.threadLocal;\nstatic assert(is(typeof(a.allocatorFor!f2()) == Mallocator));\n// Partial match\nenum f3 = AllocFlag.threadLocal;\nstatic assert(is(typeof(a.allocatorFor!f3()) == Mallocator));\n\nint* p = a.make!int;\nscope(exit) a.dispose(p);\nint[] arr = a.makeArray!int(42);\nscope(exit) a.dispose(arr);\nassert(a.expandArray(arr, 3));\nassert(a.shrinkArray(arr, 4));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL398_2717)\n",
				"parameters": [
					{
						"name": "PrimaryAllocator",
						"kind": "type"
					},
					{
						"name": "Policies",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module defines `TypedAllocator`, a statically-typed allocator that\naggregates multiple untyped allocators and uses them depending on the static\nproperties of the types allocated. For example, distinct allocators may be used\nfor thread-local vs. thread-shared data, or for fixed-size data (`struct`,\n`class` objects) vs. resizable data (arrays).\n\nMacros:\nT2=$(TR <td style=\"text-align:left\">$(D $1)</td> $(TD $(ARGS $+)))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/allocator/showcase.d",
		"name": "std.experimental.allocator.showcase",
		"members": [
			{
				"members": [
					{
						"name": "StackFront",
						"line": 36,
						"type": "FallbackAllocator!(InSituRegion!(stackSize, Allocator.alignment), Allocator)",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "StackFront",
				"line": 36,
				"comment": "\nAllocator that uses stack allocation for up to $(D stackSize) bytes and\nthen falls back to $(D Allocator). Defined as:\n\n----\nalias StackFront(size_t stackSize, Allocator) =\n    FallbackAllocator!(\n        InSituRegion!(stackSize, Allocator.alignment,\n            hasMember!(Allocator, \"deallocate\")\n                ? Yes.defineDeallocate\n                : No.defineDeallocate),\n        Allocator);\n----\n\nChoosing `stackSize` is as always a compromise. Too small a size exhausts the\nstack storage after a few allocations, after which there are no gains over the\nbackup allocator. Too large a size increases the stack consumed by the thread\nand may end up worse off because it explores cold portions of the stack.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL42_2719)\n---\nStackFront!4096 a;\nauto b = a.allocate(4000);\nassert(b.length == 4000);\nauto c = a.allocate(4000);\nassert(c.length == 4000);\na.deallocate(b);\na.deallocate(c);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL42_2719)\n",
				"parameters": [
					{
						"name": "stackSize",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Allocator",
						"default": "GCAllocator",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "mmapRegionList",
				"line": 59,
				"comment": "Creates a scalable `AllocatorList` of `Regions`, each having at least\n`bytesPerRegion` bytes. Allocation is very fast. This allocator does not offer\n`deallocate` but does free all regions in its destructor. It is recommended for\nshort-lived batch applications that count on never running out of memory.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL87_2720)\n---\nauto alloc = mmapRegionList(1024 * 1024);\nconst b = alloc.allocate(100);\nassert(b.length == 100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL87_2720)\n",
				"deco": "FmZS3std12experimental9allocator15building_blocks14allocator_list163__T13AllocatorListTS3std12experimental9allocator8showcase14mmapRegionListFmZ7FactoryTS3std12experimental9allocator15building_blocks14null_allocator13NullAllocatorZ13AllocatorList",
				"parameters": [
					{
						"name": "bytesPerRegion",
						"deco": "m"
					}
				],
				"endline": 84,
				"originalType": "(size_t bytesPerRegion)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			}
		],
		"comment": "\nCollection of typical and useful prebuilt allocators using the given\ncomponents. User code would typically import this module and use its\nfacilities, or import individual heap building blocks and assemble them.\n\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/allocator/package.d",
		"name": "std.experimental.allocator",
		"members": [
			{
				"name": "IAllocator",
				"line": 272,
				"comment": "Dynamic allocator interface. Code that defines allocators ultimately implements\nthis interface. This should be used wherever a uniform type is required for\nencapsulating various allocator implementations.\n\nComposition of allocators is not recommended at this level due to\ninflexibility of dynamic interfaces and inefficiencies caused by cascaded\nmultiple calls. Instead, compose allocators using the static interface defined\nin $(A std_experimental_allocator_building_blocks.html,\n`std.experimental.allocator.building_blocks`), then adapt the composed\nallocator to `IAllocator` (possibly by using $(LREF CAllocatorImpl) below).\n\nMethods returning $(D Ternary) return $(D Ternary.yes) upon success,\n$(D Ternary.no) upon failure, and $(D Ternary.unknown) if the primitive is not\nimplemented by the allocator instance.\n",
				"members": [
					{
						"name": "alignment",
						"line": 277,
						"comment": "    Returns the alignment offered.\n",
						"deco": "FNdZk",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "goodAllocSize",
						"line": 283,
						"comment": "    Returns the good allocation size that guarantees zero internal\n    fragmentation.\n",
						"deco": "FmZm",
						"parameters": [
							{
								"name": "s",
								"deco": "m"
							}
						],
						"originalType": "size_t(size_t s)",
						"char": 12,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "allocate",
						"line": 288,
						"comment": "    Allocates `n` bytes of memory.\n",
						"deco": "FmC8TypeInfoZAv",
						"parameters": [
							{
								"deco": "m"
							},
							{
								"name": "ti",
								"deco": "C8TypeInfo",
								"default": "null"
							}
						],
						"originalType": "void[](size_t, TypeInfo ti = null)",
						"char": 12,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "alignedAllocate",
						"line": 294,
						"comment": "    Allocates `n` bytes of memory with specified alignment `a`. Implementations\n    that do not support this primitive should always return `null`.\n",
						"deco": "FmkZAv",
						"parameters": [
							{
								"name": "n",
								"deco": "m"
							},
							{
								"name": "a",
								"deco": "k"
							}
						],
						"originalType": "void[](size_t n, uint a)",
						"char": 12,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "allocateAll",
						"line": 301,
						"comment": "    Allocates and returns all memory available to this allocator.\n    Implementations that do not support this primitive should always return\n    `null`.\n",
						"deco": "FZAv",
						"char": 12,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "expand",
						"line": 308,
						"comment": "    Expands a memory block in place and returns `true` if successful.\n    Implementations that don't support this primitive should always return\n    `false`.\n",
						"deco": "FKAvmZb",
						"parameters": [
							{
								"storageClass": [
									"ref"
								],
								"deco": "Av"
							},
							{
								"deco": "m"
							}
						],
						"originalType": "bool(ref void[], size_t)",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "reallocate",
						"line": 311,
						"comment": "Reallocates a memory block.\n",
						"deco": "FKAvmZb",
						"parameters": [
							{
								"storageClass": [
									"ref"
								],
								"deco": "Av"
							},
							{
								"deco": "m"
							}
						],
						"originalType": "bool(ref void[], size_t)",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "alignedReallocate",
						"line": 314,
						"comment": "Reallocates a memory block with specified alignment.\n",
						"deco": "FKAvmkZb",
						"parameters": [
							{
								"name": "b",
								"storageClass": [
									"ref"
								],
								"deco": "Av"
							},
							{
								"name": "size",
								"deco": "m"
							},
							{
								"name": "alignment",
								"deco": "k"
							}
						],
						"originalType": "bool(ref void[] b, size_t size, uint alignment)",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "owns",
						"line": 322,
						"comment": "    Returns $(D Ternary.yes) if the allocator owns $(D b), $(D Ternary.no) if\n    the allocator doesn't own $(D b), and $(D Ternary.unknown) if ownership\n    cannot be determined. Implementations that don't support this primitive\n    should always return `Ternary.unknown`.\n",
						"deco": "FAvZS3std12experimental9allocator6common7Ternary",
						"parameters": [
							{
								"name": "b",
								"deco": "Av"
							}
						],
						"char": 13,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "resolveInternalPointer",
						"line": 328,
						"comment": "    Resolves an internal pointer to the full block allocated. Implementations\n    that don't support this primitive should always return `Ternary.unknown`.\n",
						"deco": "FPvKAvZS3std12experimental9allocator6common7Ternary",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							},
							{
								"name": "result",
								"storageClass": [
									"ref"
								],
								"deco": "Av"
							}
						],
						"char": 13,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "deallocate",
						"line": 335,
						"comment": "    Deallocates a memory block. Implementations that don't support this\n    primitive should always return `false`. A simple way to check that an\n    allocator supports deallocation is to call $(D deallocate(null)).\n",
						"deco": "FAvZb",
						"parameters": [
							{
								"name": "b",
								"deco": "Av"
							}
						],
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "deallocateAll",
						"line": 341,
						"comment": "    Deallocates all memory. Implementations that don't support this primitive\n    should always return `false`.\n",
						"deco": "FZb",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "empty",
						"line": 348,
						"comment": "    Returns $(D Ternary.yes) if no memory is currently allocated from this\n    allocator, $(D Ternary.no) if some allocations are currently active, or\n    $(D Ternary.unknown) if not supported.\n",
						"deco": "FZS3std12experimental9allocator6common7Ternary",
						"char": 13,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					}
				],
				"char": 1,
				"kind": "interface"
			},
			{
				"endchar": 1,
				"name": "theAllocator",
				"line": 374,
				"comment": "Gets/sets the allocator for the current thread. This is the default allocator\nthat should be used for allocating thread-local memory. For allocating memory\nto be shared across threads, use $(D processAllocator) (below). By default,\n$(D theAllocator) ultimately fetches memory from $(D processAllocator), which\nin turn uses the garbage collected heap.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL387_2732)\n---\n// Install a new allocator that is faster for 128-byte allocations.\nimport std.experimental.allocator.building_blocks.free_list : FreeList;\nimport std.experimental.allocator.gc_allocator : GCAllocator;\nauto oldAllocator = theAllocator;\nscope(exit) theAllocator = oldAllocator;\ntheAllocator = allocatorObject(FreeList!(GCAllocator, 128)());\n// Use the now changed allocator to allocate an array\nconst ubyte[] arr = theAllocator.makeArray!ubyte(128);\nassert(arr.ptr);\n//...\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL387_2732)\n",
				"deco": "FNdZC3std12experimental9allocator10IAllocator",
				"endline": 377,
				"char": 22,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "theAllocator",
				"line": 380,
				"comment": "Ditto\n",
				"deco": "FNdC3std12experimental9allocator10IAllocatorZv",
				"parameters": [
					{
						"name": "a",
						"deco": "C3std12experimental9allocator10IAllocator"
					}
				],
				"endline": 384,
				"char": 16,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "processAllocator",
				"line": 406,
				"comment": "Gets/sets the allocator for the current process. This allocator must be used\nfor allocating memory shared across threads. Objects created using this\nallocator can be cast to $(D shared).\n",
				"deco": "FNdZC3std12experimental9allocator10IAllocator",
				"endline": 409,
				"char": 22,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "processAllocator",
				"line": 412,
				"comment": "Ditto\n",
				"deco": "FNdC3std12experimental9allocator10IAllocatorZv",
				"parameters": [
					{
						"name": "a",
						"deco": "C3std12experimental9allocator10IAllocator"
					}
				],
				"endline": 416,
				"char": 16,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "make",
						"line": 448,
						"type": "(auto ref Allocator alloc, auto ref A args)",
						"parameters": [
							{
								"name": "alloc",
								"type": "Allocator",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "args",
								"type": "A",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 457,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "make",
				"line": 448,
				"comment": "Dynamically allocates (using $(D alloc)) and then creates in the memory\nallocated an object of type $(D T), using $(D args) (if any) for its\ninitialization. Initialization occurs in the memory allocated and is otherwise\nsemantically the same as $(D T(args)).\n(Note that using $(D alloc.make!(T[])) creates a pointer to an (empty) array\nof $(D T)s, not an array. To use an allocator to allocate and initialize an\narray, use $(D alloc.makeArray!T) described below.)\n\nParams:\nT = Type of the object being created.\nalloc = The allocator used for getting the needed memory. It may be an object\nimplementing the static interface for allocators, or an $(D IAllocator)\nreference.\nargs = Optional arguments used for initializing the created object. If not\npresent, the object is default constructed.\n\nReturns: If $(D T) is a class type, returns a reference to the created $(D T)\nobject. Otherwise, returns a $(D T*) pointing to the created object. In all\ncases, returns $(D null) if allocation failed.\n\nThrows: If $(D T)'s constructor throws, deallocates the allocated memory and\npropagates the exception.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL460_2734)\n---\n// Dynamically allocate one integer\nconst int* p1 = theAllocator.make!int;\n// It's implicitly initialized with its .init value\nassert(*p1 == 0);\n// Dynamically allocate one double, initialize to 42.5\nconst double* p2 = theAllocator.make!double(42.5);\nassert(*p2 == 42.5);\n\n// Dynamically allocate a struct\nstatic struct Point\n{\n    int x, y, z;\n}\n// Use the generated constructor taking field values in order\nconst Point* p = theAllocator.make!Point(1, 2);\nassert(p.x == 1 && p.y == 2 && p.z == 0);\n\n// Dynamically allocate a class object\nstatic class Customer\n{\n    uint id = uint.max;\n    this() {}\n    this(uint id) { this.id = id; }\n    // ...\n}\nCustomer cust = theAllocator.make!Customer;\nassert(cust.id == uint.max); // default initialized\ncust = theAllocator.make!Customer(42);\nassert(cust.id == 42);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL460_2734)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Allocator",
						"kind": "type"
					},
					{
						"name": "A",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeArray",
						"line": 607,
						"type": "T[](auto ref Allocator alloc, size_t length)",
						"parameters": [
							{
								"name": "alloc",
								"type": "Allocator",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "length",
								"type": "size_t"
							}
						],
						"endline": 613,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "makeArray",
				"line": 607,
				"comment": "Create an array of $(D T) with $(D length) elements using $(D alloc). The array is either default-initialized, filled with copies of $(D init), or initialized with values fetched from `range`.\n\nParams:\nT = element type of the array being created\nalloc = the allocator used for getting memory\nlength = length of the newly created array\ninit = element used for filling the array\nrange = range used for initializing the array elements\n\nReturns:\nThe newly-created array, or $(D null) if either $(D length) was $(D 0) or\nallocation failed.\n\nThrows:\nThe first two overloads throw only if `alloc`'s primitives do. The\noverloads that involve copy initialization deallocate memory and propagate the\nexception if the copy operation throws.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL666_2739)\n---\nint[] a = theAllocator.makeArray!int(2);\nassert(a == [0, 0]);\na = theAllocator.makeArray!int(3, 42);\nassert(a == [42, 42, 42]);\nimport std.range : only;\na = theAllocator.makeArray!int(only(42, 43, 44));\nassert(a == [42, 43, 44]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL666_2739)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Allocator",
						"kind": "type"
					}
				],
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeArray",
						"line": 631,
						"type": "T[](auto ref Allocator alloc, size_t length, auto ref T init)",
						"parameters": [
							{
								"name": "alloc",
								"type": "Allocator",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "length",
								"type": "size_t"
							},
							{
								"name": "init",
								"type": "T",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 663,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "makeArray",
				"line": 631,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Allocator",
						"kind": "type"
					}
				],
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeArray",
						"line": 693,
						"type": "T[](auto ref Allocator alloc, R range)",
						"parameters": [
							{
								"name": "alloc",
								"type": "Allocator",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 766,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "makeArray",
				"line": 693,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Allocator",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "expandArray",
						"line": 840,
						"type": "bool(auto ref Allocator alloc, ref T[] array, size_t delta)",
						"parameters": [
							{
								"name": "alloc",
								"type": "Allocator",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "delta",
								"type": "size_t"
							}
						],
						"endline": 850,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "expandArray",
				"line": 840,
				"comment": "Grows $(D array) by appending $(D delta) more elements. The needed memory is\nallocated using $(D alloc). The extra elements added are either default-\ninitialized, filled with copies of $(D init), or initialized with values\nfetched from `range`.\n\nParams:\nT = element type of the array being created\nalloc = the allocator used for getting memory\narray = a reference to the array being grown\ndelta = number of elements to add (upon success the new length of $(D array) is\n$(D array.length + delta))\ninit = element used for filling the array\nrange = range used for initializing the array elements\n\nReturns:\n$(D true) upon success, $(D false) if memory could not be allocated. In the\nlatter case $(D array) is left unaffected.\n\nThrows:\nThe first two overloads throw only if `alloc`'s primitives do. The\noverloads that involve copy initialization deallocate memory and propagate the\nexception if the copy operation throws.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL940_2744)\n---\nauto arr = theAllocator.makeArray!int([1, 2, 3]);\nassert(theAllocator.expandArray(arr, 2));\nassert(arr == [1, 2, 3, 0, 0]);\nimport std.range : only;\nassert(theAllocator.expandArray(arr, only(4, 5)));\nassert(arr == [1, 2, 3, 0, 0, 4, 5]);\n\nForcedInputRange r;\nint[] b = [ 1, 2, 3, 4 ];\nauto temp = b;\nr.array = &temp;\nassert(theAllocator.expandArray(arr, r));\nassert(arr == [1, 2, 3, 0, 0, 4, 5, 1, 2, 3, 4]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL940_2744)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Allocator",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "expandArray",
						"line": 866,
						"type": "bool(auto ref Allocator alloc, T[] array, size_t delta, auto ref T init)",
						"parameters": [
							{
								"name": "alloc",
								"type": "Allocator",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "array",
								"type": "T[]"
							},
							{
								"name": "delta",
								"type": "size_t"
							},
							{
								"name": "init",
								"type": "T",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 878,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "expandArray",
				"line": 866,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Allocator",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "expandArray",
						"line": 881,
						"type": "bool(auto ref Allocator alloc, ref T[] array, R range)",
						"parameters": [
							{
								"name": "alloc",
								"type": "Allocator",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 937,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "expandArray",
				"line": 881,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Allocator",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "shrinkArray",
						"line": 981,
						"type": "bool(auto ref Allocator alloc, ref T[] array, size_t delta)",
						"parameters": [
							{
								"name": "alloc",
								"type": "Allocator",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "delta",
								"type": "size_t"
							}
						],
						"endline": 1017,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "shrinkArray",
				"line": 981,
				"comment": "Shrinks an array by $(D delta) elements.\n\nIf $(D array.length < delta), does nothing and returns `false`. Otherwise,\ndestroys the last $(D array.length - delta) elements in the array and then\nreallocates the array's buffer. If reallocation fails, fills the array with\ndefault-initialized data.\n\nParams:\nT = element type of the array being created\nalloc = the allocator used for getting memory\narray = a reference to the array being shrunk\ndelta = number of elements to remove (upon success the new length of $(D array) is $(D array.length - delta))\n\nReturns:\n`true` upon success, `false` if memory could not be reallocated. In the latter\ncase, the slice $(D array[$ - delta .. $]) is left with default-initialized\nelements.\n\nThrows:\nThe first two overloads throw only if `alloc`'s primitives do. The\noverloads that involve copy initialization deallocate memory and propagate the\nexception if the copy operation throws.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1020_2745)\n---\nint[] a = theAllocator.makeArray!int(100, 42);\nassert(a.length == 100);\nassert(theAllocator.shrinkArray(a, 98));\nassert(a.length == 2);\nassert(a == [42, 42]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1020_2745)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Allocator",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dispose",
						"line": 1053,
						"type": "void(auto ref A alloc, T* p)",
						"parameters": [
							{
								"name": "alloc",
								"type": "A",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "p",
								"type": "T*"
							}
						],
						"endline": 1060,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "dispose",
				"line": 1053,
				"comment": "\nDestroys and then deallocates (using $(D alloc)) the object pointed to by a\npointer, the class object referred to by a $(D class) or $(D interface)\nreference, or an entire array. It is assumed the respective entities had been\nallocated with the same allocator.\n\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dispose",
						"line": 1063,
						"type": "void(auto ref A alloc, T p)",
						"parameters": [
							{
								"name": "alloc",
								"type": "A",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "p",
								"type": "T"
							}
						],
						"endline": 1070,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "dispose",
				"line": 1063,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) || is(T == interface)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dispose",
						"line": 1073,
						"type": "void(auto ref A alloc, T[] array)",
						"parameters": [
							{
								"name": "alloc",
								"type": "A",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "array",
								"type": "T[]"
							}
						],
						"endline": 1083,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "dispose",
				"line": 1073,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allocatorObject",
						"line": 1142,
						"type": "CAllocatorImpl!A(auto ref A a)",
						"parameters": [
							{
								"name": "a",
								"type": "A",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 1181,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "allocatorObject",
				"line": 1142,
				"comment": "\nReturns a dynamically-typed $(D CAllocator) built around a given statically-\ntyped allocator $(D a) of type $(D A). Passing a pointer to the allocator\ncreates a dynamic allocator around the allocator pointed to by the pointer,\nwithout attempting to copy or move it. Passing the allocator by value or\nreference behaves as follows.\n\n$(UL\n$(LI If $(D A) has no state, the resulting object is allocated in static\nshared storage.)\n$(LI If $(D A) has state and is copyable, the result will store a copy of it\nwithin. The result itself is allocated in its own statically-typed allocator.)\n$(LI If $(D A) has state and is not copyable, the result will move the\npassed-in argument into the result. The result itself is allocated in its own\nstatically-typed allocator.)\n)\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1199_2748)\n---\nimport std.experimental.allocator.mallocator : Mallocator;\nIAllocator a = allocatorObject(Mallocator.instance);\nauto b = a.allocate(100);\nassert(b.length == 100);\nassert(a.deallocate(b));\n\n// The in-situ region must be used by pointer\nimport std.experimental.allocator.building_blocks.region : InSituRegion;\nauto r = InSituRegion!1024();\na = allocatorObject(&r);\nb = a.allocate(200);\nassert(b.length == 200);\n// In-situ regions can deallocate the last allocation\nassert(a.deallocate(b));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1199_2748)\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"constraint": "!isPointer!A",
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allocatorObject",
						"line": 1184,
						"type": "CAllocatorImpl!(A, Yes.indirect)(A* pa)",
						"parameters": [
							{
								"name": "pa",
								"type": "A*"
							}
						],
						"endline": 1196,
						"char": 34,
						"kind": "function"
					}
				],
				"name": "allocatorObject",
				"line": 1184,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"char": 34,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CAllocatorImpl",
						"line": 1226,
						"members": [
							{
								"endchar": 5,
								"name": "alignment",
								"line": 1253,
								"comment": "Returns $(D impl.alignment).\n",
								"type": "@property uint()",
								"endline": 1256,
								"char": 29,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "goodAllocSize",
								"line": 1261,
								"comment": "    Returns $(D impl.goodAllocSize(s)).\n",
								"type": "size_t(size_t s)",
								"parameters": [
									{
										"name": "s",
										"type": "size_t"
									}
								],
								"endline": 1264,
								"char": 21,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "allocate",
								"line": 1269,
								"comment": "    Returns $(D impl.allocate(s)).\n",
								"type": "void[](size_t s, TypeInfo ti = null)",
								"parameters": [
									{
										"name": "s",
										"type": "size_t"
									},
									{
										"name": "ti",
										"type": "TypeInfo",
										"default": "null"
									}
								],
								"endline": 1272,
								"char": 21,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "alignedAllocate",
								"line": 1278,
								"comment": "    If $(D impl.alignedAllocate) exists, calls it and returns the result.\n    Otherwise, always returns `null`.\n",
								"type": "void[](size_t s, uint a)",
								"parameters": [
									{
										"name": "s",
										"type": "size_t"
									},
									{
										"name": "a",
										"deco": "k"
									}
								],
								"endline": 1284,
								"char": 21,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "owns",
								"line": 1290,
								"comment": "    If `Allocator` implements `owns`, forwards to it. Otherwise, returns\n    `Ternary.unknown`.\n",
								"type": "Ternary(void[] b)",
								"parameters": [
									{
										"name": "b",
										"type": "void[]"
									}
								],
								"endline": 1294,
								"char": 22,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "expand",
								"line": 1297,
								"comment": "Returns $(D impl.expand(b, s)) if defined, $(D false) otherwise.\n",
								"type": "bool(ref void[] b, size_t s)",
								"parameters": [
									{
										"name": "b",
										"type": "void[]",
										"storageClass": [
											"ref"
										]
									},
									{
										"name": "s",
										"type": "size_t"
									}
								],
								"endline": 1303,
								"char": 19,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "reallocate",
								"line": 1306,
								"comment": "Returns $(D impl.reallocate(b, s)).\n",
								"type": "bool(ref void[] b, size_t s)",
								"parameters": [
									{
										"name": "b",
										"type": "void[]",
										"storageClass": [
											"ref"
										]
									},
									{
										"name": "s",
										"type": "size_t"
									}
								],
								"endline": 1309,
								"char": 19,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "alignedReallocate",
								"line": 1312,
								"comment": "Forwards to $(D impl.alignedReallocate).\n",
								"type": "bool(ref void[] b, size_t s, uint a)",
								"parameters": [
									{
										"name": "b",
										"type": "void[]",
										"storageClass": [
											"ref"
										]
									},
									{
										"name": "s",
										"type": "size_t"
									},
									{
										"name": "a",
										"deco": "k"
									}
								],
								"endline": 1322,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "deallocate",
								"line": 1345,
								"comment": "    If $(D impl.deallocate) is not defined, returns $(D Ternary.unknown). If\n    $(D impl.deallocate) returns $(D void) (the common case), calls it and\n    returns $(D Ternary.yes). If $(D impl.deallocate) returns $(D bool), calls\n    it and returns $(D Ternary.yes) for $(D true), $(D Ternary.no) for $(D\n    false).\n",
								"type": "bool(void[] b)",
								"parameters": [
									{
										"name": "b",
										"type": "void[]"
									}
								],
								"endline": 1355,
								"char": 19,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "deallocateAll",
								"line": 1361,
								"comment": "    Calls $(D impl.deallocateAll()) and returns $(D Ternary.yes) if defined,\n    otherwise returns $(D Ternary.unknown).\n",
								"type": "bool()",
								"endline": 1371,
								"char": 19,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 1377,
								"comment": "    Forwards to $(D impl.empty()) if defined, otherwise returns\n    $(D Ternary.unknown).\n",
								"type": "Ternary()",
								"endline": 1387,
								"char": 22,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "allocateAll",
								"line": 1392,
								"comment": "    Returns $(D impl.allocateAll()) if present, $(D null) otherwise.\n",
								"type": "void[]()",
								"endline": 1402,
								"char": 21,
								"kind": "function",
								"storageClass": [
									"override"
								]
							}
						],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "CAllocatorImpl",
				"line": 1226,
				"comment": "\nImplementation of $(D IAllocator) using $(D Allocator). This adapts a\nstatically-built allocator type to $(D IAllocator) that is directly usable by\nnon-templated code.\n\nUsually $(D CAllocatorImpl) is used indirectly by calling\n$(LREF theAllocator).\n",
				"parameters": [
					{
						"name": "Allocator",
						"kind": "type"
					},
					{
						"name": "indirect",
						"defaultValue": "No.indirect",
						"deco": "E3std8typecons32__T4FlagVAyaa8_696e646972656374Z4Flag",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "\nHigh-level interface for allocators. Implements bundled allocation/creation\nand destruction/deallocation of data including `struct`s and `class`es,\nand also array primitives related to allocation. This module is the entry point\nfor both making use of allocators and for their documentation.\n\nSynopsis:\n---\n// Allocate an int, initialize it with 42\nint* p = theAllocator.make!int(42);\nassert(*p == 42);\n// Destroy and deallocate it\ntheAllocator.dispose(p);\n\n// Allocate using the global process allocator\np = processAllocator.make!int(100);\nassert(*p == 100);\n// Destroy and deallocate\nprocessAllocator.dispose(p);\n\n// Create an array of 50 doubles initialized to -1.0\ndouble[] arr = theAllocator.makeArray!double(50, -1.0);\n// Append two zeros to it\ntheAllocator.expandArray(arr, 2, 0.0);\n// On second thought, take that back\ntheAllocator.shrinkArray(arr, 2);\n// Destroy and deallocate\ntheAllocator.dispose(arr);\n---\n\n$(H2 Layered Structure)\n\nD's allocators have a layered structure in both implementation and documentation:\n\n$(OL\n$(LI A high-level, dynamically-typed layer (described further down in this\nmodule). It consists of an interface called $(LREF IAllocator), which concrete\nallocators need to implement. The interface primitives themselves are oblivious\nto the type of the objects being allocated; they only deal in `void[]`, by\nnecessity of the interface being dynamic (as opposed to type-parameterized).\nEach thread has a current allocator it uses by default, which is a thread-local\nvariable $(LREF theAllocator) of type $(LREF IAllocator). The process has a\nglobal _allocator called $(LREF processAllocator), also of type $(LREF\nIAllocator). When a new thread is created, $(LREF processAllocator) is copied\ninto $(LREF theAllocator). An application can change the objects to which these\nreferences point. By default, at application startup, $(LREF processAllocator)\nrefers to an object that uses D's garbage collected heap. This layer also\ninclude high-level functions such as $(LREF make) and $(LREF dispose) that\ncomfortably allocate/create and respectively destroy/deallocate objects. This\nlayer is all needed for most casual uses of allocation primitives.)\n\n$(LI A mid-level, statically-typed layer for assembling several allocators into\none. It uses properties of the type of the objects being created to route\nallocation requests to possibly specialized allocators. This layer is relatively\nthin and implemented and documented in the $(XREF2\nstd,experimental,_allocator,typed) module. It allows an interested user to e.g.\nuse different allocators for arrays versus fixed-sized objects, to the end of\nbetter overall performance.)\n\n$(LI A low-level collection of highly generic $(I heap building blocks)$(MDASH)\nLego-like pieces that can be used to assemble application-specific allocators.\nThe real allocation smarts are occurring at this level. This layer is of\ninterest to advanced applications that want to configure their own allocators.\nA good illustration of typical uses of these building blocks is module $(XREF2\nstd,experimental,_allocator,showcase) which defines a collection of frequently-\nused preassembled allocator objects. The implementation and documentation entry\npoint is $(XREF2 std,experimental,_allocator,building_blocks). By design, the\nprimitives of the static interface have the same signatures as the $(LREF\nIAllocator) primitives but are for the most part optional and driven by static\nintrospection. The parameterized class $(LREF CAllocatorImpl) offers an\nimmediate and useful means to package a static low-level _allocator into an\nimplementation of $(LREF IAllocator).)\n\n$(LI Core _allocator objects that interface with D's garbage collected heap\n($(XREF2 std,experimental,_allocator,gc_allocator)), the C `malloc` family\n($(XREF2 std,experimental,_allocator,mallocator)), and the OS ($(XREF2\nstd,experimental,_allocator,mmap_allocator)). Most custom allocators would\nultimately obtain memory from one of these core allocators.)\n)\n\n$(H2 Idiomatic Use of $(D std.experimental._allocator))\n\nAs of this time, $(D std.experimental._allocator) is not integrated with D's\nbuilt-in operators that allocate memory, such as `new`, array literals, or\narray concatenation operators. That means $(D std.experimental._allocator) is\nopt-in$(MDASH)applications need to make explicit use of it.\n\nFor casual creation and disposal of dynamically-allocated objects, use $(LREF\nmake), $(LREF dispose), and the array-specific functions $(LREF makeArray),\n$(LREF expandArray), and $(LREF shrinkArray). These use by default D's garbage\ncollected heap, but open the application to better configuration options. These\nprimitives work either with `theAllocator` but also with any allocator obtained\nby combining heap building blocks. For example:\n\n----\nvoid fun(size_t n)\n{\n    // Use the current allocator\n    int[] a1 = theAllocator.makeArray!int(n);\n    scope(exit) theAllocator.dispose(a1);\n    ...\n}\n----\n\nTo experiment with alternative allocators, set $(LREF theAllocator) for the\ncurrent thread. For example, consider an application that allocates many 8-byte\nobjects. These are not well supported by the default _allocator, so a $(A\n$(MY_JOIN_LINE std,experimental,_allocator,building_blocks,free_list).html, free\nlist _allocator) would be recommended. To install one in `main`, the\napplication would use:\n\n----\nvoid main()\n{\n    import std.experimental.allocator.building_blocks.free_list\n        : FreeList;\n    theAllocator = allocatorObject(FreeList!8());\n    ...\n}\n----\n\n$(H3 Saving the `IAllocator` Reference For Later Use)\n\nAs with any global resource, setting `theAllocator` and `processAllocator`\nshould not be done often and casually. In particular, allocating memory with\none allocator and deallocating with another causes undefined behavior.\nTypically, these variables are set during application initialization phase and\nlast through the application.\n\nTo avoid this, long-lived objects that need to perform allocations,\nreallocations, and deallocations relatively often may want to store a reference\nto the _allocator object they use throughout their lifetime. Then, instead of\nusing `theAllocator` for internal allocation-related tasks, they'd use the\ninternally held reference. For example, consider a user-defined hash table:\n\n----\nstruct HashTable\n{\n    private IAllocator _allocator;\n    this(size_t buckets, IAllocator allocator = theAllocator) {\n        this._allocator = allocator;\n        ...\n    }\n    // Getter and setter\n    IAllocator allocator() { return _allocator; }\n    void allocator(IAllocator a) { assert(empty); _allocator = a; }\n}\n----\n\nFollowing initialization, the `HashTable` object would consistently use its\n$(D _allocator) object for acquiring memory. Furthermore, setting\n$(D HashTable._allocator) to point to a different _allocator should be legal but\nonly if the object is empty; otherwise, the object wouldn't be able to\ndeallocate its existing state.\n\n$(H3 Using Allocators without `IAllocator`)\n\nAllocators assembled from the heap building blocks don't need to go through\n`IAllocator` to be usable. They have the same primitives as `IAllocator` and\nthey work with $(LREF make), $(LREF makeArray), $(LREF dispose) etc. So it\nsuffice to create allocator objects wherever fit and use them appropriately:\n\n----\nvoid fun(size_t n)\n{\n    // Use a stack-installed allocator for up to 64KB\n    StackFront!65536 myAllocator;\n    int[] a2 = myAllocator.makeArray!int(n);\n    scope(exit) theAllocator.dispose(a2);\n    ...\n}\n----\n\nIn this case, `myAllocator` does not obey the `IAllocator` interface, but\nimplements its primitives so it can work with `makeArray` by means of duck\ntyping.\n\nOne important thing to note about this setup is that statically-typed assembled\nallocators are almost always faster than allocators that go through\n`IAllocator`. An important rule of thumb is: \"assemble allocator first, adapt\nto `IAllocator` after\". A good allocator implements intricate logic by means of\ntemplate assembly, and gets wrapped with `IAllocator` (usually by means of\n$(LREF allocatorObject)) only once, at client level.\n\nMacros:\nMYREF = $(LINK2 std_experimental_allocator_$2.html, $1)&nbsp;\nMYREF2 = $(LINK2 std_experimental_allocator_$2.html#$1, $1)&nbsp;\nTDC = <td nowrap>$(D $1)$+</td>\nTDC2 = <td nowrap>$(D $(MYREF $1,$+))</td>\nTDC3 = <td nowrap>$(D $(MYREF2 $1,$+))</td>\nRES = $(I result)\nPOST = $(BR)$(SMALL $(I Post:) $(BLUE $(D $0)))\nMY_JOIN_LINE = $1$(MY_JOIN_LINE_TAIL $+)\nMY_JOIN_LINE_TAIL = _$1$(MY_JOIN_LINE_TAIL $+)\nJOIN_DOT = $1$(JOIN_DOT_TAIL $+)\nJOIN_DOT_TAIL = .$1$(JOIN_DOT_TAIL $+)\nXREF2 = $(A $(MY_JOIN_LINE $1,$+).html,$(D $(JOIN_DOT $1,$+)))\n\nCopyright: Andrei Alexandrescu 2013-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/experimental/_allocator)\n\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/allocator/common.d",
		"name": "std.experimental.allocator.common",
		"members": [
			{
				"name": "Ternary",
				"line": 14,
				"comment": "Ternary type with three thruth values.\n",
				"members": [
					{
						"name": "no",
						"line": 27,
						"comment": "    In addition to `false` and `true`, `Ternary` offers `unknown`.\n",
						"deco": "S3std12experimental9allocator6common7Ternary",
						"init": "Ternary(cast(ubyte)0u)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					},
					{
						"name": "yes",
						"line": 29,
						"comment": "ditto\n",
						"deco": "S3std12experimental9allocator6common7Ternary",
						"init": "Ternary(cast(ubyte)2u)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					},
					{
						"name": "unknown",
						"line": 31,
						"comment": "ditto\n",
						"deco": "S3std12experimental9allocator6common7Ternary",
						"init": "Ternary(cast(ubyte)6u)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					},
					{
						"endchar": 36,
						"name": "this",
						"line": 37,
						"comment": "     Construct and assign from a `bool`, receiving `no` for `false` and `yes`\n     for `true`.\n",
						"deco": "FNcbZS3std12experimental9allocator6common7Ternary",
						"parameters": [
							{
								"name": "b",
								"deco": "b"
							}
						],
						"endline": 37,
						"originalType": "ref (bool b)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 45,
						"name": "opAssign",
						"line": 40,
						"comment": "ditto\n",
						"deco": "FbZv",
						"parameters": [
							{
								"name": "b",
								"deco": "b"
							}
						],
						"endline": 40,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 46,
						"name": "this",
						"line": 45,
						"comment": "    Construct a ternary value from another ternary value\n",
						"deco": "FNcxS3std12experimental9allocator6common7TernaryZS3std12experimental9allocator6common7Ternary",
						"parameters": [
							{
								"name": "b",
								"deco": "xS3std12experimental9allocator6common7Ternary"
							}
						],
						"endline": 45,
						"originalType": "ref (const Ternary b)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 61,
								"type": "Ternary()",
								"endline": 64,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 61,
						"comment": "    $(TABLE Truth table for logical operations,\n      $(TR $(TH `a`) $(TH `b`) $(TH `$(TILDE)a`) $(TH `a | b`) $(TH `a & b`) $(TH `a ^ b`))\n      $(TR $(TD `no`) $(TD `no`) $(TD `yes`) $(TD `no`) $(TD `no`) $(TD `no`))\n      $(TR $(TD `no`) $(TD `yes`) $(TD) $(TD `yes`) $(TD `no`) $(TD `yes`))\n      $(TR $(TD `no`) $(TD `unknown`) $(TD) $(TD `unknown`) $(TD `no`) $(TD `unknown`))\n      $(TR $(TD `yes`) $(TD `no`) $(TD `no`) $(TD `yes`) $(TD `no`) $(TD `yes`))\n      $(TR $(TD `yes`) $(TD `yes`) $(TD) $(TD `yes`) $(TD `yes`) $(TD `no`))\n      $(TR $(TD `yes`) $(TD `unknown`) $(TD) $(TD `yes`) $(TD `unknown`) $(TD `unknown`))\n      $(TR $(TD `unknown`) $(TD `no`) $(TD `unknown`) $(TD `unknown`) $(TD `no`) $(TD `unknown`))\n      $(TR $(TD `unknown`) $(TD `yes`) $(TD) $(TD `yes`) $(TD `unknown`) $(TD `unknown`))\n      $(TR $(TD `unknown`) $(TD `unknown`) $(TD) $(TD `unknown`) $(TD `unknown`) $(TD `unknown`))\n    )\n",
						"parameters": [
							{
								"name": "s",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "s == \"~\"",
						"char": 13,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 67,
								"type": "Ternary(Ternary rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Ternary"
									}
								],
								"endline": 70,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 67,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "s",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "s == \"|\"",
						"char": 13,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 73,
								"type": "Ternary(Ternary rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Ternary"
									}
								],
								"endline": 76,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 73,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "s",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "s == \"&\"",
						"char": 13,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 79,
								"type": "Ternary(Ternary rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Ternary"
									}
								],
								"endline": 82,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 79,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "s",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "s == \"^\"",
						"char": 13,
						"kind": "template"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [],
				"name": "stateSize",
				"line": 160,
				"comment": "Returns the size in bytes of the state that needs to be allocated to hold an\nobject of type $(D T). $(D stateSize!T) is zero for $(D struct)s that are not\nnested and have no nonstatic member variables.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "chooseAtRuntime",
				"line": 197,
				"comment": "$(D chooseAtRuntime) is a compile-time constant of type $(D size_t) that several\nparameterized structures in this module recognize to mean deferral to runtime of\nthe exact value. For example, $(D BitmappedBlock!(Allocator, 4096)) (described in\ndetail below) defines a block allocator with block size of 4096 bytes, whereas\n$(D BitmappedBlock!(Allocator, chooseAtRuntime)) defines a block allocator that has a\nfield storing the block size, initialized by the user.\n",
				"deco": "m",
				"init": "18446744073709551614LU",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "unbounded",
				"line": 207,
				"comment": "$(D unbounded) is a compile-time constant of type $(D size_t) that several\nparameterized structures in this module recognize to mean \"infinite\" bounds for\nthe parameter. For example, $(D Freelist) (described in detail below) accepts a\n$(D maxNodes) parameter limiting the number of freelist items. If $(D unbounded)\nis passed for $(D maxNodes), then there is no limit and no checking for the\nnumber of nodes.\n",
				"deco": "m",
				"init": "18446744073709551615LU",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "platformAlignment",
				"line": 213,
				"comment": "The alignment that is guaranteed to accommodate any D object allocation on the\ncurrent platform.\n",
				"deco": "k",
				"init": "16u",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "goodAllocSize",
						"line": 219,
						"type": "size_t(auto ref A a, size_t n)",
						"parameters": [
							{
								"name": "a",
								"type": "A",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 222,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "goodAllocSize",
				"line": 219,
				"comment": "The default good size allocation is deduced as $(D n) rounded up to the\nallocator's alignment.\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reallocate",
						"line": 506,
						"type": "bool(ref Allocator a, ref void[] b, size_t s)",
						"parameters": [
							{
								"name": "a",
								"type": "Allocator",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "b",
								"type": "void[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "s",
								"type": "size_t"
							}
						],
						"endline": 521,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "reallocate",
				"line": 506,
				"comment": "The default $(D reallocate) function first attempts to use $(D expand). If $(D\nAllocator.expand) is not defined or returns $(D false), $(D reallocate)\nallocates a new block of memory of appropriate size and copies data from the old\nblock to the new block. Finally, if $(D Allocator) defines $(D deallocate), $(D\nreallocate) uses it to free the old memory block.\n\n$(D reallocate) does not attempt to use $(D Allocator.reallocate) even if\ndefined. This is deliberate so allocators may use it internally within their own\nimplementation of $(D reallocate).\n\n",
				"parameters": [
					{
						"name": "Allocator",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "alignedReallocate",
						"line": 537,
						"type": "bool(ref Allocator alloc, ref void[] b, size_t s, uint a)",
						"parameters": [
							{
								"name": "alloc",
								"type": "Allocator",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "b",
								"type": "void[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "s",
								"type": "size_t"
							},
							{
								"name": "a",
								"deco": "k"
							}
						],
						"endline": 556,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "alignedReallocate",
				"line": 537,
				"comment": "\nThe default $(D alignedReallocate) function first attempts to use $(D expand).\nIf $(D Allocator.expand) is not defined or returns $(D false),  $(D\nalignedReallocate) allocates a new block of memory of appropriate size and\ncopies data from the old block to the new block. Finally, if $(D Allocator)\ndefines $(D deallocate), $(D alignedReallocate) uses it to free the old memory\nblock.\n\n$(D alignedReallocate) does not attempt to use $(D Allocator.reallocate) even if\ndefined. This is deliberate so allocators may use it internally within their own\nimplementation of $(D reallocate).\n\n",
				"parameters": [
					{
						"name": "Allocator",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "forwardToMember",
				"line": 561,
				"comment": "Forwards each of the methods in `funs` (if defined) to `member`.\n",
				"deco": "FAyaAAyaXAya",
				"parameters": [
					{
						"name": "member",
						"deco": "Aya"
					},
					{
						"name": "funs",
						"deco": "AAya"
					}
				],
				"endline": 574,
				"char": 20,
				"kind": "function"
			}
		],
		"comment": "Utility and ancillary artifacts of `std.experimental.allocator`. This module\nshouldn't be used directly; its functionality will be migrated into more\nappropriate parts of `std`.\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu), Timon Gehr (`Ternary`)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/uuid.d",
		"name": "std.uuid",
		"members": [
			{
				"name": "UUID",
				"line": 127,
				"comment": "\n",
				"members": [
					{
						"members": [
							{
								"name": "ncs",
								"line": 167,
								"value": "0",
								"comment": "NCS backward compatibility\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "rfc4122",
								"line": 168,
								"value": "1",
								"comment": "Defined in RFC 4122 document\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "microsoft",
								"line": 169,
								"value": "2",
								"comment": "Microsoft Corporation backward compatibility\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "future",
								"line": 170,
								"value": "3",
								"comment": "Reserved for future use\n",
								"char": 13,
								"kind": "enum member"
							}
						],
						"name": "Variant",
						"line": 165,
						"comment": " RFC 4122 defines different internal data layouts for UUIDs. These are\n the UUID formats supported by this module. It's\n possible to read, compare and use all these Variants, but\n UUIDs generated by this module will always be in rfc4122 format.\n\n Note: Do not confuse this with $(XREF _variant, _Variant).\n",
						"baseDeco": "i",
						"char": 9,
						"kind": "enum"
					},
					{
						"members": [
							{
								"name": "unknown",
								"line": 185,
								"value": "-1",
								"comment": "Unknown version\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "timeBased",
								"line": 187,
								"value": "1",
								"comment": "Version 1\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "dceSecurity",
								"line": 189,
								"value": "2",
								"comment": "Version 2\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "nameBasedMD5",
								"line": 191,
								"value": "3",
								"comment": "Version 3 (Name based + MD5)\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "randomNumberBased",
								"line": 193,
								"value": "4",
								"comment": "Version 4 (Random)\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "nameBasedSHA1",
								"line": 195,
								"value": "5",
								"comment": "Version 5 (Name based + SHA-1)\n",
								"char": 13,
								"kind": "enum member"
							}
						],
						"name": "Version",
						"line": 182,
						"comment": " RFC 4122 defines different UUID versions. The version shows\n how a UUID was generated, e.g. a version 4 UUID was generated\n from a random number, a version 3 UUID from an MD5 hash of a name.\n\n Note:\n All of these UUID versions can be read and processed by\n $(D std.uuid), but only version 3, 4 and 5 UUIDs can be generated.\n",
						"baseDeco": "i",
						"char": 9,
						"kind": "enum"
					},
					{
						"offset": 0,
						"name": "data",
						"line": 218,
						"comment": " It is sometimes useful to get or set the 16 bytes of a UUID\n directly.\n\n Note:\n UUID uses a 16-ubyte representation for the UUID data.\n RFC 4122 defines a UUID as a special structure in big-endian\n format. These 16-ubytes always equal the big-endian structure\n defined in RFC 4122.\n\n Example:\n -----------------------------------------------\n auto rawData = uuid.data; //get data\n rawData[0] = 1; //modify\n uuid.data = rawData; //set data\n uuid.data[1] = 2; //modify directly\n -----------------------------------------------\n",
						"deco": "G16h",
						"char": 23,
						"kind": "variable"
					},
					{
						"endchar": 9,
						"name": "this",
						"line": 251,
						"comment": " Construct a UUID struct from the 16 byte representation\n of a UUID.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL262_2766)\n---\nenum ubyte[16] data = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\nauto uuid = UUID(data);\nenum ctfe = UUID(data);\nassert(uuid.data == data);\nassert(ctfe.data == data);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL262_2766)\n",
						"deco": "FNaNbNcNiNfKxG16hZS3std4uuid4UUID",
						"parameters": [
							{
								"name": "uuidData",
								"storageClass": [
									"ref"
								],
								"deco": "xG16h"
							}
						],
						"endline": 254,
						"originalType": "pure nothrow @nogc ref @safe (ref ubyte[16] uuidData)",
						"char": 34,
						"kind": "constructor"
					},
					{
						"endchar": 9,
						"name": "this",
						"line": 256,
						"comment": "ditto\n",
						"deco": "FNaNbNcNiNfxG16hZS3std4uuid4UUID",
						"parameters": [
							{
								"name": "uuidData",
								"deco": "xG16h"
							}
						],
						"endline": 259,
						"originalType": "pure nothrow @nogc ref @safe (in ubyte[16] uuidData)",
						"char": 34,
						"kind": "constructor"
					},
					{
						"members": [
							{
								"endchar": 9,
								"name": "this",
								"line": 276,
								"type": "pure @safe (T uuidData)",
								"parameters": [
									{
										"name": "uuidData",
										"type": "T"
									}
								],
								"endline": 285,
								"char": 20,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 276,
						"comment": " Construct a UUID struct from the 16 byte representation\n of a UUID. Variadic constructor to allow a simpler syntax, see examples.\n You need to pass exactly 16 ubytes.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL288_2767)\n---\nauto tmp = UUID(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);\nassert(tmp.data == cast(ubyte[16])[0,1,2,3,4,5,6,7,8,9,10,11,\n    12,13,14,15]);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL288_2767)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "tuple"
							}
						],
						"constraint": "uuidData.length == 16 && allSatisfy!(isIntegral, T)",
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 9,
								"name": "this",
								"line": 345,
								"type": "(in T[] uuid)",
								"parameters": [
									{
										"name": "uuid",
										"type": "T[]",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 399,
								"char": 9,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 345,
						"comment": " <a name=\"UUID(string)\"></a>\n Parse a UUID from its canonical string form. An UUID in its\n canonical form looks like this: 8ab3060e-2cba-4f23-b74c-b52db3bdfb46\n\n Throws:\n $(LREF UUIDParsingException) if the input is invalid\n\n CTFE:\n This function is supported in CTFE code. Note that error messages\n caused by a malformed UUID parsed at compile time can be cryptic,\n but errors are detected and reported at\n compile time.\n\n Note:\n This is a strict parser. It only accepts the pattern above.\n It doesn't support any leading or trailing characters. It only\n accepts characters used for hex numbers and the string must have\n hyphens exactly like above.\n\n For a less strict parser, see $(LREF parseUUID)\n\n Example:\n -------------------------\n id = UUID(\"8AB3060E-2cba-4f23-b74c-b52db3bdfb46\");\n assert(id.data == [138, 179, 6, 14, 44, 186, 79, 35, 183, 76,\n    181, 45, 179, 189, 251, 70]);\n assert(id.toString() == \"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n\n //Can also be used in CTFE, for example as UUID literals:\n enum ctfeID = UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n //here parsing is done at compile time, no runtime overhead!\n -------------------------\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isSomeChar!(Unqual!T)",
						"char": 9,
						"kind": "template"
					},
					{
						"endchar": 9,
						"name": "empty",
						"line": 463,
						"comment": " Returns true if and only if the UUID is equal\n to {00000000-0000-0000-0000-000000000000}\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL478_2770)\n---\nUUID id;\nassert(id.empty);\nid = UUID(\"00000000-0000-0000-0000-000000000001\");\nassert(!id.empty);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL478_2770)\n",
						"deco": "xFNaNbNdNiNeZb",
						"endline": 475,
						"char": 52,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "variant",
						"line": 525,
						"comment": " RFC 4122 defines different internal data layouts for UUIDs.\n Returns the format used by this UUID.\n\n Note: Do not confuse this with $(XREF _variant, _Variant).\n The type of this property is $(MYREF3 std.uuid.UUID.Variant, _Variant).\n\n See_Also:\n $(MYREF3 UUID.Variant, Variant)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL545_2772)\n---\nassert(UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\").variant\n   == UUID.Variant.rfc4122);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL545_2772)\n",
						"deco": "xFNaNbNdNiNfZE3std4uuid4UUID7Variant",
						"endline": 542,
						"char": 52,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "uuidVersion",
						"line": 585,
						"comment": " RFC 4122 defines different UUID versions. The version shows\n how a UUID was generated, e.g. a version 4 UUID was generated\n from a random number, a version 3 UUID from an MD5 hash of a name.\n Returns the version used by this UUID.\n\n See_Also:\n $(MYREF3 UUID.Version, Version)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL605_2774)\n---\nassert(UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\").uuidVersion\n    == UUID.Version.randomNumberBased);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL605_2774)\n",
						"deco": "xFNaNbNdNiNfZE3std4uuid4UUID7Version",
						"endline": 602,
						"char": 52,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "swap",
						"line": 640,
						"comment": " Swap the data of this UUID with the data of rhs.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL648_2776)\n---\nimmutable ubyte[16] data = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\nUUID u1;\nUUID u2 = UUID(data);\nu1.swap(u2);\n\nassert(u1 == UUID(data));\nassert(u2 == UUID.init);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL648_2776)\n",
						"deco": "FNaNbNiNfKS3std4uuid4UUIDZv",
						"parameters": [
							{
								"name": "rhs",
								"storageClass": [
									"ref"
								],
								"deco": "S3std4uuid4UUID"
							}
						],
						"endline": 645,
						"char": 39,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "opEquals",
						"line": 663,
						"comment": " All of the standard numeric operators are defined for\n the UUID struct.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL669_2777)\n---\n//compare UUIDs\nassert(UUID(\"00000000-0000-0000-0000-000000000000\") == UUID.init);\n\n//UUIDs in associative arrays:\nint[UUID] test = [UUID(\"8a94f585-d180-44f7-8929-6fca0189c7d0\") : 1,\n    UUID(\"7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a\") : 2,\n    UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\") : 3];\n\nassert(test[UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\")] == 3);\n\n//UUIDS can be sorted:\nimport std.algorithm;\nUUID[] ids = [UUID(\"8a94f585-d180-44f7-8929-6fca0189c7d0\"),\n              UUID(\"7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a\"),\n              UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\")];\nsort(ids);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL669_2777)\n",
						"deco": "xFNaNbNiNfxS3std4uuid4UUIDZb",
						"parameters": [
							{
								"name": "s",
								"deco": "xS3std4uuid4UUID"
							}
						],
						"endline": 666,
						"originalType": "const pure nothrow @nogc @safe bool(in UUID s)",
						"char": 39,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "opEquals",
						"line": 692,
						"comment": " ditto\n",
						"deco": "xFNaNbNiNfKxS3std4uuid4UUIDZb",
						"parameters": [
							{
								"name": "s",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std4uuid4UUID"
							}
						],
						"endline": 695,
						"originalType": "const pure nothrow @nogc @safe bool(ref UUID s)",
						"char": 39,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "opCmp",
						"line": 700,
						"comment": " ditto\n",
						"deco": "xFNaNbNiNfxS3std4uuid4UUIDZi",
						"parameters": [
							{
								"name": "s",
								"deco": "xS3std4uuid4UUID"
							}
						],
						"endline": 704,
						"originalType": "const pure nothrow @nogc @safe int(in UUID s)",
						"char": 38,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "opCmp",
						"line": 709,
						"comment": " ditto\n",
						"deco": "xFNaNbNiNfKxS3std4uuid4UUIDZi",
						"parameters": [
							{
								"name": "s",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std4uuid4UUID"
							}
						],
						"endline": 713,
						"originalType": "const pure nothrow @nogc @safe int(ref UUID s)",
						"char": 38,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "opAssign",
						"line": 718,
						"comment": " ditto\n",
						"deco": "FNaNbNiNfxS3std4uuid4UUIDZS3std4uuid4UUID",
						"parameters": [
							{
								"name": "s",
								"deco": "xS3std4uuid4UUID"
							}
						],
						"endline": 723,
						"originalType": "pure nothrow @nogc @safe UUID(in UUID s)",
						"char": 38,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "opAssign",
						"line": 728,
						"comment": " ditto\n",
						"deco": "FNaNbNiNfKxS3std4uuid4UUIDZS3std4uuid4UUID",
						"parameters": [
							{
								"name": "s",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std4uuid4UUID"
							}
						],
						"endline": 733,
						"originalType": "pure nothrow @nogc @safe UUID(ref UUID s)",
						"char": 39,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "toHash",
						"line": 739,
						"comment": " ditto\n",
						"deco": "xFNaNbNiNfZm",
						"endline": 806,
						"originalType": "const pure nothrow @nogc @safe size_t()",
						"char": 41,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 9,
								"name": "toString",
								"line": 862,
								"type": "const pure nothrow @nogc @safe void(Range result)",
								"parameters": [
									{
										"name": "result",
										"type": "Range"
									}
								],
								"endline": 880,
								"char": 39,
								"kind": "function"
							}
						],
						"name": "toString",
						"line": 862,
						"comment": " Write the UUID into `result` as an ASCII string in the canonical form.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Range && hasAssignableElements!Range && hasLength!Range && (isSomeChar!(typeof(Range.init[0])) || isUnsigned!(typeof(Range.init[0]))) || isSomeString!Range && isMutable!(typeof(Range.init[0]))",
						"char": 39,
						"kind": "template"
					},
					{
						"endchar": 9,
						"name": "toString",
						"line": 885,
						"comment": " Call a delegate with a string in the canonical form.\n",
						"deco": "xFMDFAxaZvZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFAxaZv"
							}
						],
						"endline": 890,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "toString",
						"line": 895,
						"comment": " Return the UUID as a string in the canonical form.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL904_2779)\n---\nimmutable str = \"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\";\nauto id = UUID(str);\nassert(id.toString() == str);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL904_2779)\n",
						"deco": "xFNaNbNeZAya",
						"endline": 901,
						"char": 38,
						"kind": "function"
					}
				],
				"char": 8,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "md5UUID",
				"line": 995,
				"comment": " This function generates a name based (Version 3) UUID from a namespace UUID and a name.\n If no namespace UUID was passed, the empty UUID $(D UUID.init) is used.\n\n Note:\n The default namespaces ($(LREF dnsNamespace), ...) defined by\n this module should be used when appropriate.\n\n RFC 4122 recommends to use Version 5 UUIDs (SHA-1) instead of Version 3\n UUIDs (MD5) for new applications.\n\n CTFE:\n CTFE is not supported.\n\n Note:\n RFC 4122 isn't very clear on how UUIDs should be generated from names.\n It is possible that different implementations return different UUIDs\n for the same input, so be warned. The implementation for UTF-8 strings\n and byte arrays used by $(D std.uuid) is compatible with Boost's implementation.\n $(D std.uuid) guarantees that the same input to this function will generate\n the same output at any time, on any system (this especially means endianness\n doesn't matter).\n\n Note:\n This function does not provide overloads for wstring and dstring, as\n there's no clear answer on how that should be implemented. It could be\n argued, that string, wstring and dstring input should have the same output,\n but that wouldn't be compatible with Boost, which generates different output\n for strings and wstrings. It's always possible to pass wstrings and dstrings\n by using the ubyte[] function overload (but be aware of endianness issues!).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1035_2783)\n---\n//Use default UUID.init namespace\nauto simpleID = md5UUID(\"test.uuid.any.string\");\n\n//use a name-based id as namespace\nauto namespace = md5UUID(\"my.app\");\nauto id = md5UUID(\"some-description\", namespace);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1035_2783)\n",
				"deco": "FNaNbNiNfxAaxS3std4uuid4UUIDZS3std4uuid4UUID",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "namespace",
						"deco": "xS3std4uuid4UUID",
						"default": "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u], )"
					}
				],
				"endline": 998,
				"originalType": "pure nothrow @nogc @safe UUID(const(char[]) name, const UUID namespace = UUID.init)",
				"char": 31,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "md5UUID",
				"line": 1003,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfxAhxS3std4uuid4UUIDZS3std4uuid4UUID",
				"parameters": [
					{
						"name": "data",
						"deco": "xAh"
					},
					{
						"name": "namespace",
						"deco": "xS3std4uuid4UUID",
						"default": "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u], )"
					}
				],
				"endline": 1032,
				"originalType": "pure nothrow @nogc @safe UUID(const(ubyte[]) data, const UUID namespace = UUID.init)",
				"char": 31,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sha1UUID",
				"line": 1108,
				"comment": " This function generates a name based (Version 5) UUID from a namespace\n UUID and a name.\n If no namespace UUID was passed, the empty UUID $(D UUID.init) is used.\n\n Note:\n The default namespaces ($(LREF dnsNamespace), ...) defined by\n this module should be used when appropriate.\n\n CTFE:\n CTFE is not supported.\n\n Note:\n RFC 4122 isn't very clear on how UUIDs should be generated from names.\n It is possible that different implementations return different UUIDs\n for the same input, so be warned. The implementation for UTF-8 strings\n and byte arrays used by $(D std.uuid) is compatible with Boost's implementation.\n $(D std.uuid) guarantees that the same input to this function will generate\n the same output at any time, on any system (this especially means endianness\n doesn't matter).\n\n Note:\n This function does not provide overloads for wstring and dstring, as\n there's no clear answer on how that should be implemented. It could be\n argued, that string, wstring and dstring input should have the same output,\n but that wouldn't be compatible with Boost, which generates different output\n for strings and wstrings. It's always possible to pass wstrings and dstrings\n by using the ubyte[] function overload (but be aware of endianness issues!).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1149_2785)\n---\n//Use default UUID.init namespace\nauto simpleID = sha1UUID(\"test.uuid.any.string\");\n\n//use a name-based id as namespace\nauto namespace = sha1UUID(\"my.app\");\nauto id = sha1UUID(\"some-description\", namespace);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1149_2785)\n",
				"deco": "FNaNbNiNfxAaxS3std4uuid4UUIDZS3std4uuid4UUID",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "namespace",
						"deco": "xS3std4uuid4UUID",
						"default": "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u], )"
					}
				],
				"endline": 1111,
				"originalType": "pure nothrow @nogc @safe UUID(in char[] name, const UUID namespace = UUID.init)",
				"char": 31,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sha1UUID",
				"line": 1116,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfxAhxS3std4uuid4UUIDZS3std4uuid4UUID",
				"parameters": [
					{
						"name": "data",
						"deco": "xAh"
					},
					{
						"name": "namespace",
						"deco": "xS3std4uuid4UUID",
						"default": "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u], )"
					}
				],
				"endline": 1146,
				"originalType": "pure nothrow @nogc @safe UUID(in ubyte[] data, const UUID namespace = UUID.init)",
				"char": 31,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "randomUUID",
				"line": 1196,
				"comment": " This function generates a random number based UUID from a random\n number generator.\n\n CTFE:\n This function is not supported at compile time.\n\n",
				"deco": "FNfZS3std4uuid4UUID",
				"endline": 1200,
				"char": 12,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomUUID",
						"line": 1210,
						"type": "UUID(ref RNG randomGen)",
						"parameters": [
							{
								"name": "randomGen",
								"type": "RNG",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1239,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "randomUUID",
				"line": 1210,
				"comment": " ditto\n\n Params:\n      randomGen = uniform RNG\n See_Also: $(XREF random, isUniformRNG)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1242_2787)\n---\nimport std.random : Xorshift192, unpredictableSeed;\n\n//simple call\nauto uuid = randomUUID();\n\n//provide a custom RNG. Must be seeded manually.\nXorshift192 gen;\n\ngen.seed(unpredictableSeed);\nauto uuid3 = randomUUID(gen);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1242_2787)\n",
				"parameters": [
					{
						"name": "RNG",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RNG && isIntegral!(ElementType!RNG)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseUUID",
						"line": 1314,
						"type": "UUID(T uuidString)",
						"parameters": [
							{
								"name": "uuidString",
								"type": "T"
							}
						],
						"endline": 1317,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "parseUUID",
				"line": 1314,
				"comment": " This is a less strict parser compared to the parser used in the\n UUID constructor. It enforces the following rules:\n\n $(UL\n   $(LI hex numbers are always two hexdigits([0-9a-fA-F]))\n   $(LI there must be exactly 16 such pairs in the input, not less, not more)\n   $(LI there can be exactly one dash between two hex-pairs, but not more)\n   $(LI there can be multiple characters enclosing the 16 hex pairs,\n     as long as these characters do not contain [0-9a-fA-F])\n )\n\n Note:\n Like most parsers, it consumes its argument. This means:\n -------------------------\n string s = \"8AB3060E-2CBA-4F23-b74c-B52Db3BDFB46\";\n parseUUID(s);\n assert(s == \"\");\n -------------------------\n\n Throws:\n $(LREF UUIDParsingException) if the input is invalid\n\n CTFE:\n This function is supported in CTFE code. Note that error messages\n caused by a malformed UUID parsed at compile time can be cryptic,\n but errors are detected and reported at compile time.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1463_2790)\n---\nauto id = parseUUID(\"8AB3060E-2CBA-4F23-b74c-B52Db3BDFB46\");\n//no dashes\nid = parseUUID(\"8ab3060e2cba4f23b74cb52db3bdfb46\");\n//dashes at different positions\nid = parseUUID(\"8a-b3-06-0e2cba4f23b74c-b52db3bdfb-46\");\n//leading / trailing characters\nid = parseUUID(\"{8ab3060e-2cba-4f23-b74c-b52db3bdfb46}\");\n//unicode\nid = parseUUID(\"ü8ab3060e2cba4f23b74cb52db3bdfb46ü\");\n//multiple trailing/leading characters\nid = parseUUID(\"///8ab3060e2cba4f23b74cb52db3bdfb46||\");\n\n//Can also be used in CTFE, for example as UUID literals:\nenum ctfeID = parseUUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n//here parsing is done at compile time, no runtime overhead!\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1463_2790)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!T",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseUUID",
						"line": 1320,
						"type": "UUID(ref Range uuidRange)",
						"parameters": [
							{
								"name": "uuidRange",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1460,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "parseUUID",
				"line": 1320,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"name": "dnsNamespace",
				"line": 1625,
				"comment": " Default namespace from RFC 4122\n\n Name string is a fully-qualified domain name\n",
				"deco": "S3std4uuid4UUID",
				"init": "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)16u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u], )",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "urlNamespace",
				"line": 1632,
				"comment": " Default namespace from RFC 4122\n\n Name string is a URL\n",
				"deco": "S3std4uuid4UUID",
				"init": "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)17u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u], )",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "oidNamespace",
				"line": 1639,
				"comment": " Default namespace from RFC 4122\n\n Name string is an ISO OID\n",
				"deco": "S3std4uuid4UUID",
				"init": "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)18u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u], )",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "x500Namespace",
				"line": 1646,
				"comment": " Default namespace from RFC 4122\n\n Name string is an X.500 DN (in DER or a text output format)\n",
				"deco": "S3std4uuid4UUID",
				"init": "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)20u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u], )",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "uuidRegex",
				"line": 1651,
				"comment": " Regex string to extract UUIDs from text.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1655_2792)\n---\nimport std.algorithm;\nimport std.regex;\n\nstring test = \"Lorem ipsum dolor sit amet, consetetur \"~\n\"6ba7b814-9dad-11d1-80b4-00c04fd430c8 sadipscing \\n\"~\n\"elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore \\r\\n\"~\n\"magna aliquyam erat, sed diam voluptua. \"~\n\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46 At vero eos et accusam et \"~\n\"justo duo dolores et ea rebum.\";\n\nauto r = regex(uuidRegex, \"g\");\nUUID[] found;\nforeach(c; match(test, r))\n{\n    found ~= UUID(c.hit);\n}\nassert(found == [\n    UUID(\"6ba7b814-9dad-11d1-80b4-00c04fd430c8\"),\n    UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\"),\n]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1655_2792)\n",
				"deco": "Aya",
				"init": "\"[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\"",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"members": [
							{
								"name": "unknown",
								"line": 1690,
								"value": "0",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "tooLittle",
								"line": 1691,
								"value": "1",
								"comment": "The passed in input was correct, but more input was expected.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "tooMuch",
								"line": 1692,
								"value": "2",
								"comment": "The input data is too long (There's no guarantee the first part of the data is valid)\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "invalidChar",
								"line": 1693,
								"value": "3",
								"comment": "Encountered an invalid character\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "Reason",
						"line": 1688,
						"comment": " The reason why parsing the UUID string failed (if known)\n",
						"baseDeco": "i",
						"char": 5,
						"kind": "enum"
					},
					{
						"offset": 72,
						"name": "reason",
						"line": 1697,
						"comment": "ditto\n",
						"deco": "E3std4uuid20UUIDParsingException6Reason",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 80,
						"name": "input",
						"line": 1699,
						"comment": "The original input string which should have been parsed.\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 96,
						"name": "position",
						"line": 1701,
						"comment": "The position in the input string where the error occurred.\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable"
					}
				],
				"name": "UUIDParsingException",
				"line": 1683,
				"comment": " This exception is thrown if an error occurs when parsing a UUID\n from a string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1719_2793)\n---\nauto ex = new UUIDParsingException(\"foo\", 10, UUIDParsingException.Reason.tooMuch);\nassert(ex.input == \"foo\");\nassert(ex.position == 10);\nassert(ex.reason == UUIDParsingException.Reason.tooMuch);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1719_2793)\n",
				"base": "object.Exception",
				"char": 8,
				"kind": "class"
			}
		],
		"comment": " A $(LINK2 http://en.wikipedia.org/wiki/Universally_unique_identifier, UUID), or\n $(LINK2 http://en.wikipedia.org/wiki/Universally_unique_identifier, Universally unique identifier),\n is intended to uniquely identify information in a distributed environment\n without significant central coordination. It can be\n used to tag objects with very short lifetimes, or to reliably identify very\n persistent objects across a network.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Parsing UUIDs)\n     $(TD $(MYREF parseUUID)\n          $(MYREF UUID)\n          $(MYREF UUIDParsingException)\n          $(MYREF uuidRegex)\n          )\n     )\n$(TR $(TDNW Generating UUIDs)\n     $(TD $(MYREF sha1UUID)\n          $(MYREF randomUUID)\n          $(MYREF md5UUID)\n          )\n     )\n$(TR $(TDNW Using UUIDs)\n     $(TD $(MYREF2 UUID.uuidVersion, uuidVersion)\n          $(MYREF2 UUID.variant, variant)\n          $(MYREF2 UUID.toString, toString)\n          $(MYREF2 UUID.data, data)\n          $(MYREF2 UUID.swap, swap)\n          $(MYREF2 UUID.opEquals, opEquals)\n          $(MYREF2 UUID.opCmp, opCmp)\n          $(MYREF2 UUID.toHash, toHash)\n          )\n     )\n$(TR $(TDNW UUID namespaces)\n     $(TD $(MYREF dnsNamespace)\n          $(MYREF urlNamespace)\n          $(MYREF oidNamespace)\n          $(MYREF x500Namespace)\n          )\n     )\n)\n)\n\n UUIDs have many applications. Some examples follow: Databases may use UUIDs to identify\n rows or records in order to ensure that they are unique across different\n databases, or for publication/subscription services. Network messages may be\n identified with a UUID to ensure that different parts of a message are put back together\n again. Distributed computing may use UUIDs to identify a remote procedure call.\n Transactions and classes involved in serialization may be identified by UUIDs.\n Microsoft's component object model (COM) uses UUIDs to distinguish different software\n component interfaces. UUIDs are inserted into documents from Microsoft Office programs.\n UUIDs identify audio or video streams in the Advanced Systems Format (ASF). UUIDs are\n also a basis for OIDs (object identifiers), and URNs (uniform resource name).\n\n An attractive feature of UUIDs when compared to alternatives is their relative small size,\n of 128 bits, or 16 bytes. Another is that the creation of UUIDs does not require\n a centralized authority.\n\n When UUIDs are generated by one of the defined mechanisms, they are either guaranteed\n to be unique, different from all other generated UUIDs (that is, it has never been\n generated before and it will never be generated again), or it is extremely likely\n to be unique (depending on the mechanism).\n\n For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly\n initialized. An UUID is empty if $(MYREF3 UUID.empty, empty) is true. Empty UUIDs are equal to\n $(D UUID.init), which is a UUID with all 16 bytes set to 0.\n Use UUID's constructors or the UUID generator functions to get an initialized UUID.\n\n This is a port of $(LINK2 http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html,\n boost._uuid) from the Boost project with some minor additions and API\n changes for a more D-like API.\n\n Example:\n ------------------------\n UUID[] ids;\n ids ~= randomUUID();\n ids ~= md5UUID(\"test.name.123\");\n ids ~= sha1UUID(\"test.name.123\");\n\n foreach(entry; ids)\n {\n     assert(entry.variant == UUID.Variant.rfc4122);\n }\n\n assert(ids[0].uuidVersion == UUID.Version.randomNumberBased);\n assert(ids[1].toString() == \"22390768-cced-325f-8f0f-cfeaa19d0ccd\");\n assert(ids[1].data == [34, 57, 7, 104, 204, 237, 50, 95, 143, 15, 207,\n     234, 161, 157, 12, 205]);\n\n UUID id;\n assert(id.empty);\n\n ------------------------\n Standards:\n $(LINK2 http://www.ietf.org/rfc/rfc4122.txt, RFC 4122)\n\n See_Also:\n $(LINK http://en.wikipedia.org/wiki/Universally_unique_identifier)\n\n Copyright: Copyright Johannes Pfau 2011 - .\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Johannes Pfau\n Source:    $(PHOBOSSRC std/_uuid.d)\n\n Macros:\n MYREF2 = <a href=\"#$2\">$(TT $1)</a>&nbsp;\n MYREF3 = <a href=\"#$2\">$(D $1)</a>\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/base64.d",
		"name": "std.base64",
		"members": [
			{
				"name": "Base64",
				"line": 81,
				"comment": " Implementation of standard _Base64 encoding.\n\n See $(D $(LREF Base64Impl)) for a description of available methods.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL84_2840)\n---\nubyte[] data = [0x83, 0xd7, 0x30, 0x7a, 0x01, 0x3f];\nassert(Base64.encode(data) == \"g9cwegE/\");\nassert(Base64.decode(\"g9cwegE/\") == data);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL84_2840)\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Base64URL",
				"line": 97,
				"comment": " Variation of Base64 encoding that is safe for use in URLs and filenames.\n\n See $(D $(LREF Base64Impl)) for a description of available methods.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL100_2841)\n---\nubyte[] data = [0x83, 0xd7, 0x30, 0x7a, 0x01, 0x3f];\nassert(Base64URL.encode(data) == \"g9cwegE_\");\nassert(Base64URL.decode(\"g9cwegE_\") == data);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL100_2841)\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "NoPadding",
						"line": 130,
						"comment": "represents no-padding encoding\n",
						"init": "'\\x00'",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					},
					{
						"endchar": 5,
						"name": "encodeLength",
						"line": 167,
						"comment": " Calculates the length needed to store the encoded string corresponding\n to an input of the given length.\n\n Params:\n  sourceLength = Length of the source array.\n\n Returns:\n  The length of a Base64 encoding of an array of the given length.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL176_2842)\n---\nubyte[] data = [0x1a, 0x2b, 0x3c, 0x4d, 0x5d, 0x6e];\n\n// Allocate a buffer large enough to hold the encoded string.\nauto buf = new char[encodeLength(data.length)];\n\nBase64.encode(data, buf);\nassert(buf == \"Gis8TV1u\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL176_2842)\n",
						"type": "pure nothrow @safe size_t(in size_t sourceLength)",
						"parameters": [
							{
								"name": "sourceLength",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 173,
						"char": 25,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 204,
								"type": "pure @trusted char[](in R1 source, R2 buffer)",
								"parameters": [
									{
										"name": "source",
										"type": "R1",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "buffer",
										"type": "R2"
									}
								],
								"endline": 260,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 204,
						"comment": " Encode $(D_PARAM source) into a $(D char[]) buffer using Base64\n encoding.\n\n Params:\n  source = The $(LINK2 std_range_primitives.html#isInputRange, input\n           range) to _encode.\n  buffer = The $(D char[]) buffer to store the encoded result.\n\n Returns:\n  The slice of $(D_PARAM buffer) that contains the encoded string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL263_2843)\n---\nubyte[] data = [0x83, 0xd7, 0x30, 0x7a, 0x01, 0x3f];\nchar[32] buffer;    // much bigger than necessary\n\n// Just to be sure...\nauto encodedLength = Base64.encodeLength(data.length);\nassert(buffer.length >= encodedLength);\n\n// encode() returns a slice to the provided buffer.\nauto encoded = Base64.encode(data, buffer[]);\nassert(encoded is buffer[0 .. encodedLength]);\nassert(encoded == \"g9cwegE/\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL263_2843)\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "isArray!R1 && is(ElementType!R1 : ubyte) && is(R2 == char[])",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 285,
								"type": "char[](R1 source, R2 buffer)",
								"parameters": [
									{
										"name": "source",
										"type": "R1"
									},
									{
										"name": "buffer",
										"type": "R2"
									}
								],
								"endline": 353,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 285,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "!isArray!R1 && isInputRange!R1 && is(ElementType!R1 : ubyte) && hasLength!R1 && is(R2 == char[])",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 373,
								"type": "size_t(in R1 source, auto ref R2 range)",
								"parameters": [
									{
										"name": "source",
										"type": "R1",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "range",
										"type": "R2",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 433,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 373,
						"comment": " Encodes $(D_PARAM source) into an\n $(LINK2 std_range_primitives.html#isOutputRange, output range) using\n Base64 encoding.\n\n Params:\n  source = The $(LINK2 std_range_primitives.html#isInputRange, input\n           range) to _encode.\n  range  = The $(LINK2 std_range_primitives.html#isOutputRange, output\n           range) to store the encoded result.\n\n Returns:\n  The number of times the output range's $(D put) method was invoked.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL436_2844)\n---\nstruct OutputRange\n{\n    char[] result;\n    void put(const(char) ch) { result ~= ch; }\n}\n\nubyte[] data = [0x1a, 0x2b, 0x3c, 0x4d, 0x5d, 0x6e];\n\n// This overload of encode() returns the number of calls to the output\n// range's put method.\nOutputRange output;\nassert(Base64.encode(data, output) == 8);\nassert(output.result == \"Gis8TV1u\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL436_2844)\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "isArray!R1 && is(ElementType!R1 : ubyte) && !is(R2 == char[]) && isOutputRange!(R2, char)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 460,
								"type": "size_t(R1 source, auto ref R2 range)",
								"parameters": [
									{
										"name": "source",
										"type": "R1"
									},
									{
										"name": "range",
										"type": "R2",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 531,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 460,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "!isArray!R1 && isInputRange!R1 && is(ElementType!R1 : ubyte) && hasLength!R1 && !is(R2 == char[]) && isOutputRange!(R2, char)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 548,
								"type": "pure @safe char[](Range source)",
								"parameters": [
									{
										"name": "source",
										"type": "Range"
									}
								],
								"endline": 551,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 548,
						"comment": " Encodes $(D_PARAM source) to newly-allocated buffer.\n\n This convenience method alleviates the need to manually manage output\n buffers.\n\n Params:\n  source = The $(LINK2 std_range_primitives.html#isInputRange, input\n           range) to _encode.\n\n Returns:\n  A newly-allocated $(D char[]) buffer containing the encoded string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL554_2845)\n---\nubyte[] data = [0x1a, 0x2b, 0x3c, 0x4d, 0x5d, 0x6e];\nassert(Base64.encode(data) == \"Gis8TV1u\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL554_2845)\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isArray!Range && is(ElementType!Range : ubyte)",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 564,
								"type": "char[](Range source)",
								"parameters": [
									{
										"name": "source",
										"type": "Range"
									}
								],
								"endline": 568,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 564,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "!isArray!Range && isInputRange!Range && is(ElementType!Range : ubyte) && hasLength!Range",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"name": "Encoder",
								"line": 582,
								"members": [
									{
										"endchar": 9,
										"name": "empty",
										"line": 603,
										"comment": " Returns:\n  true if there is no more encoded data left.\n",
										"type": "@property @trusted bool()",
										"endline": 606,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 613,
										"comment": " Returns: The current chunk of encoded data.\n",
										"type": "nothrow @property @safe char[]()",
										"endline": 616,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 626,
										"comment": " Advance the range to the next chunk of encoded data.\n\n Throws:\n  $(D Base64Exception) If invoked when\n  $(LREF2 .Base64Impl.Encoder.empty, empty) returns $(D true).\n",
										"type": "void()",
										"endline": 640,
										"char": 14,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							}
						],
						"name": "Encoder",
						"line": 582,
						"comment": " An $(LINK2 std_range_primitives.html#isInputRange, input range) that\n iterates over the respective Base64 encodings of a range of data items.\n\n This range will be a $(LINK2 std_range_primitives.html#isForwardRange,\n forward range) if the underlying data source is at least a forward\n range.\n\n Note: This struct is not intended to be created in user code directly;\n use the $(LREF encoder) function instead.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && (is(ElementType!Range : const(ubyte)[]) || is(ElementType!Range : const(char)[]))",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"name": "Encoder",
								"line": 692,
								"members": [
									{
										"endchar": 9,
										"name": "empty",
										"line": 719,
										"comment": " Returns:\n  true if there are no more encoded characters to be iterated.\n",
										"type": "const nothrow @property @safe bool()",
										"endline": 725,
										"char": 22,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 732,
										"comment": " Returns: The current encoded character.\n",
										"type": "nothrow @property @safe ubyte()",
										"endline": 735,
										"char": 23,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 745,
										"comment": " Advance to the next encoded character.\n\n Throws:\n  $(D Base64Exception) If invoked when $(LREF2 .Base64Impl.Encoder.empty.2,\n  empty) returns $(D true).\n",
										"type": "void()",
										"endline": 804,
										"char": 14,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							}
						],
						"name": "Encoder",
						"line": 692,
						"comment": " An $(LINK2 std_range_primitives.html#isInputRange, input range) that\n iterates over the encoded bytes of the given source data.\n\n It will be a $(LINK2 std_range_primitives.html#isForwardRange, forward\n range) if the underlying data source is at least a forward range.\n\n Note: This struct is not intended to be created in user code directly;\n use the $(LREF encoder) function instead.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && is(ElementType!Range : ubyte)",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encoder",
								"line": 875,
								"type": "Encoder!Range(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 878,
								"char": 21,
								"kind": "function"
							}
						],
						"name": "encoder",
						"line": 875,
						"comment": " Construct an $(D Encoder) that iterates over the Base64 encoding of the\n given $(LINK2 std_range_primitives.html#isInputRange, input range).\n\n Params:\n  range = An $(LINK2 std_range_primitives.html#isInputRange, input\n      range) over the data to be encoded.\n\n Returns:\n  If $(D_PARAM range) is a range of bytes, an $(D Encoder) that iterates\n  over the bytes of the corresponding Base64 encoding.\n\n  If $(D_PARAM range) is a range of ranges of bytes, an $(D Encoder) that\n  iterates over the Base64 encoded strings of each element of the range.\n\n  In both cases, the returned $(D Encoder) will be a\n  $(LINK2 std_range_primitives.html#isForwardRange, forward range) if the\n  given $(D range) is at least a forward range, otherwise it will be only\n  an input range.\n\n Example:\n This example encodes the input one line at a time.\n -----\n File f = File(\"text.txt\", \"r\");\n scope(exit) f.close();\n\n uint line = 0;\n foreach (encoded; Base64.encoder(f.byLine()))\n {\n     writeln(++line, \". \", encoded);\n }\n -----\n\n Example:\n This example encodes the input data one byte at a time.\n -----\n ubyte[] data = cast(ubyte[]) \"0123456789\";\n\n // The ElementType of data is not aggregation type\n foreach (encoded; Base64.encoder(data))\n {\n     writeln(encoded);\n }\n -----\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range",
						"char": 21,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "decodeLength",
						"line": 913,
						"comment": " Given a Base64 encoded string, calculates the length of the decoded\n string.\n\n Params:\n  sourceLength = The length of the Base64 encoding.\n\n Returns:\n  The length of the decoded string corresponding to a Base64 encoding of\n  length $(D_PARAM sourceLength).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL922_2846)\n---\nauto encoded = \"Gis8TV1u\";\n\n// Allocate a sufficiently large buffer to hold to decoded result.\nauto buffer = new ubyte[Base64.decodeLength(encoded.length)];\n\nBase64.decode(encoded, buffer);\nassert(buffer == [0x1a, 0x2b, 0x3c, 0x4d, 0x5d, 0x6e]);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL922_2846)\n",
						"type": "pure nothrow @safe size_t(in size_t sourceLength)",
						"parameters": [
							{
								"name": "sourceLength",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 919,
						"char": 25,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 972,
								"type": "pure @trusted ubyte[](in R1 source, R2 buffer)",
								"parameters": [
									{
										"name": "source",
										"type": "R1",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "buffer",
										"type": "R2"
									}
								],
								"endline": 1032,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 972,
						"comment": " Decodes $(D_PARAM source) into the given buffer.\n\n Params:\n  source = The $(LINK2 std_range_primitives.html#isInputRange, input\n      range) to _decode.\n  buffer = The buffer to store decoded result.\n\n Returns:\n  The slice of $(D_PARAM buffer) containing the decoded result.\n\n Throws:\n  $(D Base64Exception) if $(D_PARAM source) contains characters outside the\n  base alphabet of the current Base64 encoding scheme.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1035_2847)\n---\nauto encoded = \"Gis8TV1u\";\nubyte[32] buffer;   // much bigger than necessary\n\n// Just to be sure...\nauto decodedLength = Base64.decodeLength(encoded.length);\nassert(buffer.length >= decodedLength);\n\n// decode() returns a slice of the given buffer.\nauto decoded = Base64.decode(encoded, buffer[]);\nassert(decoded is buffer[0 .. decodedLength]);\nassert(decoded == [0x1a, 0x2b, 0x3c, 0x4d, 0x5d, 0x6e]);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1035_2847)\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "isArray!R1 && is(ElementType!R1 : dchar) && is(R2 == ubyte[]) && isOutputRange!(R2, ubyte)",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 1056,
								"type": "ubyte[](R1 source, R2 buffer)",
								"parameters": [
									{
										"name": "source",
										"type": "R1"
									},
									{
										"name": "buffer",
										"type": "R2"
									}
								],
								"endline": 1125,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 1056,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "!isArray!R1 && isInputRange!R1 && is(ElementType!R1 : dchar) && hasLength!R1 && is(R2 == ubyte[]) && isOutputRange!(R2, ubyte)",
						"char": 13,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 1148,
								"type": "size_t(in R1 source, auto ref R2 range)",
								"parameters": [
									{
										"name": "source",
										"type": "R1",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "range",
										"type": "R2",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 1212,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 1148,
						"comment": " Decodes $(D_PARAM source) into a given\n $(LINK2 std_range_primitives.html#isOutputRange, output range).\n\n Params:\n  source = The $(LINK2 std_range_primitives.html#isInputRange, input\n           range) to _decode.\n  range  = The $(LINK2 std_range_primitives.html#isOutputRange, output\n           range) to store the decoded result.\n\n Returns:\n  The number of times the output range's $(D put) method was invoked.\n\n Throws:\n  $(D Base64Exception) if $(D_PARAM source) contains characters outside the\n  base alphabet of the current Base64 encoding scheme.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1215_2848)\n---\nstruct OutputRange\n{\n    ubyte[] result;\n    void put(ubyte b) { result ~= b; }\n}\nOutputRange output;\n\n// This overload of decode() returns the number of calls to put().\nassert(Base64.decode(\"Gis8TV1u\", output) == 6);\nassert(output.result == [0x1a, 0x2b, 0x3c, 0x4d, 0x5d, 0x6e]);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1215_2848)\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "isArray!R1 && is(ElementType!R1 : dchar) && !is(R2 == ubyte[]) && isOutputRange!(R2, ubyte)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 1236,
								"type": "size_t(R1 source, auto ref R2 range)",
								"parameters": [
									{
										"name": "source",
										"type": "R1"
									},
									{
										"name": "range",
										"type": "R2",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 1306,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 1236,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "!isArray!R1 && isInputRange!R1 && is(ElementType!R1 : dchar) && hasLength!R1 && !is(R2 == ubyte[]) && isOutputRange!(R2, ubyte)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 1323,
								"type": "pure @safe ubyte[](Range source)",
								"parameters": [
									{
										"name": "source",
										"type": "Range"
									}
								],
								"endline": 1326,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 1323,
						"comment": " Decodes $(D_PARAM source) into newly-allocated buffer.\n\n This convenience method alleviates the need to manually manage decoding\n buffers.\n\n Params:\n  source = The $(LINK2 std_range_primitives.html#isInputRange, input\n           range) to _decode.\n\n Returns:\n  A newly-allocated $(D ubyte[]) buffer containing the decoded string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1329_2849)\n---\nauto data = \"Gis8TV1u\";\nassert(Base64.decode(data) == [0x1a, 0x2b, 0x3c, 0x4d, 0x5d, 0x6e]);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1329_2849)\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isArray!Range && is(ElementType!Range : dchar)",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 1339,
								"type": "ubyte[](Range source)",
								"parameters": [
									{
										"name": "source",
										"type": "Range"
									}
								],
								"endline": 1343,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 1339,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "!isArray!Range && isInputRange!Range && is(ElementType!Range : dchar) && hasLength!Range",
						"char": 13,
						"kind": "template"
					},
					{
						"members": [
							{
								"name": "Decoder",
								"line": 1357,
								"members": [
									{
										"endchar": 9,
										"name": "empty",
										"line": 1378,
										"comment": " Returns:\n  true if there are no more elements to be iterated.\n",
										"type": "@property @trusted bool()",
										"endline": 1381,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 1388,
										"comment": " Returns: The decoding of the current element in the input.\n",
										"type": "nothrow @property @safe ubyte[]()",
										"endline": 1391,
										"char": 25,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 1401,
										"comment": " Advance to the next element in the input to be decoded.\n\n Throws:\n  $(D Base64Exception) if invoked when $(LREF2 .Base64Impl.Decoder.empty,\n  empty) returns $(D true).\n",
										"type": "void()",
										"endline": 1412,
										"char": 14,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							}
						],
						"name": "Decoder",
						"line": 1357,
						"comment": " An $(LINK2 std_range_primitives.html#isInputRange, input range) that\n iterates over the decoded data of a range of Base64 encodings.\n\n This range will be a $(LINK2 std_range_primitives.html#isForwardRange,\n forward range) if the underlying data source is at least a forward\n range.\n\n Note: This struct is not intended to be created in user code directly;\n use the $(LREF decoder) function instead.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && (is(ElementType!Range : const(char)[]) || is(ElementType!Range : const(ubyte)[]))",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"name": "Decoder",
								"line": 1482,
								"members": [
									{
										"endchar": 9,
										"name": "empty",
										"line": 1512,
										"comment": " Returns:\n  true if there are no more elements to be iterated.\n",
										"type": "const nothrow @property @safe bool()",
										"endline": 1515,
										"char": 22,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 1522,
										"comment": " Returns: The current decoded byte.\n",
										"type": "nothrow @property @safe ubyte()",
										"endline": 1525,
										"char": 23,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 1535,
										"comment": " Advance to the next decoded byte.\n\n Throws:\n  $(D Base64Exception) if invoked when $(LREF2 .Base64Impl.Decoder.empty,\n  empty) returns $(D true).\n",
										"type": "void()",
										"endline": 1605,
										"char": 14,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							}
						],
						"name": "Decoder",
						"line": 1482,
						"comment": " An $(LINK2 std_range_primitives.html#isInputRange, input range) that\n iterates over the bytes of data decoded from a Base64 encoded string.\n\n This range will be a $(LINK2 std_range_primitives.html#isForwardRange,\n forward range) if the underlying data source is at least a forward\n range.\n\n Note: This struct is not intended to be created in user code directly;\n use the $(LREF decoder) function instead.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && is(ElementType!Range : char)",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decoder",
								"line": 1676,
								"type": "Decoder!Range(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 1679,
								"char": 21,
								"kind": "function"
							}
						],
						"name": "decoder",
						"line": 1676,
						"comment": " Construct a $(D Decoder) that iterates over the decoding of the given\n Base64 encoded data.\n\n Params:\n  range = An $(LINK2 std_range_primitives.html#isInputRange, input\n      range) over the data to be decoded.\n\n Returns:\n  If $(D_PARAM range) is a range of characters, a $(D Decoder) that\n  iterates over the bytes of the corresponding Base64 decoding.\n\n  If $(D_PARAM range) is a range of ranges of characters, a $(D Decoder)\n  that iterates over the decoded strings corresponding to each element of\n  the range. In this case, the length of each subrange must be a multiple\n  of 4; the returned _decoder does not keep track of Base64 decoding\n  state across subrange boundaries.\n\n  In both cases, the returned $(D Decoder) will be a\n  $(LINK2 std_range_primitives.html#isForwardRange, forward range) if the\n  given $(D range) is at least a forward range, otherwise it will be only\n  an input range.\n\n If the input data contains characters not found in the base alphabet of\n the current Base64 encoding scheme, the returned range may throw a\n $(D Base64Exception).\n\n Example:\n This example shows decoding over a range of input data lines.\n -----\n foreach (decoded; Base64.decoder(stdin.byLine()))\n {\n     writeln(decoded);\n }\n -----\n\n Example:\n This example shows decoding one byte at a time.\n -----\n auto encoded = Base64.encoder(cast(ubyte[])\"0123456789\");\n foreach (n; map!q{a - '0'}(Base64.decoder(encoded)))\n {\n     writeln(n);\n }\n -----\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range",
						"char": 21,
						"kind": "template"
					}
				],
				"name": "Base64Impl",
				"line": 128,
				"comment": " Template for implementing Base64 encoding and decoding.\n\n For most purposes, direct usage of this template is not necessary; instead,\n this module provides two default implementations: $(D $(LREF Base64)) and\n $(D $(LREF Base64URL)), that implement basic Base64 encoding and a variant\n intended for use in URLs and filenames, respectively.\n\n Customized Base64 encoding schemes can be implemented by instantiating this\n template with the appropriate arguments. For example:\n\n -----\n // Non-standard Base64 format for embedding in regular expressions.\n alias Base64Re = Base64Impl!('!', '=', Base64.NoPadding);\n -----\n\n NOTE:\n Encoded strings will not have any padding if the $(D Padding) parameter is\n set to $(D NoPadding).\n",
				"parameters": [
					{
						"name": "Map62th",
						"deco": "a",
						"kind": "value"
					},
					{
						"name": "Map63th",
						"deco": "a",
						"kind": "value"
					},
					{
						"name": "Padding",
						"defaultValue": "'='",
						"deco": "a",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Base64Exception",
				"line": 1711,
				"comment": " Exception thrown upon encountering Base64 encoding or decoding errors.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " Support for Base64 encoding and decoding.\n\n This module provides two default implementations of Base64 encoding,\n $(D $(LREF Base64)) with a standard encoding alphabet, and a variant\n $(D $(LREF Base64URL)) that has a modified encoding alphabet designed to be\n safe for embedding in URLs and filenames.\n\n Both variants are implemented as instantiations of the template\n $(D $(LREF Base64Impl)). Most users will not need to use this template\n directly; however, it can be used to create customized Base64 encodings,\n such as one that omits padding characters, or one that is safe to embed\n inside a regular expression.\n\n Example:\n -----\n ubyte[] data = [0x14, 0xfb, 0x9c, 0x03, 0xd9, 0x7e];\n\n const(char)[] encoded = Base64.encode(data);\n assert(encoded == \"FPucA9l+\");\n\n ubyte[] decoded = Base64.decode(\"FPucA9l+\");\n assert(decoded == [0x14, 0xfb, 0x9c, 0x03, 0xd9, 0x7e]);\n -----\n\n The range API is supported for both encoding and decoding:\n\n Example:\n -----\n // Create MIME Base64 with CRLF, per line 76.\n File f = File(\"./text.txt\", \"r\");\n scope(exit) f.close();\n\n Appender!string mime64 = appender!string;\n\n foreach (encoded; Base64.encoder(f.byChunk(57)))\n {\n     mime64.put(encoded);\n     mime64.put(\"\\r\\n\");\n }\n\n writeln(mime64.data);\n -----\n\n References:\n $(WEB tools.ietf.org/html/rfc4648, RFC 4648 - The Base16, Base32, and Base64\n Data Encodings)\n\n Copyright: Masahiro Nakagawa 2010-.\n License:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Masahiro Nakagawa, Daniel Murphy (Single value Encoder and Decoder)\n Source:    $(PHOBOSSRC std/_base64.d)\n Macros:\n      LREF2=<a href=\"#$1\">$(D $2)</a>\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/dlist.d",
		"name": "std.container.dlist",
		"members": [
			{
				"members": [
					{
						"name": "DList",
						"line": 140,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 193,
										"type": "(U[] values...)",
										"parameters": [
											{
												"name": "values",
												"type": "U[]"
											}
										],
										"endline": 196,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 193,
								"comment": "Constructor taking a number of nodes\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(U, T)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 201,
										"type": "(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 205,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 201,
								"comment": "Constructor taking an input range\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opEquals",
										"line": 213,
										"type": "const bool(ref const DList rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "DList",
												"storageClass": [
													"const",
													"ref"
												]
											}
										],
										"endline": 237,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opEquals",
								"line": 213,
								"comment": "Comparison for equality.\n\nComplexity: $(BIGOH min(n, n1)) where $(D n1) is the number of\nelements in $(D rhs).\n",
								"parameters": [],
								"constraint": "is(typeof(front == front))",
								"char": 10,
								"kind": "template"
							},
							{
								"name": "Range",
								"line": 242,
								"comment": "    Defines the container's primary range, which embodies a bidirectional range.\n",
								"members": [],
								"char": 5,
								"kind": "struct"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 279,
								"comment": "Property returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n",
								"type": "const nothrow @property bool()",
								"endline": 282,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 291,
								"comment": "Removes all contents from the $(D DList).\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH 1)\n",
								"type": "void()",
								"endline": 295,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 303,
								"comment": "Duplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n",
								"type": "@property DList()",
								"endline": 306,
								"char": 21,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 314,
								"comment": "Returns a range that iterates over all elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n",
								"type": "Range()",
								"endline": 320,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 327,
								"comment": "Forward to $(D opSlice().front).\n\nComplexity: $(BIGOH 1)\n",
								"type": "inout @property ref inout(T)()",
								"endline": 331,
								"char": 28,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 338,
								"comment": "Forward to $(D opSlice().back).\n\nComplexity: $(BIGOH 1)\n",
								"type": "inout @property ref inout(T)()",
								"endline": 342,
								"char": 28,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 352,
										"type": "DList(Stuff rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Stuff"
											}
										],
										"endline": 358,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 352,
								"comment": "Returns a new $(D DList) that's the concatenation of $(D this) and its\nargument $(D rhs).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\" && is(typeof(insertBack(rhs)))",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinaryRight",
										"line": 364,
										"type": "DList(Stuff lhs)",
										"parameters": [
											{
												"name": "lhs",
												"type": "Stuff"
											}
										],
										"endline": 370,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opBinaryRight",
								"line": 364,
								"comment": "Returns a new $(D DList) that's the concatenation of the argument $(D lhs)\nand $(D this).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\" && is(typeof(insertFront(lhs)))",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 375,
										"type": "DList(Stuff rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Stuff"
											}
										],
										"endline": 380,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 375,
								"comment": "Appends the contents of the argument $(D rhs) into $(D this).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\" && is(typeof(insertBack(rhs)))",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertFront",
										"line": 404,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 408,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertFront",
								"line": 404,
								"comment": "Inserts $(D stuff) to the front/back of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n))\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBack",
										"line": 411,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 415,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBack",
								"line": 411,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "insert",
								"line": 418,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsert",
								"line": 421,
								"comment": "ditto\n",
								"type": "insert",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsertFront",
								"line": 424,
								"comment": "ditto\n",
								"type": "insertFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsertBack",
								"line": 427,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBefore",
										"line": 443,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 452,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBefore",
								"line": 443,
								"comment": "Inserts $(D stuff) after range $(D r), which must be a non-empty range\npreviously extracted from this container.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertBefore",
								"line": 455,
								"comment": "ditto\n",
								"type": "insertBefore",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertAfter",
										"line": 458,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 467,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertAfter",
								"line": 458,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertAfter",
								"line": 470,
								"comment": "ditto\n",
								"type": "insertAfter",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 487,
								"comment": "Picks one value in an unspecified position in the container, removes\nit from the container, and returns it. The stable version behaves the same,\nbut guarantees that ranges iterating over the container are never invalidated.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH 1).\n",
								"type": "T()",
								"endline": 495,
								"char": 7,
								"kind": "function"
							},
							{
								"name": "stableRemoveAny",
								"line": 497,
								"comment": "ditto\n",
								"type": "removeAny",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 508,
								"comment": "Removes the value at the front/back of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1).\n",
								"type": "void()",
								"endline": 513,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "stableRemoveFront",
								"line": 516,
								"comment": "ditto\n",
								"type": "removeFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 519,
								"comment": "ditto\n",
								"type": "void()",
								"endline": 524,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "stableRemoveBack",
								"line": 527,
								"comment": "ditto\n",
								"type": "removeBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 542,
								"comment": "Removes $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany).\n",
								"type": "size_t(size_t howMany)",
								"parameters": [
									{
										"name": "howMany",
										"type": "size_t"
									}
								],
								"endline": 554,
								"char": 12,
								"kind": "function"
							},
							{
								"name": "stableRemoveFront",
								"line": 557,
								"comment": "ditto\n",
								"type": "removeFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 560,
								"comment": "ditto\n",
								"type": "size_t(size_t howMany)",
								"parameters": [
									{
										"name": "howMany",
										"type": "size_t"
									}
								],
								"endline": 572,
								"char": 12,
								"kind": "function"
							},
							{
								"name": "stableRemoveBack",
								"line": 575,
								"comment": "ditto\n",
								"type": "removeBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "remove",
								"line": 586,
								"comment": "Removes all elements belonging to $(D r), which must be a range\nobtained originally from this container.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH 1)\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 600,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 603,
								"comment": "ditto\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 606,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 615,
								"comment": "$(D linearRemove) functions as $(D remove), but also accepts ranges that are\nresult the of a $(D take) operation. This is a convenient way to remove a\nfixed amount of elements from the range.\n\nComplexity: $(BIGOH r.walkLength)\n",
								"type": "Range(Take!Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Take!Range"
									}
								],
								"endline": 629,
								"char": 11,
								"kind": "function"
							},
							{
								"name": "stableRemove",
								"line": 632,
								"comment": "ditto\n",
								"type": "remove",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableLinearRemove",
								"line": 634,
								"comment": "ditto\n",
								"type": "linearRemove",
								"char": 5,
								"kind": "alias"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "DList",
				"line": 140,
				"comment": "Implements a doubly-linked list.\n\n$(D DList) uses reference semantics.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module implements a generic doubly-linked list container.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_dlist.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/slist.d",
		"name": "std.container.slist",
		"members": [
			{
				"members": [
					{
						"name": "SList",
						"line": 29,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 102,
										"type": "(U[] values...)",
										"parameters": [
											{
												"name": "values",
												"type": "U[]"
											}
										],
										"endline": 105,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 102,
								"comment": "Constructor taking a number of nodes\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(U, T)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 110,
										"type": "(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 116,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 110,
								"comment": "Constructor taking an input range\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T) && !is(Stuff == T[])",
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 124,
								"comment": "Comparison for equality.\n\nComplexity: $(BIGOH min(n, n1)) where $(D n1) is the number of\nelements in $(D rhs).\n",
								"type": "const bool(const SList rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "SList",
										"storageClass": [
											"const"
										]
									}
								],
								"endline": 127,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 130,
								"comment": "ditto\n",
								"type": "const bool(ref const SList rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "SList",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 143,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "Range",
								"line": 148,
								"comment": "Defines the container's primary range, which embodies a forward range.\n",
								"members": [
									{
										"endchar": 55,
										"name": "empty",
										"line": 154,
										"comment": "Input range primitives.\n",
										"type": "const @property bool()",
										"endline": 154,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 157,
										"comment": "ditto\n",
										"type": "@property ref T()",
										"endline": 161,
										"char": 25,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 164,
										"comment": "ditto\n",
										"type": "void()",
										"endline": 168,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 47,
										"name": "save",
										"line": 171,
										"comment": "Forward range primitive.\n",
										"type": "@property Range()",
										"endline": 171,
										"char": 25,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 198,
								"comment": "Property returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n",
								"type": "const @property bool()",
								"endline": 201,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 209,
								"comment": "Duplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n",
								"type": "@property SList()",
								"endline": 212,
								"char": 21,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 220,
								"comment": "Returns a range that iterates over all elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n",
								"type": "Range()",
								"endline": 226,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 233,
								"comment": "Forward to $(D opSlice().front).\n\nComplexity: $(BIGOH 1)\n",
								"type": "@property ref T()",
								"endline": 237,
								"char": 21,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 251,
										"type": "SList(Stuff rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Stuff"
											}
										],
										"endline": 261,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 251,
								"comment": "Returns a new $(D SList) that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\" && is(typeof(SList(rhs)))",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinaryRight",
										"line": 264,
										"type": "SList(Stuff lhs)",
										"parameters": [
											{
												"name": "lhs",
												"type": "Stuff"
											}
										],
										"endline": 272,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opBinaryRight",
								"line": 264,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\" && !is(typeof(lhs.opBinary!\"~\"(this))) && is(typeof(SList(lhs)))",
								"char": 11,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 281,
								"comment": "Removes all contents from the $(D SList).\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH 1)\n",
								"type": "void()",
								"endline": 284,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertFront",
										"line": 296,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 314,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertFront",
								"line": 296,
								"comment": "Inserts $(D stuff) to the front of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH m), where $(D m) is the length of $(D stuff)\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertFront",
										"line": 317,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 324,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertFront",
								"line": 317,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"name": "insert",
								"line": 327,
								"comment": "ditto\n",
								"type": "insertFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsert",
								"line": 330,
								"comment": "ditto\n",
								"type": "insert",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsertFront",
								"line": 333,
								"comment": "ditto\n",
								"type": "insertFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 346,
								"comment": "Picks one value in an unspecified position in the container, removes\nit from the container, and returns it. The stable version behaves the same,\nbut guarantees that ranges iterating over the container are never invalidated.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH 1).\n",
								"type": "T()",
								"endline": 354,
								"char": 7,
								"kind": "function"
							},
							{
								"name": "stableRemoveAny",
								"line": 356,
								"comment": "ditto\n",
								"type": "removeAny",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 367,
								"comment": "Removes the value at the front of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1).\n",
								"type": "void()",
								"endline": 371,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "stableRemoveFront",
								"line": 374,
								"comment": "ditto\n",
								"type": "removeFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 389,
								"comment": "Removes $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany * log(n)).\n",
								"type": "size_t(size_t howMany)",
								"parameters": [
									{
										"name": "howMany",
										"type": "size_t"
									}
								],
								"endline": 398,
								"char": 12,
								"kind": "function"
							},
							{
								"name": "stableRemoveFront",
								"line": 401,
								"comment": "ditto\n",
								"type": "removeFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertAfter",
										"line": 431,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 445,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertAfter",
								"line": 431,
								"comment": "Inserts $(D stuff) after range $(D r), which must be a range\npreviously extracted from this container. Given that all ranges for a\nlist end at the end of the list, this function essentially appends to\nthe list and uses $(D r) as a potentially fast way to reach the last\nnode in the list. Ideally $(D r) is positioned near or at the last\nelement of the list.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n\nExample:\n--------------------\nauto sl = SList!string([\"a\", \"b\", \"d\"]);\nsl.insertAfter(sl[], \"e\"); // insert at the end (slowest)\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"d\", \"e\"]));\nsl.insertAfter(std.range.take(sl[], 2), \"c\"); // insert after \"b\"\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"c\", \"d\", \"e\"]));\n--------------------\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertAfter",
										"line": 461,
										"type": "size_t(Take!Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Take!Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 484,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertAfter",
								"line": 461,
								"comment": "Similar to $(D insertAfter) above, but accepts a range bounded in\ncount. This is important for ensuring fast insertions in the middle of\nthe list.  For fast insertions after a specified position $(D r), use\n$(D insertAfter(take(r, 1), stuff)). The complexity of that operation\nonly depends on the number of elements in $(D stuff).\n\nPrecondition: $(D r.original.empty || r.maxLength > 0)\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertAfter",
								"line": 487,
								"comment": "ditto\n",
								"type": "insertAfter",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 496,
								"comment": "Removes a range from the list in linear time.\n\nReturns: An empty range.\n\nComplexity: $(BIGOH n)\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 506,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 515,
								"comment": "Removes a $(D Take!Range) from the list in linear time.\n\nReturns: A range comprehending the elements after the removed range.\n\nComplexity: $(BIGOH n)\n",
								"type": "Range(Take!Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Take!Range"
									}
								],
								"endline": 539,
								"char": 11,
								"kind": "function"
							},
							{
								"name": "stableLinearRemove",
								"line": 542,
								"comment": "ditto\n",
								"type": "linearRemove",
								"char": 5,
								"kind": "alias"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SList",
				"line": 29,
				"comment": "   Implements a simple and fast singly-linked list.\n\n   $(D SList) uses reference semantics.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module implements a singly-linked list container.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_slist.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/util.d",
		"name": "std.container.util",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "make",
								"line": 30,
								"type": "T(Args arguments)",
								"parameters": [
									{
										"name": "arguments",
										"type": "Args"
									}
								],
								"endline": 46,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "make",
						"line": 30,
						"parameters": [
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"constraint": "is(T == struct) && __traits(compiles, T(arguments))",
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "make",
								"line": 48,
								"type": "T(Args arguments)",
								"parameters": [
									{
										"name": "arguments",
										"type": "Args"
									}
								],
								"endline": 52,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "make",
						"line": 48,
						"parameters": [
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"constraint": "is(T == class) && __traits(compiles, new T(arguments))",
						"char": 7,
						"kind": "template"
					}
				],
				"name": "make",
				"line": 27,
				"comment": "Returns an initialized object. This function is mainly for eliminating\nconstruction differences between structs and classes. It allows code to not\nworry about whether the type it's constructing is a struct or a class.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL57_2897)\n---\nimport std.container;\nimport std.algorithm : equal;\nimport std.algorithm : equal;\n\nauto arr = make!(Array!int)([4, 2, 3, 1]);\nassert(equal(arr[], [4, 2, 3, 1]));\n\nauto rbt = make!(RedBlackTree!(int, \"a > b\"))([4, 2, 3, 1]);\nassert(equal(rbt[], [4, 3, 2, 1]));\n\nalias makeList = make!(SList!int);\nauto slist = makeList(1, 2, 3);\nassert(equal(slist[], [1, 2, 3]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL57_2897)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == struct) || is(T == class)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "make",
								"line": 114,
								"type": "(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 119,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "make",
						"line": 114,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "!isDynamicArray!Range && isInputRange!Range",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "make",
								"line": 121,
								"type": "(T[] items...)",
								"parameters": [
									{
										"name": "items",
										"type": "T[]"
									}
								],
								"endline": 124,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "make",
						"line": 121,
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "make",
				"line": 108,
				"comment": " Convenience function for constructing a generic container.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL128_2900)\n---\nimport std.container.array, std.container.rbtree, std.container.slist;\nimport std.range : iota;\nimport std.algorithm : equal;\n\nauto arr = make!Array(iota(5));\nassert(equal(arr[], [0, 1, 2, 3, 4]));\n\nauto rbtmax = make!(RedBlackTree, \"a > b\")(iota(5));\nassert(equal(rbtmax[], [4, 3, 2, 1, 0]));\n\nauto rbtmin = make!RedBlackTree(4, 1, 3, 2);\nassert(equal(rbtmin[], [1, 2, 3, 4]));\n\nalias makeList = make!SList;\nauto list = makeList(1, 7, 42);\nassert(equal(list[], [1, 7, 42]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL128_2900)\n",
				"parameters": [
					{
						"name": "Container",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "!is(Container)",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module contains some common utilities used by containers.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_util.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/package.d",
		"name": "std.container",
		"members": [],
		"comment": "This module defines generic containers.\n\nConstruction:\n\nTo implement the different containers both struct and class based\napproaches have been used. $(XREF_PACK _container,util,make) allows for\nuniform construction with either approach.\n\n---\nimport std.container;\n// Construct a red-black tree and an array both containing the values 1, 2, 3.\n// RedBlackTree should typically be allocated using `new`\nRedBlackTree!int rbTree = new RedBlackTree!int(1, 2, 3);\n// But `new` should not be used with Array\nArray!int array = Array!int(1, 2, 3);\n// `make` hides the differences\nRedBlackTree!int rbTree2 = make!(RedBlackTree!int)(1, 2, 3);\nArray!int array2 = make!(Array!int)(1, 2, 3);\n---\n\nNote that $(D make) can infer the element type from the given arguments.\n\n---\nimport std.container;\nauto rbTree = make!RedBlackTree(1, 2, 3); // RedBlackTree!int\nauto array = make!Array(\"1\", \"2\", \"3\"); // Array!string\n---\n\nReference_semantics:\n\nAll containers have reference semantics, which means that after\nassignment both variables refer to the same underlying data.\n\nTo make a copy of a _container, use the $(D c._dup) _container primitive.\n---\nimport std.container, std.range;\nArray!int originalArray = make!(Array!int)(1, 2, 3);\nArray!int secondArray = originalArray;\nassert(equal(originalArray[], secondArray[]));\n\n// changing one instance changes the other one as well!\noriginalArray[0] = 12;\nassert(secondArray[0] == 12);\n\n// secondArray now refers to an independent copy of originalArray\nsecondArray = originalArray.dup;\nsecondArray[0] = 1;\n// assert that originalArray has not been affected\nassert(originalArray[0] == 12);\n---\n\n$(B Attention:) If the _container is implemented as a class, using an\nuninitialized instance can cause a null pointer dereference.\n\n---\nimport std.container;\n\nRedBlackTree!int rbTree;\nrbTree.insert(5); // null pointer dereference\n---\n\nUsing an uninitialized struct-based _container will work, because the struct\nintializes itself upon use; however, up to this point the _container will not\nhave an identity and assignment does not create two references to the same\ndata.\n\n---\nimport std.container;\n\n// create an uninitialized array\nArray!int array1;\n// array2 does _not_ refer to array1\nArray!int array2 = array1;\narray2.insertBack(42);\n// thus array1 will not be affected\nassert(array1.empty);\n\n// after initialization reference semantics work as expected\narray1 = array2;\n// now affects array2 as well\narray1.removeBack();\nassert(array2.empty);\n---\nIt is therefore recommended to always construct containers using\n$(XREF_PACK _container,util,make).\n\nThis is in fact necessary to put containers into another _container.\nFor example, to construct an $(D Array) of ten empty $(D Array)s, use\nthe following that calls $(D make) ten times.\n\n---\nimport std.container, std.range;\n\nauto arrOfArrs = make!Array(generate!(() => make!(Array!int)).take(10));\n---\n\nSubmodules:\n\nThis module consists of the following submodules:\n\n$(UL\n    $(LI\n        The $(LINK2 std_container_array.html, std._container.array) module provides\n        an array type with deterministic control of memory, not reliant on\n        the GC unlike built-in arrays.\n    )\n    $(LI\n        The $(LINK2 std_container_binaryheap.html, std._container.binaryheap) module\n        provides a binary heap implementation that can be applied to any\n        user-provided random-access range.\n    )\n    $(LI\n        The $(LINK2 std_container_dlist.html, std._container.dlist) module provides\n        a doubly-linked list implementation.\n    )\n    $(LI\n        The $(LINK2 std_container_rbtree.html, std._container.rbtree) module\n        implements red-black trees.\n    )\n    $(LI\n        The $(LINK2 std_container_slist.html, std._container.slist) module\n        implements singly-linked lists.\n    )\n    $(LI\n        The $(LINK2 std_container_util.html, std._container.util) module contains\n        some generic tools commonly used by _container implementations.\n    )\n)\n\nThe_primary_range_of_a_container:\n\nWhile some _containers offer direct access to their elements e.g. via\n$(D opIndex), $(D c.front) or $(D c.back), access\nand modification of a _container's contents is generally done through\nits primary $(LINK2 std_range.html, range) type,\nwhich is aliased as $(D C.Range). For example, the primary range type of\n$(D Array!int) is $(D Array!int.Range).\n\nIf the documentation of a member function of a _container takes\na parameter of type $(D Range), then it refers to the primary range type of\nthis _container. Oftentimes $(D Take!Range) will be used, in which case\nthe range refers to a span of the elements in the _container. Arguments to\nthese parameters $(B must) be obtained from the same _container instance\nas the one being worked with. It is important to note that many generic range\nalgorithms return the same range type as their input range.\n\n---\nimport std.algorithm : equal, find;\nimport std.container;\nimport std.range : take;\n\nauto array = make!Array(1, 2, 3);\n\n// `find` returns an Array!int.Range advanced to the element \"2\"\narray.linearRemove(array[].find(2));\n\nassert(array[].equal([1]));\n\narray = make!Array(1, 2, 3);\n\n// the range given to `linearRemove` is a Take!(Array!int.Range)\n// spanning just the element \"2\"\narray.linearRemove(array[].find(2).take(1));\n\nassert(array[].equal([1, 3]));\n---\n\nWhen any $(LINK2 std_range.html, range) can be passed as an argument to\na member function, the documention usually refers to the parameter's templated\ntype as $(D Stuff).\n\n---\nimport std.algorithm : equal;\nimport std.container;\nimport std.range : iota;\n\nauto array = make!Array(1, 2);\n\n// the range type returned by `iota` is completely unrelated to Array,\n// which is fine for Array.insertBack:\narray.insertBack(iota(3, 10));\n\nassert(array[].equal([1, 2, 3, 4, 5, 6, 7, 8, 9]));\n---\n\nContainer_primitives:\n\nContainers do not form a class hierarchy, instead they implement a\ncommon set of primitives (see table below). These primitives each guarantee\na specific worst case complexity and thus allow generic code to be written\nindependently of the _container implementation.\n\nFor example the primitives $(D c.remove(r)) and $(D c.linearRemove(r)) both\nremove the sequence of elements in range $(D r) from the _container $(D c).\nThe primitive $(D c.remove(r)) guarantees\n$(BIGOH n$(SUBSCRIPT r) log n$(SUBSCRIPT c)) complexity in the worst case and\n$(D c.linearRemove(r)) relaxes this guarantee to $(BIGOH n$(SUBSCRIPT c)).\n\nSince a sequence of elements can be removed from a $(LINK2 std_container_dlist.html, doubly linked list)\nin constant time, $(D DList) provides the primitive $(D c.remove(r))\nas well as $(D c.linearRemove(r)). On the other hand\n$(LINK2 std_container_array.html, Array) only offers $(D c.linearRemove(r)).\n\nThe following table describes the common set of primitives that containers\nimplement.  A _container need not implement all primitives, but if a\nprimitive is implemented, it must support the syntax described in the $(B\nsyntax) column with the semantics described in the $(B description) column, and\nit must not have a worst-case complexity worse than denoted in big-O notation in\nthe $(BIGOH &middot;) column.  Below, $(D C) means a _container type, $(D c) is\na value of _container type, $(D n$(SUBSCRIPT x)) represents the effective length of\nvalue $(D x), which could be a single element (in which case $(D n$(SUBSCRIPT x)) is\n$(D 1)), a _container, or a range.\n\n$(BOOKTABLE Container primitives,\n\n$(TR $(TH Syntax) $(TH $(BIGOH &middot;)) $(TH Description))\n\n$(TR $(TDNW $(D C(x))) $(TDNW $(D n$(SUBSCRIPT x))) $(TD Creates a\n_container of type $(D C) from either another _container or a range. The created _container must not be a null reference even if x is empty.))\n\n$(TR $(TDNW $(D c.dup)) $(TDNW $(D n$(SUBSCRIPT c))) $(TD Returns a\nduplicate of the _container.))\n\n$(TR $(TDNW $(D c ~ x)) $(TDNW $(D n$(SUBSCRIPT c) + n$(SUBSCRIPT x))) $(TD\nReturns the concatenation of $(D c) and $(D r). $(D x) may be a single\nelement or an input range.))\n\n$(TR $(TDNW $(D x ~ c)) $(TDNW $(D n$(SUBSCRIPT c) + n$(SUBSCRIPT x))) $(TD\nReturns the concatenation of $(D x) and $(D c).  $(D x) may be a\nsingle element or an input range type.))\n\n$(LEADINGROWN 3, Iteration)\n\n$(TR  $(TD $(D c.Range)) $(TD) $(TD The primary range\ntype associated with the _container.))\n\n$(TR $(TD $(D c[])) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Returns a range\niterating over the entire _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c[a .. b])) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Fetches a\nportion of the _container from key $(D a) to key $(D b).))\n\n$(LEADINGROWN 3, Capacity)\n\n$(TR $(TD $(D c.empty)) $(TD $(D 1)) $(TD Returns $(D true) if the\n_container has no elements, $(D false) otherwise.))\n\n$(TR  $(TD $(D c.length)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Returns the\nnumber of elements in the _container.))\n\n$(TR $(TDNW $(D c.length = n)) $(TDNW $(D n$(SUBSCRIPT c) + n)) $(TD Forces\nthe number of elements in the _container to $(D n). If the _container\nends up growing, the added elements are initialized in a\n_container-dependent manner (usually with $(D T.init)).))\n\n$(TR $(TD $(D c.capacity)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Returns the\nmaximum number of elements that can be stored in the _container\nwithout triggering a reallocation.))\n\n$(TR $(TD $(D c.reserve(x))) $(TD $(D n$(SUBSCRIPT c))) $(TD Forces $(D\ncapacity) to at least $(D x) without reducing it.))\n\n$(LEADINGROWN 3, Access)\n\n$(TR $(TDNW $(D c.front)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Returns the\nfirst element of the _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c.moveFront)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nDestructively reads and returns the first element of the\n_container. The slot is not removed from the _container; it is left\ninitialized with $(D T.init). This routine need not be defined if $(D\nfront) returns a $(D ref).))\n\n$(TR $(TDNW $(D c.front = v)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Assigns\n$(D v) to the first element of the _container.))\n\n$(TR $(TDNW $(D c.back)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Returns the\nlast element of the _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c.moveBack)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nDestructively reads and returns the last element of the\n_container. The slot is not removed from the _container; it is left\ninitialized with $(D T.init). This routine need not be defined if $(D\nfront) returns a $(D ref).))\n\n$(TR $(TDNW $(D c.back = v)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Assigns\n$(D v) to the last element of the _container.))\n\n$(TR $(TDNW $(D c[x])) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Provides\nindexed access into the _container. The index type is\n_container-defined. A _container may define several index types (and\nconsequently overloaded indexing).))\n\n$(TR  $(TDNW $(D c.moveAt(x))) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nDestructively reads and returns the value at position $(D x). The slot\nis not removed from the _container; it is left initialized with $(D\nT.init).))\n\n$(TR  $(TDNW $(D c[x] = v)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Sets\nelement at specified index into the _container.))\n\n$(TR  $(TDNW $(D c[x] $(I op)= v)) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Performs read-modify-write operation at specified index into the\n_container.))\n\n$(LEADINGROWN 3, Operations)\n\n$(TR $(TDNW $(D e in c)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nReturns nonzero if e is found in $(D c).))\n\n$(TR  $(TDNW $(D c.lowerBound(v))) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nReturns a range of all elements strictly less than $(D v).))\n\n$(TR  $(TDNW $(D c.upperBound(v))) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nReturns a range of all elements strictly greater than $(D v).))\n\n$(TR  $(TDNW $(D c.equalRange(v))) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nReturns a range of all elements in $(D c) that are equal to $(D v).))\n\n$(LEADINGROWN 3, Modifiers)\n\n$(TR $(TDNW $(D c ~= x)) $(TDNW $(D n$(SUBSCRIPT c) + n$(SUBSCRIPT x)))\n$(TD Appends $(D x) to $(D c). $(D x) may be a single element or an\ninput range type.))\n\n$(TR  $(TDNW $(D c.clear())) $(TDNW $(D n$(SUBSCRIPT c))) $(TD Removes all\nelements in $(D c).))\n\n$(TR  $(TDNW $(D c.insert(x))) $(TDNW $(D n$(SUBSCRIPT x) * log n$(SUBSCRIPT c)))\n$(TD Inserts $(D x) in $(D c) at a position (or positions) chosen by $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsert(x)))\n$(TDNW $(D n$(SUBSCRIPT x) * log n$(SUBSCRIPT c))) $(TD Same as $(D c.insert(x)),\nbut is guaranteed to not invalidate any ranges.))\n\n$(TR  $(TDNW $(D c.linearInsert(v))) $(TDNW $(D n$(SUBSCRIPT c))) $(TD Same\nas $(D c.insert(v)) but relaxes complexity to linear.))\n\n$(TR  $(TDNW $(D c.stableLinearInsert(v))) $(TDNW $(D n$(SUBSCRIPT c)))\n$(TD Same as $(D c.stableInsert(v)) but relaxes complexity to linear.))\n\n$(TR  $(TDNW $(D c.removeAny())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Removes some element from $(D c) and returns it.))\n\n$(TR  $(TDNW $(D c.stableRemoveAny())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.removeAny()), but is guaranteed to not invalidate any\niterators.))\n\n$(TR  $(TDNW $(D c.insertFront(v))) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Inserts $(D v) at the front of $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsertFront(v))) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.insertFront(v)), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.insertBack(v))) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Inserts $(D v) at the back of $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsertBack(v))) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.insertBack(v)), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeFront())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Removes the element at the front of $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemoveFront())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.removeFront()), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeBack())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Removes the value at the back of $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemoveBack())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.removeBack()), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.remove(r))) $(TDNW $(D n$(SUBSCRIPT r) * log n$(SUBSCRIPT c)))\n$(TD Removes range $(D r) from $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemove(r)))\n$(TDNW $(D n$(SUBSCRIPT r) * log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.remove(r)), but guarantees iterators are not\ninvalidated.))\n\n$(TR  $(TDNW $(D c.linearRemove(r))) $(TDNW $(D n$(SUBSCRIPT c)))\n$(TD Removes range $(D r) from $(D c).))\n\n$(TR  $(TDNW $(D c.stableLinearRemove(r))) $(TDNW $(D n$(SUBSCRIPT c)))\n$(TD Same as $(D c.linearRemove(r)), but guarantees iterators are not\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeKey(k))) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Removes an element from $(D c) by using its key $(D k).\nThe key's type is defined by the _container.))\n\n$(TR  $(TDNW $(D )) $(TDNW $(D )) $(TD ))\n\n)\n\nSource: $(PHOBOSSRC std/_container/package.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/rbtree.d",
		"name": "std.container.rbtree",
		"members": [
			{
				"members": [
					{
						"name": "RedBlackTree",
						"line": 701,
						"members": [
							{
								"name": "Elem",
								"line": 743,
								"comment": " Element type for the tree\n",
								"type": "T",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "Range",
								"line": 774,
								"comment": " The range types for $(D RedBlackTree)\n",
								"type": "RBRange!(RBNode*)",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "ConstRange",
								"line": 775,
								"comment": "Ditto\n",
								"type": "RBRange!(const(RBNode)*)",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "ImmutableRange",
								"line": 776,
								"comment": "Ditto\n",
								"type": "RBRange!(immutable(RBNode)*)",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 927,
								"comment": " Check if any elements exist in the container.  Returns $(D false) if at least\n one element exists.\n",
								"type": "@property bool()",
								"endline": 930,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 937,
								"comment": "        Returns the number of elements in the container.\n\n        Complexity: $(BIGOH 1).\n",
								"type": "const @property size_t()",
								"endline": 940,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 948,
								"comment": " Duplicate this container.  The resulting container contains a shallow\n copy of the elements.\n\n Complexity: $(BIGOH n)\n",
								"type": "@property RedBlackTree()",
								"endline": 951,
								"char": 28,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 971,
								"comment": " Fetch a range that spans all the elements in the container.\n\n Complexity: $(BIGOH 1)\n",
								"type": "Range()",
								"endline": 974,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 977,
								"comment": "Ditto\n",
								"type": "const ConstRange()",
								"endline": 980,
								"char": 16,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 983,
								"comment": "Ditto\n",
								"type": "immutable ImmutableRange()",
								"endline": 986,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 993,
								"comment": " The front element in the container\n\n Complexity: $(BIGOH 1)\n",
								"type": "Elem()",
								"endline": 996,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 1003,
								"comment": " The last element in the container\n\n Complexity: $(BIGOH log(n))\n",
								"type": "Elem()",
								"endline": 1006,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinaryRight",
										"line": 1014,
										"type": "const bool(Elem e)",
										"parameters": [
											{
												"name": "e",
												"type": "Elem"
											}
										],
										"endline": 1017,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opBinaryRight",
								"line": 1014,
								"comment": "        $(D in) operator. Check to see if the given element exists in the\n        container.\n\n       Complexity: $(BIGOH log(n))\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"in\"",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 1031,
								"comment": " Compares two trees for equality.\n\n Complexity: $(BIGOH n)\n",
								"type": "bool(Object rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Object"
									}
								],
								"endline": 1045,
								"char": 19,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 1067,
								"comment": " Removes all elements from the container.\n\n Complexity: $(BIGOH 1)\n",
								"type": "void()",
								"endline": 1072,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "stableInsert",
										"line": 1090,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1101,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "stableInsert",
								"line": 1090,
								"comment": " Insert a single element in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Returns: The number of elements inserted.\n\n Complexity: $(BIGOH log(n))\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(Stuff, Elem)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "stableInsert",
										"line": 1111,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1131,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "stableInsert",
								"line": 1111,
								"comment": " Insert a range of elements in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Returns: The number of elements inserted.\n\n Complexity: $(BIGOH m * log(n))\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, Elem)",
								"char": 12,
								"kind": "template"
							},
							{
								"name": "insert",
								"line": 1134,
								"comment": "ditto\n",
								"type": "stableInsert",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 1172,
								"comment": " Remove an element from the container and return its value.\n\n Complexity: $(BIGOH log(n))\n",
								"type": "Elem()",
								"endline": 1182,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 1201,
								"comment": " Remove the front element from the container.\n\n Complexity: $(BIGOH log(n))\n",
								"type": "void()",
								"endline": 1208,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 1215,
								"comment": " Remove the back element from the container.\n\n Complexity: $(BIGOH log(n))\n",
								"type": "void()",
								"endline": 1226,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "remove",
								"line": 1253,
								"comment": "        Removes the given range from the container.\n\n        Returns: A range containing all of the elements that were after the\n                 given range.\n\n        Complexity: $(BIGOH m * log(n)) (where m is the number of elements in\n                    the range)\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 1267,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "remove",
								"line": 1297,
								"comment": "        Removes the given $(D Take!Range) from the container\n\n        Returns: A range containing all of the elements that were after the\n                 given range.\n\n        Complexity: $(BIGOH m * log(n)) (where m is the number of elements in\n                    the range)\n",
								"type": "Range(Take!Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Take!Range"
									}
								],
								"endline": 1313,
								"char": 11,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "removeKey",
										"line": 1360,
										"type": "size_t(U elems)",
										"parameters": [
											{
												"name": "elems",
												"type": "U"
											}
										],
										"endline": 1369,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "removeKey",
								"line": 1360,
								"comment": "       Removes elements from the container that are equal to the given values\n       according to the less comparator. One element is removed for each value\n       given which is in the container. If $(D allowDuplicates) is true,\n       duplicates are removed only if duplicate values are given.\n\n       Returns: The number of elements removed.\n\n       Complexity: $(BIGOH m log(n)) (where m is the number of elements to remove)\n\n       Example:\n--------------------\nauto rbt = redBlackTree!true(0, 1, 1, 1, 4, 5, 7);\nrbt.removeKey(1, 4, 7);\nassert(equal(rbt[], [0, 1, 1, 5]));\nrbt.removeKey(1, 1, 0);\nassert(equal(rbt[], [5]));\n--------------------\n",
								"parameters": [
									{
										"name": "U",
										"kind": "tuple"
									}
								],
								"constraint": "allSatisfy!(isImplicitlyConvertibleToElem, U)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "removeKey",
										"line": 1372,
										"type": "size_t(U[] elems)",
										"parameters": [
											{
												"name": "elems",
												"type": "U[]"
											}
										],
										"endline": 1391,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "removeKey",
								"line": 1372,
								"comment": " Ditto\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(U, Elem)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "removeKey",
										"line": 1394,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1403,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "removeKey",
								"line": 1394,
								"comment": " Ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, Elem) && !isDynamicArray!Stuff",
								"char": 12,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "upperBound",
								"line": 1501,
								"comment": " Get a range from the container with all elements that are > e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n",
								"type": "Range(Elem e)",
								"parameters": [
									{
										"name": "e",
										"type": "Elem"
									}
								],
								"endline": 1504,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "upperBound",
								"line": 1507,
								"comment": "Ditto\n",
								"type": "const ConstRange(Elem e)",
								"parameters": [
									{
										"name": "e",
										"type": "Elem"
									}
								],
								"endline": 1510,
								"char": 16,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "upperBound",
								"line": 1513,
								"comment": "Ditto\n",
								"type": "immutable ImmutableRange(Elem e)",
								"parameters": [
									{
										"name": "e",
										"type": "Elem"
									}
								],
								"endline": 1516,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "lowerBound",
								"line": 1524,
								"comment": " Get a range from the container with all elements that are < e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n",
								"type": "Range(Elem e)",
								"parameters": [
									{
										"name": "e",
										"type": "Elem"
									}
								],
								"endline": 1527,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "lowerBound",
								"line": 1530,
								"comment": "Ditto\n",
								"type": "const ConstRange(Elem e)",
								"parameters": [
									{
										"name": "e",
										"type": "Elem"
									}
								],
								"endline": 1533,
								"char": 16,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "lowerBound",
								"line": 1536,
								"comment": "Ditto\n",
								"type": "immutable ImmutableRange(Elem e)",
								"parameters": [
									{
										"name": "e",
										"type": "Elem"
									}
								],
								"endline": 1539,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "equalRange",
										"line": 1547,
										"type": "(Elem e)",
										"parameters": [
											{
												"name": "e",
												"type": "Elem"
											}
										],
										"endline": 1564,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "equalRange",
								"line": 1547,
								"comment": " Get a range from the container with all elements that are == e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n",
								"parameters": [
									{
										"name": "This",
										"kind": "this"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 1677,
								"comment": "    Formats the RedBlackTree into a sink function. For more info see\n    $(D std.format.formatValue)\n",
								"type": "const void(scope void delegate(const(char)[]) sink, FormatSpec!char fmt)",
								"parameters": [
									{
										"name": "sink",
										"type": "void delegate(const(char)[])",
										"storageClass": [
											"scope"
										]
									},
									{
										"name": "fmt",
										"type": "FormatSpec!char"
									}
								],
								"endline": 1681,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 1687,
								"comment": " Constructor. Pass in an array of elements, or individual elements to\n initialize the tree with.\n",
								"type": "(Elem[] elems...)",
								"parameters": [
									{
										"name": "elems",
										"type": "Elem[]"
									}
								],
								"endline": 1691,
								"char": 5,
								"kind": "constructor"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 1696,
										"type": "(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1700,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 1696,
								"comment": " Constructor. Pass in a range of elements to initialize the tree with.\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, Elem)",
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 1703,
								"comment": "\n",
								"type": "()",
								"endline": 1706,
								"char": 5,
								"kind": "constructor"
							}
						],
						"char": 7,
						"kind": "class"
					}
				],
				"name": "RedBlackTree",
				"line": 701,
				"comment": " Implementation of a $(LUCKY red-black tree) container.\n\n All inserts, removes, searches, and any function in general has complexity\n of $(BIGOH lg(n)).\n\n To use a different comparison than $(D \"a < b\"), pass a different operator string\n that can be used by $(XREF functional, binaryFun), or pass in a\n function, delegate, functor, or any type where $(D less(a, b)) results in a $(D bool)\n value.\n\n Note that less should produce a strict ordering.  That is, for two unequal\n elements $(D a) and $(D b), $(D less(a, b) == !less(b, a)). $(D less(a, a)) should\n always equal $(D false).\n\n If $(D allowDuplicates) is set to $(D true), then inserting the same element more than\n once continues to add more elements.  If it is $(D false), duplicate elements are\n ignored on insertion.  If duplicates are allowed, then new elements are\n inserted after all existing duplicate elements.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "allowDuplicates",
						"defaultValue": "false",
						"deco": "b",
						"kind": "value"
					}
				],
				"constraint": "is(typeof(binaryFun!less(T.init, T.init)))",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "redBlackTree",
						"line": 1782,
						"type": "(E[] elems...)",
						"parameters": [
							{
								"name": "elems",
								"type": "E[]"
							}
						],
						"endline": 1785,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "redBlackTree",
				"line": 1782,
				"comment": "    Convenience function for creating a $(D RedBlackTree!E) from a list of\n    values.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1810_2920)\n---\nauto rbt1 = redBlackTree(0, 1, 5, 7);\nauto rbt2 = redBlackTree!string(\"hello\", \"world\");\nauto rbt3 = redBlackTree!true(0, 1, 5, 7, 5);\nauto rbt4 = redBlackTree!\"a > b\"(0, 1, 5, 7);\nauto rbt5 = redBlackTree!(\"a > b\", true)(0.1, 1.3, 5.9, 7.2, 5.9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1810_2920)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "redBlackTree",
						"line": 1788,
						"type": "(E[] elems...)",
						"parameters": [
							{
								"name": "elems",
								"type": "E[]"
							}
						],
						"endline": 1791,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "redBlackTree",
				"line": 1788,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "allowDuplicates",
						"deco": "b",
						"kind": "value"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "redBlackTree",
						"line": 1794,
						"type": "(E[] elems...)",
						"parameters": [
							{
								"name": "elems",
								"type": "E[]"
							}
						],
						"endline": 1797,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "redBlackTree",
				"line": 1794,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "less",
						"kind": "alias"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "redBlackTree",
						"line": 1800,
						"type": "(E[] elems...)",
						"parameters": [
							{
								"name": "elems",
								"type": "E[]"
							}
						],
						"endline": 1807,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "redBlackTree",
				"line": 1800,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "less",
						"kind": "alias"
					},
					{
						"name": "allowDuplicates",
						"deco": "b",
						"kind": "value"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!less(E.init, E.init)))",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This module implements a red-black tree container.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_rbtree.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/array.d",
		"name": "std.container.array",
		"members": [
			{
				"members": [
					{
						"name": "Array",
						"line": 198,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 368,
										"type": "(U[] values...)",
										"parameters": [
											{
												"name": "values",
												"type": "U[]"
											}
										],
										"endline": 384,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 368,
								"comment": "Constructor taking a number of items\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(U, T)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 389,
										"type": "(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 393,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 389,
								"comment": "Constructor taking an input range\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T) && !is(Stuff == T[])",
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 399,
								"comment": "Comparison for equality.\n",
								"type": "const bool(const Array rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Array",
										"storageClass": [
											"const"
										]
									}
								],
								"endline": 402,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 405,
								"comment": "ditto\n",
								"type": "const bool(ref const Array rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Array",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 410,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "Range",
								"line": 418,
								"comment": "   Defines the container's primary range, which is a random-access range.\n\n   ConstRange is a variant with const elements.\n   ImmutableRange is a variant with immutable elements.\n",
								"type": "RangeT!Array",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "ConstRange",
								"line": 419,
								"comment": "ditto\n",
								"type": "RangeT!(const(Array))",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "ImmutableRange",
								"line": 420,
								"comment": "ditto\n",
								"type": "RangeT!(immutable(Array))",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 428,
								"comment": "Duplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n",
								"type": "@property Array()",
								"endline": 432,
								"char": 21,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 440,
								"comment": "Property returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n",
								"type": "const @property bool()",
								"endline": 443,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 450,
								"comment": "Returns the number of elements in the container.\n\nComplexity: $(BIGOH 1).\n",
								"type": "const @property size_t()",
								"endline": 453,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opDollar",
								"line": 456,
								"comment": "ditto\n",
								"type": "const size_t()",
								"endline": 459,
								"char": 12,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "capacity",
								"line": 467,
								"comment": "Returns the maximum number of elements the container can store without\n   (a) allocating memory, (b) invalidating iterators upon insertion.\n\nComplexity: $(BIGOH 1)\n",
								"type": "@property size_t()",
								"endline": 470,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "reserve",
								"line": 479,
								"comment": "Ensures sufficient capacity to accommodate $(D e) elements.\n\nPostcondition: $(D capacity >= e)\n\nComplexity: $(BIGOH 1)\n",
								"type": "void(size_t elements)",
								"parameters": [
									{
										"name": "elements",
										"type": "size_t"
									}
								],
								"endline": 497,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 505,
								"comment": "Returns a range that iterates over elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n",
								"type": "Range()",
								"endline": 508,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 526,
								"comment": "Returns a range that iterates over elements of the container from\nindex $(D a) up to (excluding) index $(D b).\n\nPrecondition: $(D a <= b && b <= length)\n\nComplexity: $(BIGOH 1)\n",
								"type": "Range(size_t i, size_t j)",
								"parameters": [
									{
										"name": "i",
										"type": "size_t"
									},
									{
										"name": "j",
										"type": "size_t"
									}
								],
								"endline": 530,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 549,
								"comment": "Forward to $(D opSlice().front) and $(D opSlice().back), respectively.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1)\n",
								"type": "inout @property ref inout(T)()",
								"endline": 553,
								"char": 28,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 556,
								"comment": "ditto\n",
								"type": "inout @property ref inout(T)()",
								"endline": 560,
								"char": 28,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opIndex",
								"line": 569,
								"comment": "Indexing operators yield or modify the value at a specified index.\n\nPrecondition: $(D i < length)\n\nComplexity: $(BIGOH 1)\n",
								"type": "inout ref inout(T)(size_t i)",
								"parameters": [
									{
										"name": "i",
										"type": "size_t"
									}
								],
								"endline": 573,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSliceAssign",
								"line": 582,
								"comment": "Slicing operations execute an operation on an entire slice.\n\nPrecondition: $(D i < j && j < length)\n\nComplexity: $(BIGOH slice.length)\n",
								"type": "void(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 586,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSliceAssign",
								"line": 589,
								"comment": "ditto\n",
								"type": "void(T value, size_t i, size_t j)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									},
									{
										"name": "i",
										"type": "size_t"
									},
									{
										"name": "j",
										"type": "size_t"
									}
								],
								"endline": 595,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opSliceUnary",
										"line": 598,
										"type": "void()",
										"endline": 603,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opSliceUnary",
								"line": 598,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"++\" || op == \"--\"",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opSliceUnary",
										"line": 606,
										"type": "void(size_t i, size_t j)",
										"parameters": [
											{
												"name": "i",
												"type": "size_t"
											},
											{
												"name": "j",
												"type": "size_t"
											}
										],
										"endline": 611,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opSliceUnary",
								"line": 606,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"++\" || op == \"--\"",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opSliceOpAssign",
										"line": 614,
										"type": "void(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 618,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opSliceOpAssign",
								"line": 614,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opSliceOpAssign",
										"line": 621,
										"type": "void(T value, size_t i, size_t j)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											},
											{
												"name": "i",
												"type": "size_t"
											},
											{
												"name": "j",
												"type": "size_t"
											}
										],
										"endline": 625,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opSliceOpAssign",
								"line": 621,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 635,
										"type": "Array(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 644,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 635,
								"comment": "Returns a new container that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n\nComplexity: $(BIGOH n + m), where m is the number of elements in $(D\nstuff)\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\"",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 649,
										"type": "void(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 660,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 649,
								"comment": "Forwards to $(D insertBack(stuff)).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\"",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 670,
								"comment": "Removes all contents from the container. The container decides how $(D\ncapacity) is affected.\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH n)\n",
								"type": "void()",
								"endline": 673,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 685,
								"comment": "Sets the number of elements in the container to $(D newSize). If $(D\nnewSize) is greater than $(D length), the added elements are added to\nunspecified positions in the container and initialized with $(D\nT.init).\n\nComplexity: $(BIGOH abs(n - newLength))\n\nPostcondition: $(D length == newLength)\n",
								"type": "@property void(size_t newLength)",
								"parameters": [
									{
										"name": "newLength",
										"type": "size_t"
									}
								],
								"endline": 689,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 702,
								"comment": "Picks one value in an unspecified position in the container, removes\nit from the container, and returns it. The stable version behaves the same,\nbut guarantees that ranges iterating over the container are never invalidated.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH log(n)).\n",
								"type": "T()",
								"endline": 707,
								"char": 7,
								"kind": "function"
							},
							{
								"name": "stableRemoveAny",
								"line": 709,
								"comment": "ditto\n",
								"type": "removeAny",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBack",
										"line": 722,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 728,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBack",
								"line": 722,
								"comment": "Inserts $(D value) to the front or back of the container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D stuff)\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(Stuff, T) || isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"name": "insert",
								"line": 730,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 741,
								"comment": "Removes the value at the back of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH log(n)).\n",
								"type": "void()",
								"endline": 748,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "stableRemoveBack",
								"line": 750,
								"comment": "ditto\n",
								"type": "removeBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 765,
								"comment": "Removes $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany).\n",
								"type": "size_t(size_t howMany)",
								"parameters": [
									{
										"name": "howMany",
										"type": "size_t"
									}
								],
								"endline": 774,
								"char": 12,
								"kind": "function"
							},
							{
								"name": "stableRemoveBack",
								"line": 776,
								"comment": "ditto\n",
								"type": "removeBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBefore",
										"line": 789,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 803,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBefore",
								"line": 789,
								"comment": "Inserts $(D stuff) before, after, or instead range $(D r), which must\nbe a valid range previously extracted from this container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBefore",
										"line": 806,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 843,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBefore",
								"line": 806,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertAfter",
										"line": 846,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 857,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertAfter",
								"line": 846,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "replace",
										"line": 860,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 879,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "replace",
								"line": 860,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "replace",
										"line": 882,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 897,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "replace",
								"line": 882,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 911,
								"comment": "Removes all elements belonging to $(D r), which must be a range\nobtained originally from this container. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH n - m), where $(D m) is the number of elements in\n$(D r)\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 923,
								"char": 11,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Array",
				"line": 198,
				"comment": "Array type with deterministic control of memory. The memory allocated\nfor the array is reclaimed as soon as possible; there is no reliance\non the garbage collector. $(D Array) uses $(D malloc) and $(D free)\nfor managing its own memory.\n\nThis means that pointers to elements of an $(D Array) will become\ndangling as soon as the element is removed from the $(D Array). On the other hand\nthe memory allocated by an $(D Array) will be scanned by the GC and\nGC managed objects referenced from an $(D Array) will be kept alive.\n\nNote:\n\nWhen using $(D Array) with range-based functions like those in $(D std.algorithm),\n$(D Array) must be sliced to get a range (for example, use $(D array[].map!)\ninstead of $(D array.map!)). The container itself is not a range.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!is(Unqual!T == bool)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Array",
						"line": 1358,
						"members": [
							{
								"name": "Range",
								"line": 1381,
								"comment": "       Defines the container's primary range.\n",
								"members": [
									{
										"endchar": 9,
										"name": "save",
										"line": 1386,
										"comment": "Range primitives\n",
										"type": "@property Range()",
										"endline": 1397,
										"char": 25,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "empty",
										"line": 1399,
										"comment": "Ditto\n",
										"type": "@property bool()",
										"endline": 1402,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 1404,
										"comment": "Ditto\n",
										"type": "@property T()",
										"endline": 1408,
										"char": 21,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 1410,
										"comment": "Ditto\n",
										"type": "@property void(bool value)",
										"parameters": [
											{
												"name": "value",
												"deco": "b"
											}
										],
										"endline": 1414,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "moveFront",
										"line": 1416,
										"comment": "Ditto\n",
										"type": "T()",
										"endline": 1420,
										"char": 11,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 1422,
										"comment": "Ditto\n",
										"type": "void()",
										"endline": 1426,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "back",
										"line": 1428,
										"comment": "Ditto\n",
										"type": "@property T()",
										"endline": 1432,
										"char": 21,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "back",
										"line": 1434,
										"comment": "Ditto\n",
										"type": "@property void(bool value)",
										"parameters": [
											{
												"name": "value",
												"deco": "b"
											}
										],
										"endline": 1438,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "moveBack",
										"line": 1440,
										"comment": "Ditto\n",
										"type": "T()",
										"endline": 1444,
										"char": 11,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popBack",
										"line": 1446,
										"comment": "Ditto\n",
										"type": "void()",
										"endline": 1450,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "opIndex",
										"line": 1452,
										"comment": "Ditto\n",
										"type": "T(size_t i)",
										"parameters": [
											{
												"name": "i",
												"type": "size_t"
											}
										],
										"endline": 1455,
										"char": 11,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "opIndexAssign",
										"line": 1457,
										"comment": "Ditto\n",
										"type": "void(T value, size_t i)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											},
											{
												"name": "i",
												"type": "size_t"
											}
										],
										"endline": 1460,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "moveAt",
										"line": 1462,
										"comment": "Ditto\n",
										"type": "T(size_t i)",
										"parameters": [
											{
												"name": "i",
												"type": "size_t"
											}
										],
										"endline": 1465,
										"char": 11,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "length",
										"line": 1467,
										"comment": "Ditto\n",
										"type": "const @property size_t()",
										"endline": 1471,
										"char": 26,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "opSlice",
										"line": 1474,
										"comment": "ditto\n",
										"type": "Range(size_t low, size_t high)",
										"parameters": [
											{
												"name": "low",
												"type": "size_t"
											},
											{
												"name": "high",
												"type": "size_t"
											}
										],
										"endline": 1478,
										"char": 15,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 1487,
								"comment": "       Property returning $(D true) if and only if the container has\n       no elements.\n\n       Complexity: $(BIGOH 1)\n",
								"type": "@property bool()",
								"endline": 1490,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 1507,
								"comment": "       Returns a duplicate of the container. The elements themselves\n       are not transitively duplicated.\n\n       Complexity: $(BIGOH n).\n",
								"type": "@property Array()",
								"endline": 1512,
								"char": 21,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 1529,
								"comment": "       Returns the number of elements in the container.\n\n       Complexity: $(BIGOH log(n)).\n",
								"type": "const @property size_t()",
								"endline": 1532,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "capacity",
								"line": 1554,
								"comment": "       Returns the maximum number of elements the container can store\n       without (a) allocating memory, (b) invalidating iterators upon\n       insertion.\n\n       Complexity: $(BIGOH log(n)).\n",
								"type": "@property size_t()",
								"endline": 1559,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "reserve",
								"line": 1581,
								"comment": "       Ensures sufficient capacity to accommodate $(D n) elements.\n\n       Postcondition: $(D capacity >= n)\n\n       Complexity: $(BIGOH log(e - capacity)) if $(D e > capacity),\n       otherwise $(BIGOH 1).\n",
								"type": "void(size_t e)",
								"parameters": [
									{
										"name": "e",
										"type": "size_t"
									}
								],
								"endline": 1586,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 1604,
								"comment": "       Returns a range that iterates over all elements of the\n       container, in a container-defined order. The container should\n       choose the most convenient and fast method of iteration for $(D\n       opSlice()).\n\n       Complexity: $(BIGOH log(n))\n",
								"type": "Range()",
								"endline": 1607,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 1622,
								"comment": "       Returns a range that iterates the container between two\n       specified positions.\n\n       Complexity: $(BIGOH log(n))\n",
								"type": "Range(size_t a, size_t b)",
								"parameters": [
									{
										"name": "a",
										"type": "size_t"
									},
									{
										"name": "b",
										"type": "size_t"
									}
								],
								"endline": 1626,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 1641,
								"comment": "       Equivalent to $(D opSlice().front) and $(D opSlice().back),\n       respectively.\n\n       Complexity: $(BIGOH log(n))\n",
								"type": "@property bool()",
								"endline": 1645,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 1648,
								"comment": "Ditto\n",
								"type": "@property void(bool value)",
								"parameters": [
									{
										"name": "value",
										"deco": "b"
									}
								],
								"endline": 1653,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 1665,
								"comment": "Ditto\n",
								"type": "@property bool()",
								"endline": 1669,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 1672,
								"comment": "Ditto\n",
								"type": "@property void(bool value)",
								"parameters": [
									{
										"name": "value",
										"deco": "b"
									}
								],
								"endline": 1684,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opIndex",
								"line": 1698,
								"comment": "       Indexing operators yield or modify the value at a specified index.\n",
								"type": "bool(size_t i)",
								"parameters": [
									{
										"name": "i",
										"type": "size_t"
									}
								],
								"endline": 1704,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opIndexAssign",
								"line": 1706,
								"comment": "ditto\n",
								"type": "void(bool value, size_t i)",
								"parameters": [
									{
										"name": "value",
										"deco": "b"
									},
									{
										"name": "i",
										"type": "size_t"
									}
								],
								"endline": 1713,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndexOpAssign",
										"line": 1715,
										"type": "void(bool value, size_t i)",
										"parameters": [
											{
												"name": "value",
												"deco": "b"
											},
											{
												"name": "i",
												"type": "size_t"
											}
										],
										"endline": 1729,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opIndexOpAssign",
								"line": 1715,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "moveAt",
								"line": 1731,
								"comment": "Ditto\n",
								"type": "T(size_t i)",
								"parameters": [
									{
										"name": "i",
										"type": "size_t"
									}
								],
								"endline": 1734,
								"char": 7,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 1752,
										"type": "Array!bool(Stuff rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Stuff"
											}
										],
										"endline": 1756,
										"char": 16,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 1752,
								"comment": "       Returns a new container that's the concatenation of $(D this)\n       and its argument.\n\n       Complexity: $(BIGOH n + m), where m is the number of elements\n       in $(D stuff)\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\"",
								"char": 16,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 1780,
										"type": "Array!bool(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1785,
										"char": 16,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 1780,
								"comment": "       Forwards to $(D insertAfter(this[], stuff)).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\"",
								"char": 16,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 1808,
								"comment": "       Removes all contents from the container. The container decides\n       how $(D capacity) is affected.\n\n       Postcondition: $(D empty)\n\n       Complexity: $(BIGOH n)\n",
								"type": "void()",
								"endline": 1811,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 1831,
								"comment": "       Sets the number of elements in the container to $(D\n       newSize). If $(D newSize) is greater than $(D length), the\n       added elements are added to the container and initialized with\n       $(D ElementType.init).\n\n       Complexity: $(BIGOH abs(n - newLength))\n\n       Postcondition: $(D _length == newLength)\n",
								"type": "@property void(size_t newLength)",
								"parameters": [
									{
										"name": "newLength",
										"type": "size_t"
									}
								],
								"endline": 1839,
								"char": 20,
								"kind": "function"
							},
							{
								"name": "insert",
								"line": 1866,
								"comment": "       Inserts $(D stuff) in the container. $(D stuff) can be a value\n       convertible to $(D ElementType) or a range of objects\n       convertible to $(D ElementType).\n\n       The $(D stable) version guarantees that ranges iterating over\n       the container are never invalidated. Client code that counts on\n       non-invalidating insertion should use $(D stableInsert).\n\n       Returns: The number of elements added.\n\n       Complexity: $(BIGOH m * log(n)), where $(D m) is the number of\n       elements in $(D stuff)\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsert",
								"line": 1868,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "linearInsert",
								"line": 1874,
								"comment": "       Same as $(D insert(stuff)) and $(D stableInsert(stuff))\n       respectively, but relax the complexity constraint to linear.\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableLinearInsert",
								"line": 1876,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 1890,
								"comment": "       Picks one value in the container, removes it from the\n       container, and returns it. The stable version behaves the same,\n       but guarantees that ranges iterating over the container are\n       never invalidated.\n\n       Precondition: $(D !empty)\n\n       Returns: The element removed.\n\n       Complexity: $(BIGOH log(n))\n",
								"type": "T()",
								"endline": 1895,
								"char": 7,
								"kind": "function"
							},
							{
								"name": "stableRemoveAny",
								"line": 1897,
								"comment": "ditto\n",
								"type": "removeAny",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBack",
										"line": 1922,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1945,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBack",
								"line": 1922,
								"comment": "       Inserts $(D value) to the back of the container. $(D stuff) can\n       be a value convertible to $(D ElementType) or a range of\n       objects convertible to $(D ElementType). The stable version\n       behaves the same, but guarantees that ranges iterating over the\n       container are never invalidated.\n\n       Returns: The number of elements inserted\n\n       Complexity: $(BIGOH log(n))\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "is(Stuff : bool)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBack",
										"line": 1947,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1958,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBack",
								"line": 1947,
								"comment": "Ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && is(ElementType!Stuff : bool)",
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertBack",
								"line": 1960,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 1974,
								"comment": "       Removes the value at the front or back of the container. The\n       stable version behaves the same, but guarantees that ranges\n       iterating over the container are never invalidated. The\n       optional parameter $(D howMany) instructs removal of that many\n       elements. If $(D howMany > n), all elements are removed and no\n       exception is thrown.\n\n       Precondition: $(D !empty)\n\n       Complexity: $(BIGOH log(n)).\n",
								"type": "void()",
								"endline": 1988,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "stableRemoveBack",
								"line": 1990,
								"comment": "ditto\n",
								"type": "removeBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 2006,
								"comment": "       Removes $(D howMany) values at the front or back of the\n       container. Unlike the unparameterized versions above, these\n       functions do not throw if they could not remove $(D howMany)\n       elements. Instead, if $(D howMany > n), all elements are\n       removed. The returned value is the effective number of elements\n       removed. The stable version behaves the same, but guarantees\n       that ranges iterating over the container are never invalidated.\n\n       Returns: The number of elements removed\n\n       Complexity: $(BIGOH howMany * log(n)).\n\nditto\n",
								"type": "size_t(size_t howMany)",
								"parameters": [
									{
										"name": "howMany",
										"type": "size_t"
									}
								],
								"endline": 2018,
								"char": 12,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBefore",
										"line": 2045,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 2055,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBefore",
								"line": 2045,
								"comment": "       Inserts $(D stuff) before, after, or instead range $(D r),\n       which must be a valid range previously extracted from this\n       container. $(D stuff) can be a value convertible to $(D\n       ElementType) or a range of objects convertible to $(D\n       ElementType). The stable version behaves the same, but\n       guarantees that ranges iterating over the container are never\n       invalidated.\n\n       Returns: The number of values inserted.\n\n       Complexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertBefore",
								"line": 2057,
								"comment": "ditto\n",
								"type": "insertBefore",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertAfter",
										"line": 2074,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 2084,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertAfter",
								"line": 2074,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertAfter",
								"line": 2086,
								"comment": "ditto\n",
								"type": "insertAfter",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "replace",
										"line": 2098,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 2113,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "replace",
								"line": 2098,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "is(Stuff : bool)",
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableReplace",
								"line": 2115,
								"comment": "ditto\n",
								"type": "replace",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 2138,
								"comment": "       Removes all elements belonging to $(D r), which must be a range\n       obtained originally from this container. The stable version\n       behaves the same, but guarantees that ranges iterating over the\n       container are never invalidated.\n\n       Returns: A range spanning the remaining elements in the container that\n       initially were right after $(D r).\n\n       Complexity: $(BIGOH n)\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 2144,
								"char": 11,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Array",
				"line": 1358,
				"comment": "\n\n\n\n_Array specialized for $(D bool). Packs together values efficiently by\nallocating one bit per element.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(Unqual!T == bool)",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module provides an $(D Array) type with deterministic memory usage not\nreliant on the GC, as an alternative to the built-in arrays.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_array.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/binaryheap.d",
		"name": "std.container.binaryheap",
		"members": [
			{
				"members": [
					{
						"name": "BinaryHeap",
						"line": 57,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 135,
								"comment": "       Converts the store $(D s) into a heap. If $(D initialSize) is\n       specified, only the first $(D initialSize) elements in $(D s)\n       are transformed into a heap, after which the heap can grow up\n       to $(D r.length) (if $(D Store) is a range) or indefinitely (if\n       $(D Store) is a container with $(D insertBack)). Performs\n       $(BIGOH min(r.length, initialSize)) evaluations of $(D less).\n",
								"type": "(Store s, size_t initialSize = size_t.max)",
								"parameters": [
									{
										"name": "s",
										"type": "Store"
									},
									{
										"name": "initialSize",
										"type": "size_t",
										"default": "size_t.max"
									}
								],
								"endline": 138,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "acquire",
								"line": 144,
								"comment": "Takes ownership of a store. After this, manipulating $(D s) may make\nthe heap work incorrectly.\n",
								"type": "void(Store s, size_t initialSize = size_t.max)",
								"parameters": [
									{
										"name": "s",
										"type": "Store"
									},
									{
										"name": "initialSize",
										"type": "size_t",
										"default": "size_t.max"
									}
								],
								"endline": 152,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "assume",
								"line": 158,
								"comment": "Takes ownership of a store assuming it already was organized as a\nheap.\n",
								"type": "void(Store s, size_t initialSize = size_t.max)",
								"parameters": [
									{
										"name": "s",
										"type": "Store"
									},
									{
										"name": "initialSize",
										"type": "size_t",
										"default": "size_t.max"
									}
								],
								"endline": 164,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "release",
								"line": 170,
								"comment": "Clears the heap. Returns the portion of the store from $(D 0) up to\n$(D length), which satisfies the $(LUCKY heap property).\n",
								"type": "()",
								"endline": 180,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 185,
								"comment": "Returns $(D true) if the heap is _empty, $(D false) otherwise.\n",
								"type": "@property bool()",
								"endline": 188,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 194,
								"comment": "Returns a duplicate of the heap. The underlying store must also\nsupport a $(D dup) method.\n",
								"type": "@property BinaryHeap()",
								"endline": 200,
								"char": 26,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 205,
								"comment": "Returns the _length of the heap.\n",
								"type": "@property size_t()",
								"endline": 208,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "capacity",
								"line": 215,
								"comment": "Returns the _capacity of the heap, which is the length of the\nunderlying store (if the store is a range) or the _capacity of the\nunderlying store (if the store is a container).\n",
								"type": "@property size_t()",
								"endline": 226,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 232,
								"comment": "Returns a copy of the _front of the heap, which is the largest element\naccording to $(D less).\n",
								"type": "@property ElementType!Store()",
								"endline": 236,
								"char": 33,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 241,
								"comment": "Clears the heap by detaching it from the underlying store.\n",
								"type": "void()",
								"endline": 244,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "insert",
								"line": 250,
								"comment": "Inserts $(D value) into the store. If the underlying store is a range\nand $(D length == capacity), throws an exception.\n",
								"type": "size_t(ElementType!Store value)",
								"parameters": [
									{
										"name": "value",
										"type": "ElementType!Store"
									}
								],
								"endline": 286,
								"char": 12,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 291,
								"comment": "Removes the largest element from the heap.\n",
								"type": "void()",
								"endline": 303,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "popFront",
								"line": 306,
								"comment": "ditto\n",
								"type": "removeFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 314,
								"comment": "Removes the largest element from the heap and returns a copy of\nit. The element still resides in the heap's store. For performance\nreasons you may want to use $(D removeFront) with heaps of objects\nthat are expensive to copy.\n",
								"type": "ElementType!Store()",
								"endline": 318,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "replaceFront",
								"line": 323,
								"comment": "Replaces the largest element in the store with $(D value).\n",
								"type": "void(ElementType!Store value)",
								"parameters": [
									{
										"name": "value",
										"type": "ElementType!Store"
									}
								],
								"endline": 330,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "conditionalInsert",
								"line": 340,
								"comment": "If the heap has room to grow, inserts $(D value) into the store and\nreturns $(D true). Otherwise, if $(D less(value, front)), calls $(D\nreplaceFront(value)) and returns again $(D true). Otherwise, leaves\nthe heap unaffected and returns $(D false). This method is useful in\nscenarios where the smallest $(D k) elements of a set of candidates\nmust be collected.\n",
								"type": "bool(ElementType!Store value)",
								"parameters": [
									{
										"name": "value",
										"type": "ElementType!Store"
									}
								],
								"endline": 355,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "BinaryHeap",
				"line": 57,
				"comment": "Implements a $(WEB en.wikipedia.org/wiki/Binary_heap, binary heap)\ncontainer on top of a given random-access range type (usually $(D\nT[])) or a random-access container type (usually $(D Array!T)). The\ndocumentation of $(D BinaryHeap) will refer to the underlying range or\ncontainer as the $(I store) of the heap.\n\nThe binary heap induces structure over the underlying store such that\naccessing the largest element (by using the $(D front) property) is a\n$(BIGOH 1) operation and extracting it (by using the $(D\nremoveFront()) method) is done fast in $(BIGOH log n) time.\n\nIf $(D less) is the less-than operator, which is the default option,\nthen $(D BinaryHeap) defines a so-called max-heap that optimizes\nextraction of the $(I largest) elements. To define a min-heap,\ninstantiate BinaryHeap with $(D \"a > b\") as its predicate.\n\nSimply extracting elements from a $(D BinaryHeap) container is\ntantamount to lazily fetching elements of $(D Store) in descending\norder. Extracting elements from the $(D BinaryHeap) to completion\nleaves the underlying store sorted in ascending order but, again,\nyields elements in descending order.\n\nIf $(D Store) is a range, the $(D BinaryHeap) cannot grow beyond the\nsize of that range. If $(D Store) is a container that supports $(D\ninsertBack), the $(D BinaryHeap) may grow by adding elements to the\ncontainer.\nExample:\nExample from \"Introduction to Algorithms\" Cormen et al, p 146$(DDOX_UNITTEST_HEADER __unittestL359_2981)\n---\nimport std.algorithm : equal;\nint[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];\nauto h = heapify(a);\n// largest element\nassert(h.front == 16);\n// a has the heap property\nassert(equal(a, [ 16, 14, 10, 8, 7, 9, 3, 2, 4, 1 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL359_2981)\nExample:\n$(D BinaryHeap) implements the standard input range interface, allowing\n\nlazy iteration of the underlying range in descending order.$(DDOX_UNITTEST_HEADER __unittestL372_2982)\n---\nimport std.algorithm : equal;\nimport std.range : take;\nint[] a = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7];\nauto top5 = heapify(a).take(5);\nassert(top5.equal([16, 14, 10, 9, 8]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL372_2982)\n",
				"parameters": [
					{
						"name": "Store",
						"kind": "type"
					},
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					}
				],
				"constraint": "isRandomAccessRange!Store || isRandomAccessRange!(typeof(Store.init[]))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "heapify",
						"line": 385,
						"type": "BinaryHeap!(Store, less)(Store s, size_t initialSize = size_t.max)",
						"parameters": [
							{
								"name": "s",
								"type": "Store"
							},
							{
								"name": "initialSize",
								"type": "size_t",
								"default": "size_t.max"
							}
						],
						"endline": 389,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "heapify",
				"line": 385,
				"comment": "Convenience function that returns a $(D BinaryHeap!Store) object\ninitialized with $(D s) and $(D initialSize).\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Store",
						"kind": "type"
					}
				],
				"char": 26,
				"kind": "template"
			}
		],
		"comment": "This module provides a $(D BinaryHeap) adaptor that makes a binary heap out of\nany user-provided random-access range.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_binaryheap.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/mutation.d",
		"name": "std.algorithm.mutation",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "bringToFront",
						"line": 114,
						"type": "size_t(Range1 front, Range2 back)",
						"parameters": [
							{
								"name": "front",
								"type": "Range1"
							},
							{
								"name": "back",
								"type": "Range2"
							}
						],
						"endline": 173,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "bringToFront",
				"line": 114,
				"comment": "The $(D bringToFront) function has considerable flexibility and\nusefulness. It can rotate elements in one buffer left or right, swap\nbuffers of equal length, and even move elements across disjoint\nbuffers of different types and different lengths.\n\n$(D bringToFront) takes two ranges $(D front) and $(D back), which may\nbe of different types. Considering the concatenation of $(D front) and\n$(D back) one unified range, $(D bringToFront) rotates that unified\nrange such that all elements in $(D back) are brought to the beginning\nof the unified range. The relative ordering of elements in $(D front)\nand $(D back), respectively, remains unchanged.\n\nPerforms $(BIGOH max(front.length, back.length)) evaluations of $(D\nswap).\n\nPreconditions:\n\nEither $(D front) and $(D back) are disjoint, or $(D back) is\nreachable from $(D front) and $(D front) is not reachable from $(D\nback).\n\nParams:\n    front = an input range\n    back = a forward range\n\nReturns:\n    The number of elements brought to the front, i.e., the length of $(D back).\n\nSee_Also:\n    $(WEB sgi.com/tech/stl/_rotate.html, STL's rotate)\nExample:\nThe simplest use of $(D bringToFront) is for rotating elements in a\nbuffer. For example:$(DDOX_UNITTEST_HEADER __unittestL179_2985)\n---\nauto arr = [4, 5, 6, 7, 1, 2, 3];\nauto p = bringToFront(arr[0 .. 4], arr[4 .. $]);\nassert(p == arr.length - 4);\nassert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL179_2985)\nExample:\nThe $(D front) range may actually \"step over\" the $(D back)\nrange. This is very useful with forward ranges that cannot compute\ncomfortably right-bounded subranges like $(D arr[0 .. 4]) above. In\nthe example below, $(D r2) is a right subrange of $(D r1).$(DDOX_UNITTEST_HEADER __unittestL193_2986)\n---\nimport std.algorithm.comparison : equal;\nimport std.container : SList;\n\nauto list = SList!(int)(4, 5, 6, 7, 1, 2, 3);\nauto r1 = list[];\nauto r2 = list[]; popFrontN(r2, 4);\nassert(equal(r2, [ 1, 2, 3 ]));\nbringToFront(r1, r2);\nassert(equal(list[], [ 1, 2, 3, 4, 5, 6, 7 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL193_2986)\nExample:\nElements can be swapped across ranges of different types:$(DDOX_UNITTEST_HEADER __unittestL210_2987)\n---\nimport std.algorithm.comparison : equal;\nimport std.container : SList;\n\nauto list = SList!(int)(4, 5, 6, 7);\nauto vec = [ 1, 2, 3 ];\nbringToFront(list[], vec);\nassert(equal(list[], [ 1, 2, 3, 4 ]));\nassert(equal(vec, [ 5, 6, 7 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL210_2987)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isForwardRange!Range2",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "copy",
						"line": 310,
						"type": "TargetRange(SourceRange source, TargetRange target)",
						"parameters": [
							{
								"name": "source",
								"type": "SourceRange"
							},
							{
								"name": "target",
								"type": "TargetRange"
							}
						],
						"endline": 336,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "copy",
				"line": 310,
				"comment": "Copies the content of $(D source) into $(D target) and returns the\nremaining (unfilled) part of $(D target).\n\nPreconditions: $(D target) shall have enough room to accommodate\nthe entirety of $(D source).\n\nParams:\n    source = an input range\n    target = an output range\n\nReturns:\n    The unfilled part of target\n\nSee_Also:\n    $(WEB sgi.com/tech/stl/_copy.html, STL's _copy)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL366_2989)\n---\nint[] a = [ 1, 5 ];\nint[] b = [ 9, 8 ];\nint[] buf = new int[](a.length + b.length + 10);\nauto rem = a.copy(buf);    // copy a into buf\nrem = b.copy(rem);         // copy b into remainder of buf\nassert(buf[0 .. a.length + b.length] == [1, 5, 9, 8]);\nassert(rem.length == 10);   // unused slots in buf\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL366_2989)\nExample:\nAs long as the target range elements support assignment from source\nrange elements, different types of ranges are accepted:$(DDOX_UNITTEST_HEADER __unittestL381_2990)\n---\nfloat[] src = [ 1.0f, 5 ];\ndouble[] dest = new double[src.length];\nsrc.copy(dest);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL381_2990)\nExample:\nTo _copy at most $(D n) elements from a range, you may want to use\n$(XREF range, take):$(DDOX_UNITTEST_HEADER __unittestL392_2991)\n---\nimport std.range;\nint[] src = [ 1, 5, 8, 9, 10 ];\nauto dest = new int[](3);\nsrc.take(dest.length).copy(dest);\nassert(dest == [ 1, 5, 8 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL392_2991)\nExample:\nTo _copy just those elements from a range that satisfy a predicate,\nuse $(LREF filter):$(DDOX_UNITTEST_HEADER __unittestL405_2993)\n---\nimport std.algorithm.iteration : filter;\nint[] src = [ 1, 5, 8, 9, 10, 1, 2, 0 ];\nauto dest = new int[src.length];\nauto rem = src\n    .filter!(a => (a & 1) == 1)\n    .copy(dest);\nassert(dest[0 .. $ - rem.length] == [ 1, 5, 9, 1 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL405_2993)\nExample:\n$(XREF range, retro) can be used to achieve behavior similar to\n$(WEB sgi.com/tech/stl/copy_backward.html, STL's copy_backward'):$(DDOX_UNITTEST_HEADER __unittestL420_2994)\n---\nimport std.algorithm, std.range;\nint[] src = [1, 2, 4];\nint[] dest = [0, 0, 0, 0, 0];\nsrc.retro.copy(dest.retro);\nassert(dest == [0, 0, 1, 2, 4]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL420_2994)\n",
				"parameters": [
					{
						"name": "SourceRange",
						"kind": "type"
					},
					{
						"name": "TargetRange",
						"kind": "type"
					}
				],
				"constraint": "areCopyCompatibleArrays!(SourceRange, TargetRange)",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "copy",
						"line": 339,
						"type": "TargetRange(SourceRange source, TargetRange target)",
						"parameters": [
							{
								"name": "source",
								"type": "SourceRange"
							},
							{
								"name": "target",
								"type": "TargetRange"
							}
						],
						"endline": 363,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "copy",
				"line": 339,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "SourceRange",
						"kind": "type"
					},
					{
						"name": "TargetRange",
						"kind": "type"
					}
				],
				"constraint": "!areCopyCompatibleArrays!(SourceRange, TargetRange) && isInputRange!SourceRange && isOutputRange!(TargetRange, ElementType!SourceRange)",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "fill",
						"line": 488,
						"type": "void(Range range, Value value)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "value",
								"type": "Value"
							}
						],
						"endline": 508,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "fill",
				"line": 488,
				"comment": "Assigns $(D value) to each element of input _range $(D range).\n\nParams:\n        range = An\n                $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n                that exposes references to its elements and has assignable\n                elements\n        value = Assigned to each element of range\n\nSee_Also:\n        $(LREF uninitializedFill)\n        $(LREF initializeAll)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL511_2997)\n---\nint[] a = [ 1, 2, 3, 4 ];\nfill(a, 5);\nassert(a == [ 5, 5, 5, 5 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL511_2997)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Value",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(typeof(range.front = value))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "fill",
						"line": 599,
						"type": "void(Range1 range, Range2 filler)",
						"parameters": [
							{
								"name": "range",
								"type": "Range1"
							},
							{
								"name": "filler",
								"type": "Range2"
							}
						],
						"endline": 666,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "fill",
				"line": 599,
				"comment": "Fills $(D range) with a pattern copied from $(D filler). The length of\n$(D range) does not have to be a multiple of the length of $(D\nfiller). If $(D filler) is empty, an exception is thrown.\n\nParams:\n    range = An $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n            that exposes references to its elements and has assignable elements.\n    filler = The\n             $(XREF_PACK_NAMED _range,primitives,isForwardRange,forward _range)\n             representing the _fill pattern.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL669_3001)\n---\nint[] a = [ 1, 2, 3, 4, 5 ];\nint[] b = [ 8, 9 ];\nfill(a, b);\nassert(a == [ 8, 9, 8, 9, 8 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL669_3001)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && (isForwardRange!Range2 || isInputRange!Range2 && isInfinite!Range2) && is(typeof(Range1.init.front = Range2.init.front))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "initializeAll",
						"line": 723,
						"type": "void(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 750,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "initializeAll",
				"line": 723,
				"comment": "Initializes all elements of $(D range) with their $(D .init) value.\nAssumes that the elements of the range are uninitialized.\n\nParams:\n        range = An\n                $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n                that exposes references to its elements and has assignable\n                elements\n\nSee_Also:\n        $(LREF fill)\n        $(LREF uninitializeFill)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL761_3003)\n---\nimport core.stdc.stdlib: malloc, free;\n\nstruct S\n{\n    int a = 10;\n}\n\nauto s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\ninitializeAll(s);\nassert(s == [S(10), S(10), S(10), S(10), S(10)]);\n\nscope(exit) free(s.ptr);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL761_3003)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && hasLvalueElements!Range && hasAssignableElements!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "initializeAll",
						"line": 753,
						"type": "void(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 758,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "initializeAll",
				"line": 753,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "is(Range == char[]) || is(Range == wchar[])",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "move",
						"line": 876,
						"type": "void(ref T source, ref T target)",
						"parameters": [
							{
								"name": "source",
								"type": "T",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "target",
								"type": "T",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 883,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "move",
				"line": 876,
				"comment": "Moves $(D source) into $(D target) via a destructive copy.\n\nParams:\n    source = Data to copy. If a destructor or postblit is defined, it is reset\n        to its $(D .init) value after it is moved into target.  Note that data\n        with internal pointers that point to itself cannot be moved, and will\n        trigger an assertion failure.\n    target = Where to copy into. The destructor, if any, is invoked before the\n        copy is performed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL886_3005)\n---\nObject obj1 = new Object;\nObject obj2 = obj1;\nObject obj3;\n\nmove(obj2, obj3);\nassert(obj3 is obj1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL886_3005)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL897_3006)\n---\n// Structs without destructors are simply copied\nstruct S1\n{\n    int a = 1;\n    int b = 2;\n}\nS1 s11 = { 10, 11 };\nS1 s12;\n\nmove(s11, s12);\n\nassert(s11.a == 10 && s11.b == 11 &&\n       s12.a == 10 && s12.b == 11);\n\n// But structs with destructors or postblits are reset to their .init value\n// after copying to the target.\nstruct S2\n{\n    int a = 1;\n    int b = 2;\n\n    ~this() pure nothrow @safe @nogc { }\n}\nS2 s21 = { 3, 4 };\nS2 s22;\n\nmove(s21, s22);\n\nassert(s21.a == 1 && s21.b == 2 &&\n       s22.a == 3 && s22.b == 4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL897_3006)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1004_3008)\n---\nstruct S\n{\n    @disable this(this);\n    ~this() pure nothrow @safe @nogc {}\n}\nS s1;\nS s2 = move(s1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1004_3008)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "move",
						"line": 994,
						"type": "T(ref T source)",
						"parameters": [
							{
								"name": "source",
								"type": "T",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1001,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "move",
				"line": 994,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveEmplace",
						"line": 1192,
						"type": "@system void(ref T source, ref T target)",
						"parameters": [
							{
								"name": "source",
								"type": "T",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "target",
								"type": "T",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1237,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "moveEmplace",
				"line": 1192,
				"comment": " Similar to $(LREF move) but assumes `target` is uninitialized. This\n is more efficient because `source` can be blitted over `target`\n without destroying or initializing it first.\n\n Params:\n   source = value to be moved into target\n   target = uninitialized value to be filled by source\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1240_3014)\n---\nstatic struct Foo\n{\npure nothrow @nogc:\n    this(int* ptr) { _ptr = ptr; }\n    ~this() { if (_ptr) ++*_ptr; }\n    int* _ptr;\n}\n\nint val;\nFoo foo1 = void; // uninitialized\nauto foo2 = Foo(&val); // initialized\n\n// Using `move(foo2, foo1)` has an undefined effect because it destroys the uninitialized foo1.\n// MoveEmplace directly overwrites foo1 without destroying or initializing it first.\nassert(foo2._ptr is &val);\nmoveEmplace(foo2, foo1);\nassert(foo1._ptr is &val && foo2._ptr is null);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1240_3014)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveAll",
						"line": 1280,
						"type": "Range2(Range1 src, Range2 tgt)",
						"parameters": [
							{
								"name": "src",
								"type": "Range1"
							},
							{
								"name": "tgt",
								"type": "Range2"
							}
						],
						"endline": 1285,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "moveAll",
				"line": 1280,
				"comment": "For each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)).\n\nPreconditions:\n$(D walkLength(src) <= walkLength(tgt)).\nThis precondition will be asserted. If you cannot ensure there is enough room in\n`tgt` to accommodate all of `src` use $(LREF moveSome) instead.\n\nParams:\n    src = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) with\n        movable elements.\n    tgt = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) with\n        elements that elements from $(D src) can be moved into.\n\nReturns: The leftover portion of $(D tgt) after all elements from $(D src) have\nbeen moved.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1288_3015)\n---\nint[3] a = [ 1, 2, 3 ];\nint[5] b;\nassert(moveAll(a[], b[]) is b[3 .. $]);\nassert(a[] == b[0 .. 3]);\nint[3] cmp = [ 1, 2, 3 ];\nassert(a[] == cmp[]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1288_3015)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(typeof(move(src.front, tgt.front)))",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveEmplaceAll",
						"line": 1303,
						"type": "@system Range2(Range1 src, Range2 tgt)",
						"parameters": [
							{
								"name": "src",
								"type": "Range1"
							},
							{
								"name": "tgt",
								"type": "Range2"
							}
						],
						"endline": 1308,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "moveEmplaceAll",
				"line": 1303,
				"comment": " Similar to $(LREF moveAll) but assumes all elements in `target` are\n uninitialized. Uses $(LREF moveEmplace) to move elements from\n `source` over elements from `target`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1311_3018)\n---\nstatic struct Foo\n{\n    ~this() pure nothrow @nogc { if (_ptr) ++*_ptr; }\n    int* _ptr;\n}\nint[3] refs = [0, 1, 2];\nFoo[3] src = [Foo(&refs[0]), Foo(&refs[1]), Foo(&refs[2])];\nFoo[5] dst = void;\n\nauto tail = moveEmplaceAll(src[], dst[]); // move 3 value from src over dst\nassert(tail.length == 2); // returns remaining uninitialized values\ninitializeAll(tail);\n\nimport std.algorithm.searching : all;\nassert(src[].all!(e => e._ptr is null));\nassert(dst[0 .. 3].all!(e => e._ptr !is null));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1311_3018)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(typeof(moveEmplace(src.front, tgt.front)))",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveSome",
						"line": 1387,
						"type": "Tuple!(Range1, Range2)(Range1 src, Range2 tgt)",
						"parameters": [
							{
								"name": "src",
								"type": "Range1"
							},
							{
								"name": "tgt",
								"type": "Range2"
							}
						],
						"endline": 1392,
						"char": 24,
						"kind": "function"
					}
				],
				"name": "moveSome",
				"line": 1387,
				"comment": "For each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)). Stops\nwhen either $(D src) or $(D tgt) have been exhausted.\n\nParams:\n    src = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) with\n        movable elements.\n    tgt = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) with\n        elements that elements from $(D src) can be moved into.\n\nReturns: The leftover portions of the two ranges after one or the other of the\nranges have been exhausted.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1395_3020)\n---\nint[5] a = [ 1, 2, 3, 4, 5 ];\nint[3] b;\nassert(moveSome(a[], b[])[0] is a[3 .. $]);\nassert(a[0 .. 3] == b);\nassert(a == [ 1, 2, 3, 4, 5 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1395_3020)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(typeof(move(src.front, tgt.front)))",
				"char": 24,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveEmplaceSome",
						"line": 1409,
						"type": "@system Tuple!(Range1, Range2)(Range1 src, Range2 tgt)",
						"parameters": [
							{
								"name": "src",
								"type": "Range1"
							},
							{
								"name": "tgt",
								"type": "Range2"
							}
						],
						"endline": 1414,
						"char": 24,
						"kind": "function"
					}
				],
				"name": "moveEmplaceSome",
				"line": 1409,
				"comment": " Same as $(LREF moveSome) but assumes all elements in `target` are\n uninitialized. Uses $(LREF moveEmplace) to move elements from\n `source` over elements from `target`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1417_3023)\n---\nstatic struct Foo\n{\n    ~this() pure nothrow @nogc { if (_ptr) ++*_ptr; }\n    int* _ptr;\n}\nint[4] refs = [0, 1, 2, 3];\nFoo[4] src = [Foo(&refs[0]), Foo(&refs[1]), Foo(&refs[2]), Foo(&refs[3])];\nFoo[3] dst = void;\n\nauto res = moveEmplaceSome(src[], dst[]);\n\nimport std.algorithm.searching : all;\nassert(src[0 .. 3].all!(e => e._ptr is null));\nassert(src[3]._ptr !is null);\nassert(dst[].all!(e => e._ptr !is null));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1417_3023)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(typeof(move(src.front, tgt.front)))",
				"char": 24,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "unstable",
						"line": 1483,
						"value": "0",
						"comment": "       Allows freely swapping of elements as long as the output\n       satisfies the algorithm's requirements.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "semistable",
						"line": 1488,
						"value": "1",
						"comment": "       In algorithms partitioning ranges in two, preserve relative\n       ordering of elements only to the left of the partition point.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stable",
						"line": 1493,
						"value": "2",
						"comment": "       Preserve the relative ordering of elements to the largest\n       extent allowed by the algorithm's requirements.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SwapStrategy",
				"line": 1477,
				"comment": "Defines the swapping strategy for algorithms that need to swap\nelements in a range (such as partition and sort). The strategy\nconcerns the swapping of elements that are not the core concern of the\nalgorithm. For example, consider an algorithm that sorts $(D [ \"abc\",\n\"b\", \"aBc\" ]) according to $(D toUpper(a) < toUpper(b)). That\nalgorithm might choose to swap the two equivalent strings $(D \"abc\")\nand $(D \"aBc\"). That does not affect the sorting since both $(D [\n\"abc\", \"aBc\", \"b\" ]) and $(D [ \"aBc\", \"abc\", \"b\" ]) are valid\noutcomes.\n\nSome situations require that the algorithm must NOT ever change the\nrelative ordering of equivalent elements (in the example above, only\n$(D [ \"abc\", \"aBc\", \"b\" ]) would be the correct result). Such\nalgorithms are called $(B stable). If the ordering algorithm may swap\nequivalent elements discretionarily, the ordering is called $(B\nunstable).\n\nYet another class of algorithms may choose an intermediate tradeoff by\nbeing stable only on a well-defined subrange of the range. There is no\nestablished terminology for such behavior; this library calls it $(B\nsemistable).\n\nGenerally, the $(D stable) ordering strategy may be more costly in\ntime and/or space than the other two because it imposes additional\nconstraints. Similarly, $(D semistable) may be costlier than $(D\nunstable). As (semi-)stability is not needed very often, the ordering\nalgorithms in this module parameterized by $(D SwapStrategy) all\nchoose $(D SwapStrategy.unstable) as the default.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "remove",
						"line": 1578,
						"type": "Range(Range range, Offset offset)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "offset",
								"type": "Offset"
							}
						],
						"endline": 1658,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "remove",
				"line": 1578,
				"comment": "Eliminates elements at given offsets from $(D range) and returns the\nshortened range. In the simplest call, one element is removed.\n\n----\nint[] a = [ 3, 5, 7, 8 ];\nassert(remove(a, 1) == [ 3, 7, 8 ]);\nassert(a == [ 3, 7, 8, 8 ]);\n----\n\nIn the case above the element at offset $(D 1) is removed and $(D\nremove) returns the range smaller by one element. The original array\nhas remained of the same length because all functions in $(D\nstd.algorithm) only change $(I content), not $(I topology). The value\n$(D 8) is repeated because $(LREF move) was invoked to\nmove elements around and on integers $(D move) simply copies the source to\nthe destination. To replace $(D a) with the effect of the removal,\nsimply assign $(D a = remove(a, 1)). The slice will be rebound to the\nshorter array and the operation completes with maximal efficiency.\n\nMultiple indices can be passed into $(D remove). In that case,\nelements at the respective indices are all removed. The indices must\nbe passed in increasing order, otherwise an exception occurs.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, 3, 5) ==\n    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);\n----\n\n(Note how all indices refer to slots in the $(I original) array, not\nin the array as it is being progressively shortened.) Finally, any\ncombination of integral offsets and tuples composed of two integral\noffsets can be passed in.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, tuple(3, 5), 9) == [ 0, 2, 6, 7, 8, 10 ]);\n----\n\nIn this case, the slots at positions 1, 3, 4, and 9 are removed from\nthe array. The tuple passes in a range closed to the left and open to\nthe right (consistent with built-in slices), e.g. $(D tuple(3, 5))\nmeans indices $(D 3) and $(D 4) but not $(D 5).\n\nIf the need is to remove some elements in the range but the order of\nthe remaining elements does not have to be preserved, you may want to\npass $(D SwapStrategy.unstable) to $(D remove).\n\n----\nint[] a = [ 0, 1, 2, 3 ];\nassert(remove!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);\n----\n\nIn the case above, the element at slot $(D 1) is removed, but replaced\nwith the last element of the range. Taking advantage of the relaxation\nof the stability requirement, $(D remove) moved elements from the end\nof the array over the slots to be removed. This way there is less data\nmovement to be done which improves the execution time of the function.\n\nThe function $(D remove) works on any forward range. The moving\nstrategy is (listed from fastest to slowest): $(UL $(LI If $(D s ==\nSwapStrategy.unstable && isRandomAccessRange!Range && hasLength!Range\n&& hasLvalueElements!Range), then elements are moved from the end\nof the range into the slots to be filled. In this case, the absolute\nminimum of moves is performed.)  $(LI Otherwise, if $(D s ==\nSwapStrategy.unstable && isBidirectionalRange!Range && hasLength!Range\n&& hasLvalueElements!Range), then elements are still moved from the\nend of the range, but time is spent on advancing between slots by repeated\ncalls to $(D range.popFront).)  $(LI Otherwise, elements are moved\nincrementally towards the front of $(D range); a given element is never\nmoved several times, but more elements are moved than in the previous\ncases.))\n\nParams:\n    s = a SwapStrategy to determine if the original order needs to be preserved\n    range = a bidirectional range with a length member\n    offset = which element(s) to remove\n\nReturns:\n    a range containing all of the elements of range with offset removed\n",
				"parameters": [
					{
						"name": "s",
						"defaultValue": "SwapStrategy.stable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Offset",
						"kind": "tuple"
					}
				],
				"constraint": "s != SwapStrategy.stable && isBidirectionalRange!Range && hasLvalueElements!Range && hasLength!Range && Offset.length >= 1",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "remove",
						"line": 1806,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 1844,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "remove",
				"line": 1806,
				"comment": "Reduces the length of the bidirectional range $(D range) by removing\nelements that satisfy $(D pred). If $(D s = SwapStrategy.unstable),\nelements are moved from the right end of the range over the elements\nto eliminate. If $(D s = SwapStrategy.stable) (the default),\nelements are moved progressively to front such that their relative\norder is preserved. Returns the filtered range.\n\nParams:\n    range = a bidirectional ranges with lvalue elements\n\nReturns:\n    the range with all of the elements where $(D pred) is $(D true)\n    removed\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1847_3029)\n---\nstatic immutable base = [1, 2, 3, 2, 4, 2, 5, 2];\n\nint[] arr = base[].dup;\n\n// using a string-based predicate\nassert(remove!(\"a == 2\")(arr) == [ 1, 3, 4, 5 ]);\n\n// The original array contents have been modified,\n// so we need to reset it to its original state.\n// The length is unmodified however.\narr[] = base[];\n\n// using a lambda predicate\nassert(remove!(a => a == 2)(arr) == [ 1, 3, 4, 5 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1847_3029)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "s",
						"defaultValue": "SwapStrategy.stable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && hasLvalueElements!Range",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reverse",
						"line": 1889,
						"type": "void(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1900,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "reverse",
				"line": 1889,
				"comment": "Reverses $(D r) in-place.  Performs $(D r.length / 2) evaluations of $(D\nswap).\n\nParams:\n    r = a bidirectional range with swappable elements or a random access range with a length member\n\nSee_Also:\n    $(WEB sgi.com/tech/stl/_reverse.html, STL's _reverse)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1903_3031)\n---\nint[] arr = [ 1, 2, 3 ];\nreverse(arr);\nassert(arr == [ 3, 2, 1 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1903_3031)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && !isRandomAccessRange!Range && hasSwappableElements!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reverse",
						"line": 1911,
						"type": "void(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1921,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "reverse",
				"line": 1911,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && hasLength!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reverse",
						"line": 1954,
						"type": "void(Char[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "Char[]"
							}
						],
						"endline": 1975,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "reverse",
				"line": 1954,
				"comment": "Reverses $(D r) in-place, where $(D r) is a narrow string (having\nelements of type $(D char) or $(D wchar)). UTF sequences consisting of\nmultiple code units are preserved properly.\n\nParams:\n    s = a narrow string\n\nBugs:\n    When passing a sting with unicode modifiers on characters, such as $(D \\u0301),\n    this function will not properly keep the position of the modifier. For example,\n    reversing $(D ba\\u0301d) (\"bád\") will result in d\\u0301ab (\"d́ab\") instead of\n    $(D da\\u0301b) (\"dáb\").\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1978_3033)\n---\nchar[] arr = \"hello\\U00010143\\u0100\\U00010143\".dup;\nreverse(arr);\nassert(arr == \"\\U00010143\\u0100\\U00010143olleh\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1978_3033)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isNarrowString!(Char[]) && !is(Char == const) && !is(Char == immutable)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strip",
						"line": 2045,
						"type": "Range(Range range, E element)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "element",
								"type": "E"
							}
						],
						"endline": 2049,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "strip",
				"line": 2045,
				"comment": "    The strip group of functions allow stripping of either leading, trailing,\n    or both leading and trailing elements.\n\n    The $(D stripLeft) function will strip the $(D front) of the range,\n    the $(D stripRight) function will strip the $(D back) of the range,\n    while the $(D strip) function will strip both the $(D front) and $(D back)\n    of the range.\n\n    Note that the $(D strip) and $(D stripRight) functions require the range to\n    be a $(LREF BidirectionalRange) range.\n\n    All of these functions come in two varieties: one takes a target element,\n    where the range will be stripped as long as this element can be found.\n    The other takes a lambda predicate, where the range will be stripped as\n    long as the predicate returns true.\n\n    Params:\n        range = a bidirectional or input range\n        element = the elements to remove\n\n    Returns:\n        a Range with all of range except element at the start and end\nExample:\nStrip leading and trailing elements equal to the target element.$(DDOX_UNITTEST_HEADER __unittestL2101_3036)\n---\nassert(\"  foobar  \".strip(' ') == \"foobar\");\nassert(\"00223.444500\".strip('0') == \"223.4445\");\nassert(\"ëëêéüŗōpéêëë\".strip('ë') == \"êéüŗōpéê\");\nassert([1, 1, 0, 1, 1].strip(1) == [0]);\nassert([0.0, 0.01, 0.01, 0.0].strip(0).length == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2101_3036)\nExample:\nStrip leading and trailing elements while the predicate returns true.$(DDOX_UNITTEST_HEADER __unittestL2111_3042)\n---\nassert(\"  foobar  \".strip!(a => a == ' ')() == \"foobar\");\nassert(\"00223.444500\".strip!(a => a == '0')() == \"223.4445\");\nassert(\"ëëêéüŗōpéêëë\".strip!(a => a == 'ë')() == \"êéüŗōpéê\");\nassert([1, 1, 0, 1, 1].strip!(a => a == 1)() == [0]);\nassert([0.0, 0.01, 0.5, 0.6, 0.01, 0.0].strip!(a => a < 0.4)().length == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2111_3042)\nExample:\nStrip leading elements equal to the target element.$(DDOX_UNITTEST_HEADER __unittestL2121_3043)\n---\nassert(\"  foobar  \".stripLeft(' ') == \"foobar  \");\nassert(\"00223.444500\".stripLeft('0') == \"223.444500\");\nassert(\"ůůűniçodêéé\".stripLeft('ů') == \"űniçodêéé\");\nassert([1, 1, 0, 1, 1].stripLeft(1) == [0, 1, 1]);\nassert([0.0, 0.01, 0.01, 0.0].stripLeft(0).length == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2121_3043)\nExample:\nStrip leading elements while the predicate returns true.$(DDOX_UNITTEST_HEADER __unittestL2131_3049)\n---\nassert(\"  foobar  \".stripLeft!(a => a == ' ')() == \"foobar  \");\nassert(\"00223.444500\".stripLeft!(a => a == '0')() == \"223.444500\");\nassert(\"ůůűniçodêéé\".stripLeft!(a => a == 'ů')() == \"űniçodêéé\");\nassert([1, 1, 0, 1, 1].stripLeft!(a => a == 1)() == [0, 1, 1]);\nassert([0.0, 0.01, 0.10, 0.5, 0.6].stripLeft!(a => a < 0.4)().length == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2131_3049)\nExample:\nStrip trailing elements equal to the target element.$(DDOX_UNITTEST_HEADER __unittestL2141_3050)\n---\nassert(\"  foobar  \".stripRight(' ') == \"  foobar\");\nassert(\"00223.444500\".stripRight('0') == \"00223.4445\");\nassert(\"ùniçodêéé\".stripRight('é') == \"ùniçodê\");\nassert([1, 1, 0, 1, 1].stripRight(1) == [1, 1, 0]);\nassert([0.0, 0.01, 0.01, 0.0].stripRight(0).length == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2141_3050)\nExample:\nStrip trailing elements while the predicate returns true.$(DDOX_UNITTEST_HEADER __unittestL2151_3056)\n---\nassert(\"  foobar  \".stripRight!(a => a == ' ')() == \"  foobar\");\nassert(\"00223.444500\".stripRight!(a => a == '0')() == \"00223.4445\");\nassert(\"ùniçodêéé\".stripRight!(a => a == 'é')() == \"ùniçodê\");\nassert([1, 1, 0, 1, 1].stripRight!(a => a == 1)() == [1, 1, 0]);\nassert([0.0, 0.01, 0.10, 0.5, 0.6].stripRight!(a => a > 0.4)().length == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2151_3056)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && is(typeof(range.front == element) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strip",
						"line": 2052,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 2056,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "strip",
				"line": 2052,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && is(typeof(pred(range.back)) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripLeft",
						"line": 2059,
						"type": "Range(Range range, E element)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "element",
								"type": "E"
							}
						],
						"endline": 2064,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "stripLeft",
				"line": 2059,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(typeof(range.front == element) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripLeft",
						"line": 2067,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 2074,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "stripLeft",
				"line": 2067,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(typeof(pred(range.front)) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripRight",
						"line": 2077,
						"type": "Range(Range range, E element)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "element",
								"type": "E"
							}
						],
						"endline": 2086,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "stripRight",
				"line": 2077,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && is(typeof(range.back == element) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripRight",
						"line": 2089,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 2098,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "stripRight",
				"line": 2089,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && is(typeof(pred(range.back)) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "swap",
						"line": 2175,
						"type": "pure nothrow @nogc @trusted void(ref T lhs, ref T rhs)",
						"parameters": [
							{
								"name": "lhs",
								"type": "T",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "rhs",
								"type": "T",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 2221,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "swap",
				"line": 2175,
				"comment": "Swaps $(D lhs) and $(D rhs). The instances $(D lhs) and $(D rhs) are moved in\nmemory, without ever calling $(D opAssign), nor any other function. $(D T)\nneed not be assignable at all to be swapped.\n\nIf $(D lhs) and $(D rhs) reference the same instance, then nothing is done.\n\n$(D lhs) and $(D rhs) must be mutable. If $(D T) is a struct or union, then\nits fields must also all be (recursively) mutable.\n\nParams:\n    lhs = Data to be swapped with $(D rhs).\n    rhs = Data to be swapped with $(D lhs).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2224_3057)\n---\n// Swapping POD (plain old data) types:\nint a = 42, b = 34;\nswap(a, b);\nassert(a == 34 && b == 42);\n\n// Swapping structs with indirection:\nstatic struct S { int x; char c; int[] y; }\nS s1 = { 0, 'z', [ 1, 2 ] };\nS s2 = { 42, 'a', [ 4, 6 ] };\nswap(s1, s2);\nassert(s1.x == 42);\nassert(s1.c == 'a');\nassert(s1.y == [ 4, 6 ]);\n\nassert(s2.x == 0);\nassert(s2.c == 'z');\nassert(s2.y == [ 1, 2 ]);\n\n// Immutables cannot be swapped:\nimmutable int imm1, imm2;\nstatic assert(!__traits(compiles, swap(imm1, imm2)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2224_3057)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2250_3058)\n---\n// Non-copyable types can still be swapped.\nstatic struct NoCopy\n{\n    this(this) { assert(0); }\n    int n;\n    string s;\n}\nNoCopy nc1, nc2;\nnc1.n = 127; nc1.s = \"abc\";\nnc2.n = 513; nc2.s = \"uvwxyz\";\n\nswap(nc1, nc2);\nassert(nc1.n == 513 && nc1.s == \"uvwxyz\");\nassert(nc2.n == 127 && nc2.s == \"abc\");\n\nswap(nc1, nc1);\nswap(nc2, nc2);\nassert(nc1.n == 513 && nc1.s == \"uvwxyz\");\nassert(nc2.n == 127 && nc2.s == \"abc\");\n\n// Types containing non-copyable fields can also be swapped.\nstatic struct NoCopyHolder\n{\n    NoCopy noCopy;\n}\nNoCopyHolder h1, h2;\nh1.noCopy.n = 31; h1.noCopy.s = \"abc\";\nh2.noCopy.n = 65; h2.noCopy.s = null;\n\nswap(h1, h2);\nassert(h1.noCopy.n == 65 && h1.noCopy.s == null);\nassert(h2.noCopy.n == 31 && h2.noCopy.s == \"abc\");\n\nswap(h1, h1);\nswap(h2, h2);\nassert(h1.noCopy.n == 65 && h1.noCopy.s == null);\nassert(h2.noCopy.n == 31 && h2.noCopy.s == \"abc\");\n\n// Const types cannot be swapped.\nconst NoCopy const1, const2;\nstatic assert(!__traits(compiles, swap(const1, const2)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2250_3058)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isBlitAssignable!T && !is(typeof(lhs.proxySwap(rhs)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "swapRanges",
						"line": 2425,
						"type": "Tuple!(Range1, Range2)(Range1 r1, Range2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "Range1"
							},
							{
								"name": "r2",
								"type": "Range2"
							}
						],
						"endline": 2435,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "swapRanges",
				"line": 2425,
				"comment": "Swaps all elements of $(D r1) with successive elements in $(D r2).\nReturns a tuple containing the remainder portions of $(D r1) and $(D\nr2) that were not swapped (one of them will be empty). The ranges may\nbe of different types but must have the same element type and support\nswapping.\n\nParams:\n    r1 = an $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n         with swappable elements\n    r2 = an $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n         with swappable elements\n\nReturns:\n    Tuple containing the remainder portions of r1 and r2 that were not swapped\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2438_3066)\n---\nint[] a = [ 100, 101, 102, 103 ];\nint[] b = [ 0, 1, 2, 3 ];\nauto c = swapRanges(a[1 .. 3], b[2 .. 4]);\nassert(c[0].empty && c[1].empty);\nassert(a == [ 100, 2, 3, 103 ]);\nassert(b == [ 0, 1, 101, 102 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2438_3066)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && hasSwappableElements!Range1 && hasSwappableElements!Range2 && is(ElementType!Range1 == ElementType!Range2)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uninitializedFill",
						"line": 2466,
						"type": "void(Range range, Value value)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "value",
								"type": "Value"
							}
						],
						"endline": 2483,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "uninitializedFill",
				"line": 2466,
				"comment": "Initializes each element of $(D range) with $(D value).\nAssumes that the elements of the range are uninitialized.\nThis is of interest for structs that\ndefine copy constructors (for all other types, $(LREF fill) and\nuninitializedFill are equivalent).\n\nParams:\n        range = An\n                $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n                that exposes references to its elements and has assignable\n                elements\n        value = Assigned to each element of range\n\nSee_Also:\n        $(LREF fill)\n        $(LREF initializeAll)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2486_3067)\n---\nimport core.stdc.stdlib : malloc, free;\n\nauto s = (cast(int*) malloc(5 * int.sizeof))[0 .. 5];\nuninitializedFill(s, 42);\nassert(s == [ 42, 42, 42, 42, 42 ]);\n\nscope(exit) free(s.ptr);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2486_3067)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Value",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && hasLvalueElements!Range && is(typeof(range.front = value))",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic _mutation algorithms.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 bringToFront,\n        If $(D a = [1, 2, 3]) and $(D b = [4, 5, 6, 7]),\n        $(D bringToFront(a, b)) leaves $(D a = [4, 5, 6]) and\n        $(D b = [7, 1, 2, 3]).)\n$(T2 copy,\n        Copies a range to another. If\n        $(D a = [1, 2, 3]) and $(D b = new int[5]), then $(D copy(a, b))\n        leaves $(D b = [1, 2, 3, 0, 0]) and returns $(D b[3 .. $]).)\n$(T2 fill,\n        Fills a range with a pattern,\n        e.g., if $(D a = new int[3]), then $(D fill(a, 4))\n        leaves $(D a = [4, 4, 4]) and $(D fill(a, [3, 4])) leaves\n        $(D a = [3, 4, 3]).)\n$(T2 initializeAll,\n        If $(D a = [1.2, 3.4]), then $(D initializeAll(a)) leaves\n        $(D a = [double.init, double.init]).)\n$(T2 move,\n        $(D move(a, b)) moves $(D a) into $(D b). $(D move(a)) reads $(D a)\n        destructively.)\n$(T2 moveAll,\n        Moves all elements from one range to another.)\n$(T2 moveSome,\n        Moves as many elements as possible from one range to another.)\n$(T2 remove,\n        Removes elements from a range in-place, and returns the shortened\n        range.)\n$(T2 reverse,\n        If $(D a = [1, 2, 3]), $(D reverse(a)) changes it to $(D [3, 2, 1]).)\n$(T2 strip,\n        Strips all leading and trailing elements equal to a value, or that\n        satisfy a predicate.\n        If $(D a = [1, 1, 0, 1, 1]), then $(D strip(a, 1)) and\n        $(D strip!(e => e == 1)(a)) returns $(D [0]).)\n$(T2 stripLeft,\n        Strips all leading elements equal to a value, or that satisfy a\n        predicate.  If $(D a = [1, 1, 0, 1, 1]), then $(D stripLeft(a, 1)) and\n        $(D stripLeft!(e => e == 1)(a)) returns $(D [0, 1, 1]).)\n$(T2 stripRight,\n        Strips all trailing elements equal to a value, or that satisfy a\n        predicate.\n        If $(D a = [1, 1, 0, 1, 1]), then $(D stripRight(a, 1)) and\n        $(D stripRight!(e => e == 1)(a)) returns $(D [1, 1, 0]).)\n$(T2 swap,\n        Swaps two values.)\n$(T2 swapRanges,\n        Swaps all elements of two ranges.)\n$(T2 uninitializedFill,\n        Fills a range (assumed uninitialized) with a value.)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_mutation.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/sorting.d",
		"name": "std.algorithm.sorting",
		"members": [
			{
				"members": [
					{
						"name": "no",
						"line": 83,
						"value": "0",
						"comment": "Don't sort output\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 84,
						"value": "1",
						"comment": "Sort output\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SortOutput",
				"line": 81,
				"comment": "Specifies whether the output of certain algorithm is desired in sorted\nformat.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "completeSort",
						"line": 104,
						"type": "void(SortedRange!(Range1, less) lhs, Range2 rhs)",
						"parameters": [
							{
								"name": "lhs",
								"type": "SortedRange!(Range1, less)"
							},
							{
								"name": "rhs",
								"type": "Range2"
							}
						],
						"endline": 120,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "completeSort",
				"line": 104,
				"comment": "Sorts the random-access range $(D chain(lhs, rhs)) according to\npredicate $(D less). The left-hand side of the range $(D lhs) is\nassumed to be already sorted; $(D rhs) is assumed to be unsorted. The\nexact strategy chosen depends on the relative sizes of $(D lhs) and\n$(D rhs).  Performs $(BIGOH lhs.length + rhs.length * log(rhs.length))\n(best case) to $(BIGOH (lhs.length + rhs.length) * log(lhs.length +\nrhs.length)) (worst-case) evaluations of $(D swap).\n\nParams:\n    less = The predicate to sort by.\n    ss = The swapping strategy to use.\n    lhs = The sorted, left-hand side of the random access range to be sorted.\n    rhs = The unsorted, right-hand side of the random access range to be\n        sorted.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL123_3068)\n---\nimport std.range : assumeSorted;\nint[] a = [ 1, 2, 3 ];\nint[] b = [ 4, 0, 6, 5 ];\ncompleteSort(assumeSorted(a), b);\nassert(a == [ 0, 1, 2 ]);\nassert(b == [ 3, 4, 5, 6 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL123_3068)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "hasLength!Range2 && hasSlicing!Range2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isSorted",
						"line": 145,
						"type": "bool(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 180,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isSorted",
				"line": 145,
				"comment": "Checks whether a forward range is sorted according to the comparison\noperation $(D less). Performs $(BIGOH r.length) evaluations of $(D\nless).\n\nParams:\n    less = Predicate the range should be sorted by.\n    r = Forward range to check for sortedness.\n\nReturns: true if the range is sorted, false otherwise.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL183_3069)\n---\nint[] arr = [4, 3, 2, 1];\nassert(!isSorted(arr));\nsort(arr);\nassert(isSorted(arr));\nsort!(\"a > b\")(arr);\nassert(isSorted!(\"a > b\")(arr));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL183_3069)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ordered",
						"line": 237,
						"type": "bool(T values)",
						"parameters": [
							{
								"name": "values",
								"type": "T"
							}
						],
						"endline": 254,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "ordered",
				"line": 237,
				"comment": "Like $(D isSorted), returns $(D true) if the given $(D values) are ordered\naccording to the comparison operation $(D less). Unlike $(D isSorted), takes values\ndirectly instead of structured in a range.\n\n$(D ordered) allows repeated values, e.g. $(D ordered(1, 1, 2)) is $(D true). To verify\nthat the values are ordered strictly monotonically, use $(D strictlyOrdered);\n$(D strictlyOrdered(1, 1, 2)) is $(D false).\n\nWith either function, the predicate must be a strict ordering just like with $(D isSorted). For\nexample, using $(D \"a <= b\") instead of $(D \"a < b\") is incorrect and will cause failed\nassertions.\n\nParams:\n    values = The tested value\n    less = The comparison predicate\n\nReturns:\n    $(D true) if the values are ordered; $(D ordered) allows for duplicates,\n    $(D strictlyOrdered) does not.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL273_3075)\n---\nassert(ordered(42, 42, 43));\nassert(!strictlyOrdered(43, 42, 45));\nassert(ordered(42, 42, 43));\nassert(!strictlyOrdered(42, 42, 43));\nassert(!ordered(43, 42, 45));\n// Ordered lexicographically\nassert(ordered(\"Jane\", \"Jim\", \"Joe\"));\nassert(strictlyOrdered(\"Jane\", \"Jim\", \"Joe\"));\n// Incidentally also ordered by length decreasing\nassert(ordered!((a, b) => a.length > b.length)(\"Jane\", \"Jim\", \"Joe\"));\n// ... but not strictly so: \"Jim\" and \"Joe\" have the same length\nassert(!strictlyOrdered!((a, b) => a.length > b.length)(\"Jane\", \"Jim\", \"Joe\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL273_3075)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 2 && is(typeof(binaryFun!less(values[1], values[0])) : bool) || T.length > 2 && is(typeof(ordered!less(values[0..1 + __dollar / 2]))) && is(typeof(ordered!less(values[__dollar / 2..__dollar])))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strictlyOrdered",
						"line": 257,
						"type": "bool(T values)",
						"parameters": [
							{
								"name": "values",
								"type": "T"
							}
						],
						"endline": 270,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strictlyOrdered",
				"line": 257,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "is(typeof(ordered!less(values)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "partition",
						"line": 321,
						"type": "Range(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 399,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "partition",
				"line": 321,
				"comment": "Partitions a range in two using the given $(D predicate).\nSpecifically, reorders the range $(D r = [left, right$(RPAREN)) using $(D swap)\nsuch that all elements $(D i) for which $(D predicate(i)) is $(D true) come\nbefore all elements $(D j) for which $(D predicate(j)) returns $(D false).\n\nPerforms $(BIGOH r.length) (if unstable or semistable) or $(BIGOH\nr.length * log(r.length)) (if stable) evaluations of $(D less) and $(D\nswap). The unstable version computes the minimum possible evaluations\nof $(D swap) (roughly half of those performed by the semistable\nversion).\n\nParams:\n    predicate = The predicate to partition by.\n    ss = The swapping strategy to employ.\n    r = The random-access range to partition.\n\nReturns:\n\nThe right part of $(D r) after partitioning.\n\nIf $(D ss == SwapStrategy.stable), $(D partition) preserves the relative\nordering of all elements $(D a), $(D b) in $(D r) for which $(D predicate(a) ==\npredicate(b)). If $(D ss == SwapStrategy.semistable), $(D partition) preserves\nthe relative ordering of all elements $(D a), $(D b) in the left part of $(D r)\nfor which $(D predicate(a) == predicate(b)).\n\nSee_Also:\n    STL's $(WEB sgi.com/tech/stl/_partition.html, _partition)$(BR)\n    STL's $(WEB sgi.com/tech/stl/stable_partition.html, stable_partition)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL402_3076)\n---\nimport std.algorithm : count, find; // FIXME\nimport std.conv : text;\n\nauto Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto arr = Arr.dup;\nstatic bool even(int a) { return (a & 1) == 0; }\n// Partition arr such that even numbers come first\nauto r = partition!(even)(arr);\n// Now arr is separated in evens and odds.\n// Numbers may have become shuffled due to instability\nassert(r == arr[5 .. $]);\nassert(count!(even)(arr[0 .. 5]) == 5);\nassert(find!(even)(r).empty);\n\n// Can also specify the predicate as a string.\n// Use 'a' as the predicate argument name\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0})(arr);\nassert(r == arr[5 .. $]);\n\n// Now for a stable partition:\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0}, SwapStrategy.stable)(arr);\n// Now arr is [2 4 6 8 10 1 3 5 7 9], and r points to 1\nassert(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] && r == arr[5 .. $]);\n\n// In case the predicate needs to hold its own state, use a delegate:\narr[] = Arr[];\nint x = 3;\n// Put stuff greater than 3 on the left\nbool fun(int a) { return a > x; }\nr = partition!(fun, SwapStrategy.semistable)(arr);\n// Now arr is [4 5 6 7 8 9 10 2 3 1] and r points to 2\nassert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] && r == arr[7 .. $]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL402_3076)\n",
				"parameters": [
					{
						"name": "predicate",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "ss == SwapStrategy.stable && isRandomAccessRange!Range || ss != SwapStrategy.stable && isForwardRange!Range",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isPartitioned",
						"line": 460,
						"type": "bool(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 473,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isPartitioned",
				"line": 460,
				"comment": "Params:\n    pred = The predicate that the range should be partitioned by.\n    r = The range to check.\nReturns: $(D true) if $(D r) is partitioned according to predicate $(D pred).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL476_3078)\n---\nint[] r = [ 1, 3, 5, 7, 8, 2, 4, ];\nassert(isPartitioned!\"a & 1\"(r));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL476_3078)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "partition3",
						"line": 504,
						"type": "(Range r, E pivot)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "pivot",
								"type": "E"
							}
						],
						"endline": 557,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "partition3",
				"line": 504,
				"comment": "Rearranges elements in $(D r) in three adjacent ranges and returns\nthem. The first and leftmost range only contains elements in $(D r)\nless than $(D pivot). The second and middle range only contains\nelements in $(D r) that are equal to $(D pivot). Finally, the third\nand rightmost range only contains elements in $(D r) that are greater\nthan $(D pivot). The less-than test is defined by the binary function\n$(D less).\n\nParams:\n    less = The predicate to use for the rearrangement.\n    ss = The swapping strategy to use.\n    r = The random-access range to rearrange.\n    pivot = The pivot element.\n\nReturns:\n    A $(XREF typecons,Tuple) of the three resulting ranges. These ranges are\n    slices of the original range.\n\nBUGS: stable $(D partition3) has not been implemented yet.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL560_3079)\n---\nauto a = [ 8, 3, 4, 1, 4, 7, 4 ];\nauto pieces = partition3(a, 4);\nassert(pieces[0] == [ 1, 3 ]);\nassert(pieces[1] == [ 4, 4, 4 ]);\nassert(pieces[2] == [ 8, 7 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL560_3079)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "ss == SwapStrategy.unstable && isRandomAccessRange!Range && hasSwappableElements!Range && hasLength!Range && is(typeof(binaryFun!less(r.front, pivot)) == bool) && is(typeof(binaryFun!less(pivot, r.front)) == bool) && is(typeof(binaryFun!less(r.front, r.front)) == bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeIndex",
						"line": 632,
						"type": "SortedRange!(RangeIndex, (a, b) => binaryFun!less(*a, *b))(Range r, RangeIndex index)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "index",
								"type": "RangeIndex"
							}
						],
						"endline": 652,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "makeIndex",
				"line": 632,
				"comment": "Computes an index for $(D r) based on the comparison $(D less). The\nindex is a sorted array of pointers or indices into the original\nrange. This technique is similar to sorting, but it is more flexible\nbecause (1) it allows \"sorting\" of immutable collections, (2) allows\nbinary search even if the original collection does not offer random\naccess, (3) allows multiple indexes, each on a different predicate,\nand (4) may be faster when dealing with large objects. However, using\nan index may also be slower under certain circumstances due to the\nextra indirection, and is always larger than a sorting-based solution\nbecause it needs space for the index in addition to the original\ncollection. The complexity is the same as $(D sort)'s.\n\nThe first overload of $(D makeIndex) writes to a range containing\npointers, and the second writes to a range containing offsets. The\nfirst overload requires $(D Range) to be a forward range, and the\nlatter requires it to be a random-access range.\n\n$(D makeIndex) overwrites its second argument with the result, but\nnever reallocates it.\n\nParams:\n    less = The comparison to use.\n    ss = The swapping strategy.\n    r = The range to index.\n    index = The resulting index.\n\nReturns: The pointer-based version returns a $(D SortedRange) wrapper\nover index, of type $(D SortedRange!(RangeIndex, (a, b) =>\nbinaryFun!less(*a, *b))) thus reflecting the ordering of the\nindex. The index-based version returns $(D void) because the ordering\nrelation involves not only $(D index) but also $(D r).\n\nThrows: If the second argument's length is less than that of the range\nindexed, an exception is thrown.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL689_3087)\n---\nimmutable(int[]) arr = [ 2, 3, 1, 5, 0 ];\n// index using pointers\nauto index1 = new immutable(int)*[arr.length];\nmakeIndex!(\"a < b\")(arr, index1);\nassert(isSorted!(\"*a < *b\")(index1));\n// index using offsets\nauto index2 = new size_t[arr.length];\nmakeIndex!(\"a < b\")(arr, index2);\nassert(isSorted!\n    ((size_t a, size_t b){ return arr[a] < arr[b];})\n    (index2));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL689_3087)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RangeIndex",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isRandomAccessRange!RangeIndex && is(ElementType!RangeIndex : ElementType!Range*)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeIndex",
						"line": 655,
						"type": "void(Range r, RangeIndex index)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "index",
								"type": "RangeIndex"
							}
						],
						"endline": 686,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "makeIndex",
				"line": 655,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RangeIndex",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && !isInfinite!Range && isRandomAccessRange!RangeIndex && !isInfinite!RangeIndex && isIntegral!(ElementType!RangeIndex)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "multiSort",
								"line": 762,
								"type": "void(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 801,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "multiSort",
						"line": 762,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "validPredicates!(ElementType!Range, less)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "multiSort",
				"line": 760,
				"comment": "$(D void multiSort(Range)(Range r)\n    if (validPredicates!(ElementType!Range, less));)\n\nSorts a range by multiple keys. The call $(D multiSort!(\"a.id < b.id\",\n\"a.date > b.date\")(r)) sorts the range $(D r) by $(D id) ascending,\nand sorts elements that have the same $(D id) by $(D date)\ndescending. Such a call is equivalent to $(D sort!\"a.id != b.id ? a.id\n< b.id : a.date > b.date\"(r)), but $(D multiSort) is faster because it\ndoes fewer comparisons (in addition to being more convenient).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL805_3089)\n---\nstatic struct Point { int x, y; }\nauto pts1 = [ Point(0, 0), Point(5, 5), Point(0, 1), Point(0, 2) ];\nauto pts2 = [ Point(0, 0), Point(0, 1), Point(0, 2), Point(5, 5) ];\nmultiSort!(\"a.x < b.x\", \"a.y < b.y\", SwapStrategy.unstable)(pts1);\nassert(pts1 == pts2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL805_3089)\n",
				"parameters": [
					{
						"name": "less",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sort",
						"line": 996,
						"type": "SortedRange!(Range, less)(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1028,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "sort",
				"line": 996,
				"comment": "Sorts a random-access range according to the predicate $(D less). Performs\n$(BIGOH r.length * log(r.length)) evaluations of $(D less). Stable sorting\nrequires $(D hasAssignableElements!Range) to be true.\n\n$(D sort) returns a $(XREF range, SortedRange) over the original range, which\nfunctions that can take advantage of sorted data can then use to know that the\nrange is sorted and adjust accordingly. The $(XREF range, SortedRange) is a\nwrapper around the original range, so both it and the original range are sorted,\nbut other functions won't know that the original range has been sorted, whereas\nthey $(I can) know that $(XREF range, SortedRange) has been sorted.\n\nThe predicate is expected to satisfy certain rules in order for $(D sort) to\nbehave as expected - otherwise, the program may fail on certain inputs (but not\nothers) when not compiled in release mode, due to the cursory $(D assumeSorted)\ncheck. Specifically, $(D sort) expects $(D less(a,b) && less(b,c)) to imply\n$(D less(a,c)) (transitivity), and, conversely, $(D !less(a,b) && !less(b,c)) to\nimply $(D !less(a,c)). Note that the default predicate ($(D \"a < b\")) does not\nalways satisfy these conditions for floating point types, because the expression\nwill always be $(D false) when either $(D a) or $(D b) is NaN.\nUse $(XREF math, cmp) instead.\n\nParams:\n    less = The predicate to sort by.\n    ss = The swapping strategy to use.\n    r = The range to sort.\n\nReturns: The initial range wrapped as a $(D SortedRange) with the predicate\n$(D binaryFun!less).\n\nAlgorithms: $(WEB en.wikipedia.org/wiki/Introsort) is used for unstable sorting and\n$(WEB en.wikipedia.org/wiki/Timsort, Timsort) is used for stable sorting.\nEach algorithm has benefits beyond stability. Introsort is generally faster but\nTimsort may achieve greater speeds on data with low entropy or if predicate calls\nare expensive. Introsort performs no allocations whereas Timsort will perform one\nor more allocations per call. Both algorithms have $(BIGOH n log n) worst-case\ntime complexity.\n\nSee_Also:\n    $(XREF range, assumeSorted)$(BR)\n    $(XREF range, SortedRange)$(BR)\n    $(XREF_PACK algorithm,mutation,SwapStrategy)$(BR)\n    $(XREF functional, binaryFun)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1031_3093)\n---\nint[] array = [ 1, 2, 3, 4 ];\n// sort in descending order\nsort!(\"a > b\")(array);\nassert(array == [ 4, 3, 2, 1 ]);\n// sort in ascending order\nsort(array);\nassert(array == [ 1, 2, 3, 4 ]);\n// sort with a delegate\nbool myComp(int x, int y) @safe pure nothrow { return x > y; }\nsort!(myComp)(array);\nassert(array == [ 4, 3, 2, 1 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1031_3093)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1046_3094)\n---\n// Showcase stable sorting\nstring[] words = [ \"aBc\", \"a\", \"abc\", \"b\", \"ABC\", \"c\" ];\nsort!(\"toUpper(a) < toUpper(b)\", SwapStrategy.stable)(words);\nassert(words == [ \"a\", \"aBc\", \"abc\", \"ABC\", \"b\", \"c\" ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1046_3094)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1055_3097)\n---\n// Sorting floating-point numbers in presence of NaN\ndouble[] numbers = [-0.0, 3.0, -2.0, double.nan, 0.0, -double.nan];\n\nimport std.math : cmp, isIdentical;\nimport std.algorithm.comparison : equal;\n\nsort!((a, b) => cmp(a, b) < 0)(numbers);\n\ndouble[] sorted = [-double.nan, -2.0, -0.0, 0.0, 3.0, double.nan];\nassert(numbers.equal!isIdentical(sorted));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1055_3097)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "(ss == SwapStrategy.unstable && (hasSwappableElements!Range || hasAssignableElements!Range) || ss != SwapStrategy.unstable && hasAssignableElements!Range) && isRandomAccessRange!Range && hasSlicing!Range && hasLength!Range",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "schwartzSort",
						"line": 1975,
						"type": "SortedRange!(R, (a, b) => binaryFun!less(unaryFun!transform(a), unaryFun!transform(b)))(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 2011,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "schwartzSort",
				"line": 1975,
				"comment": "Sorts a range using an algorithm akin to the $(WEB\nwikipedia.org/wiki/Schwartzian_transform, Schwartzian transform), also\nknown as the decorate-sort-undecorate pattern in Python and Lisp.\nThis function is helpful when the sort comparison includes\nan expensive computation. The complexity is the same as that of the\ncorresponding $(D sort), but $(D schwartzSort) evaluates $(D\ntransform) only $(D r.length) times (less than half when compared to\nregular sorting). The usage can be best illustrated with an example.\n\nExample:\n----\nuint hashFun(string) { ... expensive computation ... }\nstring[] array = ...;\n// Sort strings by hash, slow\nsort!((a, b) => hashFun(a) < hashFun(b))(array);\n// Sort strings by hash, fast (only computes arr.length hashes):\nschwartzSort!(hashFun, \"a < b\")(array);\n----\n\nThe $(D schwartzSort) function might require less temporary data and\nbe faster than the Perl idiom or the decorate-sort-undecorate idiom\npresent in Python and Lisp. This is because sorting is done in-place\nand only minimal extra data (one array of transformed elements) is\ncreated.\n\nTo check whether an array was sorted and benefit of the speedup of\nSchwartz sorting, a function $(D schwartzIsSorted) is not provided\nbecause the effect can be achieved by calling $(D\nisSorted!less(map!transform(r))).\n\nParams:\n    transform = The transformation to apply.\n    less = The predicate to sort by.\n    ss = The swapping strategy to use.\n    r = The range to sort.\n\nReturns: The initial range wrapped as a $(D SortedRange) with the\npredicate $(D (a, b) => binaryFun!less(transform(a),\ntransform(b))).\n",
				"parameters": [
					{
						"name": "transform",
						"kind": "alias"
					},
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasLength!R",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "partialSort",
						"line": 2110,
						"type": "void(Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2116,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "partialSort",
				"line": 2110,
				"comment": "Reorders the random-access range $(D r) such that the range $(D r[0\n.. mid]) is the same as if the entire $(D r) were sorted, and leaves\nthe range $(D r[mid .. r.length]) in no particular order. Performs\n$(BIGOH r.length * log(mid)) evaluations of $(D pred). The\nimplementation simply calls $(D topN!(less, ss)(r, n)) and then $(D\nsort!(less, ss)(r[0 .. n])).\n\nParams:\n    less = The predicate to sort by.\n    ss = The swapping strategy to use.\n    r = The random-access range to reorder.\n    n = The length of the initial segment of `r` to sort.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2119_3111)\n---\nint[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];\npartialSort(a, 5);\nassert(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2119_3111)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "topN",
						"line": 2155,
						"type": "(Range r, size_t nth)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "nth",
								"type": "size_t"
							}
						],
						"endline": 2192,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "topN",
				"line": 2155,
				"comment": "Reorders the range $(D r) using $(D swap) such that $(D r[nth]) refers\nto the element that would fall there if the range were fully\nsorted. In addition, it also partitions $(D r) such that all elements\n$(D e1) from $(D r[0]) to $(D r[nth]) satisfy $(D !less(r[nth], e1)),\nand all elements $(D e2) from $(D r[nth]) to $(D r[r.length]) satisfy\n$(D !less(e2, r[nth])). Effectively, it finds the nth smallest\n(according to $(D less)) elements in $(D r). Performs an expected\n$(BIGOH r.length) (if unstable) or $(BIGOH r.length * log(r.length))\n(if stable) evaluations of $(D less) and $(D swap).\n\nIf $(D n >= r.length), the algorithm has no effect.\n\nParams:\n    less = The predicate to sort by.\n    ss = The swapping strategy to use.\n    r = The random-access range to reorder.\n    nth = The index of the element that should be in sorted position after the\n        function is done.\n\nSee_Also:\n    $(LREF topNIndex),\n    $(WEB sgi.com/tech/stl/nth_element.html, STL's nth_element)\n\nBUGS:\n\nStable topN has not been implemented yet.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2195_3113)\n---\nint[] v = [ 25, 7, 9, 2, 0, 5, 21 ];\nauto n = 4;\ntopN!\"a < b\"(v, n);\nassert(v[n] == 9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2195_3113)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "topN",
						"line": 2298,
						"type": "(Range1 r1, Range2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "Range1"
							},
							{
								"name": "r2",
								"type": "Range2"
							}
						],
						"endline": 2314,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "topN",
				"line": 2298,
				"comment": "Stores the smallest elements of the two ranges in the left-hand range.\n\nParams:\n    less = The predicate to sort by.\n    ss = The swapping strategy to use.\n    r1 = The first range.\n    r2 = The second range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2317_3119)\n---\nint[] a = [ 5, 7, 2, 6, 7 ];\nint[] b = [ 2, 1, 5, 6, 7, 3, 0 ];\ntopN(a, b);\nsort(a);\nassert(a == [0, 1, 2, 2, 3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2317_3119)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range1 && hasLength!Range1 && isInputRange!Range2 && is(ElementType!Range1 == ElementType!Range2)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "topNCopy",
						"line": 2361,
						"type": "TRange(SRange source, TRange target, SortOutput sorted = SortOutput.no)",
						"parameters": [
							{
								"name": "source",
								"type": "SRange"
							},
							{
								"name": "target",
								"type": "TRange"
							},
							{
								"name": "sorted",
								"type": "SortOutput",
								"default": "SortOutput.no"
							}
						],
						"endline": 2377,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "topNCopy",
				"line": 2361,
				"comment": "Copies the top $(D n) elements of the input range $(D source) into the\nrandom-access range $(D target), where $(D n =\ntarget.length). Elements of $(D source) are not touched. If $(D\nsorted) is $(D true), the target is sorted. Otherwise, the target\nrespects the $(WEB en.wikipedia.org/wiki/Binary_heap, heap property).\n\nParams:\n    less = The predicate to sort by.\n    source = The source range.\n    target = The target range.\n    sorted = Whether to sort the elements copied into `target`.\n\nReturns: The slice of `target` containing the copied elements.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2380_3122)\n---\nint[] a = [ 10, 16, 2, 3, 1, 5, 0 ];\nint[] b = new int[3];\ntopNCopy(a, b, SortOutput.yes);\nassert(b == [ 0, 1, 2 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2380_3122)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "SRange",
						"kind": "type"
					},
					{
						"name": "TRange",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!SRange && isRandomAccessRange!TRange && hasLength!TRange && hasSlicing!TRange",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "topNIndex",
						"line": 2437,
						"type": "void(Range r, RangeIndex index, SortOutput sorted = SortOutput.no)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "index",
								"type": "RangeIndex"
							},
							{
								"name": "sorted",
								"type": "SortOutput",
								"default": "SortOutput.no"
							}
						],
						"endline": 2467,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "topNIndex",
				"line": 2437,
				"comment": "Given a range of elements, constructs an index of its top $(I n) elements\n(i.e., the first $(I n) elements if the range were sorted).\n\nSimilar to $(LREF topN), except that the range is not modified.\n\nParams:\n    less = A binary predicate that defines the ordering of range elements.\n        Defaults to $(D a < b).\n    ss = $(RED (Not implemented yet.)) Specify the swapping strategy.\n    r = A\n        $(XREF_PACK_NAMED range,primitives,isRandomAccessRange,random-access range)\n        of elements to make an index for.\n    index = A\n        $(XREF_PACK_NAMED range,primitives,isRandomAccessRange,random-access range)\n        with assignable elements to build the index in. The length of this range\n        determines how many top elements to index in $(D r).\n\n        This index range can either have integral elements, in which case the\n        constructed index will consist of zero-based numerical indices into\n        $(D r); or it can have pointers to the element type of $(D r), in which\n        case the constructed index will be pointers to the top elements in\n        $(D r).\n    sorted = Determines whether to sort the index by the elements they refer\n        to.\n\nSee_also: $(LREF topN), $(LREF topNCopy).\n\nBUGS:\nThe swapping strategy parameter is not implemented yet; currently it is\nignored.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2501_3124)\n---\n// Construct index to top 3 elements using numerical indices:\nint[] a = [ 10, 2, 7, 5, 8, 1 ];\nint[] index = new int[3];\ntopNIndex(a, index, SortOutput.yes);\nassert(index == [5, 1, 3]); // because a[5]==1, a[1]==2, a[3]==5\n\n// Construct index to top 3 elements using pointer indices:\nint*[] ptrIndex = new int*[3];\ntopNIndex(a, ptrIndex, SortOutput.yes);\nassert(ptrIndex == [ &a[5], &a[1], &a[3] ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2501_3124)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RangeIndex",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isRandomAccessRange!RangeIndex && hasAssignableElements!RangeIndex && isIntegral!(ElementType!RangeIndex)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "topNIndex",
						"line": 2470,
						"type": "void(Range r, RangeIndex index, SortOutput sorted = SortOutput.no)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "index",
								"type": "RangeIndex"
							},
							{
								"name": "sorted",
								"type": "SortOutput",
								"default": "SortOutput.no"
							}
						],
						"endline": 2498,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "topNIndex",
				"line": 2470,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RangeIndex",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isRandomAccessRange!RangeIndex && hasAssignableElements!RangeIndex && is(ElementType!RangeIndex == ElementType!Range*)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nextPermutation",
						"line": 2575,
						"type": "bool(BidirectionalRange range)",
						"parameters": [
							{
								"name": "range",
								"type": "BidirectionalRange"
							}
						],
						"endline": 2612,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "nextPermutation",
				"line": 2575,
				"comment": " Permutes $(D range) in-place to the next lexicographically greater\n permutation.\n\n The predicate $(D less) defines the lexicographical ordering to be used on\n the range.\n\n If the range is currently the lexicographically greatest permutation, it is\n permuted back to the least permutation and false is returned.  Otherwise,\n true is returned. One can thus generate all permutations of a range by\n sorting it according to $(D less), which produces the lexicographically\n least permutation, and then calling nextPermutation until it returns false.\n This is guaranteed to generate all distinct permutations of the range\n exactly once.  If there are $(I N) elements in the range and all of them are\n unique, then $(I N)! permutations will be generated. Otherwise, if there are\n some duplicated elements, fewer permutations will be produced.\n----\n// Enumerate all permutations\nint[] a = [1,2,3,4,5];\ndo\n{\n    // use the current permutation and\n    // proceed to the next permutation of the array.\n} while (nextPermutation(a));\n----\n Params:\n  less = The ordering to be used to determine lexicographical ordering of the\n      permutations.\n  range = The range to permute.\n\n Returns: false if the range was lexicographically the greatest, in which\n case the range is reversed back to the lexicographically smallest\n permutation; otherwise returns true.\n See_Also:\n $(XREF_PACK algorithm,iteration,permutations).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2615_3127)\n---\n// Step through all permutations of a sorted array in lexicographic order\nint[] a = [1,2,3];\nassert(nextPermutation(a) == true);\nassert(a == [1,3,2]);\nassert(nextPermutation(a) == true);\nassert(a == [2,1,3]);\nassert(nextPermutation(a) == true);\nassert(a == [2,3,1]);\nassert(nextPermutation(a) == true);\nassert(a == [3,1,2]);\nassert(nextPermutation(a) == true);\nassert(a == [3,2,1]);\nassert(nextPermutation(a) == false);\nassert(a == [1,2,3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2615_3127)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2634_3128)\n---\n// Step through permutations of an array containing duplicate elements:\nint[] a = [1,1,2];\nassert(nextPermutation(a) == true);\nassert(a == [1,2,1]);\nassert(nextPermutation(a) == true);\nassert(a == [2,1,1]);\nassert(nextPermutation(a) == false);\nassert(a == [1,1,2]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2634_3128)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "BidirectionalRange",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!BidirectionalRange && hasSwappableElements!BidirectionalRange",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nextEvenPermutation",
						"line": 2830,
						"type": "bool(BidirectionalRange range)",
						"parameters": [
							{
								"name": "range",
								"type": "BidirectionalRange"
							}
						],
						"endline": 2881,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "nextEvenPermutation",
				"line": 2830,
				"comment": " Permutes $(D range) in-place to the next lexicographically greater $(I even)\n permutation.\n\n The predicate $(D less) defines the lexicographical ordering to be used on\n the range.\n\n An even permutation is one which is produced by swapping an even number of\n pairs of elements in the original range. The set of $(I even) permutations\n is distinct from the set of $(I all) permutations only when there are no\n duplicate elements in the range. If the range has $(I N) unique elements,\n then there are exactly $(I N)!/2 even permutations.\n\n If the range is already the lexicographically greatest even permutation, it\n is permuted back to the least even permutation and false is returned.\n Otherwise, true is returned, and the range is modified in-place to be the\n lexicographically next even permutation.\n\n One can thus generate the even permutations of a range with unique elements\n by starting with the lexicographically smallest permutation, and repeatedly\n calling nextEvenPermutation until it returns false.\n----\n// Enumerate even permutations\nint[] a = [1,2,3,4,5];\ndo\n{\n    // use the current permutation and\n    // proceed to the next even permutation of the array.\n} while (nextEvenPermutation(a));\n----\n One can also generate the $(I odd) permutations of a range by noting that\n permutations obey the rule that even + even = even, and odd + even = odd.\n Thus, by swapping the last two elements of a lexicographically least range,\n it is turned into the first odd permutation. Then calling\n nextEvenPermutation on this first odd permutation will generate the next\n even permutation relative to this odd permutation, which is actually the\n next odd permutation of the original range. Thus, by repeatedly calling\n nextEvenPermutation until it returns false, one enumerates the odd\n permutations of the original range.\n----\n// Enumerate odd permutations\nint[] a = [1,2,3,4,5];\nswap(a[$-2], a[$-1]);    // a is now the first odd permutation of [1,2,3,4,5]\ndo\n{\n    // use the current permutation and\n    // proceed to the next odd permutation of the original array\n    // (which is an even permutation of the first odd permutation).\n} while (nextEvenPermutation(a));\n----\n\n Warning: Since even permutations are only distinct from all permutations\n when the range elements are unique, this function assumes that there are no\n duplicate elements under the specified ordering. If this is not _true, some\n permutations may fail to be generated. When the range has non-unique\n elements, you should use $(MYREF nextPermutation) instead.\n\n Params:\n  less = The ordering to be used to determine lexicographical ordering of the\n      permutations.\n  range = The range to permute.\n\n Returns: false if the range was lexicographically the greatest, in which\n case the range is reversed back to the lexicographically smallest\n permutation; otherwise returns true.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2884_3134)\n---\n// Step through even permutations of a sorted array in lexicographic order\nint[] a = [1,2,3];\nassert(nextEvenPermutation(a) == true);\nassert(a == [2,3,1]);\nassert(nextEvenPermutation(a) == true);\nassert(a == [3,1,2]);\nassert(nextEvenPermutation(a) == false);\nassert(a == [1,2,3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2884_3134)\nExample:\nEven permutations are useful for generating coordinates of certain geometric\nshapes. Here's a non-trivial example:$(DDOX_UNITTEST_HEADER __unittestL2941_3139)\n---\nimport std.math : sqrt;\n\n// Print the 60 vertices of a uniform truncated icosahedron (soccer ball)\nenum real Phi = (1.0 + sqrt(5.0)) / 2.0;    // Golden ratio\nreal[][] seeds = [\n    [0.0, 1.0, 3.0*Phi],\n    [1.0, 2.0+Phi, 2.0*Phi],\n    [Phi, 2.0, Phi^^3]\n];\nsize_t n;\nforeach (seed; seeds)\n{\n    // Loop over even permutations of each seed\n    do\n    {\n        // Loop over all sign changes of each permutation\n        size_t i;\n        do\n        {\n            // Generate all possible sign changes\n            for (i=0; i < seed.length; i++)\n            {\n                if (seed[i] != 0.0)\n                {\n                    seed[i] = -seed[i];\n                    if (seed[i] < 0.0)\n                        break;\n                }\n            }\n            n++;\n        } while (i < seed.length);\n    } while (nextEvenPermutation(seed));\n}\nassert(n == 60);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2941_3139)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "BidirectionalRange",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!BidirectionalRange && hasSwappableElements!BidirectionalRange",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic _sorting algorithms.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 completeSort,\n        If $(D a = [10, 20, 30]) and $(D b = [40, 6, 15]), then\n        $(D completeSort(a, b)) leaves $(D a = [6, 10, 15]) and $(D b = [20,\n        30, 40]).\n        The range $(D a) must be sorted prior to the call, and as a result the\n        combination $(D $(XREF range,chain)(a, b)) is sorted.)\n$(T2 isPartitioned,\n        $(D isPartitioned!\"a < 0\"([-1, -2, 1, 0, 2])) returns $(D true) because\n        the predicate is $(D true) for a portion of the range and $(D false)\n        afterwards.)\n$(T2 isSorted,\n        $(D isSorted([1, 1, 2, 3])) returns $(D true).)\n$(T2 ordered,\n        $(D ordered(1, 1, 2, 3)) returns $(D true).)\n$(T2 strictlyOrdered,\n        $(D strictlyOrdered(1, 1, 2, 3)) returns $(D false).)\n$(T2 makeIndex,\n        Creates a separate index for a range.)\n$(T2 multiSort,\n        Sorts by multiple keys.)\n$(T2 nextEvenPermutation,\n        Computes the next lexicographically greater even permutation of a range\n        in-place.)\n$(T2 nextPermutation,\n        Computes the next lexicographically greater permutation of a range\n        in-place.)\n$(T2 partialSort,\n        If $(D a = [5, 4, 3, 2, 1]), then $(D partialSort(a, 3)) leaves\n        $(D a[0 .. 3] = [1, 2, 3]).\n        The other elements of $(D a) are left in an unspecified order.)\n$(T2 partition,\n        Partitions a range according to a predicate.)\n$(T2 partition3,\n        Partitions a range in three parts (less than, equal, greater than the\n        given pivot).)\n$(T2 schwartzSort,\n        Sorts with the help of the $(LUCKY Schwartzian transform).)\n$(T2 sort,\n        Sorts.)\n$(T2 topN,\n        Separates the top elements in a range.)\n$(T2 topNCopy,\n        Copies out the top elements of a range.)\n$(T2 topNIndex,\n        Builds an index of the top elements of a range.)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_sorting.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/iteration.d",
		"name": "std.algorithm.iteration",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "cache",
						"line": 143,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 147,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "cache",
				"line": 143,
				"comment": "$(D cache) eagerly evaluates $(D front) of $(D range)\non each construction or call to $(D popFront),\nto store the result in a cache.\nThe result is then directly returned when $(D front) is called,\nrather than re-evaluated.\n\nThis can be a useful function to place in a chain, after functions\nthat have expensive evaluation, as a lazy alternative to $(XREF array,array).\nIn particular, it can be placed after a call to $(D map), or before a call\nto $(D filter).\n\n$(D cache) may provide bidirectional iteration if needed, but since\nthis comes at an increased cost, it must be explicitly requested via the\ncall to $(D cacheBidirectional). Furthermore, a bidirectional cache will\nevaluate the \"center\" element twice, when there is only one element left in\nthe range.\n\n$(D cache) does not provide random access primitives,\nas $(D cache) would be unable to cache the random accesses.\nIf $(D Range) provides slicing primitives,\nthen $(D cache) will provide the same slicing primitives,\nbut $(D hasSlicing!Cache) will not yield true (as the $(XREF_PACK _range,primitives,hasSlicing)\ntrait also checks for random access).\n\nParams:\n    range = an input range\n\nReturns:\n    an input range with the cached values of range\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL157_3143)\n---\nimport std.algorithm.comparison : equal;\nimport std.stdio, std.range;\nimport std.typecons : tuple;\n\nulong counter = 0;\ndouble fun(int x)\n{\n    ++counter;\n    // http://en.wikipedia.org/wiki/Quartic_function\n    return ( (x + 4.0) * (x + 1.0) * (x - 1.0) * (x - 3.0) ) / 14.0 + 0.5;\n}\n// Without cache, with array (greedy)\nauto result1 = iota(-4, 5).map!(a =>tuple(a, fun(a)))()\n                         .filter!\"a[1]<0\"()\n                         .map!\"a[0]\"()\n                         .array();\n\n// the values of x that have a negative y are:\nassert(equal(result1, [-3, -2, 2]));\n\n// Check how many times fun was evaluated.\n// As many times as the number of items in both source and result.\nassert(counter == iota(-4, 5).length + result1.length);\n\ncounter = 0;\n// Without array, with cache (lazy)\nauto result2 = iota(-4, 5).map!(a =>tuple(a, fun(a)))()\n                         .cache()\n                         .filter!\"a[1]<0\"()\n                         .map!\"a[0]\"();\n\n// the values of x that have a negative y are:\nassert(equal(result2, [-3, -2, 2]));\n\n// Check how many times fun was evaluated.\n// Only as many times as the number of items in source.\nassert(counter == iota(-4, 5).length);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL157_3143)\nExample:\nTip: $(D cache) is eager when evaluating elements. If calling front on the\nunderlying range has a side effect, it will be observeable before calling\nfront on the actual cached range.\n\nFurtermore, care should be taken composing $(D cache) with $(XREF range,take).\nBy placing $(D take) before $(D cache), then $(D cache) will be \"aware\"\nof when the range ends, and correctly stop caching elements when needed.\nIf calling front has no side effect though, placing $(D take) after $(D cache)\nmay yield a faster range.\n\nEither way, the resulting ranges will be equivalent, but maybe not at the\nsame cost or side effects.$(DDOX_UNITTEST_HEADER __unittestL212_3145)\n---\nimport std.algorithm.comparison : equal;\nimport std.range;\nint i = 0;\n\nauto r = iota(0, 4).tee!((a){i = a;}, No.pipeOnPop);\nauto r1 = r.take(3).cache();\nauto r2 = r.cache().take(3);\n\nassert(equal(r1, [0, 1, 2]));\nassert(i == 2); //The last \"seen\" element was 2. The data in cache has been cleared.\n\nassert(equal(r2, [0, 1, 2]));\nassert(i == 3); //cache has accessed 3. It is still stored internally by cache.\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL212_3145)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cacheBidirectional",
						"line": 150,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 154,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "cacheBidirectional",
				"line": 150,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "map",
								"line": 447,
								"type": "(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 474,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "map",
						"line": 447,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!(Unqual!Range)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "map",
				"line": 445,
				"comment": "$(D auto map(Range)(Range r) if (isInputRange!(Unqual!Range));)\n\nImplements the homonym function (also known as $(D transform)) present\nin many languages of functional flavor. The call $(D map!(fun)(range))\nreturns a range of which elements are obtained by applying $(D fun(a))\nleft to right for all elements $(D a) in $(D range). The original ranges are\nnot changed. Evaluation is done lazily.\n\nParams:\n    fun = one or more functions\n    r = an input range\n\nReturns:\n    a range with each fun applied to all the elements. If there is more than one\n    fun, the element type will be $(D Tuple) containing one element for each fun.\n\nSee_Also:\n    $(WEB en.wikipedia.org/wiki/Map_(higher-order_function), Map (higher-order function))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL478_3154)\n---\nimport std.algorithm.comparison : equal;\nimport std.range : chain;\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nauto squares = map!(a => a * a)(chain(arr1, arr2));\nassert(equal(squares, [ 1, 4, 9, 16, 25, 36 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL478_3154)\nExample:\nMultiple functions can be passed to $(D map). In that case, the\nelement type of $(D map) is a tuple containing one element for each\nfunction.$(DDOX_UNITTEST_HEADER __unittestL493_3155)\n---\nauto sums = [2, 4, 6, 8];\nauto products = [1, 4, 9, 16];\n\nsize_t i = 0;\nforeach (result; [ 1, 2, 3, 4 ].map!(\"a + a\", \"a * a\"))\n{\n    assert(result[0] == sums[i]);\n    assert(result[1] == products[i]);\n    ++i;\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL493_3155)\nExample:\nYou may alias $(D map) with some function(s) to a symbol and use\nit separately:$(DDOX_UNITTEST_HEADER __unittestL511_3156)\n---\nimport std.algorithm.comparison : equal;\nimport std.conv : to;\n\nalias stringize = map!(to!string);\nassert(equal(stringize([ 1, 2, 3, 4 ]), [ \"1\", \"2\", \"3\", \"4\" ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL511_3156)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "tuple"
					}
				],
				"constraint": "fun.length >= 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "each",
								"line": 847,
								"type": "void(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 869,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "each",
						"line": 847,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isRangeIterable!Range && !isForeachIterable!Range",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "each",
								"line": 871,
								"type": "void(Iterable r)",
								"parameters": [
									{
										"name": "r",
										"type": "Iterable"
									}
								],
								"endline": 885,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "each",
						"line": 871,
						"parameters": [
							{
								"name": "Iterable",
								"kind": "type"
							}
						],
						"constraint": "isForeachIterable!Iterable",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "each",
				"line": 816,
				"comment": "Eagerly iterates over $(D r) and calls $(D pred) over _each element.\n\nIf no predicate is specified, $(D each) will default to doing nothing\nbut consuming the entire range. $(D .front) will be evaluated, but this\ncan be avoided by explicitly specifying a predicate lambda with a\n$(D lazy) parameter.\n\n$(D each) also supports $(D opApply)-based iterators, so it will work\nwith e.g. $(XREF parallelism, parallel).\n\nParams:\n    pred = predicate to apply to each element of the range\n    r = range or iterable over which each iterates\n\nSee_Also: $(XREF range,tee)\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL889_3175)\n---\nimport std.range : iota;\n\nlong[] arr;\niota(5).each!(n => arr ~= n);\nassert(arr == [0, 1, 2, 3, 4]);\n\n// If the range supports it, the value can be mutated in place\narr.each!((ref n) => n++);\nassert(arr == [1, 2, 3, 4, 5]);\n\narr.each!\"a++\";\nassert(arr == [2, 3, 4, 5, 6]);\n\n// by-ref lambdas are not allowed for non-ref ranges\nstatic assert(!is(typeof(arr.map!(n => n).each!((ref n) => n++))));\n\n// The default predicate consumes the range\nauto m = arr.map!(n => n);\n(&m).each();\nassert(m.empty);\n\n// Indexes are also available for in-place mutations\narr[] = 0;\narr.each!\"a=i\"();\nassert(arr == [0, 1, 2, 3, 4]);\n\n// opApply iterators work as well\nstatic assert(is(typeof({\n    import std.parallelism;\n    arr.parallel.each!\"a++\";\n})));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL889_3175)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "filter",
								"line": 942,
								"type": "(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 945,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "filter",
						"line": 942,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!(Unqual!Range)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "filter",
				"line": 940,
				"comment": "$(D auto filter(Range)(Range rs) if (isInputRange!(Unqual!Range));)\n\nImplements the higher order _filter function.\n\nParams:\n    predicate = Function to apply to each element of range\n    range = Input range of elements\n\nReturns:\n    $(D filter!(predicate)(range)) returns a new range containing only elements $(D x) in $(D range) for\n    which $(D predicate(x)) returns $(D true).\n\nSee_Also:\n    $(WEB en.wikipedia.org/wiki/Filter_(higher-order_function), Filter (higher-order function))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL949_3180)\n---\nimport std.algorithm.comparison : equal;\nimport std.math : approxEqual;\nimport std.range;\n\nint[] arr = [ 1, 2, 3, 4, 5 ];\n\n// Sum all elements\nauto small = filter!(a => a < 3)(arr);\nassert(equal(small, [ 1, 2 ]));\n\n// Sum again, but with Uniform Function Call Syntax (UFCS)\nauto sum = arr.filter!(a => a < 3);\nassert(equal(sum, [ 1, 2 ]));\n\n// In combination with chain() to span multiple ranges\nint[] a = [ 3, -2, 400 ];\nint[] b = [ 100, -101, 102 ];\nauto r = chain(a, b).filter!(a => a > 0);\nassert(equal(r, [ 3, 400, 100, 102 ]));\n\n// Mixing convertible types is fair game, too\ndouble[] c = [ 2.5, 3.0 ];\nauto r1 = chain(c, a, b).filter!(a => cast(int) a != a);\nassert(approxEqual(r1, [ 2.5 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL949_3180)\n",
				"parameters": [
					{
						"name": "predicate",
						"kind": "alias"
					}
				],
				"constraint": "is(typeof(unaryFun!predicate))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "filterBidirectional",
								"line": 1140,
								"type": "(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 1143,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "filterBidirectional",
						"line": 1140,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isBidirectionalRange!(Unqual!Range)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "filterBidirectional",
				"line": 1138,
				"comment": " $(D auto filterBidirectional(Range)(Range r) if (isBidirectionalRange!(Unqual!Range));)\n\n Similar to $(D filter), except it defines a bidirectional\n range. There is a speed disadvantage - the constructor spends time\n finding the last element in the range that satisfies the filtering\n condition (in addition to finding the first one). The advantage is\n that the filtered range can be spanned from both directions. Also,\n $(XREF range, retro) can be applied against the filtered range.\n\n Params:\n     pred = Function to apply to each element of range\n     r = Bidirectional range of elements\n\n Returns:\n     a new range containing only the elements in r for which pred returns $(D true).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1147_3185)\n---\nimport std.algorithm.comparison : equal;\nimport std.range;\n\nint[] arr = [ 1, 2, 3, 4, 5 ];\nauto small = filterBidirectional!(\"a < 3\")(arr);\nstatic assert(isBidirectionalRange!(typeof(small)));\nassert(small.back == 2);\nassert(equal(small, [ 1, 2 ]));\nassert(equal(retro(small), [ 2, 1 ]));\n// In combination with chain() to span multiple ranges\nint[] a = [ 3, -2, 400 ];\nint[] b = [ 100, -101, 102 ];\nauto r = filterBidirectional!(\"a > 0\")(chain(a, b));\nassert(r.back == 102);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1147_3185)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "group",
						"line": 1308,
						"type": "Group!(pred, Range)(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1311,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "group",
				"line": 1308,
				"comment": "Groups consecutively equivalent elements into a single tuple of the element and\nthe number of its repetitions.\n\nSimilarly to $(D uniq), $(D group) produces a range that iterates over unique\nconsecutive elements of the given range. Each element of this range is a tuple\nof the element and the number of times it is repeated in the original range.\nEquivalence of elements is assessed by using the predicate $(D pred), which\ndefaults to $(D \"a == b\").\n\nParams:\n    pred = Binary predicate for determining equivalence of two elements.\n    r = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to\n        iterate over.\n\nReturns: A range of elements of type $(D Tuple!(ElementType!R, uint)),\nrepresenting each consecutively unique element and its respective number of\noccurrences in that run.  This will be an input range if $(D R) is an input\nrange, and a forward range in all other cases.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1314_3186)\n---\nimport std.algorithm.comparison : equal;\nimport std.typecons : tuple, Tuple;\n\nint[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];\nassert(equal(group(arr), [ tuple(1, 1u), tuple(2, 4u), tuple(3, 1u),\n    tuple(4, 3u), tuple(5, 1u) ][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1314_3186)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chunkBy",
						"line": 1689,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1693,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "chunkBy",
				"line": 1689,
				"comment": " Chunks an input range into subranges of equivalent adjacent elements.\n\n Equivalence is defined by the predicate $(D pred), which can be either\n binary or unary. In the binary form, two _range elements $(D a) and $(D b)\n are considered equivalent if $(D pred(a,b)) is true. In unary form, two\n elements are considered equivalent if $(D pred(a) == pred(b)) is true.\n\n This predicate must be an equivalence relation, that is, it must be\n reflexive ($(D pred(x,x)) is always true), symmetric\n ($(D pred(x,y) == pred(y,x))), and transitive ($(D pred(x,y) && pred(y,z))\n implies $(D pred(x,z))). If this is not the case, the range returned by\n chunkBy may assert at runtime or behave erratically.\n\n Params:\n  pred = Predicate for determining equivalence.\n  r = The range to be chunked.\n\n Returns: With a binary predicate, a range of ranges is returned in which\n all elements in a given subrange are equivalent under the given predicate.\n With a unary predicate, a range of tuples is returned, with the tuple\n consisting of the result of the unary predicate for each subrange, and the\n subrange itself.\n\n Notes:\n\n Equivalent elements separated by an intervening non-equivalent element will\n appear in separate subranges; this function only considers adjacent\n equivalence. Elements in the subranges will always appear in the same order\n they appear in the original range.\n\n See_also:\n $(LREF group), which collapses adjacent equivalent elements into a single\n element.\nExample:\nShowing usage with binary predicate:$(DDOX_UNITTEST_HEADER __unittestL1696_3200)\n---\nimport std.algorithm.comparison : equal;\n\n// Grouping by particular attribute of each element:\nauto data = [\n    [1, 1],\n    [1, 2],\n    [2, 2],\n    [2, 3]\n];\n\nauto r1 = data.chunkBy!((a,b) => a[0] == b[0]);\nassert(r1.equal!equal([\n    [[1, 1], [1, 2]],\n    [[2, 2], [2, 3]]\n]));\n\nauto r2 = data.chunkBy!((a,b) => a[1] == b[1]);\nassert(r2.equal!equal([\n    [[1, 1]],\n    [[1, 2], [2, 2]],\n    [[2, 3]]\n]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1696_3200)\nExample:\nShowing usage with unary predicate:$(DDOX_UNITTEST_HEADER __unittestL1746_3206)\n---\nimport std.algorithm.comparison : equal;\nimport std.typecons : tuple;\n\n// Grouping by particular attribute of each element:\nauto range =\n[\n    [1, 1],\n    [1, 1],\n    [1, 2],\n    [2, 2],\n    [2, 3],\n    [2, 3],\n    [3, 3]\n];\n\nauto byX = chunkBy!(a => a[0])(range);\nauto expected1 =\n[\n    tuple(1, [[1, 1], [1, 1], [1, 2]]),\n    tuple(2, [[2, 2], [2, 3], [2, 3]]),\n    tuple(3, [[3, 3]])\n];\nforeach (e; byX)\n{\n    assert(!expected1.empty);\n    assert(e[0] == expected1.front[0]);\n    assert(e[1].equal(expected1.front[1]));\n    expected1.popFront();\n}\n\nauto byY = chunkBy!(a => a[1])(range);\nauto expected2 =\n[\n    tuple(1, [[1, 1], [1, 1]]),\n    tuple(2, [[1, 2], [2, 2]]),\n    tuple(3, [[2, 3], [2, 3], [3, 3]])\n];\nforeach (e; byY)\n{\n    assert(!expected2.empty);\n    assert(e[0] == expected2.front[0]);\n    assert(e[1].equal(expected2.front[1]));\n    expected2.popFront();\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1746_3206)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "joiner",
						"line": 1911,
						"type": "(RoR r, Separator sep)",
						"parameters": [
							{
								"name": "r",
								"type": "RoR"
							},
							{
								"name": "sep",
								"type": "Separator"
							}
						],
						"endline": 2064,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "joiner",
				"line": 1911,
				"comment": "Lazily joins a range of ranges with a separator. The separator itself\nis a range. If you do not provide a separator, then the ranges are\njoined directly without anything in between them.\n\nParams:\n    r = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of input\n        ranges to be joined.\n    sep = A $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) of\n        element(s) to serve as separators in the joined range.\n\nReturns:\nAn input range of elements in the joined range. This will be a forward range if\nboth outer and inner ranges of $(D RoR) are forward ranges; otherwise it will\nbe only an input range.\n\nSee_also:\n$(XREF range,chain), which chains a sequence of ranges with compatible elements\ninto a single range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2067_3219)\n---\nimport std.algorithm.comparison : equal;\nimport std.conv : text;\n\ndebug(std_algorithm) scope(success)\n    writeln(\"unittest @\", __FILE__, \":\", __LINE__, \" done.\");\n\nstatic assert(isInputRange!(typeof(joiner([\"\"], \"\"))));\nstatic assert(isForwardRange!(typeof(joiner([\"\"], \"\"))));\nassert(equal(joiner([\"\"], \"xyz\"), \"\"), text(joiner([\"\"], \"xyz\")));\nassert(equal(joiner([\"\", \"\"], \"xyz\"), \"xyz\"), text(joiner([\"\", \"\"], \"xyz\")));\nassert(equal(joiner([\"\", \"abc\"], \"xyz\"), \"xyzabc\"));\nassert(equal(joiner([\"abc\", \"\"], \"xyz\"), \"abcxyz\"));\nassert(equal(joiner([\"abc\", \"def\"], \"xyz\"), \"abcxyzdef\"));\nassert(equal(joiner([\"Mary\", \"has\", \"a\", \"little\", \"lamb\"], \"...\"),\n                \"Mary...has...a...little...lamb\"));\nassert(equal(joiner([\"abc\", \"def\"]), \"abcdef\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2067_3219)\n",
				"parameters": [
					{
						"name": "RoR",
						"kind": "type"
					},
					{
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RoR && isInputRange!(ElementType!RoR) && isForwardRange!Separator && is(ElementType!Separator : ElementType!(ElementType!RoR))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "joiner",
						"line": 2194,
						"type": "(RoR r)",
						"parameters": [
							{
								"name": "r",
								"type": "RoR"
							}
						],
						"endline": 2281,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "joiner",
				"line": 2194,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "RoR",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RoR && isInputRange!(ElementType!RoR)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "reduce",
								"line": 2479,
								"type": "(R r)",
								"parameters": [
									{
										"name": "r",
										"type": "R"
									}
								],
								"endline": 2498,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "reduce",
						"line": 2479,
						"comment": "    No-seed version. The first element of $(D r) is used as the seed's value.\n\n    For each function $(D f) in $(D fun), the corresponding\n    seed type $(D S) is $(D Unqual!(typeof(f(e, e)))), where $(D e) is an\n    element of $(D r): $(D ElementType!R) for ranges,\n    and $(D ForeachType!R) otherwise.\n\n    Once S has been determined, then $(D S s = e;) and $(D s = f(s, e);)\n    must both be legal.\n\n    If $(D r) is empty, an $(D Exception) is thrown.\n\n    Params:\n        fun = one or more functions\n        r = an iterable value as defined by $(D isIterable)\n\n    Returns:\n        the final result of the accumulator applied to the iterable\n",
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isIterable!R",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "reduce",
								"line": 2517,
								"type": "(S seed, R r)",
								"parameters": [
									{
										"name": "seed",
										"type": "S"
									},
									{
										"name": "r",
										"type": "R"
									}
								],
								"endline": 2528,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "reduce",
						"line": 2517,
						"comment": "    Seed version. The seed should be a single value if $(D fun) is a\n    single function. If $(D fun) is multiple functions, then $(D seed)\n    should be a $(XREF typecons,Tuple), with one field per function in $(D f).\n\n    For convenience, if the seed is const, or has qualified fields, then\n    $(D reduce) will operate on an unqualified copy. If this happens\n    then the returned type will not perfectly match $(D S).\n\n    Params:\n        fun = one or more functions\n        seed = the initial value of the accumulator\n        r = an iterable value as defined by $(D isIterable)\n\n    Returns:\n        the final result of the accumulator applied to the iterable\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isIterable!R",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "reduce",
				"line": 2451,
				"comment": "Implements the homonym function (also known as $(D accumulate), $(D\ncompress), $(D inject), or $(D foldl)) present in various programming\nlanguages of functional flavor. The call $(D reduce!(fun)(seed,\nrange)) first assigns $(D seed) to an internal variable $(D result),\nalso called the accumulator. Then, for each element $(D x) in $(D\nrange), $(D result = fun(result, x)) gets evaluated. Finally, $(D\nresult) is returned. The one-argument version $(D reduce!(fun)(range))\nworks similarly, but it uses the first element of the range as the\nseed (the range must be non-empty).\n\nReturns:\n    the accumulated $(D result)\n\nSee_Also:\n    $(WEB en.wikipedia.org/wiki/Fold_(higher-order_function), Fold (higher-order function))\n\n    $(LREF sum) is similar to $(D reduce!((a, b) => a + b)) that offers\n    precise summing of floating point numbers.\nExample:\nMany aggregate range operations turn out to be solved with $(D reduce)\nquickly and easily. The example below illustrates $(D reduce)'s\nremarkable power and flexibility.$(DDOX_UNITTEST_HEADER __unittestL2583_3233)\n---\nimport std.algorithm.comparison : max, min;\nimport std.math : approxEqual;\nimport std.range;\n\nint[] arr = [ 1, 2, 3, 4, 5 ];\n// Sum all elements\nauto sum = reduce!((a,b) => a + b)(0, arr);\nassert(sum == 15);\n\n// Sum again, using a string predicate with \"a\" and \"b\"\nsum = reduce!\"a + b\"(0, arr);\nassert(sum == 15);\n\n// Compute the maximum of all elements\nauto largest = reduce!(max)(arr);\nassert(largest == 5);\n\n// Max again, but with Uniform Function Call Syntax (UFCS)\nlargest = arr.reduce!(max);\nassert(largest == 5);\n\n// Compute the number of odd elements\nauto odds = reduce!((a,b) => a + (b & 1))(0, arr);\nassert(odds == 3);\n\n// Compute the sum of squares\nauto ssquares = reduce!((a,b) => a + b * b)(0, arr);\nassert(ssquares == 55);\n\n// Chain multiple ranges into seed\nint[] a = [ 3, 4 ];\nint[] b = [ 100 ];\nauto r = reduce!(\"a + b\")(chain(a, b));\nassert(r == 107);\n\n// Mixing convertible types is fair game, too\ndouble[] c = [ 2.5, 3.0 ];\nauto r1 = reduce!(\"a + b\")(chain(a, b, c));\nassert(approxEqual(r1, 112.5));\n\n// To minimize nesting of parentheses, Uniform Function Call Syntax can be used\nauto r2 = chain(a, b, c).reduce!(\"a + b\");\nassert(approxEqual(r2, 112.5));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2583_3233)\nExample:\nSometimes it is very useful to compute multiple aggregates in one pass.\nOne advantage is that the computation is faster because the looping overhead\nis shared. That's why $(D reduce) accepts multiple functions.\nIf two or more functions are passed, $(D reduce) returns a\n$(XREF typecons, Tuple) object with one member per passed-in function.\nThe number of seeds must be correspondingly increased.$(DDOX_UNITTEST_HEADER __unittestL2638_3234)\n---\nimport std.algorithm.comparison : max, min;\nimport std.math : approxEqual, sqrt;\nimport std.typecons : tuple, Tuple;\n\ndouble[] a = [ 3.0, 4, 7, 11, 3, 2, 5 ];\n// Compute minimum and maximum in one pass\nauto r = reduce!(min, max)(a);\n// The type of r is Tuple!(int, int)\nassert(approxEqual(r[0], 2));  // minimum\nassert(approxEqual(r[1], 11)); // maximum\n\n// Compute sum and sum of squares in one pass\nr = reduce!(\"a + b\", \"a + b * b\")(tuple(0.0, 0.0), a);\nassert(approxEqual(r[0], 35));  // sum\nassert(approxEqual(r[1], 233)); // sum of squares\n// Compute average and standard deviation from the above\nauto avg = r[0] / a.length;\nauto stdev = sqrt(r[1] / a.length - avg * avg);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2638_3234)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "tuple"
					}
				],
				"constraint": "fun.length >= 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitter",
						"line": 2896,
						"type": "(Range r, Separator s)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "s",
								"type": "Separator"
							}
						],
						"endline": 3050,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "splitter",
				"line": 2896,
				"comment": "Lazily splits a range using an element as a separator. This can be used with\nany narrow string type or sliceable range type, but is most popular with string\ntypes.\n\nTwo adjacent separators are considered to surround an empty element in\nthe split range. Use $(D filter!(a => !a.empty)) on the result to compress\nempty elements.\n\nIf the empty range is given, the result is a range with one empty\nelement. If a range with one separator is given, the result is a range\nwith two empty elements.\n\nIf splitting a string on whitespace and token compression is desired,\nconsider using $(D splitter) without specifying a separator (see fourth overload\nbelow).\n\nParams:\n    pred = The predicate for comparing each element with the separator,\n        defaulting to $(D \"a == b\").\n    r = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to be\n        split. Must support slicing and $(D .length).\n    s = The element to be treated as the separator between range segments to be\n        split.\n\nConstraints:\n    The predicate $(D pred) needs to accept an element of $(D r) and the\n    separator $(D s).\n\nReturns:\n    An input range of the subranges of elements between separators. If $(D r)\n    is a forward range or bidirectional range, the returned range will be\n    likewise.\n\nSee_Also:\n $(XREF regex, _splitter) for a version that splits using a regular\nexpression defined separator.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3053_3245)\n---\nimport std.algorithm.comparison : equal;\n\nassert(equal(splitter(\"hello  world\", ' '), [ \"hello\", \"\", \"world\" ]));\nint[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];\nint[][] w = [ [1, 2], [], [3], [4, 5], [] ];\nassert(equal(splitter(a, 0), w));\na = [ 0 ];\nassert(equal(splitter(a, 0), [ (int[]).init, (int[]).init ]));\na = [ 0, 1 ];\nassert(equal(splitter(a, 0), [ [], [1] ]));\nw = [ [0], [1], [2] ];\nassert(equal(splitter!\"a.front == b\"(w, 1), [ [[0]], [[2]] ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3053_3245)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!pred(r.front, s)) : bool) && (hasSlicing!Range && hasLength!Range || isNarrowString!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitter",
						"line": 3176,
						"type": "(Range r, Separator s)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "s",
								"type": "Separator"
							}
						],
						"endline": 3291,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "splitter",
				"line": 3176,
				"comment": "Similar to the previous overload of $(D splitter), except this one uses another\nrange as a separator. This can be used with any narrow string type or sliceable\nrange type, but is most popular with string types.\n\nTwo adjacent separators are considered to surround an empty element in\nthe split range. Use $(D filter!(a => !a.empty)) on the result to compress\nempty elements.\n\nParams:\n    pred = The predicate for comparing each element with the separator,\n        defaulting to $(D \"a == b\").\n    r = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to be\n        split.\n    s = The $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) to\n        be treated as the separator between segments of $(D r) to be split.\n\nConstraints:\n    The predicate $(D pred) needs to accept an element of $(D r) and an\n    element of $(D s).\n\nReturns:\n    An input range of the subranges of elements between separators. If $(D r)\n    is a forward range or bidirectional range, the returned range will be\n    likewise.\n\nSee_Also: $(XREF regex, _splitter) for a version that splits using a regular\nexpression defined separator.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3294_3248)\n---\nimport std.algorithm.comparison : equal;\n\nassert(equal(splitter(\"hello  world\", \"  \"), [ \"hello\", \"world\" ]));\nint[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];\nint[][] w = [ [1, 2], [3, 0, 4, 5, 0] ];\nassert(equal(splitter(a, [0, 0]), w));\na = [ 0, 0 ];\nassert(equal(splitter(a, [0, 0]), [ (int[]).init, (int[]).init ]));\na = [ 0, 0, 1 ];\nassert(equal(splitter(a, [0, 0]), [ [], [1] ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3294_3248)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!pred(r.front, s.front)) : bool) && (hasSlicing!Range || isNarrowString!Range) && isForwardRange!Separator && (hasLength!Separator || isNarrowString!Separator)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitter",
						"line": 3443,
						"type": "(Range input)",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							}
						],
						"endline": 3447,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "splitter",
				"line": 3443,
				"comment": "\nSimilar to the previous overload of $(D splitter), except this one does not use a separator.\nInstead, the predicate is an unary function on the input range's element type.\n\nTwo adjacent separators are considered to surround an empty element in\nthe split range. Use $(D filter!(a => !a.empty)) on the result to compress\nempty elements.\n\nParams:\n    isTerminator = The predicate for deciding where to split the range.\n    input = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to\n        be split.\n\nConstraints:\n    The predicate $(D isTerminator) needs to accept an element of $(D input).\n\nReturns:\n    An input range of the subranges of elements between separators. If $(D input)\n    is a forward range or bidirectional range, the returned range will be\n    likewise.\n\nSee_Also: $(XREF regex, _splitter) for a version that splits using a regular\nexpression defined separator.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3450_3255)\n---\nimport std.algorithm.comparison : equal;\n\nassert(equal(splitter!\"a == ' '\"(\"hello  world\"), [ \"hello\", \"\", \"world\" ]));\nint[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];\nint[][] w = [ [1, 2], [], [3], [4, 5], [] ];\nassert(equal(splitter!\"a == 0\"(a), w));\na = [ 0 ];\nassert(equal(splitter!\"a == 0\"(a), [ (int[]).init, (int[]).init ]));\na = [ 0, 1 ];\nassert(equal(splitter!\"a == 0\"(a), [ [], [1] ]));\nw = [ [0], [1], [2] ];\nassert(equal(splitter!\"a.front == 1\"(w), [ [[0]], [[2]] ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3450_3255)\n",
				"parameters": [
					{
						"name": "isTerminator",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && is(typeof(unaryFun!isTerminator(input.front)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitter",
						"line": 3679,
						"type": "(C[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "C[]"
							}
						],
						"endline": 3731,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "splitter",
				"line": 3679,
				"comment": "Lazily splits the string $(D s) into words, using whitespace as the delimiter.\n\nThis function is string specific and, contrary to\n$(D splitter!(std.uni.isWhite)), runs of whitespace will be merged together\n(no empty tokens will be produced).\n\nParams:\n    s = The string to be split.\n\nReturns:\n    An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of slices of\n    the original string split by whitespace.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3734_3260)\n---\nimport std.algorithm.comparison : equal;\nauto a = \" a     bcd   ef gh \";\nassert(equal(splitter(a), [\"a\", \"bcd\", \"ef\", \"gh\"][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3734_3260)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sum",
						"line": 3904,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3913,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sum",
				"line": 3904,
				"comment": "Sums elements of $(D r), which must be a finite\n$(XREF_PACK_NAMED range,primitives,isInputRange,input range). Although\nconceptually $(D sum(r)) is equivalent to $(LREF reduce)!((a, b) => a +\nb)(0, r), $(D sum) uses specialized algorithms to maximize accuracy,\nas follows.\n\n$(UL\n$(LI If $(D $(XREF_PACK range,primitives,ElementType)!R) is a floating-point\ntype and $(D R) is a\n$(XREF_PACK_NAMED range,primitives,isRandomAccessRange,random-access range) with\nlength and slicing, then $(D sum) uses the\n$(WEB en.wikipedia.org/wiki/Pairwise_summation, pairwise summation)\nalgorithm.)\n$(LI If $(D ElementType!R) is a floating-point type and $(D R) is a\nfinite input range (but not a random-access range with slicing), then\n$(D sum) uses the $(WEB en.wikipedia.org/wiki/Kahan_summation,\nKahan summation) algorithm.)\n$(LI In all other cases, a simple element by element addition is done.)\n)\n\nFor floating point inputs, calculations are made in\n$(DDLINK spec/type, Types, $(D real))\nprecision for $(D real) inputs and in $(D double) precision otherwise\n(Note this is a special case that deviates from $(D reduce)'s behavior,\nwhich would have kept $(D float) precision for a $(D float) range).\nFor all other types, the calculations are done in the same type obtained\nfrom from adding two elements of the range, which may be a different\ntype from the elements themselves (for example, in case of\n$(DDSUBLINK spec/type,integer-promotions, integral promotion)).\n\nA seed may be passed to $(D sum). Not only will this seed be used as an initial\nvalue, but its type will override all the above, and determine the algorithm\nand precision used for summation.\n\nNote that these specialized summing algorithms execute more primitive operations\nthan vanilla summation. Therefore, if in certain cases maximum speed is required\nat expense of precision, one can use $(D reduce!((a, b) => a + b)(0, r)), which\nis not specialized for summation.\n\nParams:\n    seed = the initial value of the summation\n    r = a finite input range\n\nReturns:\n    The sum of all the elements in the range r.\nExample:\nDitto$(DDOX_UNITTEST_HEADER __unittestL3960_3273)\n---\nimport std.range;\n\n//simple integral sumation\nassert(sum([ 1, 2, 3, 4]) == 10);\n\n//with integral promotion\nassert(sum([false, true, true, false, true]) == 3);\nassert(sum(ubyte.max.repeat(100)) == 25500);\n\n//The result may overflow\nassert(uint.max.repeat(3).sum()           ==  4294967293U );\n//But a seed can be used to change the sumation primitive\nassert(uint.max.repeat(3).sum(ulong.init) == 12884901885UL);\n\n//Floating point sumation\nassert(sum([1.0, 2.0, 3.0, 4.0]) == 10);\n\n//Floating point operations have double precision minimum\nstatic assert(is(typeof(sum([1F, 2F, 3F, 4F])) == double));\nassert(sum([1F, 2, 3, 4]) == 10);\n\n//Force pair-wise floating point sumation on large integers\nimport std.math : approxEqual;\nassert(iota(ulong.max / 2, ulong.max / 2 + 4096).sum(0.0)\n           .approxEqual((ulong.max / 2) * 4096.0 + 4096^^2 / 2));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3960_3273)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && !isInfinite!R && is(typeof(r.front + r.front))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sum",
						"line": 3915,
						"type": "(R r, E seed)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							},
							{
								"name": "seed",
								"type": "E"
							}
						],
						"endline": 3929,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sum",
				"line": 3915,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && !isInfinite!R && is(typeof(seed = seed + r.front))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniq",
						"line": 4075,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 4079,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniq",
				"line": 4075,
				"comment": "Lazily iterates unique consecutive elements of the given range (functionality\nakin to the $(WEB wikipedia.org/wiki/_Uniq, _uniq) system\nutility). Equivalence of elements is assessed by using the predicate\n$(D pred), by default $(D \"a == b\"). If the given range is\nbidirectional, $(D uniq) also yields a bidirectional range.\n\nParams:\n    pred = Predicate for determining equivalence between range elements.\n    r = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of\n        elements to filter.\n\nReturns:\n    An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of\n    consecutively unique elements in the original range. If $(D r) is also a\n    forward range or bidirectional range, the returned range will be likewise.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4082_3280)\n---\nimport std.algorithm.mutation : copy;\nimport std.algorithm.comparison : equal;\n\nint[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];\nassert(equal(uniq(arr), [ 1, 2, 3, 4, 5 ][]));\n\n// Filter duplicates in-place using copy\narr.length -= arr.uniq().copy(arr).length;\nassert(arr == [ 1, 2, 3, 4, 5 ]);\n\n// Note that uniqueness is only determined consecutively; duplicated\n// elements separated by an intervening different element will not be\n// eliminated:\nassert(equal(uniq([ 1, 1, 2, 1, 1, 3, 1]), [1, 2, 1, 3, 1]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4082_3280)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(typeof(binaryFun!pred(r.front, r.front)) == bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "permutations",
						"line": 4250,
						"type": "Permutations!Range(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 4254,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "permutations",
				"line": 4250,
				"comment": "Lazily computes all _permutations of $(D r) using $(WEB\nen.wikipedia.org/wiki/Heap%27s_algorithm, Heap's algorithm).\n\nReturns:\nA forward range the elements of which are an $(XREF range,\nindexed) view into $(D r).\n\nSee_Also:\n$(XREF_PACK algorithm,sorting,nextPermutation).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4257_3282)\n---\nimport std.algorithm.comparison : equal;\nimport std.range : iota;\nassert(equal!equal(iota(3).permutations,\n    [[0, 1, 2],\n     [1, 0, 2],\n     [2, 0, 1],\n     [0, 2, 1],\n     [1, 2, 0],\n     [2, 1, 0]]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4257_3282)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && hasLength!Range",
				"char": 20,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic _iteration algorithms.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 cache,\n        Eagerly evaluates and caches another range's $(D front).)\n$(T2 cacheBidirectional,\n        As above, but also provides $(D back) and $(D popBack).)\n$(T2 chunkBy,\n        $(D chunkBy!((a,b) => a[1] == b[1])([[1, 1], [1, 2], [2, 2], [2, 1]]))\n        returns a range containing 3 subranges: the first with just\n        $(D [1, 1]); the second with the elements $(D [1, 2]) and $(D [2, 2]);\n        and the third with just $(D [2, 1]).)\n$(T2 each,\n        $(D each!writeln([1, 2, 3])) eagerly prints the numbers $(D 1), $(D 2)\n        and $(D 3) on their own lines.)\n$(T2 filter,\n        $(D filter!\"a > 0\"([1, -1, 2, 0, -3])) iterates over elements $(D 1)\n        and $(D 2).)\n$(T2 filterBidirectional,\n        Similar to $(D filter), but also provides $(D back) and $(D popBack) at\n        a small increase in cost.)\n$(T2 group,\n        $(D group([5, 2, 2, 3, 3])) returns a range containing the tuples\n        $(D tuple(5, 1)), $(D tuple(2, 2)), and $(D tuple(3, 2)).)\n$(T2 joiner,\n        $(D joiner([\"hello\", \"world!\"], \"; \")) returns a range that iterates\n        over the characters $(D \"hello; world!\"). No new string is created -\n        the existing inputs are iterated.)\n$(T2 map,\n        $(D map!\"2 * a\"([1, 2, 3])) lazily returns a range with the numbers\n        $(D 2), $(D 4), $(D 6).)\n$(T2 permutations,\n        Lazily computes all permutations using Heap's algorithm.)\n$(T2 reduce,\n        $(D reduce!\"a + b\"([1, 2, 3, 4])) returns $(D 10).)\n$(T2 splitter,\n        Lazily splits a range by a separator.)\n$(T2 sum,\n        Same as $(D reduce), but specialized for accurate summation.)\n$(T2 uniq,\n        Iterates over the unique elements in a range, which is assumed sorted.)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_iteration.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/package.d",
		"name": "std.algorithm",
		"members": [],
		"comment": "This package implements generic algorithms oriented towards the processing of\nsequences. Sequences processed by these functions define range-based\ninterfaces.  See also $(LINK2 std_range.html, Reference on ranges) and\n$(WEB ddili.org/ders/d.en/ranges.html, tutorial on ranges).\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\nAlgorithms are categorized into the following submodules:\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Submodule) $(TH Functions)\n)\n$(TR $(TDNW Searching)\n     $(TDNW $(SUBMODULE searching))\n     $(TD\n        $(SUBREF searching, all)\n        $(SUBREF searching, any)\n        $(SUBREF searching, balancedParens)\n        $(SUBREF searching, boyerMooreFinder)\n        $(SUBREF searching, canFind)\n        $(SUBREF searching, commonPrefix)\n        $(SUBREF searching, count)\n        $(SUBREF searching, countUntil)\n        $(SUBREF searching, endsWith)\n        $(SUBREF searching, find)\n        $(SUBREF searching, findAdjacent)\n        $(SUBREF searching, findAmong)\n        $(SUBREF searching, findSkip)\n        $(SUBREF searching, findSplit)\n        $(SUBREF searching, findSplitAfter)\n        $(SUBREF searching, findSplitBefore)\n        $(SUBREF searching, minCount)\n        $(SUBREF searching, minPos)\n        $(SUBREF searching, skipOver)\n        $(SUBREF searching, startsWith)\n        $(SUBREF searching, until)\n    )\n)\n$(TR $(TDNW Comparison)\n    $(TDNW $(SUBMODULE comparison))\n    $(TD\n        $(SUBREF comparison, among)\n        $(SUBREF comparison, castSwitch)\n        $(SUBREF comparison, clamp)\n        $(SUBREF comparison, cmp)\n        $(SUBREF comparison, equal)\n        $(SUBREF comparison, isPermutation)\n        $(SUBREF comparison, isSameLength)\n        $(SUBREF comparison, levenshteinDistance)\n        $(SUBREF comparison, levenshteinDistanceAndPath)\n        $(SUBREF comparison, max)\n        $(SUBREF comparison, min)\n        $(SUBREF comparison, mismatch)\n        $(SUBREF comparison, predSwitch)\n    )\n)\n$(TR $(TDNW Iteration)\n    $(TDNW $(SUBMODULE iteration))\n    $(TD\n        $(SUBREF iteration, cache)\n        $(SUBREF iteration, cacheBidirectional)\n        $(SUBREF iteration, chunkBy)\n        $(SUBREF iteration, each)\n        $(SUBREF iteration, filter)\n        $(SUBREF iteration, filterBidirectional)\n        $(SUBREF iteration, group)\n        $(SUBREF iteration, joiner)\n        $(SUBREF iteration, map)\n        $(SUBREF iteration, permutations)\n        $(SUBREF iteration, reduce)\n        $(SUBREF iteration, splitter)\n        $(SUBREF iteration, sum)\n        $(SUBREF iteration, uniq)\n    )\n)\n$(TR $(TDNW Sorting)\n    $(TDNW $(SUBMODULE sorting))\n    $(TD\n        $(SUBREF sorting, completeSort)\n        $(SUBREF sorting, isPartitioned)\n        $(SUBREF sorting, isSorted)\n        $(SUBREF sorting, makeIndex)\n        $(SUBREF sorting, multiSort)\n        $(SUBREF sorting, nextEvenPermutation)\n        $(SUBREF sorting, nextPermutation)\n        $(SUBREF sorting, partialSort)\n        $(SUBREF sorting, partition)\n        $(SUBREF sorting, partition3)\n        $(SUBREF sorting, schwartzSort)\n        $(SUBREF sorting, sort)\n        $(SUBREF sorting, topN)\n        $(SUBREF sorting, topNCopy)\n        $(SUBREF sorting, topNIndex)\n    )\n)\n$(TR $(TDNW Set&nbsp;operations)\n    $(TDNW $(SUBMODULE setops))\n    $(TD\n        $(SUBREF setops, cartesianProduct)\n        $(SUBREF setops, largestPartialIntersection)\n        $(SUBREF setops, largestPartialIntersectionWeighted)\n        $(SUBREF setops, nWayUnion)\n        $(SUBREF setops, setDifference)\n        $(SUBREF setops, setIntersection)\n        $(SUBREF setops, setSymmetricDifference)\n        $(SUBREF setops, setUnion)\n    )\n)\n$(TR $(TDNW Mutation)\n    $(TDNW $(SUBMODULE mutation))\n    $(TD\n        $(SUBREF mutation, bringToFront)\n        $(SUBREF mutation, copy)\n        $(SUBREF mutation, fill)\n        $(SUBREF mutation, initializeAll)\n        $(SUBREF mutation, move)\n        $(SUBREF mutation, moveAll)\n        $(SUBREF mutation, moveSome)\n        $(SUBREF mutation, remove)\n        $(SUBREF mutation, reverse)\n        $(SUBREF mutation, strip)\n        $(SUBREF mutation, stripLeft)\n        $(SUBREF mutation, stripRight)\n        $(SUBREF mutation, swap)\n        $(SUBREF mutation, swapRanges)\n        $(SUBREF mutation, uninitializedFill)\n    )\n)\n))\n\nMany functions in this package are parameterized with a $(GLOSSARY predicate).\nThe predicate may be any suitable callable type\n(a function, a delegate, a $(GLOSSARY functor), or a lambda), or a\ncompile-time string. The string may consist of $(B any) legal D\nexpression that uses the symbol $(D a) (for unary functions) or the\nsymbols $(D a) and $(D b) (for binary functions). These names will NOT\ninterfere with other homonym symbols in user code because they are\nevaluated in a different context. The default for all binary\ncomparison predicates is $(D \"a == b\") for unordered operations and\n$(D \"a < b\") for ordered operations.\n\nExample:\n\n----\nint[] a = ...;\nstatic bool greater(int a, int b)\n{\n    return a > b;\n}\nsort!(greater)(a);         // predicate as alias\nsort!((a, b) => a > b)(a); // predicate as a lambda.\nsort!(\"a > b\")(a);         // predicate as string\n                           // (no ambiguity with array name)\nsort(a);                   // no predicate, \"a < b\" is implicit\n----\n\nMacros:\nWIKI = Phobos/StdAlgorithm\nSUBMODULE = $(LINK2 std_algorithm_$1.html, std.algorithm.$1)\nSUBREF = $(LINK2 std_algorithm_$1.html#.$2, $(TT $2))$(NBSP)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/_algorithm/package.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/searching.d",
		"name": "std.algorithm.searching",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "all",
								"line": 107,
								"type": "bool(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 113,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "all",
						"line": 107,
						"comment": "    Returns $(D true) if and only if $(I _all) values $(D v) found in the\n    input _range $(D range) satisfy the predicate $(D pred).\n    Performs (at most) $(BIGOH range.length) evaluations of $(D pred).\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && is(typeof(unaryFun!pred(range.front)))",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "all",
				"line": 100,
				"comment": "Checks if $(I _all) of the elements verify $(D pred).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL117_3283)\n---\nassert( all!\"a & 1\"([1, 3, 5, 7, 9]));\nassert(!all!\"a & 1\"([1, 2, 3, 5, 7, 9]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL117_3283)\nExample:\n$(D all) can also be used without a predicate, if its items can be\nevaluated to true or false in a conditional statement. This can be a\nconvenient way to quickly evaluate that $(I _all) of the elements of a range\nare true.$(DDOX_UNITTEST_HEADER __unittestL129_3284)\n---\nint[3] vals = [5, 3, 18];\nassert( all(vals[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL129_3284)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "any",
								"line": 153,
								"type": "bool(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 157,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "any",
						"line": 153,
						"comment": "    Returns $(D true) if and only if $(I _any) value $(D v) found in the\n    input _range $(D range) satisfies the predicate $(D pred).\n    Performs (at most) $(BIGOH range.length) evaluations of $(D pred).\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && is(typeof(unaryFun!pred(range.front)))",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "any",
				"line": 146,
				"comment": "Checks if $(I _any) of the elements verifies $(D pred).\n$(D !any) can be used to verify that $(I none) of the elements verify\n$(D pred).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL161_3287)\n---\nimport std.ascii : isWhite;\nassert( all!(any!isWhite)([\"a a\", \"b b\"]));\nassert(!any!(all!isWhite)([\"a a\", \"b b\"]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL161_3287)\nExample:\n$(D any) can also be used without a predicate, if its items can be\nevaluated to true or false in a conditional statement. $(D !any) can be a\nconvenient way to quickly test that $(I none) of the elements of a range\nevaluate to true.$(DDOX_UNITTEST_HEADER __unittestL174_3288)\n---\nint[3] vals1 = [0, 0, 0];\nassert(!any(vals1[])); //none of vals1 evaluate to true\n\nint[3] vals2 = [2, 0, 2];\nassert( any(vals2[]));\nassert(!all(vals2[]));\n\nint[3] vals3 = [3, 3, 3];\nassert( any(vals3[]));\nassert( all(vals3[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL174_3288)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "balancedParens",
						"line": 214,
						"type": "bool(Range r, E lPar, E rPar, size_t maxNestingLevel = size_t.max)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "lPar",
								"type": "E"
							},
							{
								"name": "rPar",
								"type": "E"
							},
							{
								"name": "maxNestingLevel",
								"type": "size_t",
								"default": "size_t.max"
							}
						],
						"endline": 233,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "balancedParens",
				"line": 214,
				"comment": "Checks whether $(D r) has \"balanced parentheses\", i.e. all instances\nof $(D lPar) are closed by corresponding instances of $(D rPar). The\nparameter $(D maxNestingLevel) controls the nesting level allowed. The\nmost common uses are the default or $(D 0). In the latter case, no\nnesting is allowed.\n\nParams:\n    r = The range to check.\n    lPar = The element corresponding with a left (opening) parenthesis.\n    rPar = The element corresponding with a right (closing) parenthesis.\n    maxNestingLevel = The maximum allowed nesting level.\n\nReturns:\n    true if the given range has balanced parenthesis within the given maximum\n    nesting level; false otherwise.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL236_3290)\n---\nauto s = \"1 + (2 * (3 + 1 / 2)\";\nassert(!balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) / 2)\";\nassert(balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) / 2)\";\nassert(!balancedParens(s, '(', ')', 0));\ns = \"1 + (2 * 3 + 1) / (2 - 5)\";\nassert(balancedParens(s, '(', ')', 0));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL236_3290)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(typeof(r.front == lPar))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "boyerMooreFinder",
						"line": 263,
						"type": "BoyerMooreFinder!(binaryFun!pred, Range)(Range needle)",
						"parameters": [
							{
								"name": "needle",
								"type": "Range"
							}
						],
						"endline": 268,
						"char": 44,
						"kind": "function"
					}
				],
				"name": "boyerMooreFinder",
				"line": 263,
				"comment": " Sets up Boyer-Moore matching for use with $(D find) below.\n By default, elements are compared for equality.\n\n $(D BoyerMooreFinder) allocates GC memory.\n\n Params:\n pred = Predicate used to compare elements.\n needle = A random-access range with length and slicing.\n\n Returns:\n An instance of $(D BoyerMooreFinder) that can be used with $(D find()) to\n invoke the Boyer-Moore matching algorithm for finding of $(D needle) in a\n given haystack.\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range || isSomeString!Range",
				"char": 44,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "BoyerMooreFinder",
						"line": 271,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "BoyerMooreFinder",
				"line": 271,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "commonPrefix",
						"line": 389,
						"type": "(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 420,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "commonPrefix",
				"line": 389,
				"comment": "Returns the common prefix of two ranges.\n\nParams:\n    pred = The predicate to use in comparing elements for commonality. Defaults\n        to equality $(D \"a == b\").\n\n    r1 = A $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) of\n        elements.\n\n    r2 = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of\n        elements.\n\nReturns:\nA slice of $(D r1) which contains the characters that both ranges start with,\nif the first argument is a string; otherwise, the same as the result of\n$(D takeExactly(r1, n)), where $(D n) is the number of elements in the common\nprefix of both ranges.\n\nSee_Also:\n    $(XREF range, takeExactly)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL423_3291)\n---\nassert(commonPrefix(\"hello, world\", \"hello, there\") == \"hello, \");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL423_3291)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isInputRange!R2 && !isNarrowString!R1 && is(typeof(binaryFun!pred(r1.front, r2.front)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "commonPrefix",
						"line": 429,
						"type": "(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 447,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "commonPrefix",
				"line": 429,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isNarrowString!R1 && isInputRange!R2 && is(typeof(binaryFun!pred(r1.front, r2.front)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "commonPrefix",
						"line": 450,
						"type": "(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 455,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "commonPrefix",
				"line": 450,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isNarrowString!R1 && isInputRange!R2 && !isNarrowString!R2 && is(typeof(r1.front == r2.front))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "commonPrefix",
						"line": 458,
						"type": "(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 486,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "commonPrefix",
				"line": 458,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isNarrowString!R1 && isNarrowString!R2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "count",
						"line": 580,
						"type": "size_t(Range haystack, E needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "Range"
							},
							{
								"name": "needle",
								"type": "E"
							}
						],
						"endline": 586,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "count",
				"line": 580,
				"comment": "The first version counts the number of elements $(D x) in $(D r) for\nwhich $(D pred(x, value)) is $(D true). $(D pred) defaults to\nequality. Performs $(BIGOH haystack.length) evaluations of $(D pred).\n\nThe second version returns the number of times $(D needle) occurs in\n$(D haystack). Throws an exception if $(D needle.empty), as the _count\nof the empty range in any range would be infinite. Overlapped counts\nare not considered, for example $(D count(\"aaa\", \"aa\")) is $(D 1), not\n$(D 2).\n\nThe third version counts the elements for which $(D pred(x)) is $(D\ntrue). Performs $(BIGOH haystack.length) evaluations of $(D pred).\n\nNote: Regardless of the overload, $(D count) will not accept\ninfinite ranges for $(D haystack).\n\nParams:\n    pred = The predicate to evaluate.\n    haystack = The range to _count.\n    needle = The element or sub-range to _count in the `haystack`.\n\nReturns:\n    The number of positions in the `haystack` for which `pred` returned true.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL589_3295)\n---\nimport std.uni : toLower;\n\n// count elements in range\nint[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];\nassert(count(a, 2) == 3);\nassert(count!(\"a > b\")(a, 2) == 5);\n// count range in range\nassert(count(\"abcadfabf\", \"ab\") == 2);\nassert(count(\"ababab\", \"abab\") == 1);\nassert(count(\"ababab\", \"abx\") == 0);\n// fuzzy count range in range\nassert(count!((a, b) => std.uni.toLower(a) == std.uni.toLower(b))(\"AbcAdFaBf\", \"ab\") == 2);\n// count predicate in range\nassert(count!(\"a > 1\")(a) == 8);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL589_3295)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && !isInfinite!Range && is(typeof(binaryFun!pred(haystack.front, needle)) : bool)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "count",
						"line": 637,
						"type": "size_t(R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1"
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 658,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "count",
				"line": 637,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && !isInfinite!R1 && isForwardRange!R2 && is(typeof(binaryFun!pred(haystack.front, needle.front)) : bool)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "count",
						"line": 661,
						"type": "size_t(R haystack)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R"
							}
						],
						"endline": 670,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "count",
				"line": 661,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"true\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && !isInfinite!R && is(typeof(unaryFun!pred(haystack.front)) : bool)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "countUntil",
						"line": 708,
						"type": "ptrdiff_t(R haystack, Rs needles)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R"
							},
							{
								"name": "needles",
								"type": "Rs"
							}
						],
						"endline": 793,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "countUntil",
				"line": 708,
				"comment": "    Counts elements in the given\n    $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range)\n    until the given predicate is true for one of the given $(D needles).\n\n    Params:\n        pred = The predicate for determining when to stop counting.\n        haystack = The\n            $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to be\n            counted.\n        needles = Either a single element, or a\n            $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range)\n            of elements, to be evaluated in turn against each\n            element in $(D haystack) under the given predicate.\n\n    Returns: The number of elements which must be popped from the front of\n    $(D haystack) before reaching an element for which\n    $(D startsWith!pred(haystack, needles)) is $(D true). If\n    $(D startsWith!pred(haystack, needles)) is not $(D true) for any element in\n    $(D haystack), then $(D -1) is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL805_3300)\n---\nassert(countUntil(\"hello world\", \"world\") == 6);\nassert(countUntil(\"hello world\", 'r') == 8);\nassert(countUntil(\"hello world\", \"programming\") == -1);\nassert(countUntil(\"日本語\", \"本語\") == 1);\nassert(countUntil(\"日本語\", '語')   == 2);\nassert(countUntil(\"日本語\", \"五\") == -1);\nassert(countUntil(\"日本語\", '五') == -1);\nassert(countUntil([0, 7, 12, 22, 9], [12, 22]) == 2);\nassert(countUntil([0, 7, 12, 22, 9], 9) == 4);\nassert(countUntil!\"a > b\"([0, 7, 12, 22, 9], 20) == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL805_3300)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"constraint": "isForwardRange!R && Rs.length > 0 && isForwardRange!(Rs[0]) == isInputRange!(Rs[0]) && is(typeof(startsWith!pred(haystack, needles[0]))) && (Rs.length == 1 || is(typeof(countUntil!pred(haystack, needles[1..__dollar]))))",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "countUntil",
						"line": 796,
						"type": "ptrdiff_t(R haystack, N needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R"
							},
							{
								"name": "needle",
								"type": "N"
							}
						],
						"endline": 802,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "countUntil",
				"line": 796,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "N",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && is(typeof(binaryFun!pred(haystack.front, needle)) : bool)",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "countUntil",
						"line": 866,
						"type": "ptrdiff_t(R haystack)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R"
							}
						],
						"endline": 907,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "countUntil",
				"line": 866,
				"comment": "    Similar to the previous overload of $(D countUntil), except that this one\n    evaluates only the predicate $(D pred).\n\n    Params:\n        pred = Predicate to when to stop counting.\n        haystack = An\n          $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of\n          elements to be counted.\n    Returns: The number of elements which must be popped from $(D haystack)\n    before $(D pred(haystack.front)) is $(D true).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL910_3303)\n---\nimport std.ascii : isDigit;\nimport std.uni : isWhite;\n\nassert(countUntil!(std.uni.isWhite)(\"hello world\") == 5);\nassert(countUntil!(std.ascii.isDigit)(\"hello world\") == -1);\nassert(countUntil!\"a > 20\"([0, 7, 12, 22, 9]) == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL910_3303)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && is(typeof(unaryFun!pred(haystack.front)) : bool)",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "endsWith",
						"line": 972,
						"type": "uint(Range doesThisEnd, Needles withOneOfThese)",
						"parameters": [
							{
								"name": "doesThisEnd",
								"type": "Range"
							},
							{
								"name": "withOneOfThese",
								"type": "Needles"
							}
						],
						"endline": 1036,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "endsWith",
				"line": 972,
				"comment": "Checks if the given range ends with (one of) the given needle(s).\nThe reciprocal of $(D startsWith).\n\nParams:\n    pred = The predicate to use for comparing elements between the range and\n        the needle(s).\n\n    doesThisEnd = The\n        $(XREF_PACK_NAMED range,primitives,isBidirectionalRange,bidirectional range)\n        to check.\n\n    withOneOfThese = The needles to check against, which may be single\n        elements, or bidirectional ranges of elements.\n\n    withThis = The single element to check.\n\nReturns:\n0 if the needle(s) do not occur at the end of the given range;\notherwise the position of the matching needle, that is, 1 if the range ends\nwith $(D withOneOfThese[0]), 2 if it ends with $(D withOneOfThese[1]), and so\non.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1077_3305)\n---\nassert(endsWith(\"abc\", \"\"));\nassert(!endsWith(\"abc\", \"b\"));\nassert(endsWith(\"abc\", \"a\", 'c') == 2);\nassert(endsWith(\"abc\", \"c\", \"a\") == 1);\nassert(endsWith(\"abc\", \"c\", \"c\") == 1);\nassert(endsWith(\"abc\", \"bc\", \"c\") == 2);\nassert(endsWith(\"abc\", \"x\", \"c\", \"b\") == 2);\nassert(endsWith(\"abc\", \"x\", \"aa\", \"bc\") == 3);\nassert(endsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(endsWith(\"abc\", \"x\", \"aaa\", 'c', \"sab\") == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1077_3305)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Needles",
						"kind": "tuple"
					}
				],
				"constraint": "isBidirectionalRange!Range && Needles.length > 1 && is(typeof(.endsWith!pred(doesThisEnd, withOneOfThese[0])) : bool) && is(typeof(.endsWith!pred(doesThisEnd, withOneOfThese[1..__dollar])) : uint)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "endsWith",
						"line": 1039,
						"type": "bool(R1 doesThisEnd, R2 withThis)",
						"parameters": [
							{
								"name": "doesThisEnd",
								"type": "R1"
							},
							{
								"name": "withThis",
								"type": "R2"
							}
						],
						"endline": 1064,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "endsWith",
				"line": 1039,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!R1 && isBidirectionalRange!R2 && is(typeof(binaryFun!pred(doesThisEnd.back, withThis.back)) : bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "endsWith",
						"line": 1067,
						"type": "bool(R doesThisEnd, E withThis)",
						"parameters": [
							{
								"name": "doesThisEnd",
								"type": "R"
							},
							{
								"name": "withThis",
								"type": "E"
							}
						],
						"endline": 1074,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "endsWith",
				"line": 1067,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!R && is(typeof(binaryFun!pred(doesThisEnd.back, withThis)) : bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "find",
						"line": 1213,
						"type": "InputRange(InputRange haystack, Element needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "InputRange"
							},
							{
								"name": "needle",
								"type": "Element"
							}
						],
						"endline": 1347,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "find",
				"line": 1213,
				"comment": "Finds an individual element in an input range. Elements of $(D\nhaystack) are compared with $(D needle) by using predicate $(D\npred). Performs $(BIGOH walkLength(haystack)) evaluations of $(D\npred).\n\nTo _find the last occurrence of $(D needle) in $(D haystack), call $(D\nfind(retro(haystack), needle)). See $(XREF range, retro).\n\nParams:\n\npred = The predicate for comparing each element with the needle, defaulting to\n$(D \"a == b\").\nThe negated predicate $(D \"a != b\") can be used to search instead for the first\nelement $(I not) matching the needle.\n\nhaystack = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range)\nsearched in.\n\nneedle = The element searched for.\n\nConstraints:\n\n$(D isInputRange!InputRange && is(typeof(binaryFun!pred(haystack.front, needle)\n: bool)))\n\nReturns:\n\n$(D haystack) advanced such that the front element is the one searched for;\nthat is, until $(D binaryFun!pred(haystack.front, needle)) is $(D true). If no\nsuch position exists, returns an empty $(D haystack).\n\nSee_Also:\n     $(WEB sgi.com/tech/stl/_find.html, STL's _find)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1350_3307)\n---\nimport std.algorithm.comparison : equal;\nimport std.container : SList;\n\nassert(find(\"hello, world\", ',') == \", world\");\nassert(find([1, 2, 3, 5], 4) == []);\nassert(equal(find(SList!int(1, 2, 3, 4, 5)[], 4), SList!int(4, 5)[]));\nassert(find!\"a > b\"([1, 2, 3, 5], 2) == [3, 5]);\n\nauto a = [ 1, 2, 3 ];\nassert(find(a, 5).empty);       // not found\nassert(!find(a, 2).empty);      // found\n\n// Case-insensitive find of a string\nstring[] s = [ \"Hello\", \"world\", \"!\" ];\nassert(!find!(\"toLower(a) == b\")(s, \"hello\").empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1350_3307)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "InputRange",
						"kind": "type"
					},
					{
						"name": "Element",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!InputRange && is(typeof(binaryFun!pred(haystack.front, needle)) : bool)",
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "find",
						"line": 1498,
						"type": "InputRange(InputRange haystack)",
						"parameters": [
							{
								"name": "haystack",
								"type": "InputRange"
							}
						],
						"endline": 1538,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "find",
				"line": 1498,
				"comment": "Advances the input range $(D haystack) by calling $(D haystack.popFront)\nuntil either $(D pred(haystack.front)), or $(D\nhaystack.empty). Performs $(BIGOH haystack.length) evaluations of $(D\npred).\n\nTo _find the last element of a bidirectional $(D haystack) satisfying\n$(D pred), call $(D find!(pred)(retro(haystack))). See $(XREF\nrange, retro).\n\nParams:\n\npred = The predicate for determining if a given element is the one being\nsearched for.\n\nhaystack = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to\nsearch in.\n\nReturns:\n\n$(D haystack) advanced such that the front element is the one searched for;\nthat is, until $(D binaryFun!pred(haystack.front, needle)) is $(D true). If no\nsuch position exists, returns an empty $(D haystack).\n\nSee_Also:\n     $(WEB sgi.com/tech/stl/find_if.html, STL's find_if)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1541_3328)\n---\nauto arr = [ 1, 2, 3, 4, 1 ];\nassert(find!(\"a > 2\")(arr) == [ 3, 4, 1 ]);\n\n// with predicate alias\nbool pred(int x) { return x + 1 > 1.5; }\nassert(find!(pred)(arr) == arr);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1541_3328)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "InputRange",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!InputRange",
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "find",
						"line": 1587,
						"type": "R1(R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1"
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 1609,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "find",
				"line": 1587,
				"comment": "Finds the first occurrence of a forward range in another forward range.\n\nPerforms $(BIGOH walkLength(haystack) * walkLength(needle)) comparisons in the\nworst case.  There are specializations that improve performance by taking\nadvantage of bidirectional or random access in the given ranges (where\npossible), depending on the statistics of the two ranges' content.\n\nParams:\n\npred = The predicate to use for comparing respective elements from the haystack\nand the needle. Defaults to simple equality $(D \"a == b\").\n\nhaystack = The $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range)\nsearched in.\n\nneedle = The $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range)\nsearched for.\n\nReturns:\n\n$(D haystack) advanced such that $(D needle) is a prefix of it (if no\nsuch position exists, returns $(D haystack) advanced to termination).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1612_3333)\n---\nimport std.container : SList;\n\nassert(find(\"hello, world\", \"World\").empty);\nassert(find(\"hello, world\", \"wo\") == \"world\");\nassert([1, 2, 3, 4].find(SList!int(2, 3)[]) == [2, 3, 4]);\nalias C = Tuple!(int, \"x\", int, \"y\");\nauto a = [C(1,0), C(2,0), C(3,1), C(4,0)];\nassert(a.find!\"a.x == b\"([2, 3]) == [C(2,0), C(3,1), C(4,0)]);\nassert(a[1 .. $].find!\"a.x == b\"([2, 3]) == [C(2,0), C(3,1), C(4,0)]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1612_3333)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isForwardRange!R2 && is(typeof(binaryFun!pred(haystack.front, needle.front)) : bool) && !isRandomAccessRange!R1",
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "find",
						"line": 1952,
						"type": "Tuple!(Range, size_t)(Range haystack, Ranges needles)",
						"parameters": [
							{
								"name": "haystack",
								"type": "Range"
							},
							{
								"name": "needles",
								"type": "Ranges"
							}
						],
						"endline": 1964,
						"char": 23,
						"kind": "function"
					}
				],
				"name": "find",
				"line": 1952,
				"comment": "Finds two or more $(D needles) into a $(D haystack). The predicate $(D\npred) is used throughout to compare elements. By default, elements are\ncompared for equality.\n\nParams:\n\npred = The predicate to use for comparing elements.\n\nhaystack = The target of the search. Must be an input range.\nIf any of $(D needles) is a range with elements comparable to\nelements in $(D haystack), then $(D haystack) must be a forward range\nsuch that the search can backtrack.\n\nneedles = One or more items to search for. Each of $(D needles) must\nbe either comparable to one element in $(D haystack), or be itself a\nforward range with elements comparable with elements in\n$(D haystack).\n\nReturns:\n\nA tuple containing $(D haystack) positioned to match one of the\nneedles and also the 1-based index of the matching element in $(D\nneedles) (0 if none of $(D needles) matched, 1 if $(D needles[0])\nmatched, 2 if $(D needles[1]) matched...). The first needle to be found\nwill be the one that matches. If multiple needles are found at the\nsame spot in the range, then the shortest one is the one which matches\n(if multiple needles of the same length are found at the same spot (e.g\n$(D \"a\") and $(D 'a')), then the left-most of them in the argument list\nmatches).\n\nThe relationship between $(D haystack) and $(D needles) simply means\nthat one can e.g. search for individual $(D int)s or arrays of $(D\nint)s in an array of $(D int)s. In addition, if elements are\nindividually comparable, searches of heterogeneous types are allowed\nas well: a $(D double[]) can be searched for an $(D int) or a $(D\nshort[]), and conversely a $(D long) can be searched for a $(D float)\nor a $(D double[]). This makes for efficient searches without the need\nto coerce one side of the comparison into the other's side type.\n\nThe complexity of the search is $(BIGOH haystack.length *\nmax(needles.length)). (For needles that are individual items, length\nis considered to be 1.) The strategy used in searching several\nsubranges at once maximizes cache usage by moving in $(D haystack) as\nfew times as possible.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1967_3340)\n---\nint[] a = [ 1, 4, 2, 3 ];\nassert(find(a, 4) == [ 4, 2, 3 ]);\nassert(find(a, [ 1, 4 ]) == [ 1, 4, 2, 3 ]);\nassert(find(a, [ 1, 3 ], 4) == tuple([ 4, 2, 3 ], 2));\n// Mixed types allowed if comparable\nassert(find(a, 5, [ 1.2, 3.5 ], 2.0) == tuple([ 2, 3 ], 3));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1967_3340)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length > 1 && is(typeof(startsWith!pred(haystack, needles)))",
				"char": 23,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "find",
						"line": 2076,
						"type": "Range1(Range1 haystack, BoyerMooreFinder!(pred, Range2) needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "Range1"
							},
							{
								"name": "needle",
								"type": "BoyerMooreFinder!(pred, Range2)"
							}
						],
						"endline": 2080,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "find",
				"line": 2076,
				"comment": " Finds $(D needle) in $(D haystack) efficiently using the\n $(LUCKY Boyer-Moore) method.\n\n Params:\n haystack = A random-access range with length and slicing.\n needle = A $(LREF BoyerMooreFinder).\n\n Returns:\n $(D haystack) advanced such that $(D needle) is a prefix of it (if no\n such position exists, returns $(D haystack) advanced to termination).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2097_3346)\n---\nint[] a = [ -1, 0, 1, 2, 3, 4, 5 ];\nint[] b = [ 1, 2, 3 ];\n\nassert(find(a, boyerMooreFinder(b)) == [ 1, 2, 3, 4, 5 ]);\nassert(find(b, boyerMooreFinder(a)).empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2097_3346)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "canFind",
								"line": 2130,
								"type": "bool(Range haystack)",
								"parameters": [
									{
										"name": "haystack",
										"type": "Range"
									}
								],
								"endline": 2134,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "canFind",
						"line": 2130,
						"comment": "    Returns $(D true) if and only if any value $(D v) found in the\n    input range $(D range) satisfies the predicate $(D pred).\n    Performs (at most) $(BIGOH haystack.length) evaluations of $(D pred).\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "is(typeof(find!pred(haystack)))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "canFind",
								"line": 2140,
								"type": "bool(Range haystack, Element needle)",
								"parameters": [
									{
										"name": "haystack",
										"type": "Range"
									},
									{
										"name": "needle",
										"type": "Element"
									}
								],
								"endline": 2144,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "canFind",
						"line": 2140,
						"comment": "    Returns $(D true) if and only if $(D needle) can be found in $(D\n    range). Performs $(BIGOH haystack.length) evaluations of $(D pred).\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							},
							{
								"name": "Element",
								"kind": "type"
							}
						],
						"constraint": "is(typeof(find!pred(haystack, needle)))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "canFind",
								"line": 2157,
								"type": "size_t(Range haystack, Ranges needles)",
								"parameters": [
									{
										"name": "haystack",
										"type": "Range"
									},
									{
										"name": "needles",
										"type": "Ranges"
									}
								],
								"endline": 2163,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "canFind",
						"line": 2157,
						"comment": "    Returns the 1-based index of the first needle found in $(D haystack). If no\n    needle is found, then $(D 0) is returned.\n\n    So, if used directly in the condition of an if statement or loop, the result\n    will be $(D true) if one of the needles is found and $(D false) if none are\n    found, whereas if the result is used elsewhere, it can either be cast to\n    $(D bool) for the same effect or used to get which needle was found first\n    without having to deal with the tuple that $(D LREF find) returns for the\n    same operation.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							},
							{
								"name": "Ranges",
								"kind": "tuple"
							}
						],
						"constraint": "Ranges.length > 1 && allSatisfy!(isForwardRange, Ranges) && is(typeof(find!pred(haystack, needles)))",
						"char": 12,
						"kind": "template"
					}
				],
				"name": "canFind",
				"line": 2121,
				"comment": "Convenience function. Like find, but only returns whether or not the search\nwas successful.\n\nSee_Also:\n$(LREF among) for checking a value against multiple possibilities.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2167_3348)\n---\nassert(canFind([0, 1, 2, 3], 2) == true);\nassert(canFind([0, 1, 2, 3], [1, 2], [2, 3]));\nassert(canFind([0, 1, 2, 3], [1, 2], [2, 3]) == 1);\nassert(canFind([0, 1, 2, 3], [1, 7], [2, 3]));\nassert(canFind([0, 1, 2, 3], [1, 7], [2, 3]) == 2);\n\nassert(canFind([0, 1, 2, 3], 4) == false);\nassert(!canFind([0, 1, 2, 3], [1, 3], [2, 4]));\nassert(canFind([0, 1, 2, 3], [1, 3], [2, 4]) == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2167_3348)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findAdjacent",
						"line": 2218,
						"type": "Range(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 2231,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "findAdjacent",
				"line": 2218,
				"comment": "Advances $(D r) until it finds the first two adjacent elements $(D a),\n$(D b) that satisfy $(D pred(a, b)). Performs $(BIGOH r.length)\nevaluations of $(D pred).\n\nParams:\n    pred = The predicate to satisfy.\n    r = A $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) to\n        search in.\n\nReturns:\n$(D r) advanced to the first occurrence of two adjacent elements that satisfy\nthe given predicate. If there are no such two elements, returns $(D r) advanced\nuntil empty.\n\nSee_Also:\n     $(WEB sgi.com/tech/stl/adjacent_find.html, STL's adjacent_find)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2234_3351)\n---\nint[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];\nauto r = findAdjacent(a);\nassert(r == [ 10, 10, 9, 8, 8, 7, 8, 9 ]);\nauto p = findAdjacent!(\"a < b\")(a);\nassert(p == [ 7, 8, 9 ]);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2234_3351)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findAmong",
						"line": 2295,
						"type": "Range1(Range1 seq, Range2 choices)",
						"parameters": [
							{
								"name": "seq",
								"type": "Range1"
							},
							{
								"name": "choices",
								"type": "Range2"
							}
						],
						"endline": 2303,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "findAmong",
				"line": 2295,
				"comment": "Searches the given range for an element that matches one of the given choices.\n\nAdvances $(D seq) by calling $(D seq.popFront) until either\n$(D find!(pred)(choices, seq.front)) is $(D true), or $(D seq) becomes empty.\nPerforms $(BIGOH seq.length * choices.length) evaluations of $(D pred).\n\nParams:\n    pred = The predicate to use for determining a match.\n    seq = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to\n        search.\n    choices = A $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range)\n        of possible choices.\n\nReturns:\n$(D seq) advanced to the first matching element, or until empty if there are no\nmatching elements.\n\nSee_Also:\n    $(WEB sgi.com/tech/stl/find_first_of.html, STL's find_first_of)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2306_3353)\n---\nint[] a = [ -1, 0, 1, 2, 3, 4, 5 ];\nint[] b = [ 3, 1, 2 ];\nassert(findAmong(a, b) == a[2 .. $]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2306_3353)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isForwardRange!Range2",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findSkip",
						"line": 2341,
						"type": "bool(ref R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 2350,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "findSkip",
				"line": 2341,
				"comment": " Finds $(D needle) in $(D haystack) and positions $(D haystack)\n right after the first occurrence of $(D needle).\n\n Params:\n  haystack = The\n   $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) to search\n   in.\n  needle = The\n   $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) to search\n   for.\n\n Returns: $(D true) if the needle was found, in which case $(D haystack) is\n positioned after the end of the first occurrence of $(D needle); otherwise\n $(D false), leaving $(D haystack) untouched.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2353_3355)\n---\n// Needle is found; s is replaced by the substring following the first\n// occurrence of the needle.\nstring s = \"abcdef\";\nassert(findSkip(s, \"cd\") && s == \"ef\");\n\n// Needle is not found; s is left untouched.\ns = \"abcdef\";\nassert(!findSkip(s, \"cxd\") && s == \"abcdef\");\n\n// If the needle occurs at the end of the range, the range is left empty.\ns = \"abcdef\";\nassert(findSkip(s, \"def\") && s.empty);\n}\n\n/**\nThese functions find the first occurrence of $(D needle) in $(D\nhaystack) and then split $(D haystack) as follows.\n\n$(D findSplit) returns a tuple $(D result) containing $(I three)\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), $(D result[1]) is the portion of $(D haystack) that matches\n$(D needle), and $(D result[2]) is the portion of $(D haystack) after\nthe match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) and $(D result[2])\nare empty.\n\n$(D findSplitBefore) returns a tuple $(D result) containing two\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), and $(D result[1]) is the balance of $(D haystack) starting\nwith the match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) is empty.\n\n$(D findSplitAfter) returns a tuple $(D result) containing two ranges.\n$(D result[0]) is the portion of $(D haystack) up to and including the\nmatch, and $(D result[1]) is the balance of $(D haystack) starting\nafter the match. If $(D needle) was not found, $(D result[0]) is empty\nand $(D result[1]) is $(D haystack).\n\nIn all cases, the concatenation of the returned ranges spans the\nentire $(D haystack).\n\nIf $(D haystack) is a random-access range, all three components of the\ntuple have the same type as $(D haystack). Otherwise, $(D haystack)\nmust be a forward range and the type of $(D result[0]) and $(D\nresult[1]) is the same as $(XREF range,takeExactly).\n\nParams:\npred = Predicate to use for comparing needle against haystack.\nhaystack = The range to search.\nneedle = What to look for.\n\nReturns:\n\nA sub-type of Tuple!() of the split portions of `haystack` (see above for\ndetails).  This sub-type of Tuple!() has opCast defined for bool.  This opCast\nreturns $(D true) when the separating $(D needle) was found (!result[1].empty)\nand $(D false) otherwise.  This enables the convenient idiom shown in the\nfollowing example.\n\nExample:\n---\nif (const split = haystack.findSplit(needle))\n{\n doSomethingWithSplit(split);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2353_3355)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isForwardRange!R2 && is(typeof(binaryFun!pred(haystack.front, needle.front)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findSplit",
						"line": 2422,
						"type": "(R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1"
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 2479,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "findSplit",
				"line": 2422,
				"comment": "These functions find the first occurrence of $(D needle) in $(D\nhaystack) and then split $(D haystack) as follows.\n\n$(D findSplit) returns a tuple $(D result) containing $(I three)\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), $(D result[1]) is the portion of $(D haystack) that matches\n$(D needle), and $(D result[2]) is the portion of $(D haystack) after\nthe match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) and $(D result[2])\nare empty.\n\n$(D findSplitBefore) returns a tuple $(D result) containing two\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), and $(D result[1]) is the balance of $(D haystack) starting\nwith the match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) is empty.\n\n$(D findSplitAfter) returns a tuple $(D result) containing two ranges.\n$(D result[0]) is the portion of $(D haystack) up to and including the\nmatch, and $(D result[1]) is the balance of $(D haystack) starting\nafter the match. If $(D needle) was not found, $(D result[0]) is empty\nand $(D result[1]) is $(D haystack).\n\nIn all cases, the concatenation of the returned ranges spans the\nentire $(D haystack).\n\nIf $(D haystack) is a random-access range, all three components of the\ntuple have the same type as $(D haystack). Otherwise, $(D haystack)\nmust be a forward range and the type of $(D result[0]) and $(D\nresult[1]) is the same as $(XREF range,takeExactly).\n\nParams:\n    pred = Predicate to use for comparing needle against haystack.\n    haystack = The range to search.\n    needle = What to look for.\n\nReturns:\n\nA sub-type of Tuple!() of the split portions of `haystack` (see above for\ndetails).  This sub-type of Tuple!() has opCast defined for bool.  This opCast\nreturns $(D true) when the separating $(D needle) was found (!result[1].empty)\nand $(D false) otherwise.  This enables the convenient idiom shown in the\nfollowing example.\n\nExample:\n---\nif (const split = haystack.findSplit(needle))\n{\n     doSomethingWithSplit(split);\n}\n---\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2602_3356)\n---\nauto a = \"Carl Sagan Memorial Station\";\nauto r = findSplit(a, \"Velikovsky\");\nimport std.typecons : isTuple;\nstatic assert(isTuple!(typeof(r.asTuple)));\nstatic assert(isTuple!(typeof(r)));\nassert(!r);\nassert(r[0] == a);\nassert(r[1].empty);\nassert(r[2].empty);\nr = findSplit(a, \" \");\nassert(r[0] == \"Carl\");\nassert(r[1] == \" \");\nassert(r[2] == \"Sagan Memorial Station\");\nauto r1 = findSplitBefore(a, \"Sagan\");\nassert(r1);\nassert(r1[0] == \"Carl \", r1[0]);\nassert(r1[1] == \"Sagan Memorial Station\");\nauto r2 = findSplitAfter(a, \"Sagan\");\nassert(r2);\nassert(r2[0] == \"Carl Sagan\");\nassert(r2[1] == \" Memorial Station\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2602_3356)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isForwardRange!R2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findSplitBefore",
						"line": 2482,
						"type": "(R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1"
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 2535,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "findSplitBefore",
				"line": 2482,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isForwardRange!R2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findSplitAfter",
						"line": 2538,
						"type": "(R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1"
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 2599,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "findSplitAfter",
				"line": 2538,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isForwardRange!R2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "minCount",
						"line": 2708,
						"type": "Tuple!(ElementType!Range, size_t)(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 2786,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "minCount",
				"line": 2708,
				"comment": "Params:\n    pred = The ordering predicate to use to determine the minimal element.\n    range = The input range to count.\n\nReturns: The minimum element of a range together with the number of\noccurrences. The function can actually be used for counting the\nmaximum or any other ordering predicate (that's why $(D maxCount) is\nnot provided).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2789_3359)\n---\nimport std.conv : text;\n\ndebug(std_algorithm) scope(success)\n    writeln(\"unittest @\", __FILE__, \":\", __LINE__, \" done.\");\n\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n// Minimum is 1 and occurs 3 times\nassert(minCount(a) == tuple(1, 3));\n// Maximum is 4 and occurs 2 times\nassert(minCount!(\"a > b\")(a) == tuple(4, 2));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2789_3359)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && !isInfinite!Range && is(typeof(binaryFun!pred(range.front, range.front)))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "minPos",
						"line": 2902,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 2919,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "minPos",
				"line": 2902,
				"comment": "Params:\n    pred = The ordering predicate to use to determine the minimal element.\n    range = The input range to search.\n\nReturns: The position of the minimum element of forward range $(D range), i.e.\na subrange of $(D range) starting at the position of its smallest element and\nwith the same ending as $(D range). The function can actually be used for\nfinding the maximum or any other ordering predicate (that's why $(D maxPos) is\nnot provided).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2922_3362)\n---\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n// Minimum is 1 and first occurs in position 3\nassert(minPos(a) == [ 1, 2, 4, 1, 1, 2 ]);\n// Maximum is 4 and first occurs in position 2\nassert(minPos!(\"a > b\")(a) == [ 4, 1, 2, 4, 1, 1, 2 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2922_3362)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && !isInfinite!Range && is(typeof(binaryFun!pred(range.front, range.front)))",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "skipOver",
						"line": 2994,
						"type": "bool(ref R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 3013,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "skipOver",
				"line": 2994,
				"comment": "Skip over the initial portion of the first given range that matches the second\nrange, or do nothing if there is no match.\n\nParams:\n    pred = The predicate that determines whether elements from each respective\n        range match. Defaults to equality $(D \"a == b\").\n    r1 = The $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) to\n        move forward.\n    r2 = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range)\n        representing the initial segment of $(D r1) to skip over.\n\nReturns:\ntrue if the initial segment of $(D r1) matches $(D r2), and $(D r1) has been\nadvanced to the point past this segment; otherwise false, and $(D r1) is left\nin its original position.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3039_3372)\n---\nimport std.algorithm.comparison : equal;\n\nauto s1 = \"Hello world\";\nassert(!skipOver(s1, \"Ha\"));\nassert(s1 == \"Hello world\");\nassert(skipOver(s1, \"Hell\") && s1 == \"o world\");\n\nstring[]  r1 = [\"abc\", \"def\", \"hij\"];\ndstring[] r2 = [\"abc\"d];\nassert(!skipOver!((a, b) => a.equal(b))(r1, [\"def\"d]));\nassert(r1 == [\"abc\", \"def\", \"hij\"]);\nassert(skipOver!((a, b) => a.equal(b))(r1, r2));\nassert(r1 == [\"def\", \"hij\"]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3039_3372)\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isInputRange!R2 && is(typeof(r1.front == r2.front))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "skipOver",
						"line": 3016,
						"type": "bool(ref R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 3036,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "skipOver",
				"line": 3016,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!pred(r1.front, r2.front))) && isForwardRange!R1 && isInputRange!R2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "skipOver",
						"line": 3074,
						"type": "bool(ref R r, E e)",
						"parameters": [
							{
								"name": "r",
								"type": "R",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "e",
								"type": "E"
							}
						],
						"endline": 3078,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "skipOver",
				"line": 3074,
				"comment": "Skip over the first element of the given range if it matches the given element,\notherwise do nothing.\n\nParams:\n    pred = The predicate that determines whether an element from the range\n        matches the given element.\n\n    r = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to skip\n        over.\n\n    e = The element to match.\n\nReturns:\ntrue if the first element matches the given element according to the given\npredicate, and the range has been advanced by one element; otherwise false, and\nthe range is left untouched.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3091_3379)\n---\nimport std.algorithm.comparison : equal;\n\nauto s1 = \"Hello world\";\nassert(!skipOver(s1, 'a'));\nassert(s1 == \"Hello world\");\nassert(skipOver(s1, 'H') && s1 == \"ello world\");\n\nstring[] r = [\"abc\", \"def\", \"hij\"];\ndstring e = \"abc\"d;\nassert(!skipOver!((a, b) => a.equal(b))(r, \"def\"d));\nassert(r == [\"abc\", \"def\", \"hij\"]);\nassert(skipOver!((a, b) => a.equal(b))(r, e));\nassert(r == [\"def\", \"hij\"]);\n\nauto s2 = \"\";\nassert(!s2.skipOver('a'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3091_3379)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && is(typeof(r.front == e) : bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "skipOver",
						"line": 3081,
						"type": "bool(ref R r, E e)",
						"parameters": [
							{
								"name": "r",
								"type": "R",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "e",
								"type": "E"
							}
						],
						"endline": 3088,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "skipOver",
				"line": 3081,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!pred(r.front, e))) && isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "startsWith",
						"line": 3142,
						"type": "uint(Range doesThisStart, Needles withOneOfThese)",
						"parameters": [
							{
								"name": "doesThisStart",
								"type": "Range"
							},
							{
								"name": "withOneOfThese",
								"type": "Needles"
							}
						],
						"endline": 3212,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "startsWith",
				"line": 3142,
				"comment": "Checks whether the given\n$(XREF_PACK_NAMED range,primitives,isInputRange,input range) starts with (one\nof) the given needle(s).\n\nParams:\n\n    pred = Predicate to use in comparing the elements of the haystack and the\n        needle(s).\n\n    doesThisStart = The input range to check.\n\n    withOneOfThese = The needles against which the range is to be checked,\n        which may be individual elements or input ranges of elements.\n\n    withThis = The single needle to check, which may be either a single element\n        or an input range of elements.\n\nReturns:\n\n0 if the needle(s) do not occur at the beginning of the given range;\notherwise the position of the matching needle, that is, 1 if the range starts\nwith $(D withOneOfThese[0]), 2 if it starts with $(D withOneOfThese[1]), and so\non.\n\nIn the case where $(D doesThisStart) starts with multiple of the ranges or\nelements in $(D withOneOfThese), then the shortest one matches (if there are\ntwo which match which are of the same length (e.g. $(D \"a\") and $(D 'a')), then\nthe left-most of them in the argument\nlist matches).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3294_3380)\n---\nassert(startsWith(\"abc\", \"\"));\nassert(startsWith(\"abc\", \"a\"));\nassert(!startsWith(\"abc\", \"b\"));\nassert(startsWith(\"abc\", 'a', \"b\") == 1);\nassert(startsWith(\"abc\", \"b\", \"a\") == 2);\nassert(startsWith(\"abc\", \"a\", \"a\") == 1);\nassert(startsWith(\"abc\", \"ab\", \"a\") == 2);\nassert(startsWith(\"abc\", \"x\", \"a\", \"b\") == 2);\nassert(startsWith(\"abc\", \"x\", \"aa\", \"ab\") == 3);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"a\", \"sab\") == 3);\nalias C = Tuple!(int, \"x\", int, \"y\");\nassert(startsWith!\"a.x == b\"([ C(1,1), C(1,2), C(2,2) ], [1, 1]));\nassert(startsWith!\"a.x == b\"([ C(1,1), C(2,1), C(2,2) ], [1, 1], [1, 2], [1, 3]) == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3294_3380)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Needles",
						"kind": "tuple"
					}
				],
				"constraint": "isInputRange!Range && Needles.length > 1 && is(typeof(.startsWith!pred(doesThisStart, withOneOfThese[0])) : bool) && is(typeof(.startsWith!pred(doesThisStart, withOneOfThese[1..__dollar])) : uint)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "startsWith",
						"line": 3215,
						"type": "bool(R1 doesThisStart, R2 withThis)",
						"parameters": [
							{
								"name": "doesThisStart",
								"type": "R1"
							},
							{
								"name": "withThis",
								"type": "R2"
							}
						],
						"endline": 3281,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "startsWith",
				"line": 3215,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R1 && isInputRange!R2 && is(typeof(binaryFun!pred(doesThisStart.front, withThis.front)) : bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "startsWith",
						"line": 3284,
						"type": "bool(R doesThisStart, E withThis)",
						"parameters": [
							{
								"name": "doesThisStart",
								"type": "R"
							},
							{
								"name": "withThis",
								"type": "E"
							}
						],
						"endline": 3291,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "startsWith",
				"line": 3284,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && is(typeof(binaryFun!pred(doesThisStart.front, withThis)) : bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 3441,
						"value": "0",
						"comment": "Interval is closed to the right (last element included)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 3442,
						"value": "1",
						"comment": "Interval is open to the right (last element is not included)\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "OpenRight",
				"line": 3439,
				"comment": "Interval option specifier for $(D until) (below) and others.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "until",
						"line": 3556,
						"type": "Until!(pred, Range, Sentinel)(Range range, Sentinel sentinel, OpenRight openRight = OpenRight.yes)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "sentinel",
								"type": "Sentinel"
							},
							{
								"name": "openRight",
								"type": "OpenRight",
								"default": "OpenRight.yes"
							}
						],
						"endline": 3561,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "until",
				"line": 3556,
				"comment": "Lazily iterates $(D range) _until the element $(D e) for which\n$(D pred(e, sentinel)) is true.\n\nParams:\n    pred = Predicate to determine when to stop.\n    range = The $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n    to iterate over.\n    sentinel = The element to stop at.\n    openRight = Determines whether the element for which the given predicate is\n        true should be included in the resulting range ($(D OpenRight.no)), or\n        not ($(D OpenRight.yes)).\n\nReturns:\n    An $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range) that\n    iterates over the original range's elements, but ends when the specified\n    predicate becomes true. If the original range is a\n    $(XREF_PACK_NAMED _range,primitives,isForwardRange,forward _range) or\n    higher, this range will be a forward range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3572_3383)\n---\nimport std.algorithm.comparison : equal;\nint[] a = [ 1, 2, 4, 7, 7, 2, 4, 7, 3, 5];\nassert(equal(a.until(7), [1, 2, 4][]));\nassert(equal(a.until(7, OpenRight.no), [1, 2, 4, 7][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3572_3383)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Sentinel",
						"kind": "type"
					}
				],
				"constraint": "!is(Sentinel == OpenRight)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "until",
						"line": 3565,
						"type": "Until!(pred, Range, void)(Range range, OpenRight openRight = OpenRight.yes)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "openRight",
								"type": "OpenRight",
								"default": "OpenRight.yes"
							}
						],
						"endline": 3569,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "until",
				"line": 3565,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic _searching algorithms.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 all,\n        $(D all!\"a > 0\"([1, 2, 3, 4])) returns $(D true) because all elements\n        are positive)\n$(T2 any,\n        $(D any!\"a > 0\"([1, 2, -3, -4])) returns $(D true) because at least one\n        element is positive)\n$(T2 balancedParens,\n        $(D balancedParens(\"((1 + 1) / 2)\")) returns $(D true) because the\n        string has balanced parentheses.)\n$(T2 boyerMooreFinder,\n        $(D find(\"hello world\", boyerMooreFinder(\"or\"))) returns $(D \"orld\")\n        using the $(LUCKY Boyer-Moore _algorithm).)\n$(T2 canFind,\n        $(D canFind(\"hello world\", \"or\")) returns $(D true).)\n$(T2 count,\n        Counts elements that are equal to a specified value or satisfy a\n        predicate.  $(D count([1, 2, 1], 1)) returns $(D 2) and\n        $(D count!\"a < 0\"([1, -3, 0])) returns $(D 1).)\n$(T2 countUntil,\n        $(D countUntil(a, b)) returns the number of steps taken in $(D a) to\n        reach $(D b); for example, $(D countUntil(\"hello!\", \"o\")) returns\n        $(D 4).)\n$(T2 commonPrefix,\n        $(D commonPrefix(\"parakeet\", \"parachute\")) returns $(D \"para\").)\n$(T2 endsWith,\n        $(D endsWith(\"rocks\", \"ks\")) returns $(D true).)\n$(T2 find,\n        $(D find(\"hello world\", \"or\")) returns $(D \"orld\") using linear search.\n        (For binary search refer to $(XREF range,sortedRange).))\n$(T2 findAdjacent,\n        $(D findAdjacent([1, 2, 3, 3, 4])) returns the subrange starting with\n        two equal adjacent elements, i.e. $(D [3, 3, 4]).)\n$(T2 findAmong,\n        $(D findAmong(\"abcd\", \"qcx\")) returns $(D \"cd\") because $(D 'c') is\n        among $(D \"qcx\").)\n$(T2 findSkip,\n        If $(D a = \"abcde\"), then $(D findSkip(a, \"x\")) returns $(D false) and\n        leaves $(D a) unchanged, whereas $(D findSkip(a, \"c\")) advances $(D a)\n        to $(D \"de\") and returns $(D true).)\n$(T2 findSplit,\n        $(D findSplit(\"abcdefg\", \"de\")) returns the three ranges $(D \"abc\"),\n        $(D \"de\"), and $(D \"fg\").)\n$(T2 findSplitAfter,\n        $(D findSplitAfter(\"abcdefg\", \"de\")) returns the two ranges\n        $(D \"abcde\") and $(D \"fg\").)\n$(T2 findSplitBefore,\n        $(D findSplitBefore(\"abcdefg\", \"de\")) returns the two ranges $(D \"abc\")\n        and $(D \"defg\").)\n$(T2 minCount,\n        $(D minCount([2, 1, 1, 4, 1])) returns $(D tuple(1, 3)).)\n$(T2 minPos,\n        $(D minPos([2, 3, 1, 3, 4, 1])) returns the subrange $(D [1, 3, 4, 1]),\n        i.e., positions the range at the first occurrence of its minimal\n        element.)\n$(T2 mismatch,\n        $(D mismatch(\"parakeet\", \"parachute\")) returns the two ranges\n        $(D \"keet\") and $(D \"chute\").)\n$(T2 skipOver,\n        Assume $(D a = \"blah\"). Then $(D skipOver(a, \"bi\")) leaves $(D a)\n        unchanged and returns $(D false), whereas $(D skipOver(a, \"bl\"))\n        advances $(D a) to refer to $(D \"ah\") and returns $(D true).)\n$(T2 startsWith,\n        $(D startsWith(\"hello, world\", \"hello\")) returns $(D true).)\n$(T2 until,\n        Lazily iterates a range until a specific value is found.)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_searching.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/setops.d",
		"name": "std.algorithm.setops",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "cartesianProduct",
						"line": 80,
						"type": "(R1 range1, R2 range2)",
						"parameters": [
							{
								"name": "range1",
								"type": "R1"
							},
							{
								"name": "range2",
								"type": "R2"
							}
						],
						"endline": 121,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "cartesianProduct",
				"line": 80,
				"comment": "Lazily computes the Cartesian product of two or more ranges. The product is a\n_range of tuples of elements from each respective range.\n\nThe conditions for the two-range case are as follows:\n\nIf both ranges are finite, then one must be (at least) a forward range and the\nother an input range.\n\nIf one _range is infinite and the other finite, then the finite _range must\nbe a forward _range, and the infinite range can be an input _range.\n\nIf both ranges are infinite, then both must be forward ranges.\n\nWhen there are more than two ranges, the above conditions apply to each\nadjacent pair of ranges.\n\nParams:\n    range1 = The first range\n    range2 = The second range\n    ranges = Two or more non-infinite forward ranges\n    otherRanges = Zero or more non-infinite forward ranges\n\nReturns:\n    A forward range of $(XREF typecons,Tuple) representing elements of the\n    cartesian product of the given ranges.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL124_3390)\n---\nimport std.algorithm.searching : canFind;\nimport std.range;\nimport std.typecons : tuple;\n\nauto N = sequence!\"n\"(0);         // the range of natural numbers\nauto N2 = cartesianProduct(N, N); // the range of all pairs of natural numbers\n\n// Various arbitrary number pairs can be found in the range in finite time.\nassert(canFind(N2, tuple(0, 0)));\nassert(canFind(N2, tuple(123, 321)));\nassert(canFind(N2, tuple(11, 35)));\nassert(canFind(N2, tuple(279, 172)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL124_3390)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL141_3391)\n---\nimport std.algorithm.searching : canFind;\nimport std.typecons : tuple;\n\nauto B = [ 1, 2, 3 ];\nauto C = [ 4, 5, 6 ];\nauto BC = cartesianProduct(B, C);\n\nforeach (n; [[1, 4], [2, 4], [3, 4], [1, 5], [2, 5], [3, 5], [1, 6],\n             [2, 6], [3, 6]])\n{\n    assert(canFind(BC, tuple(n[0], n[1])));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL141_3391)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL503_3402)\n---\nimport std.algorithm.comparison : equal;\nimport std.typecons : tuple;\n\nauto A = [ 1, 2, 3 ];\nauto B = [ 'a', 'b', 'c' ];\nauto C = [ \"x\", \"y\", \"z\" ];\nauto ABC = cartesianProduct(A, B, C);\n\nassert(ABC.equal([\n    tuple(1, 'a', \"x\"), tuple(1, 'a', \"y\"), tuple(1, 'a', \"z\"),\n    tuple(1, 'b', \"x\"), tuple(1, 'b', \"y\"), tuple(1, 'b', \"z\"),\n    tuple(1, 'c', \"x\"), tuple(1, 'c', \"y\"), tuple(1, 'c', \"z\"),\n    tuple(2, 'a', \"x\"), tuple(2, 'a', \"y\"), tuple(2, 'a', \"z\"),\n    tuple(2, 'b', \"x\"), tuple(2, 'b', \"y\"), tuple(2, 'b', \"z\"),\n    tuple(2, 'c', \"x\"), tuple(2, 'c', \"y\"), tuple(2, 'c', \"z\"),\n    tuple(3, 'a', \"x\"), tuple(3, 'a', \"y\"), tuple(3, 'a', \"z\"),\n    tuple(3, 'b', \"x\"), tuple(3, 'b', \"y\"), tuple(3, 'b', \"z\"),\n    tuple(3, 'c', \"x\"), tuple(3, 'c', \"y\"), tuple(3, 'c', \"z\")\n]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL503_3402)\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "!allSatisfy!(isForwardRange, R1, R2) || anySatisfy!(isInfinite, R1, R2)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cartesianProduct",
						"line": 350,
						"type": "(RR ranges)",
						"parameters": [
							{
								"name": "ranges",
								"type": "RR"
							}
						],
						"endline": 414,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "cartesianProduct",
				"line": 350,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "RR",
						"kind": "tuple"
					}
				],
				"constraint": "ranges.length >= 2 && allSatisfy!(isForwardRange, RR) && !anySatisfy!(isInfinite, RR)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cartesianProduct",
						"line": 447,
						"type": "(R1 range1, R2 range2, RR otherRanges)",
						"parameters": [
							{
								"name": "range1",
								"type": "R1"
							},
							{
								"name": "range2",
								"type": "R2"
							},
							{
								"name": "otherRanges",
								"type": "RR"
							}
						],
						"endline": 465,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "cartesianProduct",
				"line": 447,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					},
					{
						"name": "RR",
						"kind": "tuple"
					}
				],
				"constraint": "!allSatisfy!(isForwardRange, R1, R2, RR) || anySatisfy!(isInfinite, R1, R2, RR)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "largestPartialIntersection",
						"line": 602,
						"type": "void(RangeOfRanges ror, Range tgt, SortOutput sorted = SortOutput.no)",
						"parameters": [
							{
								"name": "ror",
								"type": "RangeOfRanges"
							},
							{
								"name": "tgt",
								"type": "Range"
							},
							{
								"name": "sorted",
								"type": "SortOutput",
								"default": "SortOutput.no"
							}
						],
						"endline": 612,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "largestPartialIntersection",
				"line": 602,
				"comment": "Given a range of sorted forward ranges $(D ror), copies to $(D tgt)\nthe elements that are common to most ranges, along with their number\nof occurrences. All ranges in $(D ror) are assumed to be sorted by $(D\nless). Only the most frequent $(D tgt.length) elements are returned.\n\nParams:\n    less = The predicate the ranges are sorted by.\n    ror = A range of forward ranges sorted by `less`.\n    tgt = The target range to copy common elements to.\n    sorted = Whether the elements copied should be in sorted order.\n\nExample:\n----\n// Figure which number can be found in most arrays of the set of\n// arrays below.\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\nlargestPartialIntersection(a, b);\n// First member is the item, second is the occurrence count\nassert(b[0] == tuple(7.0, 4u));\n----\n\n$(D 7.0) is the correct answer because it occurs in $(D 4) out of the\n$(D 5) inputs, more than any other number. The second member of the\nresulting tuple is indeed $(D 4) (recording the number of occurrences\nof $(D 7.0)). If more of the top-frequent numbers are needed, just\ncreate a larger $(D tgt) range. In the example above, creating $(D b)\nwith length $(D 2) yields $(D tuple(1.0, 3u)) in the second position.\n\nThe function $(D largestPartialIntersection) is useful for\ne.g. searching an $(LUCKY inverted index) for the documents most\nlikely to contain some terms of interest. The complexity of the search\nis $(BIGOH n * log(tgt.length)), where $(D n) is the sum of lengths of\nall input ranges. This approach is faster than keeping an associative\narray of the occurrences and then selecting its top items, and also\nrequires less memory ($(D largestPartialIntersection) builds its\nresult directly in $(D tgt) and requires no extra memory).\n\nWarning: Because $(D largestPartialIntersection) does not allocate\nextra memory, it will leave $(D ror) modified. Namely, $(D\nlargestPartialIntersection) assumes ownership of $(D ror) and\ndiscretionarily swaps and advances elements of it. If you want $(D\nror) to preserve its contents after the call, you may want to pass a\nduplicate to $(D largestPartialIntersection) (and perhaps cache the\nduplicate in between calls).\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "largestPartialIntersectionWeighted",
						"line": 652,
						"type": "void(RangeOfRanges ror, Range tgt, WeightsAA weights, SortOutput sorted = SortOutput.no)",
						"parameters": [
							{
								"name": "ror",
								"type": "RangeOfRanges"
							},
							{
								"name": "tgt",
								"type": "Range"
							},
							{
								"name": "weights",
								"type": "WeightsAA"
							},
							{
								"name": "sorted",
								"type": "SortOutput",
								"default": "SortOutput.no"
							}
						],
						"endline": 666,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "largestPartialIntersectionWeighted",
				"line": 652,
				"comment": "Similar to $(D largestPartialIntersection), but associates a weight\nwith each distinct element in the intersection.\n\nParams:\n    less = The predicate the ranges are sorted by.\n    ror = A range of forward ranges sorted by `less`.\n    tgt = The target range to copy common elements to.\n    weights = An associative array mapping elements to weights.\n    sorted = Whether the elements copied should be in sorted order.\n\nExample:\n----\n// Figure which number can be found in most arrays of the set of\n// arrays below, with specific per-element weights\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\ndouble[double] weights = [ 1:1.2, 4:2.3, 7:1.1, 8:1.1 ];\nlargestPartialIntersectionWeighted(a, b, weights);\n// First member is the item, second is the occurrence count\nassert(b[0] == tuple(4.0, 2u));\n----\n\nThe correct answer in this case is $(D 4.0), which, although only\nappears two times, has a total weight $(D 4.6) (three times its weight\n$(D 2.3)). The value $(D 7) is weighted with $(D 1.1) and occurs four\ntimes for a total weight $(D 4.4).\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "WeightsAA",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "NWayUnion",
						"line": 778,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "NWayUnion",
				"line": 778,
				"comment": "Computes the union of multiple sets. The input sets are passed as a\nrange of ranges and each is assumed to be sorted by $(D\nless). Computation is done lazily, one union element at a time. The\ncomplexity of one $(D popFront) operation is $(BIGOH\nlog(ror.length)). However, the length of $(D ror) decreases as ranges\nin it are exhausted, so the complexity of a full pass through $(D\nNWayUnion) is dependent on the distribution of the lengths of ranges\ncontained within $(D ror). If all ranges have the same length $(D n)\n(worst case scenario), the complexity of a full pass through $(D\nNWayUnion) is $(BIGOH n * ror.length * log(ror.length)), i.e., $(D\nlog(ror.length)) times worse than just spanning all ranges in\nturn. The output comes sorted (unstably) by $(D less).\n\nParams:\n    less = Predicate the given ranges are sorted by.\n    ror = A range of ranges sorted by `less` to compute the union for.\n\nReturns:\n    A range of the union of the ranges in `ror`.\n\nWarning: Because $(D NWayUnion) does not allocate extra memory, it\nwill leave $(D ror) modified. Namely, $(D NWayUnion) assumes ownership\nof $(D ror) and discretionarily swaps and advances elements of it. If\nyou want $(D ror) to preserve its contents after the call, you may\nwant to pass a duplicate to $(D NWayUnion) (and perhaps cache the\nduplicate in between calls).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL837_3410)\n---\nimport std.algorithm.comparison : equal;\n\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto witness = [\n    1, 1, 1, 4, 4, 7, 7, 7, 7, 8, 8\n];\nassert(equal(nWayUnion(a), witness));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL837_3410)\n",
				"parameters": [
					{
						"name": "less",
						"kind": "alias"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nWayUnion",
						"line": 829,
						"type": "NWayUnion!(less, RangeOfRanges)(RangeOfRanges ror)",
						"parameters": [
							{
								"name": "ror",
								"type": "RangeOfRanges"
							}
						],
						"endline": 834,
						"char": 33,
						"kind": "function"
					}
				],
				"name": "nWayUnion",
				"line": 829,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					}
				],
				"char": 33,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SetDifference",
						"line": 870,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SetDifference",
				"line": 870,
				"comment": "Lazily computes the difference of $(D r1) and $(D r2). The two ranges\nare assumed to be sorted by $(D less). The element types of the two\nranges must have a common type.\n\nParams:\n    less = Predicate the given ranges are sorted by.\n    r1 = The first range.\n    r2 = The range to subtract from `r1`.\n\nReturns:\n    A range of the difference of `r1` and `r2`.\n\nSee_also: $(LREF setSymmetricDifference)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL939_3411)\n---\nimport std.algorithm.comparison : equal;\n\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nassert(equal(setDifference(a, b), [5, 9][]));\nstatic assert(isForwardRange!(typeof(setDifference(a, b))));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL939_3411)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R1 && isInputRange!R2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setDifference",
						"line": 932,
						"type": "SetDifference!(less, R1, R2)(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 936,
						"char": 30,
						"kind": "function"
					}
				],
				"name": "setDifference",
				"line": 932,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"char": 30,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SetIntersection",
						"line": 972,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SetIntersection",
				"line": 972,
				"comment": "Lazily computes the intersection of two or more input ranges $(D\nranges). The ranges are assumed to be sorted by $(D less). The element\ntypes of the ranges must have a common type.\n\nParams:\n    less = Predicate the given ranges are sorted by.\n    ranges = The ranges to compute the intersection for.\n\nReturns:\n    A range containing the intersection of the given ranges.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1068_3413)\n---\nimport std.algorithm.comparison : equal;\n\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nint[] c = [ 0, 1, 4, 5, 7, 8 ];\nassert(equal(setIntersection(a, a), a));\nassert(equal(setIntersection(a, b), [1, 2, 4, 7]));\nassert(equal(setIntersection(a, b, c), [1, 4, 7]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1068_3413)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"constraint": "Rs.length >= 2 && allSatisfy!(isInputRange, Rs) && !is(CommonType!(staticMap!(ElementType, Rs)) == void)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setIntersection",
						"line": 1060,
						"type": "SetIntersection!(less, Rs)(Rs ranges)",
						"parameters": [
							{
								"name": "ranges",
								"type": "Rs"
							}
						],
						"endline": 1065,
						"char": 28,
						"kind": "function"
					}
				],
				"name": "setIntersection",
				"line": 1060,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"constraint": "Rs.length >= 2 && allSatisfy!(isInputRange, Rs) && !is(CommonType!(staticMap!(ElementType, Rs)) == void)",
				"char": 28,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SetSymmetricDifference",
						"line": 1131,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SetSymmetricDifference",
				"line": 1131,
				"comment": "Lazily computes the symmetric difference of $(D r1) and $(D r2),\ni.e. the elements that are present in exactly one of $(D r1) and $(D\nr2). The two ranges are assumed to be sorted by $(D less), and the\noutput is also sorted by $(D less). The element types of the two\nranges must have a common type.\n\nIf both arguments are ranges of L-values of the same type then\n$(D SetSymmetricDifference) will also be a range of L-values of\nthat type.\n\nParams:\n    less = Predicate the given ranges are sorted by.\n    r1 = The first range.\n    r2 = The second range.\n\nReturns:\n    A range of the symmetric difference between `r1` and `r2`.\n\nSee_also: $(LREF setDifference)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1217_3419)\n---\nimport std.algorithm.comparison : equal;\n\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nassert(equal(setSymmetricDifference(a, b), [0, 5, 8, 9][]));\nstatic assert(isForwardRange!(typeof(setSymmetricDifference(a, b))));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1217_3419)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R1 && isInputRange!R2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setSymmetricDifference",
						"line": 1210,
						"type": "SetSymmetricDifference!(less, R1, R2)(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 1214,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "setSymmetricDifference",
				"line": 1210,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SetUnion",
						"line": 1256,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SetUnion",
				"line": 1256,
				"comment": "Lazily computes the union of two or more ranges $(D rs). The ranges\nare assumed to be sorted by $(D less). Elements in the output are not\nunique; the length of the output is the sum of the lengths of the\ninputs. (The $(D length) member is offered if all ranges also have\nlength.) The element types of all ranges must have a common type.\n\nParams:\n    less = Predicate the given ranges are sorted by.\n    rs = The ranges to compute the union for.\n\nReturns:\n    A range containing the union of the given ranges.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1374_3421)\n---\nimport std.algorithm.comparison : equal;\n\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\ndouble[] c = [ 10.5 ];\n\nstatic assert(isForwardRange!(typeof(setUnion(a, b))));\nassert(setUnion(a, b).length == a.length + b.length);\nassert(equal(setUnion(a, b), [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9][]));\nassert(equal(setUnion(a, c, b),\n                [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9, 10.5][]));\nauto u = setUnion(a, b);\nu.front--;\nassert(equal(u, [-1, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1374_3421)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isInputRange, Rs)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setUnion",
						"line": 1367,
						"type": "SetUnion!(less, Rs)(Rs rs)",
						"parameters": [
							{
								"name": "rs",
								"type": "Rs"
							}
						],
						"endline": 1371,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "setUnion",
				"line": 1367,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"char": 21,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic algorithms that implement set operations.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 cartesianProduct,\n        Computes Cartesian product of two ranges.)\n$(T2 largestPartialIntersection,\n        Copies out the values that occur most frequently in a range of ranges.)\n$(T2 largestPartialIntersectionWeighted,\n        Copies out the values that occur most frequently (multiplied by\n        per-value weights) in a range of ranges.)\n$(T2 nWayUnion,\n        Computes the union of a set of sets implemented as a range of sorted\n        ranges.)\n$(T2 setDifference,\n        Lazily computes the set difference of two or more sorted ranges.)\n$(T2 setIntersection,\n        Lazily computes the intersection of two or more sorted ranges.)\n$(T2 setSymmetricDifference,\n        Lazily computes the symmetric set difference of two or more sorted\n        ranges.)\n$(T2 setUnion,\n        Lazily computes the set union of two or more sorted ranges.)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_setops.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/comparison.d",
		"name": "std.algorithm.comparison",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "among",
						"line": 87,
						"type": "uint(Value value, Values values)",
						"parameters": [
							{
								"name": "value",
								"type": "Value"
							},
							{
								"name": "values",
								"type": "Values"
							}
						],
						"endline": 97,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "among",
				"line": 87,
				"comment": "Find $(D value) _among $(D values), returning the 1-based index\nof the first matching value in $(D values), or $(D 0) if $(D value)\nis not _among $(D values). The predicate $(D pred) is used to\ncompare values, and uses equality by default.\n\nParams:\n    pred = The predicate used to compare the values.\n    value = The value to search for.\n    values = The values to compare the value to.\n\nReturns:\n    0 if value was not found among the values, otherwise the index of the\n    found value plus one is returned.\n\nSee_Also:\n$(XREF_PACK_NAMED algorithm,searching,find,find) and $(XREF_PACK_NAMED algorithm,searching,canFind, canFind) for finding a value in a\nrange.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL118_3426)\n---\nassert(3.among(1, 42, 24, 3, 2));\n\nif (auto pos = \"bar\".among(\"foo\", \"bar\", \"baz\"))\n    assert(pos == 2);\nelse\n    assert(false);\n\n// 42 is larger than 24\nassert(42.among!((lhs, rhs) => lhs > rhs)(43, 24, 100) == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL118_3426)\nExample:\nAlternatively, $(D values) can be passed at compile-time, allowing for a more\nefficient search, but one that only supports matching on equality:$(DDOX_UNITTEST_HEADER __unittestL135_3427)\n---\nassert(3.among!(2, 3, 4));\nassert(\"bar\".among!(\"foo\", \"bar\", \"baz\") == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL135_3427)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "",
						"kind": "alias"
					},
					{
						"name": "Value",
						"kind": "type"
					},
					{
						"name": "Values",
						"kind": "tuple"
					}
				],
				"constraint": "Values.length != 0",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "among",
								"line": 103,
								"type": "uint(Value value)",
								"parameters": [
									{
										"name": "value",
										"type": "Value"
									}
								],
								"endline": 114,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "among",
						"line": 103,
						"parameters": [
							{
								"name": "Value",
								"kind": "type"
							}
						],
						"constraint": "!is(CommonType!(Value, values) == void)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "among",
				"line": 100,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "values",
						"kind": "tuple"
					}
				],
				"constraint": "isExpressionTuple!values",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "castSwitch",
						"line": 239,
						"type": "(Object switchObject)",
						"parameters": [
							{
								"name": "switchObject",
								"type": "Object"
							}
						],
						"endline": 371,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "castSwitch",
				"line": 239,
				"comment": "Executes and returns one of a collection of handlers based on the type of the\nswitch object.\n\nThe first choice that $(D switchObject) can be casted to the type\nof argument it accepts will be called with $(D switchObject) casted to that\ntype, and the value it'll return will be returned by $(D castSwitch).\n\nIf a choice's return type is void, the choice must throw an exception, unless\nall the choices are void. In that case, castSwitch itself will return void.\n\nThrows: If none of the choice matches, a $(D SwitchError) will be thrown.  $(D\nSwitchError) will also be thrown if not all the choices are void and a void\nchoice was executed without throwing anything.\n\nParams:\n    choices = The $(D choices) needs to be composed of function or delegate\n        handlers that accept one argument. There can also be a choice that\n        accepts zero arguments. That choice will be invoked if the $(D\n        switchObject) is null.\n    switchObject = the object against which the tests are being made.\n\nReturns:\n    The value of the selected choice.\n\nNote: $(D castSwitch) can only be used with object types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL374_3429)\n---\nimport std.algorithm.iteration : map;\nimport std.format : format;\n\nclass A\n{\n    int a;\n    this(int a) {this.a = a;}\n    @property int i() { return a; }\n}\ninterface I { }\nclass B : I { }\n\nObject[] arr = [new A(1), new B(), null];\n\nauto results = arr.map!(castSwitch!(\n                            (A a) => \"A with a value of %d\".format(a.a),\n                            (I i) => \"derived from I\",\n                            ()    => \"null reference\",\n                        ))();\n\n// A is handled directly:\nassert(results[0] == \"A with a value of 1\");\n// B has no handler - it is handled by the handler of I:\nassert(results[1] == \"derived from I\");\n// null is handled by the null handler:\nassert(results[2] == \"null reference\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL374_3429)\nExample:\nUsing with void handlers:$(DDOX_UNITTEST_HEADER __unittestL405_3430)\n---\nimport std.exception : assertThrown;\n\nclass A { }\nclass B { }\n// Void handlers are allowed if they throw:\nassertThrown!Exception(\n    new B().castSwitch!(\n        (A a) => 1,\n        (B d)    { throw new Exception(\"B is not allowed!\"); }\n    )()\n);\n\n// Void handlers are also allowed if all the handlers are void:\nnew A().castSwitch!(\n    (A a) { assert(true); },\n    (B b) { assert(false); },\n)();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL405_3430)\n",
				"parameters": [
					{
						"name": "choices",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "clamp",
						"line": 513,
						"type": "(T1 val, T2 lower, T3 upper)",
						"parameters": [
							{
								"name": "val",
								"type": "T1"
							},
							{
								"name": "lower",
								"type": "T2"
							},
							{
								"name": "upper",
								"type": "T3"
							}
						],
						"endline": 522,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "clamp",
				"line": 513,
				"comment": " Clamps a value into the given bounds.\n\nThis functions is equivalent to $(D max(lower, min(upper,val))).\n\nParams:\n    val = The value to _clamp.\n    lower = The _lower bound of the _clamp.\n    upper = The _upper bound of the _clamp.\n\nReturns:\n    Returns $(D val), if it is between $(D lower) and $(D upper).\n    Otherwise returns the nearest of the two.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL525_3432)\n---\nassert(clamp(2, 1, 3) == 2);\nassert(clamp(0, 1, 3) == 1);\nassert(clamp(4, 1, 3) == 3);\n\nassert(clamp(1, 1, 1) == 1);\n\nassert(clamp(5, -1, 2u) == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL525_3432)\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					},
					{
						"name": "T3",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cmp",
						"line": 590,
						"type": "int(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 601,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "cmp",
				"line": 590,
				"comment": "Performs three-way lexicographical comparison on two input ranges\naccording to predicate $(D pred). Iterating $(D r1) and $(D r2) in\nlockstep, $(D cmp) compares each element $(D e1) of $(D r1) with the\ncorresponding element $(D e2) in $(D r2). If one of the ranges has been\nfinished, $(D cmp) returns a negative value if $(D r1) has fewer\nelements than $(D r2), a positive value if $(D r1) has more elements\nthan $(D r2), and $(D 0) if the ranges have the same number of\nelements.\n\nIf the ranges are strings, $(D cmp) performs UTF decoding\nappropriately and compares the ranges one code point at a time.\n\nParams:\n    pred = The predicate used for comparison.\n    r1 = The first range.\n    r2 = The second range.\n\nReturns:\n    0 if both ranges compare equal. -1 if the first differing element of $(D\n    r1) is less than the corresponding element of $(D r2) according to $(D\n    pred). 1 if the first differing element of $(D r2) is less than the\n    corresponding element of $(D r1) according to $(D pred).\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL674_3434)\n---\nint result;\n\nresult = cmp(\"abc\", \"abc\");\nassert(result == 0);\nresult = cmp(\"\", \"\");\nassert(result == 0);\nresult = cmp(\"abc\", \"abcd\");\nassert(result < 0);\nresult = cmp(\"abcd\", \"abc\");\nassert(result > 0);\nresult = cmp(\"abc\"d, \"abd\");\nassert(result < 0);\nresult = cmp(\"bbc\", \"abc\"w);\nassert(result > 0);\nresult = cmp(\"aaa\", \"aaaa\"d);\nassert(result < 0);\nresult = cmp(\"aaaa\", \"aaa\"d);\nassert(result > 0);\nresult = cmp(\"aaa\", \"aaa\"d);\nassert(result == 0);\nresult = cmp(cast(int[])[], cast(int[])[]);\nassert(result == 0);\nresult = cmp([1, 2, 3], [1, 2, 3]);\nassert(result == 0);\nresult = cmp([1, 3, 2], [1, 2, 3]);\nassert(result > 0);\nresult = cmp([1, 2, 3], [1L, 2, 3, 4]);\nassert(result < 0);\nresult = cmp([1L, 2, 3], [1, 2]);\nassert(result > 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL674_3434)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R1 && isInputRange!R2 && !(isSomeString!R1 && isSomeString!R2)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cmp",
						"line": 604,
						"type": "int(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 671,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "cmp",
				"line": 604,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R1 && isSomeString!R2",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "equal",
								"line": 732,
								"type": "bool(Range1 r1, Range2 r2)",
								"parameters": [
									{
										"name": "r1",
										"type": "Range1"
									},
									{
										"name": "r2",
										"type": "Range2"
									}
								],
								"endline": 766,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "equal",
						"line": 732,
						"comment": "    This function compares to ranges for equality. The ranges may have\n    different element types, as long as $(D pred(a, b)) evaluates to $(D bool)\n    for $(D a) in $(D r1) and $(D b) in $(D r2).\n    Performs $(BIGOH min(r1.length, r2.length)) evaluations of $(D pred).\n\n    Params:\n        r1 = The first range to be compared.\n        r2 = The second range to be compared.\n\n    Returns:\n        $(D true) if and only if the two ranges compare equal element\n        for element, according to binary predicate $(D pred).\n\n    See_Also:\n        $(WEB sgi.com/tech/stl/_equal.html, STL's _equal)\n",
						"parameters": [
							{
								"name": "Range1",
								"kind": "type"
							},
							{
								"name": "Range2",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(typeof(binaryFun!pred(r1.front, r2.front)))",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "equal",
				"line": 713,
				"comment": "Compares two ranges for equality, as defined by predicate $(D pred)\n(which is $(D ==) by default).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL770_3435)\n---\nimport std.math : approxEqual;\nimport std.algorithm : equal;\n\nint[] a = [ 1, 2, 4, 3 ];\nassert(!equal(a, a[1..$]));\nassert(equal(a, a));\n\n// different types\ndouble[] b = [ 1.0, 2, 4, 3];\nassert(!equal(a, b[1..$]));\nassert(equal(a, b));\n\n// predicated: ensure that two vectors are approximately equal\ndouble[] c = [ 1.005, 2, 4, 3];\nassert(equal!approxEqual(b, c));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL770_3435)\nExample:\nTip: $(D equal) can itself be used as a predicate to other functions.\nThis can be very useful when the element type of a range is itself a\nrange. In particular, $(D equal) can be its own predicate, allowing\nrange of range (of range...) comparisons.$(DDOX_UNITTEST_HEADER __unittestL795_3436)\n---\nimport std.range : iota, chunks;\nimport std.algorithm : equal;\nassert(equal!(equal!equal)(\n    [[[0, 1], [2, 3]], [[4, 5], [6, 7]]],\n    iota(0, 8).chunks(2).chunks(2)\n));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL795_3436)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 910,
						"value": "'n'",
						"comment": " Current items are equal; no editing is necessary.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "substitute",
						"line": 912,
						"value": "'s'",
						"comment": " Substitute current item in target with current item in source.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "insert",
						"line": 914,
						"value": "'i'",
						"comment": " Insert current item from the source into the target.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "remove",
						"line": 916,
						"value": "'r'",
						"comment": " Remove current item from the target.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "EditOp",
				"line": 907,
				"comment": "Encodes $(WEB realityinteractive.com/rgrzywinski/archives/000249.html,\nedit operations) necessary to transform one sequence into\nanother. Given sequences $(D s) (source) and $(D t) (target), a\nsequence of $(D EditOp) encodes the steps that need to be taken to\nconvert $(D s) into $(D t). For example, if $(D s = \"cat\") and $(D\n\"cars\"), the minimal sequence that transforms $(D s) into $(D t) is:\nskip two characters, replace 't' with 'r', and insert an 's'. Working\nwith edit operations is useful in applications such as spell-checkers\n(to find the closest word to a given misspelled word), approximate\nsearches, diff-style programs that compute the difference between\nfiles, efficient encoding of patches, DNA sequence analysis, and\nplagiarism detection.\n",
				"baseDeco": "a",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "levenshteinDistance",
						"line": 1101,
						"type": "size_t(Range1 s, Range2 t)",
						"parameters": [
							{
								"name": "s",
								"type": "Range1"
							},
							{
								"name": "t",
								"type": "Range2"
							}
						],
						"endline": 1147,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "levenshteinDistance",
				"line": 1101,
				"comment": "Returns the $(WEB wikipedia.org/wiki/Levenshtein_distance, Levenshtein\ndistance) between $(D s) and $(D t). The Levenshtein distance computes\nthe minimal amount of edit operations necessary to transform $(D s)\ninto $(D t).  Performs $(BIGOH s.length * t.length) evaluations of $(D\nequals) and occupies $(BIGOH s.length * t.length) storage.\n\nParams:\n    equals = The binary predicate to compare the elements of the two ranges.\n    s = The original range.\n    t = The transformation target\n\nReturns:\n    The minimal number of edits to transform s into t.\n\nDoes not allocate GC memory.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1150_3442)\n---\nimport std.algorithm.iteration : filter;\nimport std.uni : toUpper;\n\nassert(levenshteinDistance(\"cat\", \"rat\") == 1);\nassert(levenshteinDistance(\"parks\", \"spark\") == 2);\nassert(levenshteinDistance(\"abcde\", \"abcde\") == 0);\nassert(levenshteinDistance(\"abcde\", \"abCde\") == 1);\nassert(levenshteinDistance(\"kitten\", \"sitting\") == 3);\nassert(levenshteinDistance!((a, b) => std.uni.toUpper(a) == std.uni.toUpper(b))\n    (\"parks\", \"SPARK\") == 2);\nassert(levenshteinDistance(\"parks\".filter!\"true\", \"spark\".filter!\"true\") == 2);\nassert(levenshteinDistance(\"ID\", \"I♥D\") == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1150_3442)\n",
				"parameters": [
					{
						"name": "equals",
						"defaultAlias": "",
						"kind": "alias"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range1 && isForwardRange!Range2",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "levenshteinDistanceAndPath",
						"line": 1213,
						"type": "Tuple!(size_t, EditOp[])(Range1 s, Range2 t)",
						"parameters": [
							{
								"name": "s",
								"type": "Range1"
							},
							{
								"name": "t",
								"type": "Range2"
							}
						],
						"endline": 1220,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "levenshteinDistanceAndPath",
				"line": 1213,
				"comment": "Returns the Levenshtein distance and the edit path between $(D s) and\n$(D t).\n\nParams:\n    equals = The binary predicate to compare the elements of the two ranges.\n    s = The original range.\n    t = The transformation target\n\nReturns:\n    Tuple with the first element being the minimal amount of edits to transform s into t and\n    the second element being the sequence of edits to effect this transformation.\n\nAllocates GC memory for the returned EditOp[] array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1223_3450)\n---\nstring a = \"Saturday\", b = \"Sundays\";\nauto p = levenshteinDistanceAndPath(a, b);\nassert(p[0] == 4);\nassert(equal(p[1], \"nrrnsnnni\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1223_3450)\n",
				"parameters": [
					{
						"name": "equals",
						"defaultAlias": "",
						"kind": "alias"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range1 && isForwardRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "max",
						"line": 1274,
						"type": "MaxType!T(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 1299,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "max",
				"line": 1274,
				"comment": "Iterates the passed arguments and return the maximum value.\n\nParams:\n    args = The values to select the maximum from. At least two arguments must\n    be passed.\n\nReturns:\n    The maximum of the passed-in args. The type of the returned value is\n    the type among the passed arguments that is able to store the largest value.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1302_3455)\n---\nint a = 5;\nshort b = 6;\ndouble c = 2;\nauto d = max(a, b);\nassert(is(typeof(d) == int));\nassert(d == 6);\nauto e = min(a, b, c);\nassert(is(typeof(e) == double));\nassert(e == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1302_3455)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length >= 2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "min",
						"line": 1386,
						"type": "MinType!T(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 1411,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "min",
				"line": 1386,
				"comment": "Iterates the passed arguments and returns the minimum value.\n\nParams: args = The values to select the minimum from. At least two arguments\n    must be passed, and they must be comparable with `<`.\nReturns: The minimum of the passed-in values.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1414_3457)\n---\nint a = 5;\nshort b = 6;\ndouble c = 2;\nauto d = min(a, b);\nstatic assert(is(typeof(d) == int));\nassert(d == 5);\nauto e = min(a, b, c);\nstatic assert(is(typeof(e) == double));\nassert(e == 2);\n\n// With arguments of mixed signedness, the return type is the one that can\n// store the lowest values.\na = -10;\nuint f = 10;\nstatic assert(is(typeof(min(a, f)) == int));\nassert(min(a, f) == -10);\n\n// User-defined types that support comparison with < are supported.\nimport std.datetime;\nassert(min(Date(2012, 12, 21), Date(1982, 1, 4)) == Date(1982, 1, 4));\nassert(min(Date(1982, 1, 4), Date(2012, 12, 21)) == Date(1982, 1, 4));\nassert(min(Date(1982, 1, 4), Date.min) == Date.min);\nassert(min(Date.min, Date(1982, 1, 4)) == Date.min);\nassert(min(Date(1982, 1, 4), Date.max) == Date(1982, 1, 4));\nassert(min(Date.max, Date(1982, 1, 4)) == Date(1982, 1, 4));\nassert(min(Date.min, Date.max) == Date.min);\nassert(min(Date.max, Date.min) == Date.min);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1414_3457)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length >= 2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "mismatch",
						"line": 1457,
						"type": "Tuple!(Range1, Range2)(Range1 r1, Range2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "Range1"
							},
							{
								"name": "r2",
								"type": "Range2"
							}
						],
						"endline": 1465,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "mismatch",
				"line": 1457,
				"comment": "Sequentially compares elements in $(D r1) and $(D r2) in lockstep, and\nstops at the first mismatch (according to $(D pred), by default\nequality). Returns a tuple with the reduced ranges that start with the\ntwo mismatched values. Performs $(BIGOH min(r1.length, r2.length))\nevaluations of $(D pred).\n\nSee_Also:\n    $(WEB sgi.com/tech/stl/_mismatch.html, STL's _mismatch)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1468_3458)\n---\nint[]    x = [ 1,  5, 2, 7,   4, 3 ];\ndouble[] y = [ 1.0, 5, 2, 7.3, 4, 8 ];\nauto m = mismatch(x, y);\nassert(m[0] == x[3 .. $]);\nassert(m[1] == y[3 .. $]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1468_3458)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "predSwitch",
						"line": 1521,
						"type": "(T switchExpression, lazy R choices)",
						"parameters": [
							{
								"name": "switchExpression",
								"type": "T"
							},
							{
								"name": "choices",
								"type": "R",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 1563,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "predSwitch",
				"line": 1521,
				"comment": "Returns one of a collection of expressions based on the value of the switch\nexpression.\n\n$(D choices) needs to be composed of pairs of test expressions and return\nexpressions. Each test-expression is compared with $(D switchExpression) using\n$(D pred)($(D switchExpression) is the first argument) and if that yields true\n- the return expression is returned.\n\nBoth the test and the return expressions are lazily evaluated.\n\nParams:\n\nswitchExpression = The first argument for the predicate.\n\nchoices = Pairs of test expressions and return expressions. The test\nexpressions will be the second argument for the predicate, and the return\nexpression will be returned if the predicate yields true with $(D\nswitchExpression) and the test expression as arguments.  May also have a\ndefault return expression, that needs to be the last expression without a test\nexpression before it. A return expression may be of void type only if it\nalways throws.\n\nReturns: The return expression associated with the first test expression that\nmade the predicate yield true, or the default return expression if no test\nexpression matched.\n\nThrows: If there is no default return expression and the predicate does not\nyield true with any test expression - $(D SwitchError) is thrown. $(D\nSwitchError) is also thrown if a void return expression was executed without\nthrowing anything.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1566_3460)\n---\nstring res = 2.predSwitch!\"a < b\"(\n    1, \"less than 1\",\n    5, \"less than 5\",\n    10, \"less than 10\",\n    \"greater or equal to 10\");\n\nassert(res == \"less than 5\");\n\n//The arguments are lazy, which allows us to use predSwitch to create\n//recursive functions:\nint factorial(int n)\n{\n    return n.predSwitch!\"a <= b\"(\n        -1, {throw new Exception(\"Can not calculate n! for n < 0\");}(),\n        0, 1, // 0! = 1\n        n * factorial(n - 1) // n! = n * (n - 1)! for n >= 0\n        );\n}\nassert(factorial(3) == 6);\n\n//Void return expressions are allowed if they always throw:\nimport std.exception : assertThrown;\nassertThrown!Exception(factorial(-9));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1566_3460)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isSameLength",
						"line": 1642,
						"type": "bool(Range1 r1, Range2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "Range1"
							},
							{
								"name": "r2",
								"type": "Range2"
							}
						],
						"endline": 1699,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isSameLength",
				"line": 1642,
				"comment": "Checks if the two ranges have the same number of elements. This function is\noptimized to always take advantage of the $(D length) member of either range\nif it exists.\n\nIf both ranges have a length member, this function is $(BIGOH 1). Otherwise,\nthis function is $(BIGOH min(r1.length, r2.length)).\n\nParams:\n    r1 = a finite input range\n    r2 = a finite input range\n\nReturns:\n    $(D true) if both ranges have the same length, $(D false) otherwise.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1702_3462)\n---\nassert(isSameLength([1, 2, 3], [4, 5, 6]));\nassert(isSameLength([0.3, 90.4, 23.7, 119.2], [42.6, 23.6, 95.5, 6.3]));\nassert(isSameLength(\"abc\", \"xyz\"));\n\nint[] a;\nint[] b;\nassert(isSameLength(a, b));\n\nassert(!isSameLength([1, 2, 3], [4, 5]));\nassert(!isSameLength([0.3, 90.4, 23.7], [42.6, 23.6, 95.5, 6.3]));\nassert(!isSameLength(\"abcd\", \"xyz\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1702_3462)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && !isInfinite!Range1 && !isInfinite!Range2",
				"char": 6,
				"kind": "template"
			},
			{
				"name": "AllocateGC",
				"line": 1757,
				"comment": "For convenience\n",
				"deco": "E3std8typecons37__T4FlagVAyaa10_616c6c6f636174654743Z4Flag",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isPermutation",
						"line": 1785,
						"type": "bool(Range1 r1, Range2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "Range1"
							},
							{
								"name": "r2",
								"type": "Range2"
							}
						],
						"endline": 1830,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isPermutation",
				"line": 1785,
				"comment": "Checks if both ranges are permutations of each other.\n\nThis function can allocate if the $(D AllocateGC.yes) flag is passed. This has\nthe benefit of have better complexity than the $(D AllocateGC.no) option. However,\nthis option is only available for ranges whose equality can be determined via each\nelement's $(D toHash) method. If customized equality is needed, then the $(D pred)\ntemplate parameter can be passed, and the function will automatically switch to\nthe non-allocating algorithm. See $(XREF functional,binaryFun) for more details on\nhow to define $(D pred).\n\nNon-allocating forward range option: $(BIGOH n^2)\nNon-allocating forward range option with custom $(D pred): $(BIGOH n^2)\nAllocating forward range option: amortized $(BIGOH r1.length) + $(BIGOH r2.length)\n\nParams:\n    pred = an optional parameter to change how equality is defined\n    allocate_gc = AllocateGC.yes/no\n    r1 = A finite forward range\n    r2 = A finite forward range\n\nReturns:\n    $(D true) if all of the elements in $(D r1) appear the same number of times in $(D r2).\n    Otherwise, returns $(D false).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1901_3465)\n---\nassert(isPermutation([1, 2, 3], [3, 2, 1]));\nassert(isPermutation([1.1, 2.3, 3.5], [2.3, 3.5, 1.1]));\nassert(isPermutation(\"abc\", \"bca\"));\n\nassert(!isPermutation([1, 2], [3, 4]));\nassert(!isPermutation([1, 1, 2, 3], [1, 2, 2, 3]));\nassert(!isPermutation([1, 1], [1, 1, 1]));\n\n// Faster, but allocates GC handled memory\nassert(isPermutation!(AllocateGC.yes)([1.1, 2.3, 3.5], [2.3, 3.5, 1.1]));\nassert(!isPermutation!(AllocateGC.yes)([1, 2], [3, 4]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1901_3465)\n",
				"parameters": [
					{
						"name": "allocate_gc",
						"deco": "E3std8typecons37__T4FlagVAyaa10_616c6c6f636174654743Z4Flag",
						"kind": "value"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "allocate_gc == AllocateGC.yes && isForwardRange!Range1 && isForwardRange!Range2 && !isInfinite!Range1 && !isInfinite!Range2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isPermutation",
						"line": 1833,
						"type": "bool(Range1 r1, Range2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "Range1"
							},
							{
								"name": "r2",
								"type": "Range2"
							}
						],
						"endline": 1898,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isPermutation",
				"line": 1833,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!pred)) && isForwardRange!Range1 && isForwardRange!Range2 && !isInfinite!Range1 && !isInfinite!Range2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "either",
						"line": 1984,
						"type": "CommonType!(T, Ts)(T first, lazy Ts alternatives)",
						"parameters": [
							{
								"name": "first",
								"type": "T"
							},
							{
								"name": "alternatives",
								"type": "Ts",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 1997,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "either",
				"line": 1984,
				"comment": "Get first parameter $(D p) that passes an $(D if (unaryFun!pred(p))) test.  If\nno parameter passes the test return the last.\n\nSimilar to behaviour of `or` operator in dynamic languages such as Lisp's\n`(or ...)` and Python's `a or b or ...` except that the last argument is\nreturned upon no match.\n\nSimplifies logic, for instance, in parsing rules where a set of alternative\nmatchers are tried. The first one that matches returns it match result,\ntypically as an abstract syntax tree (AST).\n\nNOTE: Lazy parameters are currently, too restrictively, inferred by DMD to\nalways throw eventhough they don't need to be. This makes it impossible to\ncurrently mark $(D either) as $(D nothrow). See issue at\nhttps://issues.dlang.org/show_bug.cgi?id=12647\n\nReturns:\n    The first parameter that passes the test $(D pred).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2000_3470)\n---\nconst a = 1;\nconst b = 2;\nauto ab = either(a, b);\nstatic assert(is(typeof(ab) == const(int)));\nassert(ab == a);\n\nauto c = 2;\nconst d = 3;\nauto cd = either!(a => a == 3)(c, d); // use predicate\nstatic assert(is(typeof(cd) == int));\nassert(cd == d);\n\nauto e = 0;\nconst f = 2;\nauto ef = either(e, f);\nstatic assert(is(typeof(ef) == int));\nassert(ef == f);\n\nimmutable p = 1;\nimmutable q = 2;\nauto pq = either(p, q);\nstatic assert(is(typeof(pq) == immutable(int)));\nassert(pq == p);\n\nassert(either(3, 4) == 3);\nassert(either(0, 4) == 4);\nassert(either(0, 0) == 0);\nassert(either(\"\", \"a\") == \"\");\n\nstring r = null;\nassert(either(r, \"a\") == \"a\");\nassert(either(\"a\", \"\") == \"a\");\n\nimmutable s = [1, 2];\nassert(either(s, s) == s);\n\nassert(either([0, 1], [1, 2]) == [0, 1]);\nassert(either([0, 1], [1]) == [0, 1]);\nassert(either(\"a\", \"b\") == \"a\");\n\nstatic assert(!__traits(compiles, either(1, \"a\")));\nstatic assert(!__traits(compiles, either(1.0, \"a\")));\nstatic assert(!__traits(compiles, either('a', \"a\")));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2000_3470)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Ts",
						"kind": "tuple"
					}
				],
				"constraint": "alternatives.length >= 1 && !is(CommonType!(T, Ts) == void) && allSatisfy!(ifTestable, T, Ts)",
				"char": 20,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic _comparison algorithms.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 among,\n        Checks if a value is among a set of values, e.g.\n        $(D if (v.among(1, 2, 3)) // `v` is 1, 2 or 3))\n$(T2 castSwitch,\n        $(D (new A()).castSwitch((A a)=>1,(B b)=>2)) returns $(D 1).)\n$(T2 clamp,\n        $(D clamp(1, 3, 6)) returns $(D 3). $(D clamp(4, 3, 6)) returns $(D 4).)\n$(T2 cmp,\n        $(D cmp(\"abc\", \"abcd\")) is $(D -1), $(D cmp(\"abc\", \"aba\")) is $(D 1),\n        and $(D cmp(\"abc\", \"abc\")) is $(D 0).)\n$(T2 either,\n        Return first parameter $(D p) that passes an $(D if (p)) test, e.g.\n        $(D either(0, 42, 43)) returns $(D 42).)\n$(T2 equal,\n        Compares ranges for element-by-element equality, e.g.\n        $(D equal([1, 2, 3], [1.0, 2.0, 3.0])) returns $(D true).)\n$(T2 isPermutation,\n        $(D isPermutation([1, 2], [2, 1])) returns $(D true).)\n$(T2 isSameLength,\n        $(D isSameLength([1, 2, 3], [4, 5, 6])) returns $(D true).)\n$(T2 levenshteinDistance,\n        $(D levenshteinDistance(\"kitten\", \"sitting\")) returns $(D 3) by using\n        the $(LUCKY Levenshtein distance _algorithm).)\n$(T2 levenshteinDistanceAndPath,\n        $(D levenshteinDistanceAndPath(\"kitten\", \"sitting\")) returns\n        $(D tuple(3, \"snnnsni\")) by using the $(LUCKY Levenshtein distance\n        _algorithm).)\n$(T2 max,\n        $(D max(3, 4, 2)) returns $(D 4).)\n$(T2 min,\n        $(D min(3, 4, 2)) returns $(D 2).)\n$(T2 mismatch,\n        $(D mismatch(\"oh hi\", \"ohayo\")) returns $(D tuple(\" hi\", \"ayo\")).)\n$(T2 predSwitch,\n        $(D 2.predSwitch(1, \"one\", 2, \"two\", 3, \"three\")) returns $(D \"two\").)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_comparison.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/concurrency.d",
		"name": "std.concurrency",
		"members": [
			{
				"members": [],
				"name": "MessageMismatch",
				"line": 220,
				"comment": "\n\n\n\n Thrown on calls to $(D receiveOnly) if a message other than the type\n the receiving thread expected is sent.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "OwnerTerminated",
				"line": 233,
				"comment": " Thrown on calls to $(D receive) if the thread that spawned the receiving\n thread has terminated and no more messages exist.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "LinkTerminated",
				"line": 248,
				"comment": " Thrown if a linked thread has terminated.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "message",
						"line": 276,
						"comment": " The message that was sent.\n",
						"deco": "S3std7variant18__T8VariantNVmi32Z8VariantN",
						"originalType": "Variant",
						"char": 13,
						"kind": "variable"
					}
				],
				"name": "PriorityMessageException",
				"line": 265,
				"comment": " Thrown if a message was sent to a thread via\n $(XREF concurrency, prioritySend) and the receiver does not have a handler\n for a message of this type.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "MailboxFull",
				"line": 284,
				"comment": " Thrown on mailbox crowding if the mailbox is configured with\n $(D OnCrowding.throwException).\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "TidMissingException",
				"line": 300,
				"comment": " Thrown when a Tid is missing, e.g. when $(D ownerTid) doesn't\n find an owner thread.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Tid",
				"line": 317,
				"comment": "\n\n\n\n An opaque type used to represent a logical thread.\n",
				"members": [
					{
						"endchar": 5,
						"name": "toString",
						"line": 337,
						"comment": " Generate a convenient string for identifying this Tid.  This is only\n useful to see if Tid's that are currently executing are the same or\n different, e.g. for logging and debugging.  It is potentially possible\n that a Tid executed in the future will have the same toString() output\n as another Tid that has already terminated.\n",
						"deco": "FMDFAxaZvZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFAxaZv"
							}
						],
						"endline": 341,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "thisTid",
				"line": 349,
				"comment": " Returns the caller's Tid.\n",
				"deco": "FNdNfZS3std11concurrency3Tid",
				"endline": 361,
				"char": 15,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "ownerTid",
				"line": 369,
				"comment": " Return the Tid of the thread which spawned the caller's thread.\n\n Throws: A $(D TidMissingException) exception if\n there is no owner thread.\n",
				"deco": "FNdZS3std11concurrency3Tid",
				"endline": 374,
				"char": 15,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "spawn",
						"line": 466,
						"type": "Tid(F fn, T args)",
						"parameters": [
							{
								"name": "fn",
								"type": "F"
							},
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 472,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "spawn",
				"line": 466,
				"comment": " Starts fn(args) in a new logical thread.\n\n Executes the supplied function in a new logical thread represented by\n $(D Tid).  The calling thread is designated as the owner of the new thread.\n When the owner thread terminates an $(D OwnerTerminated) message will be\n sent to the new thread, causing an $(D OwnerTerminated) exception to be\n thrown on $(D receive()).\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new logical thread.\n\n Notes:\n  $(D args) must not have unshared aliasing.  In other words, all arguments\n  to $(D fn) must either be $(D shared) or $(D immutable) or have no\n  pointer indirection.  This is necessary for enforcing isolation among\n  threads.\n\n Example:\n ---\n import std.stdio, std.concurrency;\n\n void f1(string str)\n {\n     writeln(str);\n }\n\n void f2(char[] str)\n {\n     writeln(str);\n }\n\n void main()\n {\n     auto str = \"Hello, world\";\n\n     // Works:  string is immutable.\n     auto tid1 = spawn(&f1, str);\n\n     // Fails:  char[] has mutable aliasing.\n     auto tid2 = spawn(&f2, str.dup);\n }\n ---\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "isSpawnable!(F, T)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "spawnLinked",
						"line": 494,
						"type": "Tid(F fn, T args)",
						"parameters": [
							{
								"name": "fn",
								"type": "F"
							},
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 500,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "spawnLinked",
				"line": 494,
				"comment": " Starts fn(args) in a logical thread and will receive a LinkTerminated\n message when the operation terminates.\n\n Executes the supplied function in a new logical thread represented by\n Tid.  This new thread is linked to the calling thread so that if either\n it or the calling thread terminates a LinkTerminated message will be sent\n to the other, causing a LinkTerminated exception to be thrown on receive().\n The owner relationship from spawn() is preserved as well, so if the link\n between threads is broken, owner termination will still result in an\n OwnerTerminated exception to be thrown on receive().\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new thread.\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "isSpawnable!(F, T)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "send",
						"line": 590,
						"type": "void(Tid tid, T vals)",
						"parameters": [
							{
								"name": "tid",
								"type": "Tid"
							},
							{
								"name": "vals",
								"type": "T"
							}
						],
						"endline": 595,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "send",
				"line": 590,
				"comment": "\n\n\n\n Places the values as a message at the back of tid's message queue.\n\n Sends the supplied value to the thread represented by tid.  As with\n $(XREF concurrency, spawn), $(D T) must not have unshared aliasing.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "prioritySend",
						"line": 605,
						"type": "void(Tid tid, T vals)",
						"parameters": [
							{
								"name": "tid",
								"type": "Tid"
							},
							{
								"name": "vals",
								"type": "T"
							}
						],
						"endline": 610,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "prioritySend",
				"line": 605,
				"comment": " Places the values as a message on the front of tid's message queue.\n\n Send a message to $(D tid) but place it at the front of $(D tid)'s message\n queue instead of at the back.  This function is typically used for\n out-of-band communication, to signal exceptional conditions, etc.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "receive",
						"line": 668,
						"type": "void(T ops)",
						"parameters": [
							{
								"name": "ops",
								"type": "T"
							}
						],
						"endline": 680,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "receive",
				"line": 668,
				"comment": " Receives a message from another thread.\n\n Receive a message from another thread, or block if no messages of the\n specified types are available.  This function works by pattern matching\n a message against a set of delegates and executing the first match found.\n\n If a delegate that accepts a $(XREF variant, Variant) is included as\n the last argument to $(D receive), it will match any message that was not\n matched by an earlier delegate.  If more than one argument is sent,\n the $(D Variant) will contain a $(XREF typecons, Tuple) of all values\n sent.\n\n Example:\n ---\n import std.stdio;\n import std.variant;\n import std.concurrency;\n\n void spawnedFunction()\n {\n     receive(\n         (int i) { writeln(\"Received an int.\"); },\n         (float f) { writeln(\"Received a float.\"); },\n         (Variant v) { writeln(\"Received some other type.\"); }\n     );\n }\n\n void main()\n {\n      auto tid = spawn(&spawnedFunction);\n      send(tid, 42);\n }\n ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "receiveOnly",
						"line": 752,
						"type": "receiveOnlyRet!T()",
						"endline": 792,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "receiveOnly",
				"line": 752,
				"comment": " Receives only messages with arguments of types $(D T).\n\n Throws:  $(D MessageMismatch) if a message of types other than $(D T)\n          is received.\n\n Returns: The received message.  If $(D T.length) is greater than one,\n          the message will be packed into a $(XREF typecons, Tuple).\n\n Example:\n ---\n import std.concurrency;\n\n void spawnedFunc()\n {\n     auto msg = receiveOnly!(int, string)();\n     assert(msg[0] == 42);\n     assert(msg[1] == \"42\");\n }\n\n void main()\n {\n     auto tid = spawn(&spawnedFunc);\n     send(tid, 42, \"42\");\n }\n ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 20,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "receiveTimeout",
						"line": 824,
						"type": "bool(Duration duration, T ops)",
						"parameters": [
							{
								"name": "duration",
								"type": "Duration"
							},
							{
								"name": "ops",
								"type": "T"
							}
						],
						"endline": 836,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "receiveTimeout",
				"line": 824,
				"comment": " Tries to receive but will give up if no matches arrive within duration.\n Won't wait at all if provided $(CXREF time, Duration) is negative.\n\n Same as $(D receive) except that rather than wait forever for a message,\n it waits until either it receives a message or the given\n $(CXREF time, Duration) has passed. It returns $(D true) if it received a\n message and $(D false) if it timed out waiting for one.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "block",
						"line": 873,
						"value": "0",
						"comment": "Wait until room is available.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "throwException",
						"line": 874,
						"value": "1",
						"comment": "Throw a MailboxFull exception.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ignore",
						"line": 875,
						"value": "2",
						"comment": "Abort the send and return.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "OnCrowding",
				"line": 871,
				"comment": "\n\n\n\n These behaviors may be specified when a mailbox is full.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"endchar": 1,
				"name": "setMaxMailboxSize",
				"line": 914,
				"comment": " Sets a maximum mailbox size.\n\n Sets a limit on the maximum number of user messages allowed in the mailbox.\n If this limit is reached, the caller attempting to add a new message will\n execute the behavior specified by doThis.  If messages is zero, the mailbox\n is unbounded.\n\n Params:\n  tid      = The Tid of the thread for which this limit should be set.\n  messages = The maximum number of messages or zero if no limit.\n  doThis   = The behavior executed when a message is sent to a full\n             mailbox.\n",
				"deco": "FS3std11concurrency3TidmE3std11concurrency10OnCrowdingZv",
				"parameters": [
					{
						"name": "tid",
						"deco": "S3std11concurrency3Tid"
					},
					{
						"name": "messages",
						"deco": "m"
					},
					{
						"name": "doThis",
						"deco": "E3std11concurrency10OnCrowding"
					}
				],
				"endline": 925,
				"originalType": "void(Tid tid, size_t messages, OnCrowding doThis)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "setMaxMailboxSize",
				"line": 941,
				"comment": " Sets a maximum mailbox size.\n\n Sets a limit on the maximum number of user messages allowed in the mailbox.\n If this limit is reached, the caller attempting to add a new message will\n execute onCrowdingDoThis.  If messages is zero, the mailbox is unbounded.\n\n Params:\n  tid      = The Tid of the thread for which this limit should be set.\n  messages = The maximum number of messages or zero if no limit.\n  onCrowdingDoThis = The routine called when a message is sent to a full\n                     mailbox.\n",
				"deco": "FS3std11concurrency3TidmPFS3std11concurrency3TidZbZv",
				"parameters": [
					{
						"name": "tid",
						"deco": "S3std11concurrency3Tid"
					},
					{
						"name": "messages",
						"deco": "m"
					},
					{
						"name": "onCrowdingDoThis",
						"deco": "PFS3std11concurrency3TidZb"
					}
				],
				"endline": 944,
				"originalType": "void(Tid tid, size_t messages, bool function(Tid) onCrowdingDoThis)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "register",
				"line": 997,
				"comment": " Associates name with tid.\n\n Associates name with tid in a process-local map.  When the thread\n represented by tid terminates, any names associated with it will be\n automatically unregistered.\n\n Params:\n  name = The name to associate with tid.\n  tid  = The tid register by name.\n\n Returns:\n  true if the name is available and tid is not known to represent a\n  defunct thread.\n",
				"deco": "FAyaS3std11concurrency3TidZb",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					},
					{
						"name": "tid",
						"deco": "S3std11concurrency3Tid"
					}
				],
				"endline": 1009,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "unregister",
				"line": 1021,
				"comment": " Removes the registered name associated with a tid.\n\n Params:\n  name = The name to unregister.\n\n Returns:\n  true if the name is registered, false if not.\n",
				"deco": "FAyaZb",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					}
				],
				"endline": 1035,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "locate",
				"line": 1047,
				"comment": " Gets the Tid associated with name.\n\n Params:\n  name = The name to locate within the registry.\n\n Returns:\n  The associated Tid or Tid.init if name is not registered.\n",
				"deco": "FAyaZS3std11concurrency3Tid",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					}
				],
				"endline": 1055,
				"char": 5,
				"kind": "function"
			},
			{
				"name": "ThreadInfo",
				"line": 1070,
				"comment": "\n\n\n\n Encapsulates all implementation-level data needed for scheduling.\n\n When definining a Scheduler, an instance of this struct must be associated\n with each logical thread.  It contains all implementation-level information\n needed by the internal API.\n",
				"members": [
					{
						"endchar": 5,
						"name": "thisInfo",
						"line": 1083,
						"comment": " Gets a thread-local instance of ThreadInfo.\n\n Gets a thread-local instance of ThreadInfo, which should be used as the\n default instance when info is requested for a thread not created by the\n Scheduler.\n",
						"deco": "FNbNcNdNiNfZS3std11concurrency10ThreadInfo",
						"endline": 1087,
						"originalType": "nothrow @property ref ()",
						"char": 26,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "cleanup",
						"line": 1097,
						"comment": " Cleans up this ThreadInfo.\n\n This must be called when a scheduled thread terminates.  It tears down\n the messaging system for the thread and notifies interested parties of\n the thread's termination.\n",
						"deco": "FZv",
						"endline": 1106,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "Scheduler",
				"line": 1142,
				"comment": " A Scheduler controls how threading is performed by spawn.\n\n Implementing a Scheduler allows the concurrency mechanism used by this\n module to be customized according to different needs.  By default, a call\n to spawn will create a new kernel thread that executes the supplied routine\n and terminates when finished.  But it is possible to create Schedulers that\n reuse threads, that multiplex Fibers (coroutines) across a single thread,\n or any number of other approaches.  By making the choice of Scheduler a\n user-level option, std.concurrency may be used for far more types of\n application than if this behavior were predefined.\n\n Example:\n ---\n import std.concurrency;\n import std.stdio;\n\n void main()\n {\n     scheduler = new FiberScheduler;\n     scheduler.start(\n     {\n         writeln(\"the rest of main goes here\");\n     });\n }\n ---\n\n Some schedulers have a dispatching loop that must run if they are to work\n properly, so for the sake of consistency, when using a scheduler, start()\n must be called within main().  This yields control to the scheduler and\n will ensure that any spawned threads are executed in an expected manner.\n",
				"members": [
					{
						"name": "start",
						"line": 1158,
						"comment": " Spawns the supplied op and starts the Scheduler.\n\n This is intended to be called at the start of the program to yield all\n scheduling to the active Scheduler instance.  This is necessary for\n schedulers that explicitly dispatch threads rather than simply relying\n on the operating system to do so, and so start should always be called\n within main() to begin normal program execution.\n\n Params:\n  op = A wrapper for whatever the main thread would have done in the\n       absence of a custom scheduler.  It will be automatically executed\n       via a call to spawn by the Scheduler.\n",
						"deco": "FDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "spawn",
						"line": 1173,
						"comment": " Assigns a logical thread to execute the supplied op.\n\n This routine is called by spawn.  It is expected to instantiate a new\n logical thread and run the supplied operation.  This thread must call\n thisInfo.cleanup() when the thread terminates if the scheduled thread\n is not a kernel thread--all kernel threads will have their ThreadInfo\n cleaned up automatically by a thread-local destructor.\n\n Params:\n  op = The function to execute.  This may be the actual function passed\n       by the user to spawn itself, or may be a wrapper function.\n",
						"deco": "FDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "yield",
						"line": 1184,
						"comment": " Yields execution to another logical thread.\n\n This routine is called at various points within concurrency-aware APIs\n to provide a scheduler a chance to yield execution when using some sort\n of cooperative multithreading model.  If this is not appropriate, such\n as when each logical thread is backed by a dedicated kernel thread,\n this routine may be a no-op.\n",
						"deco": "FNbZv",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "thisInfo",
						"line": 1193,
						"comment": " Returns an appropriate ThreadInfo instance.\n\n Returns an instance of ThreadInfo specific to the logical thread that\n is calling this routine or, if the calling thread was not create by\n this scheduler, returns ThreadInfo.thisInfo instead.\n",
						"deco": "FNbNcNdZS3std11concurrency10ThreadInfo",
						"char": 30,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "newCondition",
						"line": 1210,
						"comment": " Creates a Condition variable analog for signaling.\n\n Creates a new Condition variable analog which is used to check for and\n to signal the addition of messages to a thread's message queue.  Like\n yield, some schedulers may need to define custom behavior so that calls\n to Condition.wait() yield to another thread when no new messages are\n available instead of blocking.\n\n Params:\n  m = The Mutex that will be associated with this condition.  It will be\n      locked prior to any operation on the condition, and so in some\n      cases a Scheduler may need to hold this reference and unlock the\n      mutex before yielding execution to another logical thread.\n",
						"deco": "FNbC4core4sync5mutex5MutexZC4core4sync9condition9Condition",
						"parameters": [
							{
								"name": "m",
								"deco": "C4core4sync5mutex5Mutex"
							}
						],
						"char": 15,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					}
				],
				"char": 1,
				"kind": "interface"
			},
			{
				"interfaces": [
					"std.concurrency.Scheduler"
				],
				"members": [
					{
						"endchar": 5,
						"name": "start",
						"line": 1229,
						"comment": " This simply runs op directly, since no real scheduling is needed by\n this approach.\n",
						"deco": "FDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"endline": 1232,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.start"
						]
					},
					{
						"endchar": 5,
						"name": "spawn",
						"line": 1238,
						"comment": " Creates a new kernel thread and assigns it to run the supplied op.\n",
						"deco": "FDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"endline": 1242,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.spawn"
						]
					},
					{
						"endchar": 5,
						"name": "yield",
						"line": 1248,
						"comment": " This scheduler does no explicit multiplexing, so this is a no-op.\n",
						"deco": "FNbZv",
						"endline": 1251,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.yield"
						]
					},
					{
						"endchar": 5,
						"name": "thisInfo",
						"line": 1258,
						"comment": " Returns ThreadInfo.thisInfo, since it is a thread-local instance of\n ThreadInfo, which is the correct behavior for this scheduler.\n",
						"deco": "FNbNcNdZS3std11concurrency10ThreadInfo",
						"endline": 1261,
						"char": 30,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.thisInfo"
						]
					},
					{
						"endchar": 5,
						"name": "newCondition",
						"line": 1267,
						"comment": " Creates a new Condition variable.  No custom behavior is needed here.\n",
						"deco": "FNbC4core4sync5mutex5MutexZC4core4sync9condition9Condition",
						"parameters": [
							{
								"name": "m",
								"deco": "C4core4sync5mutex5Mutex"
							}
						],
						"endline": 1270,
						"char": 15,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.newCondition"
						]
					}
				],
				"name": "ThreadScheduler",
				"line": 1222,
				"comment": " An example Scheduler using kernel threads.\n\n This is an example Scheduler that mirrors the default scheduling behavior\n of creating one kernel thread per call to spawn.  It is fully functional\n and may be instantiated and used, but is not a necessary part of the\n default functioning of this module.\n",
				"char": 1,
				"kind": "class"
			},
			{
				"interfaces": [
					"std.concurrency.Scheduler"
				],
				"members": [
					{
						"endchar": 5,
						"name": "start",
						"line": 1287,
						"comment": " This creates a new Fiber for the supplied op and then starts the\n dispatcher.\n",
						"deco": "FDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"endline": 1291,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.start"
						]
					},
					{
						"endchar": 5,
						"name": "spawn",
						"line": 1298,
						"comment": " This created a new Fiber for the supplied op and adds it to the\n dispatch list.\n",
						"deco": "FNbDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"endline": 1302,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.spawn"
						]
					},
					{
						"endchar": 5,
						"name": "yield",
						"line": 1309,
						"comment": " If the caller is a scheduled Fiber, this yields execution to another\n scheduled Fiber.\n",
						"deco": "FNbZv",
						"endline": 1316,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.yield"
						]
					},
					{
						"endchar": 5,
						"name": "thisInfo",
						"line": 1326,
						"comment": " Returns an appropriate ThreadInfo instance.\n\n Returns a ThreadInfo instance specific to the calling Fiber if the\n Fiber was created by this dispatcher, otherwise it returns\n ThreadInfo.thisInfo.\n",
						"deco": "FNbNcNdZS3std11concurrency10ThreadInfo",
						"endline": 1333,
						"char": 30,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.thisInfo"
						]
					},
					{
						"endchar": 5,
						"name": "newCondition",
						"line": 1339,
						"comment": " Returns a Condition analog that yields when wait or notify is called.\n",
						"deco": "FNbC4core4sync5mutex5MutexZC4core4sync9condition9Condition",
						"parameters": [
							{
								"name": "m",
								"deco": "C4core4sync5mutex5Mutex"
							}
						],
						"endline": 1342,
						"char": 15,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.newCondition"
						]
					}
				],
				"name": "FiberScheduler",
				"line": 1280,
				"comment": " An example Scheduler using Fibers.\n\n This is an example scheduler that creates a new Fiber per call to spawn\n and multiplexes the execution of all fibers within the main thread.\n",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "scheduler",
				"line": 1507,
				"comment": " Sets the Scheduler behavior within the program.\n\n This variable sets the Scheduler behavior within this program.  Typically,\n when setting a Scheduler, scheduler.start() should be called in main.  This\n routine will not return until program execution is complete.\n",
				"deco": "C3std11concurrency9Scheduler",
				"originalType": "Scheduler",
				"char": 21,
				"kind": "variable",
				"storageClass": [
					"__gshared"
				]
			},
			{
				"endchar": 1,
				"name": "yield",
				"line": 1519,
				"comment": "\n\n\n\n If the caller is a Fiber and is not a Generator, this function will call\n scheduler.yield() or Fiber.yield(), as appropriate.\n",
				"deco": "FNbZv",
				"endline": 1531,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "Generator",
						"line": 1571,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 1585,
								"comment": " Initializes a generator object which is associated with a static\n D function.  The function will be called once to prepare the range\n for iteration.\n\n Params:\n  fn = The fiber function.\n\n In:\n  fn must not be null.\n",
								"type": "(void function() fn)",
								"parameters": [
									{
										"name": "fn",
										"type": "void function()"
									}
								],
								"endline": 1589,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 1604,
								"comment": " Initializes a generator object which is associated with a static\n D function.  The function will be called once to prepare the range\n for iteration.\n\n Params:\n  fn = The fiber function.\n  sz = The stack size for this fiber.\n\n In:\n  fn must not be null.\n",
								"type": "(void function() fn, size_t sz)",
								"parameters": [
									{
										"name": "fn",
										"type": "void function()"
									},
									{
										"name": "sz",
										"type": "size_t"
									}
								],
								"endline": 1608,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 1622,
								"comment": " Initializes a generator object which is associated with a dynamic\n D function.  The function will be called once to prepare the range\n for iteration.\n\n Params:\n  dg = The fiber function.\n\n In:\n  dg must not be null.\n",
								"type": "(void delegate() dg)",
								"parameters": [
									{
										"name": "dg",
										"type": "void delegate()"
									}
								],
								"endline": 1626,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 1641,
								"comment": " Initializes a generator object which is associated with a dynamic\n D function.  The function will be called once to prepare the range\n for iteration.\n\n Params:\n  dg = The fiber function.\n  sz = The stack size for this fiber.\n\n In:\n  dg must not be null.\n",
								"type": "(void delegate() dg, size_t sz)",
								"parameters": [
									{
										"name": "dg",
										"type": "void delegate()"
									},
									{
										"name": "sz",
										"type": "size_t"
									}
								],
								"endline": 1645,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 1651,
								"comment": " Returns true if the generator is empty.\n",
								"type": "@property bool()",
								"endline": 1654,
								"char": 16,
								"kind": "function",
								"storageClass": [
									"final"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 1660,
								"comment": " Obtains the next value from the underlying function.\n",
								"type": "void()",
								"endline": 1663,
								"char": 16,
								"kind": "function",
								"storageClass": [
									"final"
								]
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 1669,
								"comment": " Returns the most recently generated value.\n",
								"type": "@property T()",
								"endline": 1672,
								"char": 13,
								"kind": "function",
								"storageClass": [
									"final"
								]
							}
						],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "Generator",
				"line": 1571,
				"comment": " A Generator is a Fiber that periodically returns values of type T to the\n caller via yield.  This is represented as an InputRange.\n\n Example:\n ---\n import std.concurrency;\n import std.stdio;\n\n\n void main()\n {\n     auto tid = spawn(\n     {\n         while (true)\n         {\n             writeln(receiveOnly!int());\n         }\n     });\n\n     auto r = new Generator!int(\n     {\n         foreach (i; 1 .. 10)\n             yield(i);\n     });\n\n     foreach (e; r)\n     {\n         tid.send(e);\n     }\n }\n ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "yield",
						"line": 1687,
						"type": "void(ref T value)",
						"parameters": [
							{
								"name": "value",
								"type": "T",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1697,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "yield",
				"line": 1687,
				"comment": " Yields a value of type T to the caller of the currently executing\n generator.\n\n Params:\n  value = The value to yield.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "yield",
						"line": 1701,
						"type": "void(T value)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							}
						],
						"endline": 1704,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "yield",
				"line": 1701,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "initOnce",
						"line": 2546,
						"type": "ref (lazy typeof(var) init)",
						"parameters": [
							{
								"name": "init",
								"type": "typeof(var)",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 2549,
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "initOnce",
				"line": 2546,
				"comment": " Initializes $(D_PARAM var) with the lazy $(D_PARAM init) value in a\n thread-safe manner.\n\n The implementation guarantees that all threads simultaneously calling\n initOnce with the same $(D_PARAM var) argument block until $(D_PARAM var) is\n fully initialized. All side-effects of $(D_PARAM init) are globally visible\n afterwards.\n\n Params:\n   var = The variable to initialize\n   init = The lazy initializer value\n\n Returns:\n   A reference to the initialized variable\nExample:\nA typical use-case is to perform lazy but thread-safe initialization.$(DDOX_UNITTEST_HEADER __unittestL2552_3482)\n---\nstatic class MySingleton\n{\n    static MySingleton instance()\n    {\n        static __gshared MySingleton inst;\n        return initOnce!inst(new MySingleton);\n    }\n}\nassert(MySingleton.instance !is null);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2552_3482)\n",
				"parameters": [
					{
						"name": "var",
						"kind": "alias"
					}
				],
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "initOnce",
						"line": 2603,
						"type": "ref (lazy typeof(var) init, Mutex mutex)",
						"parameters": [
							{
								"name": "init",
								"type": "typeof(var)",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "mutex",
								"type": "Mutex"
							}
						],
						"endline": 2622,
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "initOnce",
				"line": 2603,
				"comment": " Same as above, but takes a separate mutex instead of sharing one among\n all initOnce instances.\n\n This should be used to avoid dead-locks when the $(D_PARAM init)\n expression waits for the result of another thread that might also\n call initOnce. Use with care.\n\n Params:\n   var = The variable to initialize\n   init = The lazy initializer value\n   mutex = A mutex to prevent race conditions\n\n Returns:\n   A reference to the initialized variable\nExample:\nUse a separate mutex when init blocks on another thread that might also call initOnce.$(DDOX_UNITTEST_HEADER __unittestL2625_3484)\n---\nstatic shared bool varA, varB;\n__gshared Mutex m;\nm = new Mutex;\n\nspawn({\n    // use a different mutex for varB to avoid a dead-lock\n    initOnce!varB(true, m);\n    ownerTid.send(true);\n});\n// init depends on the result of the spawned thread\ninitOnce!varA(receiveOnly!bool);\nassert(varA == true);\nassert(varB == true);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2625_3484)\n",
				"parameters": [
					{
						"name": "var",
						"kind": "alias"
					}
				],
				"char": 10,
				"kind": "template"
			}
		],
		"comment": " This is a low-level messaging API upon which more structured or restrictive\n APIs may be built.  The general idea is that every messageable entity is\n represented by a common handle type called a Tid, which allows messages to\n be sent to logical threads that are executing in both the current process\n and in external processes using the same interface.  This is an important\n aspect of scalability because it allows the components of a program to be\n spread across available resources with few to no changes to the actual\n implementation.\n\n A logical thread is an execution context that has its own stack and which\n runs asynchronously to other logical threads.  These may be preemptively\n scheduled kernel threads, fibers (cooperative user-space threads), or some\n other concept with similar behavior.\n\n The type of concurrency used when logical threads are created is determined\n by the Scheduler selected at initialization time.  The default behavior is\n currently to create a new kernel thread per call to spawn, but other\n schedulers are available that multiplex fibers across the main thread or\n use some combination of the two approaches.\n\n Synposis:\n ---\n import std.stdio;\n import std.concurrency;\n\n void spawnedFunc(Tid ownerTid)\n {\n     // Receive a message from the owner thread.\n     receive(\n         (int i) { writeln(\"Received the number \", i);}\n     );\n\n     // Send a message back to the owner thread\n     // indicating success.\n     send(ownerTid, true);\n }\n\n void main()\n {\n     // Start spawnedFunc in a new thread.\n     auto childTid = spawn(&spawnedFunc, thisTid);\n\n     // Send the number 42 to this new thread.\n     send(childTid, 42);\n\n     // Receive the result code.\n     auto wasSuccessful = receiveOnly!(bool);\n     assert(wasSuccessful);\n     writeln(\"Successfully printed number.\");\n }\n ---\n\n Copyright: Copyright Sean Kelly 2009 - 2014.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   Sean Kelly, Alex Rønne Petersen, Martin Nowak\n Source:    $(PHOBOSSRC std/_concurrency.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/exception.d",
		"name": "std.exception",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "assertNotThrown",
						"line": 77,
						"type": "(lazy E expression, string msg = null, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "expression",
								"type": "E",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "msg",
								"type": "string",
								"default": "null"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 94,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "assertNotThrown",
				"line": 77,
				"comment": "    Asserts that the given expression does $(I not) throw the given type\n    of $(D Throwable). If a $(D Throwable) of the given type is thrown,\n    it is caught and does not escape assertNotThrown. Rather, an\n    $(D AssertError) is thrown. However, any other $(D Throwable)s will escape.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n                     If msg is empty, and the thrown exception has a\n                     non-empty msg field, the exception's msg field\n                     will be output on test failure.\n        file       = The file where the error occurred.\n                     Defaults to $(D __FILE__).\n        line       = The line where the error occurred.\n                     Defaults to $(D __LINE__).\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is thrown.\n\n    Returns:\n        the result of `expression`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL96_3486)\n---\nimport core.exception : AssertError;\n\nimport std.string;\nassertNotThrown!StringException(enforce!StringException(true, \"Error!\"));\n\n//Exception is the default.\nassertNotThrown(enforce!StringException(true, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertNotThrown!StringException(\n           enforce!StringException(false, \"Error!\"))) ==\n       `assertNotThrown failed: StringException was thrown: Error!`);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL96_3486)\n",
				"parameters": [
					{
						"name": "T",
						"deco": "C6object9Throwable",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assertThrown",
						"line": 222,
						"type": "void(lazy E expression, string msg = null, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "expression",
								"type": "E",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "msg",
								"type": "string",
								"default": "null"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 237,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "assertThrown",
				"line": 222,
				"comment": "    Asserts that the given expression throws the given type of $(D Throwable).\n    The $(D Throwable) is caught and does not escape assertThrown. However,\n    any other $(D Throwable)s $(I will) escape, and if no $(D Throwable)\n    of the given type is thrown, then an $(D AssertError) is thrown.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n        file       = The file where the error occurred.\n                     Defaults to $(D __FILE__).\n        line       = The line where the error occurred.\n                     Defaults to $(D __LINE__).\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is not thrown.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL239_3489)\n---\nimport core.exception : AssertError;\nimport std.string;\n\nassertThrown!StringException(enforce!StringException(false, \"Error!\"));\n\n//Exception is the default.\nassertThrown(enforce!StringException(false, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertThrown!StringException(\n           enforce!StringException(true, \"Error!\"))) ==\n       `assertThrown failed: No StringException was thrown.`);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL239_3489)\n",
				"parameters": [
					{
						"name": "T",
						"deco": "C6object9Throwable",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforce",
						"line": 360,
						"type": "T(T value, lazy const(char)[] msg = null, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "msg",
								"type": "const(char)[]",
								"storageClass": [
									"lazy"
								],
								"default": "null"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 365,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "enforce",
				"line": 360,
				"comment": "    Enforces that the given value is true.\n\n    Params:\n        value = The value to test.\n        E = Exception type to throw if the value evalues to false.\n        msg = The error message to put in the exception if it is thrown.\n        file = The source file of the caller.\n        line = The line number of the caller.\n\n    Returns: $(D value), if `cast(bool)value` is true. Otherwise,\n    $(D new Exception(msg)) is thrown.\n\n    Note:\n        $(D enforce) is used to throw exceptions and is therefore intended to\n        aid in error handling. It is $(I not) intended for verifying the logic\n        of your program. That is what $(D assert) is for. Also, do not use\n        $(D enforce) inside of contracts (i.e. inside of $(D in) and $(D out)\n        blocks and $(D invariant)s), because they will be compiled out when\n        compiling with $(I -release). Use $(D assert) in contracts.\n\n    Example:\n    --------------------\n    auto f = enforce(fopen(\"data.txt\"));\n    auto line = readln(f);\n    enforce(line.length, \"Expected a non-empty line.\");\n    --------------------\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(()\n{\nif (!value)\n{\n}\n}\n))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforce",
						"line": 392,
						"type": "T(T value, scope Dg dg)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "dg",
								"type": "Dg",
								"storageClass": [
									"scope"
								]
							}
						],
						"endline": 399,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "enforce",
				"line": 392,
				"comment": "    Enforces that the given value is true.\n\n    Params:\n        value = The value to test.\n        dg = The delegate to be called if the value evaluates to false.\n        file = The source file of the caller.\n        line = The line number of the caller.\n\n    Returns: $(D value), if `cast(bool)value` is true. Otherwise, the given\n    delegate is called.\n\n    The safety and purity of this function are inferred from $(D Dg)'s safety\n    and purity.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Dg",
						"kind": "type"
					},
					{
						"name": "file",
						"defaultValue": "__FILE__",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "line",
						"defaultValue": "__LINE__",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "isSomeFunction!Dg && is(typeof(dg())) && is(typeof(()\n{\nif (!value)\n{\n}\n}\n))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforce",
						"line": 556,
						"type": "T(T value, lazy Throwable ex)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "ex",
								"type": "Throwable",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 560,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "enforce",
				"line": 556,
				"comment": "    Enforces that the given value is true.\n\n    Params:\n        value = The value to test.\n        ex = The exception to throw if the value evaluates to false.\n\n    Returns: $(D value), if `cast(bool)value` is true. Otherwise, $(D ex) is\n    thrown.\n\n    Example:\n    --------------------\n    auto f = enforce(fopen(\"data.txt\"));\n    auto line = readln(f);\n    enforce(line.length, new IOException); // expect a non-empty line\n    --------------------\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "errnoEnforce",
						"line": 588,
						"type": "T(T value, lazy string msg = null)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "msg",
								"type": "string",
								"storageClass": [
									"lazy"
								],
								"default": "null"
							}
						],
						"endline": 593,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "errnoEnforce",
				"line": 588,
				"comment": "    Enforces that the given value is true, throwing an `ErrnoException` if it\n    is not.\n\n    Params:\n        value = The value to test.\n        msg = The message to include in the `ErrnoException` if it is thrown.\n\n    Returns: $(D value), if `cast(bool)value` is true. Otherwise,\n    $(D new ErrnoException(msg)) is thrown.  It is assumed that the last\n    operation set $(D errno) to an error code corresponding with the failed\n    condition.\n\n    Example:\n    --------------------\n    auto f = errnoEnforce(fopen(\"data.txt\"));\n    auto line = readln(f);\n    enforce(line.length); // expect a non-empty line\n    --------------------\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "file",
						"defaultValue": "__FILE__",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "line",
						"defaultValue": "__LINE__",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "enforceEx",
								"line": 615,
								"type": "T(T value, lazy string msg = \"\", string file = __FILE__, size_t line = __LINE__)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									},
									{
										"name": "msg",
										"type": "string",
										"storageClass": [
											"lazy"
										],
										"default": "\"\""
									},
									{
										"name": "file",
										"type": "string",
										"default": "__FILE__"
									},
									{
										"name": "line",
										"type": "size_t",
										"default": "__LINE__"
									}
								],
								"endline": 619,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "enforceEx",
						"line": 615,
						"comment": " Ditto\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 7,
						"kind": "template"
					}
				],
				"name": "enforceEx",
				"line": 611,
				"comment": "    If $(D !value) is $(D false), $(D value) is returned. Otherwise,\n    $(D new E(msg, file, line)) is thrown. Or if $(D E) doesn't take a message\n    and can be constructed with $(D new E(file, line)), then\n    $(D new E(file, line)) will be thrown.\n\n    This is legacy name, it is recommended to use $(D enforce!E) instead.\n\n    Example:\n    --------------------\n    auto f = enforceEx!FileMissingException(fopen(\"data.txt\"));\n    auto line = readln(f);\n    enforceEx!DataCorruptionException(line.length);\n    --------------------\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(new E(\"\", \"/home/seb/dlang/docs/work/repo/phobos/std/exception.d\", 612)))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "enforceEx",
								"line": 627,
								"type": "T(T value, string file = __FILE__, size_t line = __LINE__)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									},
									{
										"name": "file",
										"type": "string",
										"default": "__FILE__"
									},
									{
										"name": "line",
										"type": "size_t",
										"default": "__LINE__"
									}
								],
								"endline": 631,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "enforceEx",
						"line": 627,
						"comment": " Ditto\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 7,
						"kind": "template"
					}
				],
				"name": "enforceEx",
				"line": 623,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(new E(\"/home/seb/dlang/docs/work/repo/phobos/std/exception.d\", 624))) && !is(typeof(new E(\"\", \"/home/seb/dlang/docs/work/repo/phobos/std/exception.d\", 624)))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "collectException",
						"line": 702,
						"type": "T(lazy E expression, ref E result)",
						"parameters": [
							{
								"name": "expression",
								"type": "E",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "result",
								"type": "E",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 713,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "collectException",
				"line": 702,
				"comment": "    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned and $(D result) is\n    set to the result of the expression.\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n        result     = The result of the expression if no exception is thrown.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL715_3500)\n---\nint b;\nint foo() { throw new Exception(\"blah\"); }\nassert(collectException(foo(), b));\n\nint[] a = new int[3];\nimport core.exception : RangeError;\nassert(collectException!RangeError(a[4], b));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL715_3500)\n",
				"parameters": [
					{
						"name": "T",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "collectException",
						"line": 742,
						"type": "T(lazy E expression)",
						"parameters": [
							{
								"name": "expression",
								"type": "E",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 753,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "collectException",
				"line": 742,
				"comment": "    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned. $(D E) can be\n    $(D void).\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n",
				"parameters": [
					{
						"name": "T",
						"deco": "C6object9Throwable",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "collectExceptionMsg",
						"line": 780,
						"type": "string(lazy E expression)",
						"parameters": [
							{
								"name": "expression",
								"type": "E",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 791,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "collectExceptionMsg",
				"line": 780,
				"comment": "    Catches the exception thrown from the given expression and returns the\n    msg property of that exception. If no exception is thrown, then null is\n    returned. $(D E) can be $(D void).\n\n    If an exception is thrown but it has an empty message, then\n    $(D emptyExceptionMsg) is returned.\n\n    Note that while $(D collectExceptionMsg) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectExceptionMsg) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL793_3502)\n---\nvoid throwFunc() { throw new Exception(\"My Message.\"); }\nassert(collectExceptionMsg(throwFunc()) == \"My Message.\");\n\nvoid nothrowFunc() {}\nassert(collectExceptionMsg(nothrowFunc()) is null);\n\nvoid throwEmptyFunc() { throw new Exception(\"\"); }\nassert(collectExceptionMsg(throwEmptyFunc()) == emptyExceptionMsg);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL793_3502)\n",
				"parameters": [
					{
						"name": "T",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"name": "emptyExceptionMsg",
				"line": 809,
				"comment": "    Value that collectExceptionMsg returns when it catches an exception\n    with an empty exception message.\n",
				"deco": "Aya",
				"init": "\"<Empty Exception Message>\"",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeUnique",
						"line": 907,
						"type": "pure nothrow immutable(T)[](T[] array)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]"
							}
						],
						"endline": 910,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "assumeUnique",
				"line": 907,
				"comment": " Casts a mutable array to an immutable array in an idiomatic\n manner. Technically, $(D assumeUnique) just inserts a cast,\n but its name documents assumptions on the part of the\n caller. $(D assumeUnique(arr)) should only be called when\n there are no more active mutable aliases to elements of $(D\n arr). To strengthen this assumption, $(D assumeUnique(arr))\n also clears $(D arr) before returning. Essentially $(D\n assumeUnique(arr)) indicates commitment from the caller that there\n is no more mutable access to any of $(D arr)'s elements\n (transitively), and that all future accesses will be done through\n the immutable array returned by $(D assumeUnique).\n\n Typically, $(D assumeUnique) is used to return arrays from\n functions that have allocated and built them.\n\n Params:\n  array = The array to cast to immutable.\n\n Returns: The immutable array.\n\n Example:\n\n ----\n string letters()\n {\n   char[] result = new char['z' - 'a' + 1];\n   foreach (i, ref e; result)\n   {\n     e = cast(char)('a' + i);\n   }\n   return assumeUnique(result);\n }\n ----\n\n The use in the example above is correct because $(D result)\n was private to $(D letters) and is inaccessible in writing\n after the function returns. The following example shows an\n incorrect use of $(D assumeUnique).\n\n Bad:\n\n ----\n private char[] buffer;\n string letters(char first, char last)\n {\n   if (first >= last) return null; // fine\n   auto sneaky = buffer;\n   sneaky.length = last - first + 1;\n   foreach (i, ref e; sneaky)\n   {\n     e = cast(char)('a' + i);\n   }\n   return assumeUnique(sneaky); // BAD\n }\n ----\n\n The example above wreaks havoc on client code because it is\n modifying arrays that callers considered immutable. To obtain an\n immutable array from the writable array $(D buffer), replace\n the last line with:\n ----\n return to!(string)(sneaky); // not that sneaky anymore\n ----\n\n The call will duplicate the array appropriately.\n\n Note that checking for uniqueness during compilation is\n possible in certain cases, especially when a function is\n marked as a pure function. The following example does not\n need to call assumeUnique because the compiler can infer the\n uniqueness of the array in the pure function:\n ----\n string letters() pure\n {\n   char[] result = new char['z' - 'a' + 1];\n   foreach (i, ref e; result)\n   {\n     e = cast(char)('a' + i);\n   }\n   return result;\n }\n ----\n\n For more on infering uniqueness see the $(B unique) and\n $(B lent) keywords in the\n $(WEB archjava.fluid.cs.cmu.edu/papers/oopsla02.pdf, ArchJava)\n language.\n\n The downside of using $(D assumeUnique)'s\n convention-based usage is that at this time there is no\n formal checking of the correctness of the assumption;\n on the upside, the idiomatic use of $(D assumeUnique) is\n simple and rare enough to be tolerable.\n\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeUnique",
						"line": 912,
						"type": "pure nothrow immutable(T)[](ref T[] array)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 917,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "assumeUnique",
				"line": 912,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeWontThrow",
						"line": 966,
						"type": "nothrow T(lazy T expr, string msg = null, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "expr",
								"type": "T",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "msg",
								"type": "string",
								"default": "null"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 983,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "assumeWontThrow",
				"line": 966,
				"comment": " Wraps a possibly-throwing expression in a $(D nothrow) wrapper so that it\n can be called by a $(D nothrow) function.\n\n This wrapper function documents commitment on the part of the caller that\n the appropriate steps have been taken to avoid whatever conditions may\n trigger an exception during the evaluation of $(D expr).  If it turns out\n that the expression $(I does) throw at runtime, the wrapper will throw an\n $(D AssertError).\n\n (Note that $(D Throwable) objects such as $(D AssertError) that do not\n subclass $(D Exception) may be thrown even from $(D nothrow) functions,\n since they are considered to be serious runtime problems that cannot be\n recovered from.)\n\n Params:\n  expr = The expression asserted not to throw.\n  msg = The message to include in the `AssertError` if the assumption turns\n      out to be false.\n  file = The source file name of the caller.\n  line = The line number of the caller.\n\n Returns:\n  The value of `expr`, if any.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL986_3505)\n---\nimport std.math : sqrt;\n\n// This function may throw.\nint squareRoot(int x)\n{\n    if (x < 0)\n        throw new Exception(\"Tried to take root of negative number\");\n    return cast(int)sqrt(cast(double)x);\n}\n\n// This function never throws.\nint computeLength(int x, int y) nothrow\n{\n    // Since x*x + y*y is always positive, we can safely assume squareRoot\n    // won't throw, and use it to implement this nothrow function. If it\n    // does throw (e.g., if x*x + y*y overflows a 32-bit value), then the\n    // program will terminate.\n    return assumeWontThrow(squareRoot(x*x + y*y));\n}\n\nassert(computeLength(3, 4) == 5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL986_3505)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "doesPointTo",
						"line": 1064,
						"type": "pure nothrow @trusted bool(auto ref const S source, ref const T target)",
						"parameters": [
							{
								"name": "source",
								"type": "S",
								"storageClass": [
									"auto",
									"const",
									"ref"
								]
							},
							{
								"name": "target",
								"type": "T",
								"storageClass": [
									"const",
									"ref"
								]
							}
						],
						"endline": 1097,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "doesPointTo",
				"line": 1064,
				"comment": "Checks whether a given source object contains pointers or references to a given\ntarget object.\n\nParams:\n    source = The source object\n    target = The target object\n\nReturns: $(D true) if $(D source)'s representation embeds a pointer\nthat points to $(D target)'s representation or somewhere inside\nit.\n\nIf $(D source) is or contains a dynamic array, then, then these functions will check\nif there is overlap between the dynamic array and $(D target)'s representation.\n\nIf $(D source) is a class, then it will be handled as a pointer.\n\nIf $(D target) is a pointer, a dynamic array or a class, then these functions will only\ncheck if $(D source) points to $(D target), $(I not) what $(D target) references.\n\nIf $(D source) is or contains a union, then there may be either false positives or\nfalse negatives:\n\n$(D doesPointTo) will return $(D true) if it is absolutely certain\n$(D source) points to $(D target). It may produce false negatives, but never\nfalse positives. This function should be prefered when trying to validate\ninput data.\n\n$(D mayPointTo) will return $(D false) if it is absolutely certain\n$(D source) does not point to $(D target). It may produce false positives, but never\nfalse negatives. This function should be prefered for defensively choosing a\ncode path.\n\nNote: Evaluating $(D doesPointTo(x, x)) checks whether $(D x) has\ninternal pointers. This should only be done as an assertive test,\nas the language is free to assume objects don't have internal pointers\n(TDPL 7.1.3.5).\nExample:\nPointers$(DDOX_UNITTEST_HEADER __unittestL1149_3507)\n---\nint  i = 0;\nint* p = null;\nassert(!p.doesPointTo(i));\np = &i;\nassert( p.doesPointTo(i));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1149_3507)\nExample:\nStructs and Unions$(DDOX_UNITTEST_HEADER __unittestL1159_3508)\n---\nstruct S\n{\n    int v;\n    int* p;\n}\nint i;\nauto s = S(0, &i);\n\n// structs and unions \"own\" their members\n// pointsTo will answer true if one of the members pointsTo.\nassert(!s.doesPointTo(s.v)); //s.v is just v member of s, so not pointed.\nassert( s.p.doesPointTo(i)); //i is pointed by s.p.\nassert( s  .doesPointTo(i)); //which means i is pointed by s itself.\n\n// Unions will behave exactly the same. Points to will check each \"member\"\n// individually, even if they share the same memory\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1159_3508)\nExample:\nArrays (dynamic and static)$(DDOX_UNITTEST_HEADER __unittestL1180_3509)\n---\nint i;\nint[]  slice = [0, 1, 2, 3, 4];\nint[5] arr   = [0, 1, 2, 3, 4];\nint*[]  slicep = [&i];\nint*[1] arrp   = [&i];\n\n// A slice points to all of its members:\nassert( slice.doesPointTo(slice[3]));\nassert(!slice[0 .. 2].doesPointTo(slice[3])); // Object 3 is outside of the\n                                              // slice [0 .. 2]\n\n// Note that a slice will not take into account what its members point to.\nassert( slicep[0].doesPointTo(i));\nassert(!slicep   .doesPointTo(i));\n\n// static arrays are objects that own their members, just like structs:\nassert(!arr.doesPointTo(arr[0])); // arr[0] is just a member of arr, so not\n                                  // pointed.\nassert( arrp[0].doesPointTo(i));  // i is pointed by arrp[0].\nassert( arrp   .doesPointTo(i));  // which means i is pointed by arrp\n                                  // itself.\n\n// Notice the difference between static and dynamic arrays:\nassert(!arr  .doesPointTo(arr[0]));\nassert( arr[].doesPointTo(arr[0]));\nassert( arrp  .doesPointTo(i));\nassert(!arrp[].doesPointTo(i));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1180_3509)\nExample:\nClasses$(DDOX_UNITTEST_HEADER __unittestL1212_3510)\n---\nclass C\n{\n    this(int* p){this.p = p;}\n    int* p;\n}\nint i;\nC a = new C(&i);\nC b = a;\n\n// Classes are a bit particular, as they are treated like simple pointers\n// to a class payload.\nassert( a.p.doesPointTo(i)); // a.p points to i.\nassert(!a  .doesPointTo(i)); // Yet a itself does not point i.\n\n//To check the class payload itself, iterate on its members:\n()\n{\n    foreach (index, _; Fields!C)\n        if (doesPointTo(a.tupleof[index], i))\n            return;\n    assert(0);\n}();\n\n// To check if a class points a specific payload, a direct memmory check\n// can be done:\nauto aLoc = cast(ubyte[__traits(classInstanceSize, C)]*) a;\nassert(b.doesPointTo(*aLoc)); // b points to where a is pointing\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1212_3510)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"defaultDeco": "v",
						"name": "Tdummy",
						"kind": "type"
					}
				],
				"constraint": "__traits(isRef, source) || isDynamicArray!S || isPointer!S || is(S == class)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "doesPointTo",
						"line": 1101,
						"type": "pure nothrow @trusted bool(auto ref const shared S source, ref const shared T target)",
						"parameters": [
							{
								"name": "source",
								"type": "S",
								"storageClass": [
									"auto",
									"const",
									"shared",
									"ref"
								]
							},
							{
								"name": "target",
								"type": "T",
								"storageClass": [
									"const",
									"shared",
									"ref"
								]
							}
						],
						"endline": 1104,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "doesPointTo",
				"line": 1101,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "mayPointTo",
						"line": 1107,
						"type": "pure nothrow @trusted bool(auto ref const S source, ref const T target)",
						"parameters": [
							{
								"name": "source",
								"type": "S",
								"storageClass": [
									"auto",
									"const",
									"ref"
								]
							},
							{
								"name": "target",
								"type": "T",
								"storageClass": [
									"const",
									"ref"
								]
							}
						],
						"endline": 1139,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "mayPointTo",
				"line": 1107,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"defaultDeco": "v",
						"name": "Tdummy",
						"kind": "type"
					}
				],
				"constraint": "__traits(isRef, source) || isDynamicArray!S || isPointer!S || is(S == class)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "mayPointTo",
						"line": 1143,
						"type": "pure nothrow @trusted bool(auto ref const shared S source, ref const shared T target)",
						"parameters": [
							{
								"name": "source",
								"type": "S",
								"storageClass": [
									"auto",
									"const",
									"shared",
									"ref"
								]
							},
							{
								"name": "target",
								"type": "T",
								"storageClass": [
									"const",
									"shared",
									"ref"
								]
							}
						],
						"endline": 1146,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "mayPointTo",
				"line": 1143,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 51,
						"name": "errno",
						"line": 1489,
						"comment": "Operating system error code.\n",
						"deco": "FNdZk",
						"endline": 1489,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					}
				],
				"name": "ErrnoException",
				"line": 1487,
				"comment": " Thrown if errors that set $(D errno) occur.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ifThrown",
						"line": 1572,
						"type": "CommonType!(T1, T2)(lazy scope T1 expression, lazy scope T2 errorHandler)",
						"parameters": [
							{
								"name": "expression",
								"type": "T1",
								"storageClass": [
									"scope",
									"lazy"
								]
							},
							{
								"name": "errorHandler",
								"type": "T2",
								"storageClass": [
									"scope",
									"lazy"
								]
							}
						],
						"endline": 1584,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "ifThrown",
				"line": 1572,
				"comment": "    ML-style functional exception handling. Runs the supplied expression and\n    returns its result. If the expression throws a $(D Throwable), runs the\n    supplied error handler instead and return its result. The error handler's\n    type must be the same as the expression's type.\n\n    Params:\n        E            = The type of $(D Throwable)s to catch. Defaults to $(D Exception)\n        T1           = The type of the expression.\n        T2           = The return type of the error handler.\n        expression   = The expression to run and return its result.\n        errorHandler = The handler to run if the expression throwed.\n\n    Returns:\n        expression, if it does not throw. Otherwise, returns the result of\n        errorHandler.\n\n    Example:\n    --------------------\n    //Revert to a default value upon an error:\n    assert(\"x\".to!int().ifThrown(0) == 0);\n    --------------------\n\n    You can also chain multiple calls to ifThrown, each capturing errors from the\n    entire preceding expression.\n\n    Example:\n    --------------------\n    //Chaining multiple calls to ifThrown to attempt multiple things in a row:\n    string s=\"true\";\n    assert(s.to!int().\n            ifThrown(cast(int)s.to!double()).\n            ifThrown(cast(int)s.to!bool())\n            == 1);\n\n    //Respond differently to different types of errors\n    assert(enforce(\"x\".to!int() < 1).to!string()\n            .ifThrown!ConvException(\"not a number\")\n            .ifThrown!Exception(\"number too small\")\n            == \"not a number\");\n    --------------------\n\n    The expression and the errorHandler must have a common type they can both\n    be implicitly casted to, and that type will be the type of the compound\n    expression.\n\n    Example:\n    --------------------\n    //null and new Object have a common type(Object).\n    static assert(is(typeof(null.ifThrown(new Object())) == Object));\n    static assert(is(typeof((new Object()).ifThrown(null)) == Object));\n\n    //1 and new Object do not have a common type.\n    static assert(!__traits(compiles, 1.ifThrown(new Object())));\n    static assert(!__traits(compiles, (new Object()).ifThrown(1)));\n    --------------------\n\n    If you need to use the actual thrown exception, you can use a delegate.\n    Example:\n    --------------------\n    //Use a lambda to get the thrown object.\n    assert(\"%s\".format().ifThrown!Exception(e => e.classinfo.name) == \"std.format.FormatException\");\n    --------------------\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ifThrown",
						"line": 1588,
						"type": "CommonType!(T1, T2)(lazy scope T1 expression, scope T2 delegate(E) errorHandler)",
						"parameters": [
							{
								"name": "expression",
								"type": "T1",
								"storageClass": [
									"scope",
									"lazy"
								]
							},
							{
								"name": "errorHandler",
								"type": "T2 delegate(E)",
								"storageClass": [
									"scope"
								]
							}
						],
						"endline": 1600,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "ifThrown",
				"line": 1588,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"kind": "type"
					},
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ifThrown",
						"line": 1604,
						"type": "CommonType!(T1, T2)(lazy scope T1 expression, scope T2 delegate(Exception) errorHandler)",
						"parameters": [
							{
								"name": "expression",
								"type": "T1",
								"storageClass": [
									"scope",
									"lazy"
								]
							},
							{
								"name": "errorHandler",
								"type": "T2 delegate(Exception)",
								"storageClass": [
									"scope"
								]
							}
						],
						"endline": 1616,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "ifThrown",
				"line": 1604,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "front",
						"line": 1707,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "back",
						"line": 1708,
						"value": "2",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "popFront",
						"line": 1709,
						"value": "4",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "popBack",
						"line": 1710,
						"value": "8",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "empty",
						"line": 1711,
						"value": "16",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "save",
						"line": 1712,
						"value": "32",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "length",
						"line": 1713,
						"value": "64",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "opDollar",
						"line": 1714,
						"value": "128",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "opIndex",
						"line": 1715,
						"value": "256",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "opSlice",
						"line": 1716,
						"value": "512",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "access",
						"line": 1717,
						"value": "259",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "pop",
						"line": 1718,
						"value": "12",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "RangePrimitive",
				"line": 1705,
				"comment": " This $(D enum) is used to select the primitives of the range to handle by the\n  $(LREF handle) range wrapper. The values of the $(D enum) can be $(D OR)'d to\n  select multiple primitives to be handled.\n\n  $(D RangePrimitive.access) is a shortcut for the access primitives; $(D front),\n  $(D back) and $(D opIndex).\n\n  $(D RangePrimitive.pop) is a shortcut for the mutating primitives;\n  $(D popFront) and $(D popBack).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "handle",
						"line": 1748,
						"type": "(Range input)",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							}
						],
						"endline": 1977,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "handle",
				"line": 1748,
				"comment": " Handle exceptions thrown from range primitives.\n\nUse the $(LREF RangePrimitive) enum to specify which primitives to _handle.\nMultiple range primitives can be handled at once by using the $(D OR) operator\nor the pseudo-primitives $(D RangePrimitive.access) and $(D RangePrimitive.pop).\nAll handled primitives must have return types or values compatible with the\nuser-supplied handler.\n\nParams:\n    E = The type of $(D Throwable) to _handle.\n    primitivesToHandle = Set of range primitives to _handle.\n    handler = The callable that is called when a handled primitive throws a\n    $(D Throwable) of type $(D E). The handler must accept arguments of\n    the form $(D E, ref IRange) and its return value is used as the primitive's\n    return value whenever $(D E) is thrown. For $(D opIndex), the handler can\n    optionally recieve a third argument; the index that caused the exception.\n    input = The range to _handle.\n\nReturns: A wrapper $(D struct) that preserves the range interface of $(D input).\n\nopSlice:\nInfinite ranges with slicing support must return an instance of\n$(XREF range, Take) when sliced with a specific lower and upper\nbound (see $(XREF_PACK range,primitives,hasSlicing)); $(D handle) deals with\nthis by $(D take)ing 0 from the return value of the handler function and\nreturning that when an exception is caught.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1980_3534)\n---\nimport std.algorithm : equal, map, splitter;\nimport std.conv : to, ConvException;\n\nauto s = \"12,1337z32,54,2,7,9,1z,6,8\";\n\n// The next line composition will throw when iterated\n// as some elements of the input do not convert to integer\nauto r = s.splitter(',').map!(a => to!int(a));\n\n// Substitute 0 for cases of ConvException\nauto h = r.handle!(ConvException, RangePrimitive.front, (e, r) => 0);\nassert(h.equal([12, 0, 54, 2, 7, 9, 0, 6, 8]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1980_3534)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1997_3537)\n---\nimport std.algorithm : equal;\nimport std.range : retro;\nimport std.utf : UTFException;\n\nauto str = \"hello\\xFFworld\"; // 0xFF is an invalid UTF-8 code unit\n\nauto handled = str.handle!(UTFException, RangePrimitive.access,\n        (e, r) => ' '); // Replace invalid code points with spaces\n\nassert(handled.equal(\"hello world\")); // `front` is handled,\nassert(handled.retro.equal(\"dlrow olleh\")); // as well as `back`\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1997_3537)\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"kind": "type"
					},
					{
						"name": "primitivesToHandle",
						"deco": "E3std9exception14RangePrimitive",
						"kind": "value"
					},
					{
						"name": "handler",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "    This module defines functions related to exceptions and general error\n    handling. It also defines functions intended to aid in unit testing.\n\n    Synopsis of some of std.exception's functions:\n    --------------------\n    string synopsis()\n    {\n        FILE* f = enforce(fopen(\"some/file\"));\n        // f is not null from here on\n        FILE* g = enforce!WriteException(fopen(\"some/other/file\", \"w\"));\n        // g is not null from here on\n\n        Exception e = collectException(write(g, readln(f)));\n        if (e)\n        {\n            ... an exception occurred...\n            ... We have the exception to play around with...\n        }\n\n        string msg = collectExceptionMsg(write(g, readln(f)));\n        if (msg)\n        {\n            ... an exception occurred...\n            ... We have the message from the exception but not the exception...\n        }\n\n        char[] line;\n        enforce(readln(f, line));\n        return assumeUnique(line);\n    }\n    --------------------\n\n    Macros:\n        WIKI = Phobos/StdException\n\n    Copyright: Copyright Andrei Alexandrescu 2008-, Jonathan M Davis 2011-.\n    License:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n    Authors:   $(WEB erdani.org, Andrei Alexandrescu) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std/_exception.d)\n\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/range/interfaces.d",
		"name": "std.range.interfaces",
		"members": [
			{
				"members": [
					{
						"name": "InputRange",
						"line": 93,
						"members": [
							{
								"name": "front",
								"line": 95,
								"comment": "\n",
								"type": "@property E()",
								"char": 17,
								"kind": "function"
							},
							{
								"name": "moveFront",
								"line": 98,
								"comment": "\n",
								"type": "E()",
								"char": 7,
								"kind": "function"
							},
							{
								"name": "popFront",
								"line": 101,
								"comment": "\n",
								"type": "void()",
								"char": 10,
								"kind": "function"
							},
							{
								"name": "empty",
								"line": 104,
								"comment": "\n",
								"type": "@property bool()",
								"char": 20,
								"kind": "function"
							},
							{
								"name": "opApply",
								"line": 118,
								"comment": "$(D foreach) iteration uses opApply, since one delegate call per loop\n iteration is faster than three virtual function calls.\n",
								"type": "int(int delegate(E))",
								"parameters": [
									{
										"type": "int delegate(E)"
									}
								],
								"char": 9,
								"kind": "function"
							},
							{
								"name": "opApply",
								"line": 121,
								"comment": "Ditto\n",
								"type": "int(int delegate(size_t, E))",
								"parameters": [
									{
										"type": "int delegate(size_t, E)"
									}
								],
								"char": 9,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "InputRange",
				"line": 93,
				"comment": "These interfaces are intended to provide virtual function-based wrappers\n around input ranges with element type E.  This is useful where a well-defined\n binary interface is required, such as when a DLL function or virtual function\n needs to accept a generic range as a parameter. Note that\n $(LINK2 std_range_primitives.html#isInputRange, isInputRange) and friends check for conformance to structural\n interfaces, not for implementation of these $(D interface) types.\n\n Limitations:\n\n These interfaces are not capable of forwarding $(D ref) access to elements.\n\n Infiniteness of the wrapped range is not propagated.\n\n Length is not propagated in the case of non-random access ranges.\n\n See_Also:\n $(LREF inputRangeObject)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL126_3556)\n---\nimport std.algorithm : map;\nimport std.range : iota;\n\nvoid useRange(InputRange!int range) {\n    // Function body.\n}\n\n// Create a range type.\nauto squares = map!\"a * a\"(iota(10));\n\n// Wrap it in an interface.\nauto squaresWrapped = inputRangeObject(squares);\n\n// Use it.\nuseRange(squaresWrapped);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL126_3556)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ForwardRange",
						"line": 146,
						"members": [
							{
								"name": "save",
								"line": 148,
								"comment": "\n",
								"type": "@property ForwardRange!E()",
								"char": 30,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "ForwardRange",
				"line": 146,
				"comment": "Interface for a forward range of type $(D E).\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "BidirectionalRange",
						"line": 152,
						"members": [
							{
								"name": "save",
								"line": 154,
								"comment": "\n",
								"type": "@property BidirectionalRange!E()",
								"char": 36,
								"kind": "function"
							},
							{
								"name": "back",
								"line": 157,
								"comment": "\n",
								"type": "@property E()",
								"char": 17,
								"kind": "function"
							},
							{
								"name": "moveBack",
								"line": 160,
								"comment": "\n",
								"type": "E()",
								"char": 7,
								"kind": "function"
							},
							{
								"name": "popBack",
								"line": 163,
								"comment": "\n",
								"type": "void()",
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "BidirectionalRange",
				"line": 152,
				"comment": "Interface for a bidirectional range of type $(D E).\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RandomAccessFinite",
						"line": 167,
						"members": [
							{
								"name": "save",
								"line": 169,
								"comment": "\n",
								"type": "@property RandomAccessFinite!E()",
								"char": 36,
								"kind": "function"
							},
							{
								"name": "opIndex",
								"line": 172,
								"comment": "\n",
								"type": "E(size_t)",
								"parameters": [
									{
										"type": "size_t"
									}
								],
								"char": 7,
								"kind": "function"
							},
							{
								"name": "moveAt",
								"line": 175,
								"comment": "\n",
								"type": "E(size_t)",
								"parameters": [
									{
										"type": "size_t"
									}
								],
								"char": 7,
								"kind": "function"
							},
							{
								"name": "length",
								"line": 178,
								"comment": "\n",
								"type": "@property size_t()",
								"char": 22,
								"kind": "function"
							},
							{
								"name": "opDollar",
								"line": 181,
								"comment": "\n",
								"type": "length",
								"char": 5,
								"kind": "alias"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "RandomAccessFinite",
				"line": 167,
				"comment": "Interface for a finite random access range of type $(D E).\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RandomAccessInfinite",
						"line": 192,
						"members": [
							{
								"name": "moveAt",
								"line": 194,
								"comment": "\n",
								"type": "E(size_t)",
								"parameters": [
									{
										"type": "size_t"
									}
								],
								"char": 7,
								"kind": "function"
							},
							{
								"name": "save",
								"line": 197,
								"comment": "\n",
								"type": "@property RandomAccessInfinite!E()",
								"char": 38,
								"kind": "function"
							},
							{
								"name": "opIndex",
								"line": 200,
								"comment": "\n",
								"type": "E(size_t)",
								"parameters": [
									{
										"type": "size_t"
									}
								],
								"char": 7,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "RandomAccessInfinite",
				"line": 192,
				"comment": "Interface for an infinite random access range of type $(D E).\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "InputAssignable",
						"line": 204,
						"members": [
							{
								"name": "front",
								"line": 206,
								"comment": "\n",
								"type": "@property void(E newVal)",
								"parameters": [
									{
										"name": "newVal",
										"type": "E"
									}
								],
								"char": 20,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "InputAssignable",
				"line": 204,
				"comment": "Adds assignable elements to InputRange.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ForwardAssignable",
						"line": 210,
						"members": [
							{
								"name": "save",
								"line": 212,
								"comment": "\n",
								"type": "@property ForwardAssignable!E()",
								"char": 35,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "ForwardAssignable",
				"line": 210,
				"comment": "Adds assignable elements to ForwardRange.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "BidirectionalAssignable",
						"line": 216,
						"members": [
							{
								"name": "save",
								"line": 218,
								"comment": "\n",
								"type": "@property BidirectionalAssignable!E()",
								"char": 41,
								"kind": "function"
							},
							{
								"name": "back",
								"line": 221,
								"comment": "\n",
								"type": "@property void(E newVal)",
								"parameters": [
									{
										"name": "newVal",
										"type": "E"
									}
								],
								"char": 20,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "BidirectionalAssignable",
				"line": 216,
				"comment": "Adds assignable elements to BidirectionalRange.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RandomFiniteAssignable",
						"line": 225,
						"members": [
							{
								"name": "save",
								"line": 227,
								"comment": "\n",
								"type": "@property RandomFiniteAssignable!E()",
								"char": 40,
								"kind": "function"
							},
							{
								"name": "opIndexAssign",
								"line": 230,
								"comment": "\n",
								"type": "void(E val, size_t index)",
								"parameters": [
									{
										"name": "val",
										"type": "E"
									},
									{
										"name": "index",
										"type": "size_t"
									}
								],
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "RandomFiniteAssignable",
				"line": 225,
				"comment": "Adds assignable elements to RandomAccessFinite.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "OutputRange",
						"line": 235,
						"members": [
							{
								"name": "put",
								"line": 237,
								"comment": "\n",
								"type": "void(E)",
								"parameters": [
									{
										"type": "E"
									}
								],
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "OutputRange",
				"line": 235,
				"comment": "Interface for an output range of type $(D E).  Usage is similar to the\n $(D InputRange) interface and descendants.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "OutputRangeObject",
						"line": 266,
						"members": [],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "OutputRangeObject",
				"line": 266,
				"comment": "Implements the $(D OutputRange) interface for all types E and wraps the\n $(D put) method for each type $(D E) in a virtual function.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "MostDerivedInputRange",
				"line": 280,
				"comment": "Returns the interface type that best matches $(D R).\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!R)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "InputRangeObject",
				"line": 316,
				"comment": "Implements the most derived interface that $(D R) works with and wraps\n all relevant range primitives in virtual functions.  If $(D R) is already\n derived from the $(D InputRange) interface, aliases itself away.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!R)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "inputRangeObject",
						"line": 434,
						"type": "InputRangeObject!R(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 440,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "inputRangeObject",
				"line": 434,
				"comment": "Convenience function for creating an $(D InputRangeObject) of the proper type.\n See $(LREF InputRange) for an example.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 20,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "outputRangeObject",
								"line": 448,
								"type": "OutputRangeObject!(R, E)(R range)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									}
								],
								"endline": 450,
								"char": 30,
								"kind": "function"
							}
						],
						"name": "outputRangeObject",
						"line": 448,
						"comment": "\n",
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"char": 30,
						"kind": "template"
					}
				],
				"name": "outputRangeObject",
				"line": 445,
				"comment": "Convenience function for creating an $(D OutputRangeObject) with a base range\n of type $(D R) that accepts types $(D E).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL454_3558)\n---\nimport std.array;\nauto app = appender!(uint[])();\nauto appWrapped = outputRangeObject!(uint, uint[])(app);\nstatic assert(is(typeof(appWrapped) : OutputRange!(uint[])));\nstatic assert(is(typeof(appWrapped) : OutputRange!(uint)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL454_3558)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module is a submodule of $(LINK2 std_range.html, std.range).\n\nThe main $(D std.range) module provides template-based tools for working with\nranges, but sometimes an object-based interface for ranges is needed, such as\nwhen runtime polymorphism is required. For this purpose, this submodule\nprovides a number of object and $(D interface) definitions that can be used to\nwrap around _range objects created by the $(D std.range) templates.\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF InputRange)))\n        $(TD Wrapper for input ranges.\n    ))\n    $(TR $(TD $(D $(LREF InputAssignable)))\n        $(TD Wrapper for input ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF ForwardRange)))\n        $(TD Wrapper for forward ranges.\n    ))\n    $(TR $(TD $(D $(LREF ForwardAssignable)))\n        $(TD Wrapper for forward ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF BidirectionalRange)))\n        $(TD Wrapper for bidirectional ranges.\n    ))\n    $(TR $(TD $(D $(LREF BidirectionalAssignable)))\n        $(TD Wrapper for bidirectional ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF RandomAccessFinite)))\n        $(TD Wrapper for finite random-access ranges.\n    ))\n    $(TR $(TD $(D $(LREF RandomAccessAssignable)))\n        $(TD Wrapper for finite random-access ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF RandomAccessInfinite)))\n        $(TD Wrapper for infinite random-access ranges.\n    ))\n    $(TR $(TD $(D $(LREF OutputRange)))\n        $(TD Wrapper for output ranges.\n    ))\n    $(TR $(TD $(D $(LREF OutputRangeObject)))\n        $(TD Class that implements the $(D OutputRange) interface and wraps the\n        $(D put) methods in virtual functions.\n    ))\n    $(TR $(TD $(D $(LREF InputRangeObject)))\n        $(TD Class that implements the $(D InputRange) interface and wraps the\n        input _range methods in virtual functions.\n    ))\n    $(TR $(TD $(D $(LREF RefRange)))\n        $(TD Wrapper around a forward _range that gives it reference semantics.\n    ))\n)\n\n\nSource: $(PHOBOSSRC std/range/_interfaces.d)\n\nMacros:\n\nWIKI = Phobos/StdRange\n\nCopyright: Copyright by authors 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu), David Simcha,\nand Jonathan M Davis. Credit for some of the ideas in building this module goes\nto $(WEB fantascienza.net/leonardo/so/, Leonardo Maffi).\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/range/package.d",
		"name": "std.range",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "retro",
						"line": 194,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 303,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "retro",
				"line": 194,
				"comment": "Iterates a bidirectional range backwards. The original range can be\naccessed by using the $(D source) property. Applying retro twice to\nthe same range yields the original range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL307_3560)\n---\nimport std.algorithm : equal;\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(retro(a), [ 5, 4, 3, 2, 1 ][]));\nassert(retro(a).source is a);\nassert(retro(retro(a)) is a);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL307_3560)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!(Unqual!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 421,
						"type": "(Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 629,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "stride",
				"line": 421,
				"comment": "Iterates range $(D r) with stride $(D n). If the range is a\nrandom-access range, moves by indexing into the range; otherwise,\nmoves by successive calls to $(D popFront). Applying stride twice to\nthe same range results in a stride with a step that is the\nproduct of the two applications. It is an error for $(D n) to be 0.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL632_3565)\n---\nimport std.algorithm : equal;\n\nint[] a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];\nassert(equal(stride(a, 3), [ 1, 4, 7, 10 ][]));\nassert(stride(stride(a, 2), 3) == stride(a, 6));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL632_3565)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chain",
						"line": 804,
						"type": "(Ranges rs)",
						"parameters": [
							{
								"name": "rs",
								"type": "Ranges"
							}
						],
						"endline": 1117,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "chain",
				"line": 804,
				"comment": "Spans multiple ranges in sequence. The function $(D chain) takes any\nnumber of ranges and returns a $(D Chain!(R1, R2,...)) object. The\nranges may be different, but they must have the same element type. The\nresult is a range that offers the $(D front), $(D popFront), and $(D\nempty) primitives. If all input ranges offer random access and $(D\nlength), $(D Chain) offers them as well.\n\nIf only one range is offered to $(D Chain) or $(D chain), the $(D\nChain) type exits the picture by aliasing itself directly to that\nrange's type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1120_3570)\n---\nimport std.algorithm : equal;\n\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nint[] arr3 = [ 7 ];\nauto s = chain(arr1, arr2, arr3);\nassert(s.length == 7);\nassert(s[5] == 6);\nassert(equal(s, [1, 2, 3, 4, 5, 6, 7][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1120_3570)\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length > 0 && allSatisfy!(isInputRange, staticMap!(Unqual, Ranges)) && !is(CommonType!(staticMap!(ElementType, staticMap!(Unqual, Ranges))) == void)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "choose",
						"line": 1255,
						"type": "(bool condition, R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "condition",
								"deco": "b"
							},
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 1417,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "choose",
				"line": 1255,
				"comment": "Choose one of two ranges at runtime depending on a Boolean condition.\n\nThe ranges may be different, but they must have compatible element types (i.e.\n$(D CommonType) must exist for the two element types). The result is a range\nthat offers the weakest capabilities of the two (e.g. $(D ForwardRange) if $(D\nR1) is a random-access range and $(D R2) is a forward range).\n\nParams:\n    condition = which range to choose: $(D r1) if $(D true), $(D r2) otherwise\n    r1 = the \"true\" range\n    r2 = the \"false\" range\n\nReturns:\n    A range type dependent on $(D R1) and $(D R2).\n\nBugs:\n    $(BUGZILLA 14660)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1420_3575)\n---\nimport std.algorithm.iteration : filter, map;\nimport std.algorithm.comparison : equal;\n\nauto data1 = [ 1, 2, 3, 4 ].filter!(a => a != 3);\nauto data2 = [ 5, 6, 7, 8 ].map!(a => a + 1);\n\n// choose() is primarily useful when you need to select one of two ranges\n// with different types at runtime.\nstatic assert(!is(typeof(data1) == typeof(data2)));\n\nauto chooseRange(bool pickFirst)\n{\n    // The returned range is a common wrapper type that can be used for\n    // returning or storing either range without running into a type error.\n    return choose(pickFirst, data1, data2);\n\n    // Simply returning the chosen range without using choose() does not\n    // work, because map() and filter() return different types.\n    //return pickFirst ? data1 : data2; // does not compile\n}\n\nauto result = chooseRange(true);\nassert(result.equal([ 1, 2, 4 ]));\n\nresult = chooseRange(false);\nassert(result.equal([ 6, 7, 8, 9 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1420_3575)\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!R1) && isInputRange!(Unqual!R2) && !is(CommonType!(ElementType!(Unqual!R1), ElementType!(Unqual!R2)) == void)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chooseAmong",
						"line": 1464,
						"type": "(size_t index, Ranges rs)",
						"parameters": [
							{
								"name": "index",
								"type": "size_t"
							},
							{
								"name": "rs",
								"type": "Ranges"
							}
						],
						"endline": 1470,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "chooseAmong",
				"line": 1464,
				"comment": "Choose one of multiple ranges at runtime.\n\nThe ranges may be different, but they must have compatible element types. The\nresult is a range that offers the weakest capabilities of all $(D Ranges).\n\nParams:\n    index = which range to choose, must be less than the number of ranges\n    rs = two or more ranges\n\nReturns:\n    The indexed range. If rs consists of only one range, the return type is an\n    alias of that range's type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1480_3576)\n---\nimport std.algorithm : equal;\n\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nint[] arr3 = [ 7 ];\n\n{\n    auto s = chooseAmong(0, arr1, arr2, arr3);\n    auto t = s.save;\n    assert(s.length == 4);\n    assert(s[2] == 3);\n    s.popFront();\n    assert(equal(t, [1, 2, 3, 4][]));\n}\n{\n    auto s = chooseAmong(1, arr1, arr2, arr3);\n    assert(s.length == 2);\n    s.front = 8;\n    assert(equal(s, [8, 6][]));\n}\n{\n    auto s = chooseAmong(1, arr1, arr2, arr3);\n    assert(s.length == 2);\n    s[1] = 9;\n    assert(equal(s, [8, 9][]));\n}\n{\n    auto s = chooseAmong(1, arr2, arr1, arr3)[1..3];\n    assert(s.length == 2);\n    assert(equal(s, [2, 3][]));\n}\n{\n    auto s = chooseAmong(0, arr1, arr2, arr3);\n    assert(s.length == 4);\n    assert(s.back == 4);\n    s.popBack();\n    s.back = 5;\n    assert(equal(s, [1, 2, 5][]));\n    s.back = 3;\n    assert(equal(s, [1, 2, 3][]));\n}\n{\n    uint[] foo = [1,2,3,4,5];\n    uint[] bar = [6,7,8,9,10];\n    auto c = chooseAmong(1,foo, bar);\n    assert(c[3] == 9);\n    c[3] = 42;\n    assert(c[3] == 42);\n    assert(c.moveFront() == 6);\n    assert(c.moveBack() == 10);\n    assert(c.moveAt(4) == 10);\n}\n{\n    import std.range : cycle;\n    auto s = chooseAmong(1, cycle(arr2), cycle(arr3));\n    assert(isInfinite!(typeof(s)));\n    assert(!s.empty);\n    assert(s[100] == 7);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1480_3576)\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length > 2 && is(typeof(choose(true, rs[0], rs[1]))) && is(typeof(chooseAmong(0, rs[1..__dollar])))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chooseAmong",
						"line": 1473,
						"type": "(size_t index, Ranges rs)",
						"parameters": [
							{
								"name": "index",
								"type": "size_t"
							},
							{
								"name": "rs",
								"type": "Ranges"
							}
						],
						"endline": 1477,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "chooseAmong",
				"line": 1473,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length == 2 && is(typeof(choose(true, rs[0], rs[1])))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "roundRobin",
						"line": 1561,
						"type": "(Rs rs)",
						"parameters": [
							{
								"name": "rs",
								"type": "Rs"
							}
						],
						"endline": 1655,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "roundRobin",
				"line": 1561,
				"comment": "$(D roundRobin(r1, r2, r3)) yields $(D r1.front), then $(D r2.front),\nthen $(D r3.front), after which it pops off one element from each and\ncontinues again from $(D r1). For example, if two ranges are involved,\nit alternately yields elements off the two ranges. $(D roundRobin)\nstops after it has consumed all ranges (skipping over the ones that\nfinish early).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1658_3578)\n---\nimport std.algorithm : equal;\n\nint[] a = [ 1, 2, 3 ];\nint[] b = [ 10, 20, 30, 40 ];\nauto r = roundRobin(a, b);\nassert(equal(r, [ 1, 10, 2, 20, 3, 30, 40 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1658_3578)\n",
				"parameters": [
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"constraint": "Rs.length > 1 && allSatisfy!(isInputRange, staticMap!(Unqual, Rs))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "radial",
						"line": 1674,
						"type": "(Range r, I startingIndex)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "startingIndex",
								"type": "I"
							}
						],
						"endline": 1679,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "radial",
				"line": 1674,
				"comment": "Iterates a random-access range starting from a given point and\nprogressively extending left and right from that point. If no initial\npoint is given, iteration starts from the middle of the\nrange. Iteration spans the entire range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1689_3579)\n---\nimport std.algorithm : equal;\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(radial(a), [ 3, 4, 2, 5, 1 ]));\na = [ 1, 2, 3, 4 ];\nassert(equal(radial(a), [ 2, 3, 1, 4 ]));\n\n// If the left end is reached first, the remaining elements on the right\n// are concatenated in order:\na = [ 0, 1, 2, 3, 4, 5 ];\nassert(equal(radial(a, 1), [ 1, 2, 0, 3, 4, 5 ]));\n\n// If the right end is reached first, the remaining elements on the left\n// are concatenated in reverse order:\nassert(equal(radial(a, 4), [ 4, 5, 3, 2, 1, 0 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1689_3579)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!(Unqual!Range) && hasLength!(Unqual!Range) && isIntegral!I",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "radial",
						"line": 1682,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 1686,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "radial",
				"line": 1682,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!(Unqual!R) && hasLength!(Unqual!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Take",
						"line": 1761,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Take",
				"line": 1761,
				"comment": "Lazily takes only up to $(D n) elements of a range. This is\nparticularly useful when using with infinite ranges. If the range\noffers random access and $(D length), $(D Take) offers them as well.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1951_3582)\n---\nimport std.algorithm : equal;\n\nint[] arr1 = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nauto s = take(arr1, 5);\nassert(s.length == 5);\nassert(s[4] == 5);\nassert(equal(s, [ 1, 2, 3, 4, 5 ][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1951_3582)\nExample:\nIf the range runs out before `n` elements, `take` simply returns the entire\n range (unlike $(LREF takeExactly), which will cause an assertion failure if\n the range ends prematurely):$(DDOX_UNITTEST_HEADER __unittestL1967_3583)\n---\nimport std.algorithm : equal;\n\nint[] arr2 = [ 1, 2, 3 ];\nauto t = take(arr2, 5);\nassert(t.length == 3);\nassert(equal(t, [ 1, 2, 3 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1967_3583)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!Range) && !(!isInfinite!(Unqual!Range) && hasSlicing!(Unqual!Range) || is(Range T == Take!T))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "take",
						"line": 1940,
						"type": "Take!R(R input, size_t n)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1948,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "take",
				"line": 1940,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!R) && !isInfinite!(Unqual!R) && hasSlicing!(Unqual!R) && !is(R T == Take!T)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "takeExactly",
						"line": 2108,
						"type": "(R range, size_t n)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2184,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "takeExactly",
				"line": 2108,
				"comment": "Similar to $(LREF take), but assumes that $(D range) has at least $(D\nn) elements. Consequently, the result of $(D takeExactly(range, n))\nalways defines the $(D length) property (and initializes it to $(D n))\neven when $(D range) itself does not define $(D length).\n\nThe result of $(D takeExactly) is identical to that of $(LREF take) in\ncases where the original range defines $(D length) or is infinite.\n\nUnlike $(LREF take), however, it is illegal to pass a range with less than\n$(D n) elements to $(D takeExactly); this will cause an assertion failure.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2187_3589)\n---\nimport std.algorithm : equal;\n\nauto a = [ 1, 2, 3, 4, 5 ];\n\nauto b = takeExactly(a, 3);\nassert(equal(b, [1, 2, 3]));\nstatic assert(is(typeof(b.length) == size_t));\nassert(b.length == 3);\nassert(b.front == 1);\nassert(b.back == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2187_3589)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "takeOne",
						"line": 2306,
						"type": "(R source)",
						"parameters": [
							{
								"name": "source",
								"type": "R"
							}
						],
						"endline": 2341,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "takeOne",
				"line": 2306,
				"comment": "Returns a range with at most one element; for example, $(D\ntakeOne([42, 43, 44])) returns a range consisting of the integer $(D\n42). Calling $(D popFront()) off that range renders it empty.\n\nIn effect $(D takeOne(r)) is somewhat equivalent to $(D take(r, 1)) but in\ncertain interfaces it is important to know statically that the range may only\nhave at most one element.\n\nThe type returned by $(D takeOne) is a random-access range with length\nregardless of $(D R)'s capabilities (another feature that distinguishes\n$(D takeOne) from $(D take)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2344_3593)\n---\nauto s = takeOne([42, 43, 44]);\nstatic assert(isRandomAccessRange!(typeof(s)));\nassert(s.length == 1);\nassert(!s.empty);\nassert(s.front == 42);\ns.front = 43;\nassert(s.front == 43);\nassert(s.back == 43);\nassert(s[0] == 43);\ns.popFront();\nassert(s.length == 0);\nassert(s.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2344_3593)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "takeNone",
						"line": 2380,
						"type": "()",
						"endline": 2384,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "takeNone",
				"line": 2380,
				"comment": "    Returns an empty range which is statically known to be empty and is\n    guaranteed to have $(D length) and be random access regardless of $(D R)'s\n    capabilities.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2387_3595)\n---\nauto range = takeNone!(int[])();\nassert(range.length == 0);\nassert(range.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2387_3595)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "takeNone",
						"line": 2407,
						"type": "(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2429,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "takeNone",
				"line": 2407,
				"comment": "    Creates an empty range from the given range in $(BIGOH 1). If it can, it\n    will return the same range type. If not, it will return\n    $(D takeExactly(range, 0)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2432_3597)\n---\nimport std.algorithm : filter;\nassert(takeNone([42, 27, 19]).empty);\nassert(takeNone(\"dlang.org\").empty);\nassert(takeNone(filter!\"true\"([42, 27, 19])).empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2432_3597)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "drop",
						"line": 2573,
						"type": "R(R range, size_t n)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2578,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "drop",
				"line": 2573,
				"comment": "    Convenience function which calls\n    $(D range.$(LREF popFrontN)(n)) and returns $(D range). $(D drop)\n    makes it easier to pop elements from a range\n    and then pass it to another function within a single expression,\n    whereas $(D popFrontN) would require multiple statements.\n\n    $(D dropBack) provides the same functionality but instead calls\n    $(D range.popBackN(n)).\n\n    Note: $(D drop) and $(D dropBack) will only pop $(I up to)\n    $(D n) elements but will stop if the range is empty first.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2588_3599)\n---\nimport std.algorithm : equal;\n\nassert([0, 2, 1, 5, 0, 3].drop(3) == [5, 0, 3]);\nassert(\"hello world\".drop(6) == \"world\");\nassert(\"hello world\".drop(50).empty);\nassert(\"hello world\".take(6).drop(3).equal(\"lo \"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2588_3599)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropBack",
						"line": 2580,
						"type": "R(R range, size_t n)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2585,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "dropBack",
				"line": 2580,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropExactly",
						"line": 2651,
						"type": "R(R range, size_t n)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2656,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "dropExactly",
				"line": 2651,
				"comment": "    Similar to $(LREF drop) and $(D dropBack) but they call\n    $(D range.$(LREF popFrontExactly)(n)) and $(D range.popBackExactly(n))\n    instead.\n\n    Note: Unlike $(D drop), $(D dropExactly) will assume that the\n    range holds at least $(D n) elements. This makes $(D dropExactly)\n    faster than $(D drop), but it also means that if $(D range) does\n    not contain at least $(D n) elements, it will attempt to call $(D popFront)\n    on an empty range, which is undefined behavior. So, only use\n    $(D popFrontExactly) when it is guaranteed that $(D range) holds at least\n    $(D n) elements.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2666_3604)\n---\nimport std.algorithm : equal, filterBidirectional;\n\nauto a = [1, 2, 3];\nassert(a.dropExactly(2) == [3]);\nassert(a.dropBackExactly(2) == [1]);\n\nstring s = \"日本語\";\nassert(s.dropExactly(2) == \"語\");\nassert(s.dropBackExactly(2) == \"日\");\n\nauto bd = filterBidirectional!\"true\"([1, 2, 3]);\nassert(bd.dropExactly(2).equal([3]));\nassert(bd.dropBackExactly(2).equal([1]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2666_3604)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropBackExactly",
						"line": 2658,
						"type": "R(R range, size_t n)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2663,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "dropBackExactly",
				"line": 2658,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropOne",
						"line": 2693,
						"type": "R(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2698,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "dropOne",
				"line": 2693,
				"comment": "    Convenience function which calls\n    $(D range.popFront()) and returns $(D range). $(D dropOne)\n    makes it easier to pop an element from a range\n    and then pass it to another function within a single expression,\n    whereas $(D popFront) would require multiple statements.\n\n    $(D dropBackOne) provides the same functionality but instead calls\n    $(D range.popBack()).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2708_3605)\n---\nimport std.algorithm : equal, filterBidirectional;\n\nimport std.container.dlist;\n\nauto dl = DList!int(9, 1, 2, 3, 9);\nassert(dl[].dropOne().dropBackOne().equal([1, 2, 3]));\n\nauto a = [1, 2, 3];\nassert(a.dropOne() == [2, 3]);\nassert(a.dropBackOne() == [1, 2]);\n\nstring s = \"日本語\";\nassert(s.dropOne() == \"本語\");\nassert(s.dropBackOne() == \"日本\");\n\nauto bd = filterBidirectional!\"true\"([1, 2, 3]);\nassert(bd.dropOne().equal([2, 3]));\nassert(bd.dropBackOne().equal([1, 2]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2708_3605)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropBackOne",
						"line": 2700,
						"type": "R(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2705,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "dropBackOne",
				"line": 2700,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Repeat",
						"line": 2735,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Repeat",
				"line": 2735,
				"comment": "Repeats one value forever.\n\nModels an infinite bidirectional and random access range, with slicing.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2776_3606)\n---\nimport std.algorithm : equal;\n\nassert(equal(5.repeat().take(4), [ 5, 5, 5, 5 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2776_3606)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 55,
						"name": "repeat",
						"line": 2773,
						"type": "Repeat!T(T value)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							}
						],
						"endline": 2773,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "repeat",
				"line": 2773,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "repeat",
						"line": 2806,
						"type": "Take!(Repeat!T)(T value, size_t n)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2809,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "repeat",
				"line": 2806,
				"comment": "   Repeats $(D value) exactly $(D n) times. Equivalent to $(D\n   take(repeat(value), n)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2812_3608)\n---\nimport std.algorithm : equal;\n\nassert(equal(5.repeat(4), 5.repeat().take(4)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2812_3608)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "generate",
						"line": 2859,
						"type": "(Fun fun)",
						"parameters": [
							{
								"name": "fun",
								"type": "Fun"
							}
						],
						"endline": 2863,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "generate",
				"line": 2859,
				"comment": "Given callable ($(XREF traits, isCallable)) $(D fun), create as a range\nwhose front is defined by successive calls to $(D fun()).\nThis is especially useful to call function with global side effects (random\nfunctions), or to create ranges expressed as a single delegate, rather than\nan entire $(D front)/$(D popFront)/$(D empty) structure.\n$(D fun) maybe be passed either a template alias parameter (existing\nfunction, delegate, struct type defining static $(D opCall)... ) or\na run-time value argument (delegate, function object... ).\nThe result range models an InputRange\n($(XREF_PACK range,primitives,isInputRange)).\nThe resulting range will call $(D fun()) on every call to $(D front),\nand only when $(D front) is called, regardless of how the range is\niterated.\nIt is advised to compose generate with either\n$(XREF_PACK algorithm,iteration,cache) or $(XREF array,array), or to use it in a\nforeach loop.\nA by-value foreach loop means that the loop value is not $(D ref).\n\nParams:\n    fun = is the $(D isCallable) that gets called on every call to front.\n\nReturns: an $(D inputRange) that returns a new value generated by $(D Fun) on\n    any call to $(D front).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2873_3610)\n---\nimport std.algorithm : equal, map;\n\nint i = 1;\nauto powersOfTwo = generate!(() => i *= 2)().take(10);\nassert(equal(powersOfTwo, iota(1, 11).map!\"2^^a\"()));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2873_3610)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2883_3611)\n---\nimport std.algorithm : equal;\n\n//Returns a run-time delegate\nauto infiniteIota(T)(T low, T high)\n{\n    T i = high;\n    return (){if (i == high) i = low; return i++;};\n}\n//adapted as a range.\nassert(equal(generate(infiniteIota(1, 4)).take(10), [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2883_3611)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2898_3612)\n---\nimport std.format, std.random;\n\nauto r = generate!(() => uniform(0, 6)).take(10);\nformat(\"%(%s %)\", r);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2898_3612)\n",
				"parameters": [
					{
						"name": "Fun",
						"kind": "type"
					}
				],
				"constraint": "isCallable!fun",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "generate",
						"line": 2866,
						"type": "()",
						"endline": 2870,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "generate",
				"line": 2866,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					}
				],
				"constraint": "isCallable!fun",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Cycle",
						"line": 2967,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Cycle",
				"line": 2967,
				"comment": "Repeats the given forward range ad infinitum. If the original range is\ninfinite (fact that would make $(D Cycle) the identity application),\n$(D Cycle) detects that and aliases itself to the range type\nitself. If the original range has random access, $(D Cycle) offers\nrandom access and also offers a constructor taking an initial position\n$(D index). $(D Cycle) works with static arrays in addition to ranges,\nmostly for performance reasons.\n\nNote: The input range must not be empty.\n\nTip: This is a great way to implement simple circular buffers.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3193_3615)\n---\nimport std.algorithm : equal;\nimport std.range : cycle, take;\n\n// Here we create an infinitive cyclic sequence from [1, 2]\n// (i.e. get here [1, 2, 1, 2, 1, 2 and so on]) then\n// take 5 elements of this sequence (so we have [1, 2, 1, 2, 1])\n// and compare them with the expected values for equality.\nassert(cycle([1, 2]).take(5).equal([ 1, 2, 1, 2, 1 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3193_3615)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R && !isInfinite!R",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cycle",
						"line": 3185,
						"type": "Cycle!R(R input)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							}
						],
						"endline": 3190,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "cycle",
				"line": 3185,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R && !isInfinite!R",
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cycle",
						"line": 3206,
						"type": "Cycle!R(R input, size_t index = 0)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "index",
								"type": "size_t",
								"default": "0"
							}
						],
						"endline": 3211,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "cycle",
				"line": 3206,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && !isInfinite!R",
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Zip",
						"line": 3405,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 3420,
								"comment": "   Builds an object. Usually this is invoked indirectly by using the\n   $(LREF zip) function.\n",
								"type": "(R rs, StoppingPolicy s = StoppingPolicy.shortest)",
								"parameters": [
									{
										"name": "rs",
										"type": "R"
									},
									{
										"name": "s",
										"type": "StoppingPolicy",
										"default": "StoppingPolicy.shortest"
									}
								],
								"endline": 3424,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 3498,
								"comment": "   Returns the current iterated element.\n",
								"type": "@property ElementType()",
								"endline": 3503,
								"char": 27,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 3588,
								"comment": "   Advances to the next element in all controlled ranges.\n",
								"type": "void()",
								"endline": 3615,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Zip",
				"line": 3405,
				"comment": "   Iterate several ranges in lockstep. The element type is a proxy tuple\n   that allows accessing the current element in the $(D n)th range by\n   using $(D e[n]).\n   $(D Zip) offers the lowest range facilities of all components, e.g. it\n   offers random access iff all ranges offer random access, and also\n   offers mutation and swapping if all ranges offer it. Due to this, $(D\n   Zip) is extremely powerful because it allows manipulating several\n   ranges in lockstep. For example, the following code sorts two arrays\n   in parallel:\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3754_3627)\n---\nimport std.algorithm : sort;\nint[] a = [ 1, 2, 3 ];\nstring[] b = [ \"a\", \"b\", \"c\" ];\nsort!((c, d) => c[0] > d[0])(zip(a, b));\nassert(a == [ 3, 2, 1 ]);\nassert(b == [ \"c\", \"b\", \"a\" ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3754_3627)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3765_3628)\n---\nint[] a = [ 1, 2, 3 ];\nstring[] b = [ \"a\", \"b\", \"c\" ];\n\nsize_t idx = 0;\nforeach (e; zip(a, b))\n{\n    assert(e[0] == a[idx]);\n    assert(e[1] == b[idx]);\n    ++idx;\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3765_3628)\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length && allSatisfy!(isInputRange, Ranges)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "zip",
						"line": 3747,
						"type": "(Ranges ranges)",
						"parameters": [
							{
								"name": "ranges",
								"type": "Ranges"
							}
						],
						"endline": 3751,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "zip",
				"line": 3747,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length && allSatisfy!(isInputRange, Ranges)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "zip",
						"line": 3780,
						"type": "(StoppingPolicy sp, Ranges ranges)",
						"parameters": [
							{
								"name": "sp",
								"type": "StoppingPolicy"
							},
							{
								"name": "ranges",
								"type": "Ranges"
							}
						],
						"endline": 3784,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "zip",
				"line": 3780,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length && allSatisfy!(isInputRange, Ranges)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "shortest",
						"line": 3793,
						"value": "0",
						"comment": "Stop when the shortest range is exhausted\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "longest",
						"line": 3795,
						"value": "1",
						"comment": "Stop when the longest range is exhausted\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "requireSameLength",
						"line": 3797,
						"value": "2",
						"comment": "Require that all ranges are equal\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "StoppingPolicy",
				"line": 3790,
				"comment": "   Dictates how iteration in a $(D Zip) should stop. By default stop at\n   the end of the shortest of all ranges.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "Lockstep",
						"line": 4048,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Lockstep",
				"line": 4048,
				"comment": "   Iterate multiple ranges in lockstep using a $(D foreach) loop.  If only a single\n   range is passed in, the $(D Lockstep) aliases itself away.  If the\n   ranges are of different lengths and $(D s) == $(D StoppingPolicy.shortest)\n   stop after the shortest range is empty.  If the ranges are of different\n   lengths and $(D s) == $(D StoppingPolicy.requireSameLength), throw an\n   exception.  $(D s) may not be $(D StoppingPolicy.longest), and passing this\n   will throw an exception.\n\n   By default $(D StoppingPolicy) is set to $(D StoppingPolicy.shortest).\n\n   Lockstep also supports iterating with an index variable:\n   -------\n   foreach (index, a, b; lockstep(arr1, arr2))\n   {\n       writefln(\"Index %s:  a = %s, b = %s\", index, a, b);\n   }\n   -------\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4094_3634)\n---\nauto arr1 = [1,2,3,4,5];\nauto arr2 = [6,7,8,9,10];\n\nforeach (ref a, ref b; lockstep(arr1, arr2))\n{\n    a += b;\n}\n\nassert(arr1 == [7,9,11,13,15]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4094_3634)\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length > 1 && allSatisfy!(isInputRange, Ranges)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lockstep",
						"line": 4078,
						"type": "Lockstep!Ranges(Ranges ranges)",
						"parameters": [
							{
								"name": "ranges",
								"type": "Ranges"
							}
						],
						"endline": 4082,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "lockstep",
				"line": 4078,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isInputRange, Ranges)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lockstep",
						"line": 4084,
						"type": "Lockstep!Ranges(Ranges ranges, StoppingPolicy s)",
						"parameters": [
							{
								"name": "ranges",
								"type": "Ranges"
							},
							{
								"name": "s",
								"type": "StoppingPolicy"
							}
						],
						"endline": 4091,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "lockstep",
				"line": 4084,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isInputRange, Ranges)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Recurrence",
						"line": 4253,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Recurrence",
				"line": 4253,
				"comment": "Creates a mathematical sequence given the initial values and a\nrecurrence function that computes the next value from the existing\nvalues. The sequence comes in the form of an infinite forward\nrange. The type $(D Recurrence) itself is seldom used directly; most\noften, recurrences are obtained by calling the function $(D\nrecurrence).\n\nWhen calling $(D recurrence), the function that computes the next\nvalue is specified as a template argument, and the initial values in\nthe recurrence are passed as regular arguments. For example, in a\nFibonacci sequence, there are two initial values (and therefore a\nstate size of 2) because computing the next Fibonacci value needs the\npast two values.\n\nThe signature of this function should be:\n----\nauto fun(R)(R state, size_t n)\n----\nwhere $(D n) will be the index of the current value, and $(D state) will be an\nopaque state vector that can be indexed with array-indexing notation\n$(D state[i]), where valid values of $(D i) range from $(D (n - 1)) to\n$(D (n - State.length)).\n\nIf the function is passed in string form, the state has name $(D \"a\")\nand the zero-based index in the recurrence has name $(D \"n\"). The\ngiven string must return the desired value for $(D a[n]) given $(D a[n\n- 1]), $(D a[n - 2]), $(D a[n - 3]),..., $(D a[n - stateSize]). The\nstate size is dictated by the number of arguments passed to the call\nto $(D recurrence). The $(D Recurrence) struct itself takes care of\nmanaging the recurrence's state and shifting it appropriately.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4290_3639)\n---\nimport std.algorithm : equal;\n\n// The Fibonacci numbers, using function in string form:\n// a[0] = 1, a[1] = 1, and compute a[n+1] = a[n-1] + a[n]\nauto fib = recurrence!(\"a[n-1] + a[n-2]\")(1, 1);\nassert(fib.take(10).equal([1, 1, 2, 3, 5, 8, 13, 21, 34, 55]));\n\n// The factorials, using function in lambda form:\nauto fac = recurrence!((a,n) => a[n-1] * n)(1);\nassert(take(fac, 10).equal([\n    1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880\n]));\n\n// The triangular numbers, using function in explicit form:\nstatic size_t genTriangular(R)(R state, size_t n)\n{\n    return state[n-1] + n;\n}\nauto tri = recurrence!genTriangular(0);\nassert(take(tri, 10).equal([0, 1, 3, 6, 10, 15, 21, 28, 36, 45]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4290_3639)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "StateType",
						"kind": "type"
					},
					{
						"name": "stateSize",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "recurrence",
						"line": 4316,
						"type": "Recurrence!(fun, CommonType!State, State.length)(State initial)",
						"parameters": [
							{
								"name": "initial",
								"type": "State"
							}
						],
						"endline": 4324,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "recurrence",
				"line": 4316,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "State",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Sequence",
						"line": 4359,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Sequence",
				"line": 4359,
				"comment": "   $(D Sequence) is similar to $(D Recurrence) except that iteration is\n   presented in the so-called $(WEB en.wikipedia.org/wiki/Closed_form,\n   closed form). This means that the $(D n)th element in the series is\n   computable directly from the initial values and $(D n) itself. This\n   implies that the interface offered by $(D Sequence) is a random-access\n   range, as opposed to the regular $(D Recurrence), which only offers\n   forward iteration.\n\n   The state of the sequence is stored as a $(D Tuple) so it can be\n   heterogeneous.\nExample:\nOdd numbers, using function in string form:$(DDOX_UNITTEST_HEADER __unittestL4424_3641)\n---\nauto odds = sequence!(\"a[0] + n * a[1]\")(1, 2);\nassert(odds.front == 1);\nodds.popFront();\nassert(odds.front == 3);\nodds.popFront();\nassert(odds.front == 5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4424_3641)\nExample:\nTriangular numbers, using function in lambda form:$(DDOX_UNITTEST_HEADER __unittestL4435_3644)\n---\nauto tri = sequence!((a,n) => n*(n+1)/2)();\n\n// Note random access\nassert(tri[0] == 0);\nassert(tri[3] == 6);\nassert(tri[1] == 1);\nassert(tri[4] == 10);\nassert(tri[2] == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4435_3644)\nExample:\nFibonacci numbers, using function in explicit form:$(DDOX_UNITTEST_HEADER __unittestL4448_3645)\n---\nimport std.math : pow, round, sqrt;\nstatic ulong computeFib(S)(S state, size_t n)\n{\n    // Binet's formula\n    return cast(ulong)(round((pow(state[0], n+1) - pow(state[1], n+1)) /\n                             state[2]));\n}\nauto fib = sequence!computeFib(\n    (1.0 + sqrt(5.0)) / 2.0,    // Golden Ratio\n    (1.0 - sqrt(5.0)) / 2.0,    // Conjugate of Golden Ratio\n    sqrt(5.0));\n\n// Note random access with [] operator\nassert(fib[1] == 1);\nassert(fib[4] == 5);\nassert(fib[3] == 3);\nassert(fib[2] == 2);\nassert(fib[9] == 55);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4448_3645)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "State",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sequence",
						"line": 4416,
						"type": "(State args)",
						"parameters": [
							{
								"name": "args",
								"type": "State"
							}
						],
						"endline": 4421,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sequence",
				"line": 4416,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "State",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4570,
						"type": "(B begin, E end, S step)",
						"parameters": [
							{
								"name": "begin",
								"type": "B"
							},
							{
								"name": "end",
								"type": "E"
							},
							{
								"name": "step",
								"type": "S"
							}
						],
						"endline": 4659,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4570,
				"comment": "   Construct a range of values that span the given starting and stopping\n   values.\n\n   Params:\n   begin = The starting value.\n   end = The value that serves as the stopping criterion. This value is not\n        included in the range.\n   step = The value to add to the current value at each iteration.\n\n   Returns:\n   A range that goes through the numbers $(D begin), $(D begin + step),\n   $(D begin + 2 * step), $(D ...), up to and excluding $(D end).\n\n   The two-argument overloads have $(D step = 1). If $(D begin < end && step <\n   0) or $(D begin > end && step > 0) or $(D begin == end), then an empty range\n   is returned. If $(D step == 0) then $(D begin == end) is an error.\n\n   For built-in types, the range returned is a random access range. For\n   user-defined types that support $(D ++), the range is an input\n   range.\n\n    Example:\n    ---\n    void main()\n    {\n        import std.stdio;\n\n        // The following groups all produce the same output of:\n        // 0 1 2 3 4\n\n        foreach (i; 0..5)\n            writef(\"%s \", i);\n        writeln();\n\n        import std.range : iota;\n        foreach (i; iota(0, 5))\n            writef(\"%s \", i);\n        writeln();\n\n        writefln(\"%(%s %|%)\", iota(0, 5));\n\n        import std.algorithm : map, copy;\n        import std.format;\n        iota(0, 5).map!(i => format(\"%s \", i)).copy(stdout.lockingTextWriter());\n        writeln();\n    }\n    ---\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4826_3651)\n---\nimport std.algorithm : equal;\nimport std.math : approxEqual;\n\nauto r = iota(0, 10, 1);\nassert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][]));\nr = iota(0, 11, 3);\nassert(equal(r, [0, 3, 6, 9][]));\nassert(r[2] == 6);\nauto rf = iota(0.0, 0.5, 0.1);\nassert(approxEqual(rf, [0.0, 0.1, 0.2, 0.3, 0.4]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4826_3651)\nExample:\nUser-defined types such as $(XREF bigint, BigInt) are also supported, as long\nas they can be incremented with $(D ++) and compared with $(D <) or $(D ==).$(DDOX_UNITTEST_HEADER __unittestL5082_3659)\n---\nimport std.algorithm.comparison : equal;\nimport std.bigint;\n\nauto s = BigInt(1_000_000_000_000);\nauto e = BigInt(1_000_000_000_003);\nauto r = iota(s, e);\nassert(r.equal([\n    BigInt(1_000_000_000_000),\n    BigInt(1_000_000_000_001),\n    BigInt(1_000_000_000_002)\n]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5082_3659)\n",
				"parameters": [
					{
						"name": "B",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "(isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B, E))) && isIntegral!S",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4662,
						"type": "(B begin, E end)",
						"parameters": [
							{
								"name": "begin",
								"type": "B"
							},
							{
								"name": "end",
								"type": "E"
							}
						],
						"endline": 4666,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4662,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "B",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!(CommonType!(B, E))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4669,
						"type": "(B begin, E end)",
						"parameters": [
							{
								"name": "begin",
								"type": "B"
							},
							{
								"name": "end",
								"type": "E"
							}
						],
						"endline": 4729,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4669,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "B",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B, E))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4732,
						"type": "(E end)",
						"parameters": [
							{
								"name": "end",
								"type": "E"
							}
						],
						"endline": 4736,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4732,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4740,
						"type": "(B begin, E end, S step)",
						"parameters": [
							{
								"name": "begin",
								"type": "B"
							},
							{
								"name": "end",
								"type": "E"
							},
							{
								"name": "step",
								"type": "S"
							}
						],
						"endline": 4823,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4740,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "B",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!(CommonType!(B, E, S))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 5046,
						"type": "(B begin, E end)",
						"parameters": [
							{
								"name": "begin",
								"type": "B"
							},
							{
								"name": "end",
								"type": "E"
							}
						],
						"endline": 5075,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 5046,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "B",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "!isIntegral!(CommonType!(B, E)) && !isFloatingPoint!(CommonType!(B, E)) && !isPointer!(CommonType!(B, E)) && is(typeof((ref B b)\n{\n++b;\n}\n)) && (is(typeof(B.init < E.init)) || is(typeof(B.init == E.init)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "assumeJagged",
						"line": 5137,
						"value": "0",
						"comment": "   When transversed, the elements of a range of ranges are assumed to\n   have different lengths (e.g. a jagged array).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "enforceNotJagged",
						"line": 5144,
						"value": "1",
						"comment": "       The transversal enforces that the elements of a range of ranges have\n       all the same length (e.g. an array of arrays, all having the same\n       length). Checking is done once upon construction of the transversal\n       range.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "assumeNotJagged",
						"line": 5150,
						"value": "2",
						"comment": "       The transversal assumes, without verifying, that the elements of a\n       range of ranges have all the same length. This option is useful if\n       checking was already done from the outside of the range.\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "TransverseOptions",
				"line": 5131,
				"comment": "   Options for the $(LREF FrontTransversal) and $(LREF Transversal) ranges\n   (below).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "FrontTransversal",
						"line": 5157,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 5185,
								"comment": "   Construction from an input.\n",
								"type": "(RangeOfRanges input)",
								"parameters": [
									{
										"name": "input",
										"type": "RangeOfRanges"
									}
								],
								"endline": 5202,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 5220,
								"comment": "Ditto\n",
								"type": "@property ref ()",
								"endline": 5224,
								"char": 24,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 5244,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 5249,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "FrontTransversal",
				"line": 5157,
				"comment": "   Given a range of ranges, iterate transversally through the first\n   elements of each of the enclosed ranges.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5362_3661)\n---\nimport std.algorithm : equal;\nint[][] x = new int[][2];\nx[0] = [1, 2];\nx[1] = [3, 4];\nauto ror = frontTransversal(x);\nassert(equal(ror, [ 1, 3 ][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5362_3661)\n",
				"parameters": [
					{
						"name": "Ror",
						"kind": "type"
					},
					{
						"name": "opt",
						"defaultValue": "TransverseOptions.assumeJagged",
						"deco": "E3std5range17TransverseOptions",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "frontTransversal",
						"line": 5353,
						"type": "FrontTransversal!(RangeOfRanges, opt)(RangeOfRanges rr)",
						"parameters": [
							{
								"name": "rr",
								"type": "RangeOfRanges"
							}
						],
						"endline": 5359,
						"char": 39,
						"kind": "function"
					}
				],
				"name": "frontTransversal",
				"line": 5353,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "opt",
						"defaultValue": "TransverseOptions.assumeJagged",
						"deco": "E3std5range17TransverseOptions",
						"kind": "value"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					}
				],
				"char": 39,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Transversal",
						"line": 5440,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 5468,
								"comment": "   Construction from an input and an index.\n",
								"type": "(RangeOfRanges input, size_t n)",
								"parameters": [
									{
										"name": "input",
										"type": "RangeOfRanges"
									},
									{
										"name": "n",
										"type": "size_t"
									}
								],
								"endline": 5484,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 5502,
								"comment": "Ditto\n",
								"type": "@property ref ()",
								"endline": 5506,
								"char": 24,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 5528,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 5533,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Transversal",
				"line": 5440,
				"comment": "   Given a range of ranges, iterate transversally through the the $(D\n   n)th element of each of the enclosed ranges. All elements of the\n   enclosing range must offer random access.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5658_3663)\n---\nimport std.algorithm : equal;\nint[][] x = new int[][2];\nx[0] = [1, 2];\nx[1] = [3, 4];\nauto ror = transversal(x, 1);\nassert(equal(ror, [ 2, 4 ][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5658_3663)\n",
				"parameters": [
					{
						"name": "Ror",
						"kind": "type"
					},
					{
						"name": "opt",
						"defaultValue": "TransverseOptions.assumeJagged",
						"deco": "E3std5range17TransverseOptions",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "transversal",
						"line": 5650,
						"type": "Transversal!(RangeOfRanges, opt)(RangeOfRanges rr, size_t n)",
						"parameters": [
							{
								"name": "rr",
								"type": "RangeOfRanges"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 5655,
						"char": 34,
						"kind": "function"
					}
				],
				"name": "transversal",
				"line": 5650,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "opt",
						"defaultValue": "TransverseOptions.assumeJagged",
						"deco": "E3std5range17TransverseOptions",
						"kind": "value"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					}
				],
				"char": 34,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "transposed",
						"line": 5813,
						"type": "Transposed!RangeOfRanges(RangeOfRanges rr)",
						"parameters": [
							{
								"name": "rr",
								"type": "RangeOfRanges"
							}
						],
						"endline": 5819,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "transposed",
				"line": 5813,
				"comment": "Given a range of ranges, returns a range of ranges where the $(I i)'th subrange\ncontains the $(I i)'th elements of the original subranges.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5822_3669)\n---\nimport std.algorithm : equal;\nint[][] ror = [\n    [1, 2, 3],\n    [4, 5, 6]\n];\nauto xp = transposed(ror);\nassert(equal!\"a.equal(b)\"(xp, [\n    [1, 4],\n    [2, 5],\n    [3, 6]\n]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5822_3669)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5838_3670)\n---\nint[][] x = new int[][2];\nx[0] = [1, 2];\nx[1] = [3, 4];\nauto tr = transposed(x);\nint[][] witness = [ [ 1, 3 ], [ 2, 4 ] ];\nuint i;\n\nforeach (e; tr)\n{\n    assert(array(e) == witness[i++]);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5838_3670)\n",
				"parameters": [
					{
						"name": "RangeOfRanges",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!RangeOfRanges && isInputRange!(ElementType!RangeOfRanges) && hasAssignableElements!RangeOfRanges",
				"char": 26,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Indexed",
						"line": 5877,
						"members": [
							{
								"endchar": 5,
								"name": "front",
								"line": 5888,
								"comment": "Range primitives\n",
								"type": "@property ref ()",
								"endline": 5892,
								"char": 24,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 5895,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 5899,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "source",
								"line": 6035,
								"comment": "    Returns the source range.\n",
								"type": "@property Source()",
								"endline": 6038,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "indices",
								"line": 6043,
								"comment": "    Returns the indices range.\n",
								"type": "@property Indices()",
								"endline": 6046,
								"char": 24,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Indexed",
				"line": 5877,
				"comment": "This struct takes two ranges, $(D source) and $(D indices), and creates a view\nof $(D source) as if its elements were reordered according to $(D indices).\n$(D indices) may include only a subset of the elements of $(D source) and\nmay also repeat elements.\n\n$(D Source) must be a random access range.  The returned range will be\nbidirectional or random-access if $(D Indices) is bidirectional or\nrandom-access, respectively.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6080_3672)\n---\nimport std.algorithm : equal;\nauto source = [1, 2, 3, 4, 5];\nauto indices = [4, 3, 1, 2, 0, 4];\nauto ind = indexed(source, indices);\nassert(equal(ind, [5, 4, 2, 3, 1, 5]));\nassert(equal(retro(ind), [5, 1, 3, 2, 4, 5]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6080_3672)\n",
				"parameters": [
					{
						"name": "Source",
						"kind": "type"
					},
					{
						"name": "Indices",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Source && isInputRange!Indices && is(typeof(Source.init[ElementType!Indices.init]))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexed",
						"line": 6074,
						"type": "Indexed!(Source, Indices)(Source source, Indices indices)",
						"parameters": [
							{
								"name": "source",
								"type": "Source"
							},
							{
								"name": "indices",
								"type": "Indices"
							}
						],
						"endline": 6077,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "indexed",
				"line": 6074,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Source",
						"kind": "type"
					},
					{
						"name": "Indices",
						"kind": "type"
					}
				],
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Chunks",
						"line": 6130,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 6134,
								"comment": "Standard constructor\n",
								"type": "(Source source, size_t chunkSize)",
								"parameters": [
									{
										"name": "source",
										"type": "Source"
									},
									{
										"name": "chunkSize",
										"type": "size_t"
									}
								],
								"endline": 6139,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 6142,
								"comment": "Forward range primitives. Always present.\n",
								"type": "@property ()",
								"endline": 6146,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 6149,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 6153,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 6166,
								"comment": "Ditto\n",
								"type": "@property typeof(this)()",
								"endline": 6169,
								"char": 28,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Chunks",
				"line": 6130,
				"comment": "This range iterates over fixed-sized chunks of size $(D chunkSize) of a\n$(D source) range. $(D Source) must be a forward range. $(D chunkSize) must be\ngreater than zero.\n\nIf $(D !isInfinite!Source) and $(D source.walkLength) is not evenly\ndivisible by $(D chunkSize), the back element of this range will contain\nfewer than $(D chunkSize) elements.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6336_3675)\n---\nimport std.algorithm : equal;\nauto source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto chunks = chunks(source, 4);\nassert(chunks[0] == [1, 2, 3, 4]);\nassert(chunks[1] == [5, 6, 7, 8]);\nassert(chunks[2] == [9, 10]);\nassert(chunks.back == chunks[2]);\nassert(chunks.front == chunks[0]);\nassert(chunks.length == 3);\nassert(equal(retro(array(chunks)), array(retro(chunks))));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6336_3675)\n",
				"parameters": [
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Source",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chunks",
						"line": 6329,
						"type": "Chunks!Source(Source source, size_t chunkSize)",
						"parameters": [
							{
								"name": "source",
								"type": "Source"
							},
							{
								"name": "chunkSize",
								"type": "size_t"
							}
						],
						"endline": 6333,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "chunks",
				"line": 6329,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Source",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "EvenChunks",
						"line": 6437,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 6441,
								"comment": "Standard constructor\n",
								"type": "(Source source, size_t chunkCount)",
								"parameters": [
									{
										"name": "source",
										"type": "Source"
									},
									{
										"name": "chunkCount",
										"type": "size_t"
									}
								],
								"endline": 6446,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 6449,
								"comment": "Forward range primitives. Always present.\n",
								"type": "@property ()",
								"endline": 6453,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 6456,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 6461,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 6464,
								"comment": "Ditto\n",
								"type": "@property bool()",
								"endline": 6467,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 6470,
								"comment": "Ditto\n",
								"type": "@property typeof(this)()",
								"endline": 6473,
								"char": 28,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 6476,
								"comment": "Length\n",
								"type": "@property size_t()",
								"endline": 6479,
								"char": 22,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "EvenChunks",
				"line": 6437,
				"comment": "This range splits a $(D source) range into $(D chunkCount) chunks of\napproximately equal length. $(D Source) must be a forward range with\nknown length.\n\nUnlike $(LREF chunks), $(D evenChunks) takes a chunk count (not size).\nThe returned range will contain zero or more $(D source.length /\nchunkCount + 1) elements followed by $(D source.length / chunkCount)\nelements. If $(D source.length < chunkCount), some chunks will be empty.\n\n$(D chunkCount) must not be zero, unless $(D source) is also empty.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6572_3679)\n---\nimport std.algorithm : equal;\nauto source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto chunks = evenChunks(source, 3);\nassert(chunks[0] == [1, 2, 3, 4]);\nassert(chunks[1] == [5, 6, 7]);\nassert(chunks[2] == [8, 9, 10]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6572_3679)\n",
				"parameters": [
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Source && hasLength!Source",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "evenChunks",
						"line": 6565,
						"type": "EvenChunks!Source(Source source, size_t chunkCount)",
						"parameters": [
							{
								"name": "source",
								"type": "Source"
							},
							{
								"name": "chunkCount",
								"type": "size_t"
							}
						],
						"endline": 6569,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "evenChunks",
				"line": 6565,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Source && hasLength!Source",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "only",
						"line": 6785,
						"type": "(auto ref Values values)",
						"parameters": [
							{
								"name": "values",
								"type": "Values",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 6789,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "only",
				"line": 6785,
				"comment": "Assemble $(D values) into a range that carries all its\nelements in-situ.\n\nUseful when a single value or multiple disconnected values\nmust be passed to an algorithm expecting a range, without\nhaving to perform dynamic memory allocation.\n\nAs copying the range means copying all elements, it can be\nsafely returned from functions. For the same reason, copying\nthe returned range may be expensive for a large number of arguments.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6792_3682)\n---\nimport std.algorithm;\nimport std.uni;\n\nassert(equal(only('♡'), \"♡\"));\nassert([1, 2, 3, 4].findSplitBefore(only(3))[0] == [1, 2]);\n\nassert(only(\"one\", \"two\", \"three\").joiner(\" \").equal(\"one two three\"));\n\nstring title = \"The D Programming Language\";\nassert(filter!isUpper(title).map!only().join(\".\") == \"T.D.P.L\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6792_3682)\n",
				"parameters": [
					{
						"name": "Values",
						"kind": "tuple"
					}
				],
				"constraint": "!is(CommonType!Values == void) || Values.length == 0",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enumerate",
						"line": 7008,
						"type": "(Range range, Enumerator start = 0)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "start",
								"type": "Enumerator",
								"default": "0"
							}
						],
						"endline": 7148,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "enumerate",
				"line": 7008,
				"comment": "Iterate over $(D range) with an attached index variable.\n\nEach element is a $(XREF typecons, Tuple) containing the index\nand the element, in that order, where the index member is named $(D index)\nand the element member is named $(D value).\n\nThe index starts at $(D start) and is incremented by one on every iteration.\n\nBidirectionality is propagated only if $(D range) has length.\n\nOverflow:\nIf $(D range) has length, then it is an error to pass a value for $(D start)\nso that $(D start + range.length) is bigger than $(D Enumerator.max), thus it is\nensured that overflow cannot happen.\n\nIf $(D range) does not have length, and $(D popFront) is called when\n$(D front.index == Enumerator.max), the index will overflow and\ncontinue from $(D Enumerator.min).\n\nExample:\nUseful for using $(D foreach) with an index loop variable:\n----\n    import std.stdio : stdin, stdout;\n    import std.range : enumerate;\n\n    foreach (lineNum, line; stdin.byLine().enumerate(1))\n        stdout.writefln(\"line #%s: %s\", lineNum, line);\n----\nExample:\nCan start enumeration from a negative position:$(DDOX_UNITTEST_HEADER __unittestL7151_3687)\n---\nimport std.array : assocArray;\nimport std.range : enumerate;\n\nbool[int] aa = true.repeat(3).enumerate(-1).assocArray();\nassert(aa[-1]);\nassert(aa[0]);\nassert(aa[1]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7151_3687)\n",
				"parameters": [
					{
						"name": "Enumerator",
						"default": "size_t",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!Enumerator && isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isTwoWayCompatible",
						"line": 7347,
						"init": "is(typeof(()\n{\nT1 foo();\nT2 bar();\nfn(foo(), bar());\nfn(bar(), foo());\n}\n))",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isTwoWayCompatible",
				"line": 7345,
				"comment": "  Returns true if $(D fn) accepts variables of type T1 and T2 in any order.\n  The following code should compile:\n  ---\n  T1 foo();\n  T2 bar();\n\n  fn(foo(), bar());\n  fn(bar(), foo());\n  ---\n",
				"parameters": [
					{
						"name": "fn",
						"kind": "alias"
					},
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "linear",
						"line": 7367,
						"value": "0",
						"comment": "       Searches in a linear fashion.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "trot",
						"line": 7378,
						"value": "1",
						"comment": "       Searches with a step that is grows linearly (1, 2, 3,...)\n       leading to a quadratic search schedule (indexes tried are 0, 1,\n       3, 6, 10, 15, 21, 28,...) Once the search overshoots its target,\n       the remaining interval is searched using binary search. The\n       search is completed in $(BIGOH sqrt(n)) time. Use it when you\n       are reasonably confident that the value is around the beginning\n       of the range.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "gallop",
						"line": 7388,
						"value": "2",
						"comment": "       Performs a $(LUCKY galloping search algorithm), i.e. searches\n       with a step that doubles every time, (1, 2, 4, 8, ...)  leading\n       to an exponential search schedule (indexes tried are 0, 1, 3,\n       7, 15, 31, 63,...) Once the search overshoots its target, the\n       remaining interval is searched using binary search. A value is\n       found in $(BIGOH log(n)) time.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "binarySearch",
						"line": 7399,
						"value": "3",
						"comment": "       Searches using a classic interval halving policy. The search\n       starts in the middle of the range, and each search step cuts\n       the range in half. This policy finds a value in $(BIGOH log(n))\n       time but is less cache friendly than $(D gallop) for large\n       ranges. The $(D binarySearch) policy is used as the last step\n       of $(D trot), $(D gallop), $(D trotBackwards), and $(D\n       gallopBackwards) strategies.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "trotBackwards",
						"line": 7405,
						"value": "4",
						"comment": "       Similar to $(D trot) but starts backwards. Use it when\n       confident that the value is around the end of the range.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "gallopBackwards",
						"line": 7411,
						"value": "5",
						"comment": "       Similar to $(D gallop) but starts backwards. Use it when\n       confident that the value is around the end of the range.\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "SearchPolicy",
				"line": 7362,
				"comment": "   Policy used with the searching primitives $(D lowerBound), $(D\n   upperBound), and $(D equalRange) of $(LREF SortedRange) below.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "SortedRange",
						"line": 7424,
						"members": [
							{
								"endchar": 5,
								"name": "empty",
								"line": 7478,
								"comment": "Range primitives.\n",
								"type": "@property bool()",
								"endline": 7481,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 7494,
								"comment": "Ditto\n",
								"type": "@property ref ()",
								"endline": 7497,
								"char": 24,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 7500,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 7503,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "release",
								"line": 7550,
								"comment": "   Releases the controlled range and returns it.\n",
								"type": "()",
								"endline": 7554,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "lowerBound",
										"line": 7661,
										"type": "(V value)",
										"parameters": [
											{
												"name": "value",
												"type": "V"
											}
										],
										"endline": 7666,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "lowerBound",
								"line": 7661,
								"comment": "   This function uses a search with policy $(D sp) to find the\n   largest left subrange on which $(D pred(x, value)) is $(D true) for\n   all $(D x) (e.g., if $(D pred) is \"less than\", returns the portion of\n   the range with elements strictly smaller than $(D value)). The search\n   schedule and its complexity are documented in\n   $(LREF SearchPolicy).  See also STL's\n   $(WEB sgi.com/tech/stl/lower_bound.html, lower_bound).\n\n   Example:\n   ----\n   auto a = assumeSorted([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);\n   auto p = a.lowerBound(4);\n   assert(equal(p, [ 0, 1, 2, 3 ]));\n   ----\n",
								"parameters": [
									{
										"name": "sp",
										"type": "SearchPolicy",
										"defaultValue": "SearchPolicy.binarySearch",
										"kind": "value"
									},
									{
										"name": "V",
										"kind": "type"
									}
								],
								"constraint": "isTwoWayCompatible!(predFun, ElementType!Range, V) && hasSlicing!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "upperBound",
										"line": 7690,
										"type": "(V value)",
										"parameters": [
											{
												"name": "value",
												"type": "V"
											}
										],
										"endline": 7708,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "upperBound",
								"line": 7690,
								"comment": "This function searches with policy $(D sp) to find the largest right\nsubrange on which $(D pred(value, x)) is $(D true) for all $(D x)\n(e.g., if $(D pred) is \"less than\", returns the portion of the range\nwith elements strictly greater than $(D value)). The search schedule\nand its complexity are documented in $(LREF SearchPolicy).\n\nFor ranges that do not offer random access, $(D SearchPolicy.linear)\nis the only policy allowed (and it must be specified explicitly lest it exposes\nuser code to unexpected inefficiencies). For random-access searches, all\npolicies are allowed, and $(D SearchPolicy.binarySearch) is the default.\n\nSee_Also: STL's $(WEB sgi.com/tech/stl/lower_bound.html,upper_bound).\n\nExample:\n----\nauto a = assumeSorted([ 1, 2, 3, 3, 3, 4, 4, 5, 6 ]);\nauto p = a.upperBound(3);\nassert(equal(p, [4, 4, 5, 6]));\n----\n",
								"parameters": [
									{
										"name": "sp",
										"type": "SearchPolicy",
										"defaultValue": "SearchPolicy.binarySearch",
										"kind": "value"
									},
									{
										"name": "V",
										"kind": "type"
									}
								],
								"constraint": "isTwoWayCompatible!(predFun, ElementType!Range, V)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "equalRange",
										"line": 7731,
										"type": "(V value)",
										"parameters": [
											{
												"name": "value",
												"type": "V"
											}
										],
										"endline": 7768,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "equalRange",
								"line": 7731,
								"comment": "   Returns the subrange containing all elements $(D e) for which both $(D\n   pred(e, value)) and $(D pred(value, e)) evaluate to $(D false) (e.g.,\n   if $(D pred) is \"less than\", returns the portion of the range with\n   elements equal to $(D value)). Uses a classic binary search with\n   interval halving until it finds a value that satisfies the condition,\n   then uses $(D SearchPolicy.gallopBackwards) to find the left boundary\n   and $(D SearchPolicy.gallop) to find the right boundary. These\n   policies are justified by the fact that the two boundaries are likely\n   to be near the first found value (i.e., equal ranges are relatively\n   small). Completes the entire search in $(BIGOH log(n)) time. See also\n   STL's $(WEB sgi.com/tech/stl/equal_range.html, equal_range).\n\n   Example:\n   ----\n   auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\n   auto r = equalRange(a, 3);\n   assert(equal(r, [ 3, 3, 3 ]));\n   ----\n",
								"parameters": [
									{
										"name": "V",
										"kind": "type"
									}
								],
								"constraint": "isTwoWayCompatible!(predFun, ElementType!Range, V) && isRandomAccessRange!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "trisect",
										"line": 7788,
										"type": "(V value)",
										"parameters": [
											{
												"name": "value",
												"type": "V"
											}
										],
										"endline": 7828,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "trisect",
								"line": 7788,
								"comment": "Returns a tuple $(D r) such that $(D r[0]) is the same as the result\nof $(D lowerBound(value)), $(D r[1]) is the same as the result of $(D\nequalRange(value)), and $(D r[2]) is the same as the result of $(D\nupperBound(value)). The call is faster than computing all three\nseparately. Uses a search schedule similar to $(D\nequalRange). Completes the entire search in $(BIGOH log(n)) time.\n\nExample:\n----\nauto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\nauto r = assumeSorted(a).trisect(3);\nassert(equal(r[0], [ 1, 2 ]));\nassert(equal(r[1], [ 3, 3, 3 ]));\nassert(equal(r[2], [ 4, 4, 5, 6 ]));\n----\n",
								"parameters": [
									{
										"name": "V",
										"kind": "type"
									}
								],
								"constraint": "isTwoWayCompatible!(predFun, ElementType!Range, V) && isRandomAccessRange!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "contains",
										"line": 7838,
										"type": "bool(V value)",
										"parameters": [
											{
												"name": "value",
												"type": "V"
											}
										],
										"endline": 7845,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "contains",
								"line": 7838,
								"comment": "Returns $(D true) if and only if $(D value) can be found in $(D\nrange), which is assumed to be sorted. Performs $(BIGOH log(r.length))\nevaluations of $(D pred). See also STL's $(WEB\nsgi.com/tech/stl/binary_search.html, binary_search).\n",
								"parameters": [
									{
										"name": "V",
										"kind": "type"
									}
								],
								"constraint": "isRandomAccessRange!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "groupBy",
										"line": 7852,
										"type": "()",
										"endline": 7856,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "groupBy",
								"line": 7852,
								"comment": "Returns a range of subranges of elements that are equivalent according to the\nsorting relation.\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SortedRange",
				"line": 7424,
				"comment": "Represents a sorted range. In addition to the regular range\nprimitives, supports additional operations that take advantage of the\nordering, such as merge and binary search. To obtain a $(D\nSortedRange) from an unsorted range $(D r), use\n$(XREF_PACK algorithm,sorting,sort) which sorts $(D r) in place and returns the\ncorresponding $(D SortedRange). To construct a $(D SortedRange) from a range\n$(D r) that is known to be already sorted, use $(LREF assumeSorted) described\nbelow.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7860_3693)\n---\nimport std.algorithm : sort;\nauto a = [ 1, 2, 3, 42, 52, 64 ];\nauto r = assumeSorted(a);\nassert(r.contains(3));\nassert(!r.contains(32));\nauto r1 = sort!\"a > b\"(a);\nassert(r1.contains(3));\nassert(!r1.contains(32));\nassert(r1.release() == [ 64, 52, 42, 3, 2, 1 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7860_3693)\nExample:\n$(D SortedRange) could accept ranges weaker than random-access, but it\nis unable to provide interesting functionality for them. Therefore,\n$(D SortedRange) is currently restricted to random-access ranges.\n\nNo copy of the original range is ever made. If the underlying range is\nchanged concurrently with its corresponding $(D SortedRange) in ways\nthat break its sortedness, $(D SortedRange) will work erratically.$(DDOX_UNITTEST_HEADER __unittestL7882_3694)\n---\nimport std.algorithm : swap;\nauto a = [ 1, 2, 3, 42, 52, 64 ];\nauto r = assumeSorted(a);\nassert(r.contains(42));\nswap(a[3], a[5]);         // illegal to break sortedness of original range\nassert(!r.contains(42));  // passes although it shouldn't\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7882_3694)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeSorted",
						"line": 8025,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 8029,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "assumeSorted",
				"line": 8025,
				"comment": "Assumes $(D r) is sorted by predicate $(D pred) and returns the\ncorresponding $(D SortedRange!(pred, R)) having $(D r) as support. To\nkeep the checking costs low, the cost is $(BIGOH 1) in release mode\n(no checks for sortedness are performed). In debug mode, a few random\nelements of $(D r) are checked for sortedness. The size of the sample\nis proportional $(BIGOH log(r.length)). That way, checking has no\neffect on the complexity of subsequent operations specific to sorted\nranges (such as binary search). The probability of an arbitrary\nunsorted range failing the test is very high (however, an\nalmost-sorted range is likely to pass it). To check for sortedness at\ncost $(BIGOH n), use $(XREF_PACK algorithm,sorting,isSorted).\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RefRange",
						"line": 8131,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 8137,
								"comment": "\n",
								"type": "pure nothrow @safe (R* range)",
								"parameters": [
									{
										"name": "range",
										"type": "R*"
									}
								],
								"endline": 8140,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 8152,
								"comment": "        This does not assign the pointer of $(D rhs) to this $(D RefRange).\n        Rather it assigns the range pointed to by $(D rhs) to the range pointed\n        to by this $(D RefRange). This is because $(I any) operation on a\n        $(D RefRange) is the same is if it occurred to the original range. The\n        one exception is when a $(D RefRange) is assigned $(D null) either\n        directly or because $(D rhs) is $(D null). In that case, $(D RefRange)\n        no longer refers to the original range but is $(D null).\n",
								"type": "(RefRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "RefRange"
									}
								],
								"endline": 8160,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 8163,
								"comment": "\n",
								"type": "(typeof(null) rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "typeof(null)"
									}
								],
								"endline": 8166,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "ptr",
								"line": 8172,
								"comment": "        A pointer to the wrapped range.\n",
								"type": "inout pure nothrow @property @safe inout(R*)()",
								"endline": 8175,
								"char": 25,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 8228,
								"comment": "\n",
								"type": "void()",
								"endline": 8231,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "RefRange",
				"line": 8131,
				"comment": "    Wrapper which effectively makes it possible to pass a range by reference.\n    Both the original range and the RefRange will always have the exact same\n    elements. Any operation done on one will affect the other. So, for instance,\n    if it's passed to a function which would implicitly copy the original range\n    if it were passed to it, the original range is $(I not) copied but is\n    consumed as if it were a reference type.\n\n    Note that $(D save) works as normal and operates on a new range, so if\n    $(D save) is ever called on the RefRange, then no operations on the saved\n    range will affect the original.\n\nExample:\nBasic Example$(DDOX_UNITTEST_HEADER __unittestL8462_3712)\n---\nimport std.algorithm;\nubyte[] buffer = [1, 9, 45, 12, 22];\nauto found1 = find(buffer, 45);\nassert(found1 == [45, 12, 22]);\nassert(buffer == [1, 9, 45, 12, 22]);\n\nauto wrapped1 = refRange(&buffer);\nauto found2 = find(wrapped1, 45);\nassert(*found2.ptr == [45, 12, 22]);\nassert(buffer == [45, 12, 22]);\n\nauto found3 = find(wrapped1.save, 22);\nassert(*found3.ptr == [22]);\nassert(buffer == [45, 12, 22]);\n\nstring str = \"hello world\";\nauto wrappedStr = refRange(&str);\nassert(str.front == 'h');\nstr.popFrontN(5);\nassert(str == \" world\");\nassert(wrappedStr.front == ' ');\nassert(*wrappedStr.ptr == \" world\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8462_3712)\nExample:\nopAssign Example.$(DDOX_UNITTEST_HEADER __unittestL8489_3713)\n---\nubyte[] buffer1 = [1, 2, 3, 4, 5];\nubyte[] buffer2 = [6, 7, 8, 9, 10];\nauto wrapped1 = refRange(&buffer1);\nauto wrapped2 = refRange(&buffer2);\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\nassert(buffer1 != buffer2);\n\nwrapped1 = wrapped2;\n\n//Everything points to the same stuff as before.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n//But buffer1 has changed due to the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [6, 7, 8, 9, 10]);\n\nbuffer2 = [11, 12, 13, 14, 15];\n\n//Everything points to the same stuff as before.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n//But buffer2 has changed due to the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [11, 12, 13, 14, 15]);\n\nwrapped2 = null;\n\n//The pointer changed for wrapped2 but not wrapped1.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is null);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n//buffer2 is not affected by the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [11, 12, 13, 14, 15]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8489_3713)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "refRange",
						"line": 8836,
						"type": "(R* range)",
						"parameters": [
							{
								"name": "range",
								"type": "R*"
							}
						],
						"endline": 8840,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "refRange",
				"line": 8836,
				"comment": "    Helper function for constructing a $(LREF RefRange).\n\n    If the given range is a class type (and thus is already a reference type),\n    then the original range is returned rather than a $(LREF RefRange).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8851_3723)\n---\nimport std.algorithm : map, joiner, group, until;\n// fix for std.algorithm\nauto r = map!(x => 0)([1]);\nchain(r, r);\nzip(r, r);\nroundRobin(r, r);\n\nstruct NRAR {\n    typeof(r) input;\n    @property empty() { return input.empty; }\n    @property front() { return input.front; }\n    void popFront()   { input.popFront(); }\n    @property save()  { return NRAR(input.save); }\n}\nauto n1 = NRAR(r);\ncycle(n1);  // non random access range version\n\nassumeSorted(r);\n\n// fix for std.range\njoiner([r], [9]);\n\nstruct NRAR2 {\n    NRAR input;\n    @property empty() { return true; }\n    @property front() { return input; }\n    void popFront() { }\n    @property save()  { return NRAR2(input.save); }\n}\nauto n2 = NRAR2(n1);\njoiner(n2);\n\ngroup(r);\n\nuntil(r, 7);\nstatic void foo(R)(R r) { until!(x => x > 7)(r); }\nfoo(r);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8851_3723)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && !is(R == class)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "refRange",
						"line": 8843,
						"type": "(R* range)",
						"parameters": [
							{
								"name": "range",
								"type": "R*"
							}
						],
						"endline": 8847,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "refRange",
				"line": 8843,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && is(R == class)",
				"char": 6,
				"kind": "template"
			},
			{
				"name": "NullSink",
				"line": 8896,
				"comment": " An OutputRange that discards the data it receives.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8902_3725)\n---\nimport std.algorithm : map, copy;\n[4, 5, 6].map!(x => x * 2).copy(NullSink()); // data is discarded\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8902_3725)\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "tee",
						"line": 8944,
						"type": "(R1 inputRange, R2 outputRange)",
						"parameters": [
							{
								"name": "inputRange",
								"type": "R1"
							},
							{
								"name": "outputRange",
								"type": "R2"
							}
						],
						"endline": 9002,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "tee",
				"line": 8944,
				"comment": "\n  Implements a \"tee\" style pipe, wrapping an input range so that elements of the\n  range can be passed to a provided function or $(LREF OutputRange) as they are\n  iterated over. This is useful for printing out intermediate values in a long\n  chain of range code, performing some operation with side-effects on each call\n  to $(D front) or $(D popFront), or diverting the elements of a range into an\n  auxiliary $(LREF OutputRange).\n\n  It is important to note that as the resultant range is evaluated lazily,\n  in the case of the version of $(D tee) that takes a function, the function\n  will not actually be executed until the range is \"walked\" using functions\n  that evaluate ranges, such as $(XREF array,array) or\n  $(XREF_PACK algorithm,iteration,reduce).\n\n  Params:\n  pipeOnPop = If `Yes.pipeOnPop`, simply iterating the range without ever\n  calling `front` is enough to have `tee` mirror elements to `outputRange` (or,\n  respectively, `fun`). If `No.pipeOnPop`, only elements for which `front` does\n  get called will be also sent to `outputRange`/`fun`.\n  inputRange = The input range beeing passed through.\n  outputRange = This range will receive elements of `inputRange` progressively\n  as iteration proceeds.\n  fun = This function will be called with elements of `inputRange`\n  progressively as iteration proceeds.\n\n  Returns:\n  An input range that offers the elements of `inputRange`. Regardless of\n  whether `inputRange` is a more powerful range (forward, bidirectional etc),\n  the result is always an input range. Reading this causes `inputRange` to be\n  iterated and returns its elements in turn. In addition, the same elements\n  will be passed to `outputRange` or `fun` as well.\n\n  See_Also: $(XREF_PACK algorithm,iteration,each)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9031_3731)\n---\nimport std.algorithm : equal, filter, map;\n\n// Sum values while copying\nint[] values = [1, 4, 9, 16, 25];\nint sum = 0;\nauto newValues = values.tee!(a => sum += a).array;\nassert(equal(newValues, values));\nassert(sum == 1 + 4 + 9 + 16 + 25);\n\n// Count values that pass the first filter\nint count = 0;\nauto newValues4 = values.filter!(a => a < 10)\n                        .tee!(a => count++)\n                        .map!(a => a + 1)\n                        .filter!(a => a < 10);\n\n//Fine, equal also evaluates any lazy ranges passed to it.\n//count is not 3 until equal evaluates newValues4\nassert(equal(newValues4, [2, 5]));\nassert(count == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9031_3731)\n",
				"parameters": [
					{
						"name": "pipeOnPop",
						"defaultValue": "Yes.pipeOnPop",
						"deco": "E3std8typecons34__T4FlagVAyaa9_706970654f6e506f70Z4Flag",
						"kind": "value"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R1 && isOutputRange!(R2, ElementType!R1)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "tee",
						"line": 9005,
						"type": "(R1 inputRange)",
						"parameters": [
							{
								"name": "inputRange",
								"type": "R1"
							}
						],
						"endline": 9028,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "tee",
				"line": 9005,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "pipeOnPop",
						"defaultValue": "Yes.pipeOnPop",
						"deco": "E3std8typecons34__T4FlagVAyaa9_706970654f6e506f70Z4Flag",
						"kind": "value"
					},
					{
						"name": "R1",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(fun) == void) || isSomeFunction!fun",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This module defines the notion of a range. Ranges generalize the concept of\narrays, lists, or anything that involves sequential access. This abstraction\nenables the same set of algorithms (see $(LINK2 std_algorithm.html,\nstd.algorithm)) to be used with a vast variety of different concrete types. For\nexample, a linear search algorithm such as $(LINK2 std_algorithm.html#find,\nstd.algorithm.find) works not just for arrays, but for linked-lists, input\nfiles, incoming network data, etc. See also Ali Çehreli's\n$(WEB ddili.org/ders/d.en/ranges.html, tutorial on ranges) for the basics\nof working with and creating range-based code.\n\nFor more detailed information about the conceptual aspect of ranges and the\nmotivation behind them, see Andrei Alexandrescu's article\n$(LINK2 http://www.informit.com/articles/printerfriendly.aspx?p=1407357$(AMP)rll=1,\n$(I On Iteration)).\n\nSubmodules:\n\nThis module has two submodules:\n\nThe $(LINK2 std_range_primitives.html, $(D std._range.primitives)) submodule\nprovides basic _range functionality. It defines several templates for testing\nwhether a given object is a _range, what kind of _range it is, and provides\nsome common _range operations.\n\nThe $(LINK2 std_range_interfaces.html, $(D std._range.interfaces)) submodule\nprovides object-based interfaces for working with ranges via runtime\npolymorphism.\n\nThe remainder of this module provides a rich set of _range creation and\ncomposition templates that let you construct new ranges out of existing ranges:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF chain)))\n        $(TD Concatenates several ranges into a single _range.\n    ))\n    $(TR $(TD $(D $(LREF choose)))\n        $(TD Chooses one of two ranges at runtime based on a boolean condition.\n    ))\n    $(TR $(TD $(D $(LREF chooseAmong)))\n        $(TD Chooses one of several ranges at runtime based on an index.\n    ))\n    $(TR $(TD $(D $(LREF chunks)))\n        $(TD Creates a _range that returns fixed-size chunks of the original\n        _range.\n    ))\n    $(TR $(TD $(D $(LREF cycle)))\n        $(TD Creates an infinite _range that repeats the given forward _range\n        indefinitely. Good for implementing circular buffers.\n    ))\n    $(TR $(TD $(D $(LREF drop)))\n        $(TD Creates the _range that results from discarding the first $(I n)\n        elements from the given _range.\n    ))\n    $(TR $(TD $(D $(LREF dropExactly)))\n        $(TD Creates the _range that results from discarding exactly $(I n)\n        of the first elements from the given _range.\n    ))\n    $(TR $(TD $(D $(LREF dropOne)))\n        $(TD Creates the _range that results from discarding\n        the first elements from the given _range.\n    ))\n    $(TR $(TD $(D $(LREF enumerate)))\n        $(TD Iterates a _range with an attached index variable.\n    ))\n    $(TR $(TD $(D $(LREF evenChunks)))\n        $(TD Creates a _range that returns a number of chunks of\n        approximately equal length from the original _range.\n    ))\n    $(TR $(TD $(D $(LREF frontTransversal)))\n        $(TD Creates a _range that iterates over the first elements of the\n        given ranges.\n    ))\n    $(TR $(TD $(D $(LREF indexed)))\n        $(TD Creates a _range that offers a view of a given _range as though\n        its elements were reordered according to a given _range of indices.\n    ))\n    $(TR $(TD $(D $(LREF iota)))\n        $(TD Creates a _range consisting of numbers between a starting point\n        and ending point, spaced apart by a given interval.\n    ))\n    $(TR $(TD $(D $(LREF lockstep)))\n        $(TD Iterates $(I n) _ranges in lockstep, for use in a $(D foreach)\n        loop. Similar to $(D zip), except that $(D lockstep) is designed\n        especially for $(D foreach) loops.\n    ))\n    $(TR $(TD $(D $(LREF NullSink)))\n        $(TD An output _range that discards the data it receives.\n    ))\n    $(TR $(TD $(D $(LREF only)))\n        $(TD Creates a _range that iterates over the given arguments.\n    ))\n    $(TR $(TD $(D $(LREF radial)))\n        $(TD Given a random-access _range and a starting point, creates a\n        _range that alternately returns the next left and next right element to\n        the starting point.\n    ))\n    $(TR $(TD $(D $(LREF recurrence)))\n        $(TD Creates a forward _range whose values are defined by a\n        mathematical recurrence relation.\n    ))\n    $(TR $(TD $(D $(LREF repeat)))\n        $(TD Creates a _range that consists of a single element repeated $(I n)\n        times, or an infinite _range repeating that element indefinitely.\n    ))\n    $(TR $(TD $(D $(LREF retro)))\n        $(TD Iterates a bidirectional _range backwards.\n    ))\n    $(TR $(TD $(D $(LREF roundRobin)))\n        $(TD Given $(I n) ranges, creates a new _range that return the $(I n)\n        first elements of each _range, in turn, then the second element of each\n        _range, and so on, in a round-robin fashion.\n    ))\n    $(TR $(TD $(D $(LREF sequence)))\n        $(TD Similar to $(D recurrence), except that a random-access _range is\n        created.\n    ))\n    $(TR $(TD $(D $(LREF stride)))\n        $(TD Iterates a _range with stride $(I n).\n    ))\n    $(TR $(TD $(D $(LREF take)))\n        $(TD Creates a sub-_range consisting of only up to the first $(I n)\n        elements of the given _range.\n    ))\n    $(TR $(TD $(D $(LREF takeExactly)))\n        $(TD Like $(D take), but assumes the given _range actually has $(I n)\n        elements, and therefore also defines the $(D length) property.\n    ))\n    $(TR $(TD $(D $(LREF takeNone)))\n        $(TD Creates a random-access _range consisting of zero elements of the\n        given _range.\n    ))\n    $(TR $(TD $(D $(LREF takeOne)))\n        $(TD Creates a random-access _range consisting of exactly the first\n        element of the given _range.\n    ))\n    $(TR $(TD $(D $(LREF tee)))\n        $(TD Creates a _range that wraps a given _range, forwarding along\n        its elements while also calling a provided function with each element.\n    ))\n    $(TR $(TD $(D $(LREF transposed)))\n        $(TD Transposes a _range of ranges.\n    ))\n    $(TR $(TD $(D $(LREF transversal)))\n        $(TD Creates a _range that iterates over the $(I n)'th elements of the\n        given random-access ranges.\n    ))\n    $(TR $(TD $(D $(LREF zip)))\n        $(TD Given $(I n) _ranges, creates a _range that successively returns a\n        tuple of all the first elements, a tuple of all the second elements,\n        etc.\n    ))\n)\n\nRanges whose elements are sorted afford better efficiency with certain\noperations. For this, the $(D $(LREF assumeSorted)) function can be used to\nconstruct a $(D $(LREF SortedRange)) from a pre-sorted _range. The $(LINK2\nstd_algorithm.html#sort, $(D std.algorithm.sort)) function also conveniently\nreturns a $(D SortedRange). $(D SortedRange) objects provide some additional\n_range operations that take advantage of the fact that the _range is sorted.\n\nSource: $(PHOBOSSRC std/_range/_package.d)\n\nMacros:\n\nWIKI = Phobos/StdRange\n\nCopyright: Copyright by authors 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu), David Simcha,\nand Jonathan M Davis. Credit for some of the ideas in building this module goes\nto $(WEB fantascienza.net/leonardo/so/, Leonardo Maffi).\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/range/primitives.d",
		"name": "std.range.primitives",
		"members": [
			{
				"members": [
					{
						"name": "isInputRange",
						"line": 151,
						"deco": "b",
						"init": "is(typeof((inout int = 0)\n{\nR r = R.init;\nif (r.empty)\n{\n}\nr.popFront();\nauto h = r.front;\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isInputRange",
				"line": 149,
				"comment": "Returns $(D true) if $(D R) is an input range. An input range must\ndefine the primitives $(D empty), $(D popFront), and $(D front). The\nfollowing code should compile for any input range.\n\n----\nR r;              // can define a range object\nif (r.empty) {}   // can test for empty\nr.popFront();     // can invoke popFront()\nauto h = r.front; // can get the front of the range of non-void type\n----\n\nThe semantics of an input range (not checkable during compilation) are\nassumed to be the following ($(D r) is an object of type $(D R)):\n\n$(UL $(LI $(D r.empty) returns $(D false) iff there is more data\navailable in the range.)  $(LI $(D r.front) returns the current\nelement in the range. It may return by value or by reference. Calling\n$(D r.front) is allowed only if calling $(D r.empty) has, or would\nhave, returned $(D false).) $(LI $(D r.popFront) advances to the next\nelement in the range. Calling $(D r.popFront) is allowed only if\ncalling $(D r.empty) has, or would have, returned $(D false).))\n\nParams:\n    R = type to be tested\n\nReturns:\n    true if R is an InputRange, false if not\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL162_3751)\n---\nstruct A {}\nstruct B\n{\n    void popFront();\n    @property bool empty();\n    @property int front();\n}\nstatic assert(!isInputRange!A);\nstatic assert( isInputRange!B);\nstatic assert( isInputRange!(int[]));\nstatic assert( isInputRange!(char[]));\nstatic assert(!isInputRange!(char[4]));\nstatic assert( isInputRange!(inout(int)[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL162_3751)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "put",
						"line": 284,
						"type": "void(ref R r, E e)",
						"parameters": [
							{
								"name": "r",
								"type": "R",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "e",
								"type": "E"
							}
						],
						"endline": 337,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "put",
				"line": 284,
				"comment": "Outputs $(D e) to $(D r). The exact effect is dependent upon the two\ntypes. Several cases are accepted, as described below. The code snippets\nare attempted in order, and the first to compile \"wins\" and gets\nevaluated.\n\nIn this table \"doPut\" is a method that places $(D e) into $(D r), using the\ncorrect primitive: $(D r.put(e)) if $(D R) defines $(D put), $(D r.front = e)\nif $(D r) is an input range (followed by $(D r.popFront())), or $(D r(e))\notherwise.\n\n$(BOOKTABLE ,\n    $(TR\n        $(TH Code Snippet)\n        $(TH Scenario)\n    )\n    $(TR\n        $(TD $(D r.doPut(e);))\n        $(TD $(D R) specifically accepts an $(D E).)\n    )\n    $(TR\n        $(TD $(D r.doPut([ e ]);))\n        $(TD $(D R) specifically accepts an $(D E[]).)\n    )\n    $(TR\n        $(TD $(D r.putChar(e);))\n        $(TD $(D R) accepts some form of string or character. put will\n            transcode the character $(D e) accordingly.)\n    )\n    $(TR\n        $(TD $(D for (; !e.empty; e.popFront()) put(r, e.front);))\n        $(TD Copying range $(D E) into $(D R).)\n    )\n)\n\nTip: $(D put) should $(I not) be used \"UFCS-style\", e.g. $(D r.put(e)).\nDoing this may call $(D R.put) directly, by-passing any transformation\nfeature provided by $(D Range.put). $(D put(r, e)) is prefered.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL690_3772)\n---\nint[] r = new int[](4);\nstatic assert(isInputRange!(int[]));\nstatic assert( isNativeOutputRange!(int[], int));\nstatic assert(!isNativeOutputRange!(int[], int[]));\nstatic assert( isOutputRange!(int[], int[]));\n\nif (!r.empty)\n    put(r, 1); //guaranteed to succeed\nif (!r.empty)\n    put(r, [1, 2]); //May actually error out.\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL690_3772)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isOutputRange",
						"line": 710,
						"deco": "b",
						"init": "is(typeof((inout int = 0)\n{\nR r = R.init;\nE e = E.init;\nput(r, e);\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isOutputRange",
				"line": 708,
				"comment": "Returns $(D true) if $(D R) is an output range for elements of type\n$(D E). An output range is defined functionally as a range that\nsupports the operation $(D put(r, e)) as defined above.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL720_3773)\n---\nvoid myprint(in char[] s) { }\nstatic assert(isOutputRange!(typeof(&myprint), char));\n\nstatic assert(!isOutputRange!(char[], char));\nstatic assert( isOutputRange!(dchar[], wchar));\nstatic assert( isOutputRange!(dchar[], dchar));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL720_3773)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isForwardRange",
						"line": 781,
						"deco": "b",
						"init": "isInputRange!R && is(typeof((inout int = 0)\n{\nR r1 = R.init;\nauto s1 = r1.save;\nstatic assert(is(typeof(s1) == R));\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isForwardRange",
				"line": 779,
				"comment": "Returns $(D true) if $(D R) is a forward range. A forward range is an\ninput range $(D r) that can save \"checkpoints\" by saving $(D r.save)\nto another value of type $(D R). Notable examples of input ranges that\nare $(I not) forward ranges are file/socket ranges; copying such a\nrange will not save the position in the stream, and they most likely\nreuse an internal buffer as the entire stream does not sit in\nmemory. Subsequently, advancing either the original or the copy will\nadvance the stream, so the copies are not independent.\n\nThe following code should compile for any forward range.\n\n----\nstatic assert(isInputRange!R);\nR r1;\nauto s1 = r1.save;\nstatic assert (is(typeof(s1) == R));\n----\n\nSaving a range is not duplicating it; in the example above, $(D r1)\nand $(D r2) still refer to the same underlying data. They just\nnavigate that data independently.\n\nThe semantics of a forward range (not checkable during compilation)\nare the same as for an input range, with the additional requirement\nthat backtracking must be possible by saving a copy of the range\nobject with $(D save) and using it later.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL794_3775)\n---\nstatic assert(!isForwardRange!(int));\nstatic assert( isForwardRange!(int[]));\nstatic assert( isForwardRange!(inout(int)[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL794_3775)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isBidirectionalRange",
						"line": 831,
						"deco": "b",
						"init": "isForwardRange!R && is(typeof((inout int = 0)\n{\nR r = R.init;\nr.popBack();\nauto t = r.back;\nauto w = r.front;\nstatic assert(is(typeof(t) == typeof(w)));\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isBidirectionalRange",
				"line": 829,
				"comment": "Returns $(D true) if $(D R) is a bidirectional range. A bidirectional\nrange is a forward range that also offers the primitives $(D back) and\n$(D popBack). The following code should compile for any bidirectional\nrange.\n\nThe semantics of a bidirectional range (not checkable during\ncompilation) are assumed to be the following ($(D r) is an object of\ntype $(D R)):\n\n$(UL $(LI $(D r.back) returns (possibly a reference to) the last\nelement in the range. Calling $(D r.back) is allowed only if calling\n$(D r.empty) has, or would have, returned $(D false).))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL843_3777)\n---\nalias R = int[];\nR r = [0,1];\nstatic assert(isForwardRange!R);           // is forward range\nr.popBack();                               // can invoke popBack\nauto t = r.back;                           // can get the back of the range\nauto w = r.front;\nstatic assert(is(typeof(t) == typeof(w))); // same type for front and back\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL843_3777)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isRandomAccessRange",
						"line": 901,
						"deco": "b",
						"init": "is(typeof((inout int = 0)\n{\nstatic assert(isBidirectionalRange!R || isForwardRange!R && isInfinite!R);\nR r = R.init;\nauto e = r[1];\nauto f = r.front;\nstatic assert(is(typeof(e) == typeof(f)));\nstatic assert(!isNarrowString!R);\nstatic assert(hasLength!R || isInfinite!R);\nstatic if (is(typeof(r[__dollar])))\n{\nstatic assert(is(typeof(f) == typeof(r[__dollar])));\nstatic if (!isInfinite!R)\n{\nstatic assert(is(typeof(f) == typeof(r[__dollar - 1])));\n}\n\n}\n\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isRandomAccessRange",
				"line": 899,
				"comment": "Returns $(D true) if $(D R) is a random-access range. A random-access\nrange is a bidirectional range that also offers the primitive $(D\nopIndex), OR an infinite forward range that offers $(D opIndex). In\neither case, the range must either offer $(D length) or be\ninfinite. The following code should compile for any random-access\nrange.\n\nThe semantics of a random-access range (not checkable during\ncompilation) are assumed to be the following ($(D r) is an object of\ntype $(D R)): $(UL $(LI $(D r.opIndex(n)) returns a reference to the\n$(D n)th element in the range.))\n\nAlthough $(D char[]) and $(D wchar[]) (as well as their qualified\nversions including $(D string) and $(D wstring)) are arrays, $(D\nisRandomAccessRange) yields $(D false) for them because they use\nvariable-length encodings (UTF-8 and UTF-16 respectively). These types\nare bidirectional ranges only.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL924_3779)\n---\nalias R = int[];\n\n// range is finite and bidirectional or infinite and forward.\nstatic assert(isBidirectionalRange!R ||\n              isForwardRange!R && isInfinite!R);\n\nR r = [0,1];\nauto e = r[1]; // can index\nauto f = r.front;\nstatic assert(is(typeof(e) == typeof(f))); // same type for indexed and front\nstatic assert(!isNarrowString!R); // narrow strings cannot be indexed as ranges\nstatic assert(hasLength!R || isInfinite!R); // must have length or be infinite\n\n// $ must work as it does with arrays if opIndex works with $\nstatic if(is(typeof(r[$])))\n{\n    static assert(is(typeof(f) == typeof(r[$])));\n\n    // $ - 1 doesn't make sense with infinite ranges but needs to work\n    // with finite ones.\n    static if(!isInfinite!R)\n        static assert(is(typeof(f) == typeof(r[$ - 1])));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL924_3779)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasMobileElements",
						"line": 1053,
						"deco": "b",
						"init": "isInputRange!R && is(typeof((inout int = 0)\n{\nalias E = ElementType!R;\nR r = R.init;\nstatic assert(is(typeof(moveFront(r)) == E));\nstatic if (isBidirectionalRange!R)\n{\nstatic assert(is(typeof(moveBack(r)) == E));\n}\n\nstatic if (isRandomAccessRange!R)\n{\nstatic assert(is(typeof(moveAt(r, 0)) == E));\n}\n\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasMobileElements",
				"line": 1051,
				"comment": "Returns $(D true) iff $(D R) is an input range that supports the\n$(D moveFront) primitive, as well as $(D moveBack) and $(D moveAt) if it's a\nbidirectional or random access range. These may be explicitly implemented, or\nmay work via the default behavior of the module level functions $(D moveFront)\nand friends. The following code should compile for any range\nwith mobile elements.\n\n----\nalias E = ElementType!R;\nR r;\nstatic assert(isInputRange!R);\nstatic assert(is(typeof(moveFront(r)) == E));\nstatic if (isBidirectionalRange!R)\n    static assert(is(typeof(moveBack(r)) == E));\nstatic if (isRandomAccessRange!R)\n    static assert(is(typeof(moveAt(r, 0)) == E));\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1067_3782)\n---\nimport std.algorithm : map;\nimport std.range : iota, repeat;\n\nstatic struct HasPostblit\n{\n    this(this) {}\n}\n\nauto nonMobile = map!\"a\"(repeat(HasPostblit.init));\nstatic assert(!hasMobileElements!(typeof(nonMobile)));\nstatic assert( hasMobileElements!(int[]));\nstatic assert( hasMobileElements!(inout(int)[]));\nstatic assert( hasMobileElements!(typeof(iota(1000))));\n\nstatic assert( hasMobileElements!( string));\nstatic assert( hasMobileElements!(dstring));\nstatic assert( hasMobileElements!( char[]));\nstatic assert( hasMobileElements!(dchar[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1067_3782)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "ElementType",
				"line": 1097,
				"comment": "The element type of $(D R). $(D R) does not have to be a range. The\nelement type is determined as the type yielded by $(D r.front) for an\nobject $(D r) of type $(D R). For example, $(D ElementType!(T[])) is\n$(D T) if $(D T[]) isn't a narrow string; if it is, the element type is\n$(D dchar). If $(D R) doesn't have $(D front), $(D ElementType!R) is\n$(D void).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1106_3783)\n---\nimport std.range : iota;\n\n// Standard arrays: returns the type of the elements of the array\nstatic assert(is(ElementType!(int[]) == int));\n\n// Accessing .front retrieves the decoded dchar\nstatic assert(is(ElementType!(char[])  == dchar)); // rvalue\nstatic assert(is(ElementType!(dchar[]) == dchar)); // lvalue\n\n// Ditto\nstatic assert(is(ElementType!(string) == dchar));\nstatic assert(is(ElementType!(dstring) == immutable(dchar)));\n\n// For ranges it gets the type of .front.\nauto range = iota(0, 10);\nstatic assert(is(ElementType!(typeof(range)) == int));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1106_3783)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "ElementEncodingType",
				"line": 1183,
				"comment": "The encoding element type of $(D R). For narrow strings ($(D char[]),\n$(D wchar[]) and their qualified variants including $(D string) and\n$(D wstring)), $(D ElementEncodingType) is the character type of the\nstring. For all other types, $(D ElementEncodingType) is the same as\n$(D ElementType).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1192_3789)\n---\nimport std.range : iota;\n// internally the range stores the encoded type\nstatic assert(is(ElementEncodingType!(char[])  == char));\n\nstatic assert(is(ElementEncodingType!(wstring) == immutable(wchar)));\n\nstatic assert(is(ElementEncodingType!(byte[]) == byte));\n\nauto range = iota(0, 10);\nstatic assert(is(ElementEncodingType!(typeof(range)) == int));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1192_3789)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasSwappableElements",
						"line": 1257,
						"deco": "b",
						"init": "isInputRange!R && is(typeof((inout int = 0)\n{\nR r = R.init;\nswap(r.front, r.front);\nstatic if (isBidirectionalRange!R)\n{\nswap(r.back, r.front);\n}\n\nstatic if (isRandomAccessRange!R)\n{\nswap(r[0], r.front);\n}\n\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasSwappableElements",
				"line": 1254,
				"comment": "Returns $(D true) if $(D R) is an input range and has swappable\nelements. The following code should compile for any range\nwith swappable elements.\n\n----\nR r;\nstatic assert(isInputRange!R);\nswap(r.front, r.front);\nstatic if (isBidirectionalRange!R) swap(r.back, r.front);\nstatic if (isRandomAccessRange!R) swap(r[], r.front);\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1268_3793)\n---\nstatic assert(!hasSwappableElements!(const int[]));\nstatic assert(!hasSwappableElements!(const(int)[]));\nstatic assert(!hasSwappableElements!(inout(int)[]));\nstatic assert( hasSwappableElements!(int[]));\n\nstatic assert(!hasSwappableElements!( string));\nstatic assert(!hasSwappableElements!(dstring));\nstatic assert(!hasSwappableElements!( char[]));\nstatic assert( hasSwappableElements!(dchar[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1268_3793)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasAssignableElements",
						"line": 1296,
						"deco": "b",
						"init": "isInputRange!R && is(typeof((inout int = 0)\n{\nR r = R.init;\nr.front = r.front;\nstatic if (isBidirectionalRange!R)\n{\nr.back = r.front;\n}\n\nstatic if (isRandomAccessRange!R)\n{\nr[0] = r.front;\n}\n\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasAssignableElements",
				"line": 1294,
				"comment": "Returns $(D true) if $(D R) is an input range and has mutable\nelements. The following code should compile for any range\nwith assignable elements.\n\n----\nR r;\nstatic assert(isInputRange!R);\nr.front = r.front;\nstatic if (isBidirectionalRange!R) r.back = r.front;\nstatic if (isRandomAccessRange!R) r[0] = r.front;\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1307_3794)\n---\nstatic assert(!hasAssignableElements!(const int[]));\nstatic assert(!hasAssignableElements!(const(int)[]));\nstatic assert( hasAssignableElements!(int[]));\nstatic assert(!hasAssignableElements!(inout(int)[]));\n\nstatic assert(!hasAssignableElements!( string));\nstatic assert(!hasAssignableElements!(dstring));\nstatic assert(!hasAssignableElements!( char[]));\nstatic assert( hasAssignableElements!(dchar[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1307_3794)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasLvalueElements",
						"line": 1335,
						"deco": "b",
						"init": "isInputRange!R && is(typeof((inout int = 0)\n{\nvoid checkRef(ref ElementType!R stuff);\nR r = R.init;\ncheckRef(r.front);\nstatic if (isBidirectionalRange!R)\n{\ncheckRef(r.back);\n}\n\nstatic if (isRandomAccessRange!R)\n{\ncheckRef(r[0]);\n}\n\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasLvalueElements",
				"line": 1333,
				"comment": "Tests whether the range $(D R) has lvalue elements. These are defined as\nelements that can be passed by reference and have their address taken.\nThe following code should compile for any range with lvalue elements.\n----\nvoid passByRef(ref ElementType!R stuff);\n...\nstatic assert(isInputRange!R);\npassByRef(r.front);\nstatic if (isBidirectionalRange!R) passByRef(r.back);\nstatic if (isRandomAccessRange!R) passByRef(r[0]);\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1348_3795)\n---\nimport std.range : iota, chain;\n\nstatic assert( hasLvalueElements!(int[]));\nstatic assert( hasLvalueElements!(const(int)[]));\nstatic assert( hasLvalueElements!(inout(int)[]));\nstatic assert( hasLvalueElements!(immutable(int)[]));\nstatic assert(!hasLvalueElements!(typeof(iota(3))));\n\nstatic assert(!hasLvalueElements!( string));\nstatic assert( hasLvalueElements!(dstring));\nstatic assert(!hasLvalueElements!( char[]));\nstatic assert( hasLvalueElements!(dchar[]));\n\nauto c = chain([1, 2, 3], [4, 5, 6]);\nstatic assert( hasLvalueElements!(typeof(c)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1348_3795)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasLength",
						"line": 1392,
						"deco": "b",
						"init": "!isNarrowString!R && is(typeof((inout int = 0)\n{\nR r = R.init;\nulong l = r.length;\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasLength",
				"line": 1390,
				"comment": "Returns $(D true) if $(D R) has a $(D length) member that returns an\nintegral type. $(D R) does not have to be a range. Note that $(D\nlength) is an optional primitive as no range must implement it. Some\nranges do not store their length explicitly, some cannot compute it\nwithout actually exhausting the range (e.g. socket streams), and some\nother ranges may be infinite.\n\nAlthough narrow string types ($(D char[]), $(D wchar[]), and their\nqualified derivatives) do define a $(D length) property, $(D\nhasLength) yields $(D false) for them. This is because a narrow\nstring's length does not reflect the number of characters, but instead\nthe number of encoding units, and as such is not useful with\nrange-oriented algorithms.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1401_3797)\n---\nstatic assert(!hasLength!(char[]));\nstatic assert( hasLength!(int[]));\nstatic assert( hasLength!(inout(int)[]));\n\nstruct A { ulong length; }\nstruct B { size_t length() { return 0; } }\nstruct C { @property size_t length() { return 0; } }\nstatic assert( hasLength!(A));\nstatic assert( hasLength!(B));\nstatic assert( hasLength!(C));\n}\n\n/**\nReturns $(D true) if $(D R) is an infinite input range. An\ninfinite input range is an input range that has a statically-defined\nenumerated member called $(D empty) that is always $(D false),\nfor example:\n\n----\nstruct MyInfiniteRange\n{\nenum bool empty = false;\n...\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1401_3797)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isInfinite",
				"line": 1430,
				"comment": "Returns $(D true) if $(D R) is an infinite input range. An\ninfinite input range is an input range that has a statically-defined\nenumerated member called $(D empty) that is always $(D false),\nfor example:\n\n----\nstruct MyInfiniteRange\n{\n    enum bool empty = false;\n    ...\n}\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1439_3798)\n---\nimport std.range : Repeat;\nstatic assert(!isInfinite!(int[]));\nstatic assert( isInfinite!(Repeat!(int)));\n}\n\n/**\nReturns $(D true) if $(D R) offers a slicing operator with integral boundaries\nthat returns a forward range type.\n\nFor finite ranges, the result of $(D opSlice) must be of the same type as the\noriginal range type. If the range defines $(D opDollar), then it must support\nsubtraction.\n\nFor infinite ranges, when $(I not) using $(D opDollar), the result of\n$(D opSlice) must be the result of $(LREF take) or $(LREF takeExactly) on the\noriginal range (they both return the same type for infinite ranges). However,\nwhen using $(D opDollar), the result of $(D opSlice) must be that of the\noriginal range type.\n\nThe following code must compile for $(D hasSlicing) to be $(D true):\n\n----\nR r = void;\n\nstatic if(isInfinite!R)\ntypeof(take(r, 1)) s = r[1 .. 2];\nelse\n{\nstatic assert(is(typeof(r[1 .. 2]) == R));\nR s = r[1 .. 2];\n}\n\ns = r[1 .. 2];\n\nstatic if(is(typeof(r[0 .. $])))\n{\nstatic assert(is(typeof(r[0 .. $]) == R));\nR t = r[0 .. $];\nt = r[0 .. $];\n\nstatic if(!isInfinite!R)\n{\n    static assert(is(typeof(r[0 .. $ - 1]) == R));\n    R u = r[0 .. $ - 1];\n    u = r[0 .. $ - 1];\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1439_3798)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasSlicing",
						"line": 1495,
						"deco": "b",
						"init": "isForwardRange!R && !isNarrowString!R && is(typeof((inout int = 0)\n{\nR r = R.init;\nstatic if (isInfinite!R)\n{\ntypeof(r[1..1]) s = r[1..2];\n}\nelse\n{\nstatic assert(is(typeof(r[1..2]) == R));\nR s = r[1..2];\n}\ns = r[1..2];\nstatic if (is(typeof(r[0..__dollar])))\n{\nstatic assert(is(typeof(r[0..__dollar]) == R));\nR t = r[0..__dollar];\nt = r[0..__dollar];\nstatic if (!isInfinite!R)\n{\nstatic assert(is(typeof(r[0..__dollar - 1]) == R));\nR u = r[0..__dollar - 1];\nu = r[0..__dollar - 1];\n}\n\n}\n\nstatic assert(isForwardRange!(typeof(r[1..2])));\nstatic assert(hasLength!(typeof(r[1..2])));\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasSlicing",
				"line": 1493,
				"comment": "Returns $(D true) if $(D R) offers a slicing operator with integral boundaries\nthat returns a forward range type.\n\nFor finite ranges, the result of $(D opSlice) must be of the same type as the\noriginal range type. If the range defines $(D opDollar), then it must support\nsubtraction.\n\nFor infinite ranges, when $(I not) using $(D opDollar), the result of\n$(D opSlice) must be the result of $(LREF take) or $(LREF takeExactly) on the\noriginal range (they both return the same type for infinite ranges). However,\nwhen using $(D opDollar), the result of $(D opSlice) must be that of the\noriginal range type.\n\nThe following code must compile for $(D hasSlicing) to be $(D true):\n\n----\nR r = void;\n\nstatic if(isInfinite!R)\n    typeof(take(r, 1)) s = r[1 .. 2];\nelse\n{\n    static assert(is(typeof(r[1 .. 2]) == R));\n    R s = r[1 .. 2];\n}\n\ns = r[1 .. 2];\n\nstatic if(is(typeof(r[0 .. $])))\n{\n    static assert(is(typeof(r[0 .. $]) == R));\n    R t = r[0 .. $];\n    t = r[0 .. $];\n\n    static if(!isInfinite!R)\n    {\n        static assert(is(typeof(r[0 .. $ - 1]) == R));\n        R u = r[0 .. $ - 1];\n        u = r[0 .. $ - 1];\n    }\n}\n\nstatic assert(isForwardRange!(typeof(r[1 .. 2])));\nstatic assert(hasLength!(typeof(r[1 .. 2])));\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1532_3799)\n---\nimport std.range : takeExactly;\nstatic assert( hasSlicing!(int[]));\nstatic assert( hasSlicing!(const(int)[]));\nstatic assert(!hasSlicing!(const int[]));\nstatic assert( hasSlicing!(inout(int)[]));\nstatic assert(!hasSlicing!(inout int []));\nstatic assert( hasSlicing!(immutable(int)[]));\nstatic assert(!hasSlicing!(immutable int[]));\nstatic assert(!hasSlicing!string);\nstatic assert( hasSlicing!dstring);\n\nenum rangeFuncs = \"@property int front();\" ~\n                  \"void popFront();\" ~\n                  \"@property bool empty();\" ~\n                  \"@property auto save() { return this; }\" ~\n                  \"@property size_t length();\";\n\nstruct A { mixin(rangeFuncs); int opSlice(size_t, size_t); }\nstruct B { mixin(rangeFuncs); B opSlice(size_t, size_t); }\nstruct C { mixin(rangeFuncs); @disable this(); C opSlice(size_t, size_t); }\nstruct D { mixin(rangeFuncs); int[] opSlice(size_t, size_t); }\nstatic assert(!hasSlicing!(A));\nstatic assert( hasSlicing!(B));\nstatic assert( hasSlicing!(C));\nstatic assert(!hasSlicing!(D));\n\nstruct InfOnes\n{\n    enum empty = false;\n    void popFront() {}\n    @property int front() { return 1; }\n    @property InfOnes save() { return this; }\n    auto opSlice(size_t i, size_t j) { return takeExactly(this, j - i); }\n    auto opSlice(size_t i, Dollar d) { return this; }\n\n    struct Dollar {}\n    Dollar opDollar() const { return Dollar.init; }\n}\n\nstatic assert(hasSlicing!InfOnes);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1532_3799)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "walkLength",
						"line": 1596,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 1608,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "walkLength",
				"line": 1596,
				"comment": "This is a best-effort implementation of $(D length) for any kind of\nrange.\n\nIf $(D hasLength!Range), simply returns $(D range.length) without\nchecking $(D upTo) (when specified).\n\nOtherwise, walks the range through its length and returns the number\nof elements seen. Performes $(BIGOH n) evaluations of $(D range.empty)\nand $(D range.popFront()), where $(D n) is the effective length of $(D\nrange).\n\nThe $(D upTo) parameter is useful to \"cut the losses\" in case\nthe interest is in seeing whether the range has at least some number\nof elements. If the parameter $(D upTo) is specified, stops if $(D\nupTo) steps have been taken and returns $(D upTo).\n\nInfinite ranges are compatible, provided the parameter $(D upTo) is\nspecified, in which case the implementation simply returns upTo.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && !isInfinite!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "walkLength",
						"line": 1610,
						"type": "(Range range, const size_t upTo)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "upTo",
								"type": "size_t",
								"storageClass": [
									"const"
								]
							}
						],
						"endline": 1624,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "walkLength",
				"line": 1610,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popFrontN",
						"line": 1667,
						"type": "size_t(ref Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1700,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "popFrontN",
				"line": 1667,
				"comment": "    Eagerly advances $(D r) itself (not a copy) up to $(D n) times (by\n    calling $(D r.popFront)). $(D popFrontN) takes $(D r) by $(D ref),\n    so it mutates the original range. Completes in $(BIGOH 1) steps for ranges\n    that support slicing and have length.\n    Completes in $(BIGOH n) time for all other ranges.\n\n    Returns:\n    How much $(D r) was actually advanced, which may be less than $(D n) if\n    $(D r) did not have at least $(D n) elements.\n\n    $(D popBackN) will behave the same but instead removes elements from\n    the back of the (bidirectional) range instead of the front.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1739_3801)\n---\nint[] a = [ 1, 2, 3, 4, 5 ];\na.popFrontN(2);\nassert(a == [ 3, 4, 5 ]);\na.popFrontN(7);\nassert(a == [ ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1739_3801)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1749_3802)\n---\nimport std.algorithm : equal;\nimport std.range : iota;\nauto LL = iota(1L, 7L);\nauto r = popFrontN(LL, 2);\nassert(equal(LL, [3L, 4L, 5L, 6L]));\nassert(r == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1749_3802)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1760_3803)\n---\nint[] a = [ 1, 2, 3, 4, 5 ];\na.popBackN(2);\nassert(a == [ 1, 2, 3 ]);\na.popBackN(7);\nassert(a == [ ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1760_3803)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1770_3804)\n---\nimport std.algorithm : equal;\nimport std.range : iota;\nauto LL = iota(1L, 7L);\nauto r = popBackN(LL, 2);\nassert(equal(LL, [1L, 2L, 3L, 4L]));\nassert(r == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1770_3804)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popBackN",
						"line": 1703,
						"type": "size_t(ref Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1736,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "popBackN",
				"line": 1703,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popFrontExactly",
						"line": 1798,
						"type": "void(ref Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1811,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "popFrontExactly",
				"line": 1798,
				"comment": "    Eagerly advances $(D r) itself (not a copy) exactly $(D n) times (by\n    calling $(D r.popFront)). $(D popFrontExactly) takes $(D r) by $(D ref),\n    so it mutates the original range. Completes in $(BIGOH 1) steps for ranges\n    that support slicing, and have either length or are infinite.\n    Completes in $(BIGOH n) time for all other ranges.\n\n    Note: Unlike $(LREF popFrontN), $(D popFrontExactly) will assume that the\n    range holds at least $(D n) elements. This makes $(D popFrontExactly)\n    faster than $(D popFrontN), but it also means that if $(D range) does\n    not contain at least $(D n) elements, it will attempt to call $(D popFront)\n    on an empty range, which is undefined behavior. So, only use\n    $(D popFrontExactly) when it is guaranteed that $(D range) holds at least\n    $(D n) elements.\n\n    $(D popBackExactly) will behave the same but instead removes elements from\n    the back of the (bidirectional) range instead of the front.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1830_3805)\n---\nimport std.algorithm : filterBidirectional, equal;\n\nauto a = [1, 2, 3];\na.popFrontExactly(1);\nassert(a == [2, 3]);\na.popBackExactly(1);\nassert(a == [2]);\n\nstring s = \"日本語\";\ns.popFrontExactly(1);\nassert(s == \"本語\");\ns.popBackExactly(1);\nassert(s == \"本\");\n\nauto bd = filterBidirectional!\"true\"([1, 2, 3]);\nbd.popFrontExactly(1);\nassert(bd.equal([2, 3]));\nbd.popBackExactly(1);\nassert(bd.equal([2]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1830_3805)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popBackExactly",
						"line": 1814,
						"type": "void(ref Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1827,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "popBackExactly",
				"line": 1814,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveFront",
						"line": 1858,
						"type": "ElementType!R(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 1871,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "moveFront",
				"line": 1858,
				"comment": "   Moves the front of $(D r) out and returns it. Leaves $(D r.front) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1874_3806)\n---\nauto a = [ 1, 2, 3 ];\nassert(moveFront(a) == 1);\n\n// define a perfunctory input range\nstruct InputRange\n{\n    @property bool empty() { return false; }\n    @property int front() { return 42; }\n    void popFront() {}\n    int moveFront() { return 43; }\n}\nInputRange r;\nassert(moveFront(r) == 43);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1874_3806)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveBack",
						"line": 1907,
						"type": "ElementType!R(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 1920,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "moveBack",
				"line": 1907,
				"comment": "   Moves the back of $(D r) out and returns it. Leaves $(D r.back) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1923_3808)\n---\nstruct TestRange\n{\n    int payload = 5;\n    @property bool empty() { return false; }\n    @property TestRange save() { return this; }\n    @property ref int front() return { return payload; }\n    @property ref int back() return { return payload; }\n    void popFront() { }\n    void popBack() { }\n}\nstatic assert(isBidirectionalRange!TestRange);\nTestRange r;\nauto x = moveBack(r);\nassert(x == 5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1923_3808)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveAt",
						"line": 1946,
						"type": "ElementType!R(R r, I i)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							},
							{
								"name": "i",
								"type": "I"
							}
						],
						"endline": 1959,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "moveAt",
				"line": 1946,
				"comment": "   Moves element at index $(D i) of $(D r) out and returns it. Leaves $(D\n   r.front) in a destroyable state that does not allocate any resources\n   (usually equal to its $(D .init) value).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1962_3809)\n---\nauto a = [1,2,3,4];\nforeach(idx, it; a)\n{\n    assert(it == moveAt(a, idx));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1962_3809)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!I",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "empty",
						"line": 1996,
						"type": "pure nothrow @nogc @property @safe bool(in T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1999,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "empty",
				"line": 1996,
				"comment": "Implements the range interface primitive $(D empty) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.empty) is\nequivalent to $(D empty(array)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2002_3811)\n---\nauto a = [ 1, 2, 3 ];\nassert(!a.empty);\nassert(a[3 .. $].empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2002_3811)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "save",
						"line": 2017,
						"type": "pure nothrow @nogc @property @safe T[](T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]"
							}
						],
						"endline": 2020,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "save",
				"line": 2017,
				"comment": "Implements the range interface primitive $(D save) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.save) is\nequivalent to $(D save(array)). The function does not duplicate the\ncontent of the array, it simply returns its argument.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2023_3812)\n---\nauto a = [ 1, 2, 3 ];\nauto b = a.save;\nassert(b is a);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2023_3812)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popFront",
						"line": 2039,
						"type": "pure nothrow @nogc @safe void(ref T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 2044,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "popFront",
				"line": 2039,
				"comment": "Implements the range interface primitive $(D popFront) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popFront) is\nequivalent to $(D popFront(array)). For $(GLOSSARY narrow strings),\n$(D popFront) automatically advances to the next $(GLOSSARY code\npoint).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2047_3813)\n---\nauto a = [ 1, 2, 3 ];\na.popFront();\nassert(a == [ 2, 3 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2047_3813)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!isNarrowString!(T[]) && !is(T[] == void[])",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popBack",
						"line": 2138,
						"type": "pure nothrow @nogc @safe void(ref T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 2143,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "popBack",
				"line": 2138,
				"comment": "Implements the range interface primitive $(D popBack) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popBack) is\nequivalent to $(D popBack(array)). For $(GLOSSARY narrow strings), $(D\npopFront) automatically eliminates the last $(GLOSSARY code point).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2146_3815)\n---\nauto a = [ 1, 2, 3 ];\na.popBack();\nassert(a == [ 1, 2 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2146_3815)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!isNarrowString!(T[]) && !is(T[] == void[])",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "front",
						"line": 2204,
						"type": "pure nothrow @nogc @property ref @safe T(T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]"
							}
						],
						"endline": 2209,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "front",
				"line": 2204,
				"comment": "Implements the range interface primitive $(D front) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.front) is\nequivalent to $(D front(array)). For $(GLOSSARY narrow strings), $(D\nfront) automatically returns the first $(GLOSSARY code point) as a $(D\ndchar).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2212_3817)\n---\nint[] a = [ 1, 2, 3 ];\nassert(a.front == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2212_3817)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!isNarrowString!(T[]) && !is(T[] == void[])",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "back",
						"line": 2248,
						"type": "pure nothrow @nogc @property ref @safe T(T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]"
							}
						],
						"endline": 2253,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "back",
				"line": 2248,
				"comment": "Implements the range interface primitive $(D back) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.back) is\nequivalent to $(D back(array)). For $(GLOSSARY narrow strings), $(D\nback) automatically returns the last $(GLOSSARY code point) as a $(D\ndchar).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2256_3819)\n---\nint[] a = [ 1, 2, 3 ];\nassert(a.back == 3);\na.back += 4;\nassert(a.back == 7);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2256_3819)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!isNarrowString!(T[])",
				"char": 17,
				"kind": "template"
			}
		],
		"comment": "This module is a submodule of $(LINK2 std_range.html, std.range).\n\nIt provides basic range functionality by defining several templates for testing\nwhether a given object is a _range, and what kind of _range it is:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF isInputRange)))\n        $(TD Tests if something is an $(I input _range), defined to be\n        something from which one can sequentially read data using the\n        primitives $(D front), $(D popFront), and $(D empty).\n    ))\n    $(TR $(TD $(D $(LREF isOutputRange)))\n        $(TD Tests if something is an $(I output _range), defined to be\n        something to which one can sequentially write data using the\n        $(D $(LREF put)) primitive.\n    ))\n    $(TR $(TD $(D $(LREF isForwardRange)))\n        $(TD Tests if something is a $(I forward _range), defined to be an\n        input _range with the additional capability that one can save one's\n        current position with the $(D save) primitive, thus allowing one to\n        iterate over the same _range multiple times.\n    ))\n    $(TR $(TD $(D $(LREF isBidirectionalRange)))\n        $(TD Tests if something is a $(I bidirectional _range), that is, a\n        forward _range that allows reverse traversal using the primitives $(D\n        back) and $(D popBack).\n    ))\n    $(TR $(TD $(D $(LREF isRandomAccessRange)))\n        $(TD Tests if something is a $(I random access _range), which is a\n        bidirectional _range that also supports the array subscripting\n        operation via the primitive $(D opIndex).\n    ))\n)\n\nIt also provides number of templates that test for various _range capabilities:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF hasMobileElements)))\n        $(TD Tests if a given _range's elements can be moved around using the\n        primitives $(D moveFront), $(D moveBack), or $(D moveAt).\n    ))\n    $(TR $(TD $(D $(LREF ElementType)))\n        $(TD Returns the element type of a given _range.\n    ))\n    $(TR $(TD $(D $(LREF ElementEncodingType)))\n        $(TD Returns the encoding element type of a given _range.\n    ))\n    $(TR $(TD $(D $(LREF hasSwappableElements)))\n        $(TD Tests if a _range is a forward _range with swappable elements.\n    ))\n    $(TR $(TD $(D $(LREF hasAssignableElements)))\n        $(TD Tests if a _range is a forward _range with mutable elements.\n    ))\n    $(TR $(TD $(D $(LREF hasLvalueElements)))\n        $(TD Tests if a _range is a forward _range with elements that can be\n        passed by reference and have their address taken.\n    ))\n    $(TR $(TD $(D $(LREF hasLength)))\n        $(TD Tests if a given _range has the $(D length) attribute.\n    ))\n    $(TR $(TD $(D $(LREF isInfinite)))\n        $(TD Tests if a given _range is an $(I infinite _range).\n    ))\n    $(TR $(TD $(D $(LREF hasSlicing)))\n        $(TD Tests if a given _range supports the array slicing operation $(D\n        R[x..y]).\n    ))\n)\n\nFinally, it includes some convenience functions for manipulating ranges:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF popFrontN)))\n        $(TD Advances a given _range by up to $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF popBackN)))\n        $(TD Advances a given bidirectional _range from the right by up to\n        $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF popFrontExactly)))\n        $(TD Advances a given _range by up exactly $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF popBackExactly)))\n        $(TD Advances a given bidirectional _range from the right by exactly\n        $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF moveFront)))\n        $(TD Removes the front element of a _range.\n    ))\n    $(TR $(TD $(D $(LREF moveBack)))\n        $(TD Removes the back element of a bidirectional _range.\n    ))\n    $(TR $(TD $(D $(LREF moveAt)))\n        $(TD Removes the $(I i)'th element of a random-access _range.\n    ))\n    $(TR $(TD $(D $(LREF walkLength)))\n        $(TD Computes the length of any _range in O(n) time.\n    ))\n)\n\nSource: $(PHOBOSSRC std/range/_primitives.d)\n\nMacros:\n\nWIKI = Phobos/StdRange\n\nCopyright: Copyright by authors 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu), David Simcha,\nand Jonathan M Davis. Credit for some of the ideas in building this module goes\nto $(WEB fantascienza.net/leonardo/so/, Leonardo Maffi).\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/net/curl.d",
		"name": "std.net.curl",
		"members": [
			{
				"name": "AutoProtocol",
				"line": 371,
				"comment": "Macros:\n\nCALLBACK_PARAMS = $(TABLE ,\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM dlTotal))\n        $(DDOC_PARAM_DESC total bytes to download)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM dlNow))\n        $(DDOC_PARAM_DESC currently downloaded bytes)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM ulTotal))\n        $(DDOC_PARAM_DESC total bytes to upload)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM ulNow))\n        $(DDOC_PARAM_DESC currently uploaded bytes)\n        )\n)\n\n Connection type used when the URL should be used to auto detect the protocol.\n\n This struct is used as placeholder for the connection parameter when calling\n the high level API and the connection type (HTTP/FTP) should be guessed by\n inspecting the URL parameter.\n\n The rules for guessing the protocol are:\n 1, if URL starts with ftp://, ftps:// or ftp. then FTP connection is assumed.\n 2, HTTP connection otherwise.\n\n Example:\n ---\n import std.net.curl;\n // Two requests below will do the same.\n string content;\n\n // Explicit connection provided\n content = get!HTTP(\"dlang.org\");\n\n // Guess connection type by looking at the URL\n content = get!AutoProtocol(\"ftp://foo.com/file\");\n // and since AutoProtocol is default this is the same as\n connect = get(\"ftp://foo.com/file\");\n // and will end up detecting FTP from the url and be the same as\n connect = get!FTP(\"ftp://foo.com/file\");\n ---\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "download",
						"line": 400,
						"type": "void(const(char)[] url, string saveToPath, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "saveToPath",
								"type": "string"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 418,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "download",
				"line": 400,
				"comment": " HTTP/FTP download to local file system.\n\n Params:\n url = resource to download\n saveToPath = path to store the downloaded content on local disk\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n Example:\n ----\n import std.net.curl;\n download(\"d-lang.appspot.com/testUrl2\", \"/tmp/downloaded-http-file\");\n ----\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "upload",
						"line": 450,
						"type": "void(string loadFromPath, const(char)[] url, Conn conn = Conn())",
						"parameters": [
							{
								"name": "loadFromPath",
								"type": "string"
							},
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 480,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "upload",
				"line": 450,
				"comment": " Upload file from local files system using the HTTP or FTP protocol.\n\n Params:\n loadFromPath = path load data from local disk.\n url = resource to upload to\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n Example:\n ----\n import std.net.curl;\n upload(\"/tmp/downloaded-ftp-file\", \"ftp.digitalmars.com/sieve.ds\");\n upload(\"/tmp/downloaded-http-file\", \"d-lang.appspot.com/testUrl2\");\n ----\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "get",
						"line": 527,
						"type": "T[](const(char)[] url, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 547,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "get",
				"line": 527,
				"comment": " HTTP/FTP get content.\n\n Params:\n url = resource to get\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]). If asking\n for $(D char), content will be converted from the connection character set\n (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n by default) to UTF-8.\n\n Example:\n ----\n import std.net.curl;\n auto content = get(\"d-lang.appspot.com/testUrl2\");\n ----\n\n Returns:\n A T[] range containing the content of the resource pointed to by the URL.\n\n Throws:\n\n $(D CurlException) on error.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn && (is(T == char) || is(T == ubyte))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "post",
						"line": 589,
						"type": "T[](const(char)[] url, const(PostUnit)[] postData, HTTP conn = HTTP())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "postData",
								"type": "const(PostUnit)[]"
							},
							{
								"name": "conn",
								"type": "HTTP",
								"default": "HTTP()"
							}
						],
						"endline": 594,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "post",
				"line": 589,
				"comment": " HTTP post content.\n\n Params:\n url = resource to post to\n postData = data to send as the body of the request. An array\n            of an arbitrary type is accepted and will be cast to ubyte[]\n            before sending it.\n conn = HTTP connection to use\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]). If asking\n for $(D char), content will be converted from the connection character set\n (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n by default) to UTF-8.\n\n Example:\n ----\n import std.net.curl;\n auto content = post(\"d-lang.appspot.com/testUrl2\", [1,2,3,4]);\n ----\n\n Returns:\n A T[] range containing the content of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					},
					{
						"name": "PostUnit",
						"kind": "type"
					}
				],
				"constraint": "is(T == char) || is(T == ubyte)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "put",
						"line": 656,
						"type": "T[](const(char)[] url, const(PutUnit)[] putData, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "putData",
								"type": "const(PutUnit)[]"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 676,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "put",
				"line": 656,
				"comment": " HTTP/FTP put content.\n\n Params:\n url = resource to put\n putData = data to send as the body of the request. An array\n           of an arbitrary type is accepted and will be cast to ubyte[]\n           before sending it.\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]). If asking\n for $(D char), content will be converted from the connection character set\n (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n by default) to UTF-8.\n\n Example:\n ----\n import std.net.curl;\n auto content = put(\"d-lang.appspot.com/testUrl2\",\n                      \"Putting this data\");\n ----\n\n Returns:\n A T[] range containing the content of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					},
					{
						"name": "PutUnit",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn && (is(T == char) || is(T == ubyte))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "del",
						"line": 709,
						"type": "void(const(char)[] url, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 738,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "del",
				"line": 709,
				"comment": " HTTP/FTP delete content.\n\n Params:\n url = resource to delete\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n Example:\n ----\n import std.net.curl;\n del(\"d-lang.appspot.com/testUrl2\");\n ----\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "options",
						"line": 777,
						"type": "T[](const(char)[] url, HTTP conn = HTTP())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "HTTP",
								"default": "HTTP()"
							}
						],
						"endline": 782,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "options",
				"line": 777,
				"comment": " HTTP options request.\n\n Params:\n url = resource make a option call to\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n\n Example:\n ----\n import std.net.curl;\n auto http = HTTP();\n options(\"d-lang.appspot.com/testUrl2\", http);\n writeln(\"Allow set to \" ~ http.responseHeaders[\"Allow\"]);\n ----\n\n Returns:\n A T[] range containing the options of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == char) || is(T == ubyte)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "trace",
						"line": 827,
						"type": "T[](const(char)[] url, HTTP conn = HTTP())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "HTTP",
								"default": "HTTP()"
							}
						],
						"endline": 832,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "trace",
				"line": 827,
				"comment": " HTTP trace request.\n\n Params:\n url = resource make a trace call to\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n\n Example:\n ----\n import std.net.curl;\n trace(\"d-lang.appspot.com/testUrl1\");\n ----\n\n Returns:\n A T[] range containing the trace info of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == char) || is(T == ubyte)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "connect",
						"line": 866,
						"type": "T[](const(char)[] url, HTTP conn = HTTP())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "HTTP",
								"default": "HTTP()"
							}
						],
						"endline": 871,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "connect",
				"line": 866,
				"comment": " HTTP connect request.\n\n Params:\n url = resource make a connect to\n conn = HTTP connection to use\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n\n Example:\n ----\n import std.net.curl;\n connect(\"d-lang.appspot.com/testUrl1\");\n ----\n\n Returns:\n A T[] range containing the connect info of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == char) || is(T == ubyte)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "patch",
						"line": 909,
						"type": "T[](const(char)[] url, const(PatchUnit)[] patchData, HTTP conn = HTTP())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "patchData",
								"type": "const(PatchUnit)[]"
							},
							{
								"name": "conn",
								"type": "HTTP",
								"default": "HTTP()"
							}
						],
						"endline": 915,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "patch",
				"line": 909,
				"comment": " HTTP patch content.\n\n Params:\n url = resource to patch\n patchData = data to send as the body of the request. An array\n           of an arbitrary type is accepted and will be cast to ubyte[]\n           before sending it.\n conn = HTTP connection to use\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n\n Example:\n ----\n auto http = HTTP();\n http.addRequestHeader(\"Content-Type\", \"application/json\");\n auto content = patch(\"d-lang.appspot.com/testUrl2\", `{\"title\": \"Patched Title\"}`, http);\n ----\n\n Returns:\n A T[] range containing the content of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					},
					{
						"name": "PatchUnit",
						"kind": "type"
					}
				],
				"constraint": "is(T == char) || is(T == ubyte)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byLine",
						"line": 1188,
						"type": "(const(char)[] url, KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a', Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "keepTerminator",
								"type": "KeepTerminator",
								"default": "KeepTerminator.no"
							},
							{
								"name": "terminator",
								"type": "Terminator",
								"default": "'\\x0a'"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1256,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byLine",
				"line": 1188,
				"comment": " HTTP/FTP fetch content as a range of lines.\n\n A range of lines is returned when the request is complete. If the method or\n other request properties is to be customized then set the $(D conn) parameter\n with a HTTP/FTP instance that has these properties set.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n foreach (line; byLine(\"dlang.org\"))\n     writeln(line);\n ----\n\n Params:\n url = The url to receive content from\n keepTerminator = KeepTerminator.yes signals that the line terminator should be\n                  returned as part of the lines in the range.\n terminator = The character that terminates a line\n conn = The connection to use e.g. HTTP or FTP.\n\n Returns:\n A range of Char[] with the content of the resource pointer to by the URL\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Terminator",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn && isSomeChar!Char && isSomeChar!Terminator",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byChunk",
						"line": 1291,
						"type": "(const(char)[] url, size_t chunkSize = 1024, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "chunkSize",
								"type": "size_t",
								"default": "1024"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1328,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byChunk",
				"line": 1291,
				"comment": " HTTP/FTP fetch content as a range of chunks.\n\n A range of chunks is returned when the request is complete. If the method or\n other request properties is to be customized then set the $(D conn) parameter\n with a HTTP/FTP instance that has these properties set.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n foreach (chunk; byChunk(\"dlang.org\", 100))\n     writeln(chunk); // chunk is ubyte[100]\n ----\n\n Params:\n url = The url to receive content from\n chunkSize = The size of each chunk\n conn = The connection to use e.g. HTTP or FTP.\n\n Returns:\n A range of ubyte[chunkSize] with the content of the resource pointer to by the URL\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byLineAsync",
						"line": 1568,
						"type": "(const(char)[] url, const(PostUnit)[] postData, KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a', size_t transmitBuffers = 10, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "postData",
								"type": "const(PostUnit)[]"
							},
							{
								"name": "keepTerminator",
								"type": "KeepTerminator",
								"default": "KeepTerminator.no"
							},
							{
								"name": "terminator",
								"type": "Terminator",
								"default": "'\\x0a'"
							},
							{
								"name": "transmitBuffers",
								"type": "size_t",
								"default": "10"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1598,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byLineAsync",
				"line": 1568,
				"comment": " HTTP/FTP fetch content as a range of lines asynchronously.\n\n A range of lines is returned immediately and the request that fetches the\n lines is performed in another thread. If the method or other request\n properties is to be customized then set the $(D conn) parameter with a\n HTTP/FTP instance that has these properties set.\n\n If $(D postData) is non-_null the method will be set to $(D post) for HTTP\n requests.\n\n The background thread will buffer up to transmitBuffers number of lines\n before it stops receiving data from network. When the main thread reads the\n lines from the range it frees up buffers and allows for the background thread\n to receive more data from the network.\n\n If no data is available and the main thread accesses the range it will block\n until data becomes available. An exception to this is the $(D wait(Duration)) method on\n the $(LREF AsyncLineInputRange). This method will wait at maximum for the\n specified duration and return true if data is available.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n // Get some pages in the background\n auto range1 = byLineAsync(\"www.google.com\");\n auto range2 = byLineAsync(\"www.wikipedia.org\");\n foreach (line; byLineAsync(\"dlang.org\"))\n     writeln(line);\n\n // Lines already fetched in the background and ready\n foreach (line; range1) writeln(line);\n foreach (line; range2) writeln(line);\n ----\n\n ----\n import std.net.curl, std.stdio;\n // Get a line in a background thread and wait in\n // main thread for 2 seconds for it to arrive.\n auto range3 = byLineAsync(\"dlang.com\");\n if (range.wait(dur!\"seconds\"(2)))\n     writeln(range.front);\n else\n     writeln(\"No line received after 2 seconds!\");\n ----\n\n Params:\n url = The url to receive content from\n postData = Data to HTTP Post\n keepTerminator = KeepTerminator.yes signals that the line terminator should be\n                  returned as part of the lines in the range.\n terminator = The character that terminates a line\n transmitBuffers = The number of lines buffered asynchronously\n conn = The connection to use e.g. HTTP or FTP.\n\n Returns:\n A range of Char[] with the content of the resource pointer to by the\n URL.\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Terminator",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "PostUnit",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn && isSomeChar!Char && isSomeChar!Terminator",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byLineAsync",
						"line": 1601,
						"type": "(const(char)[] url, KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a', size_t transmitBuffers = 10, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "keepTerminator",
								"type": "KeepTerminator",
								"default": "KeepTerminator.no"
							},
							{
								"name": "terminator",
								"type": "Terminator",
								"default": "'\\x0a'"
							},
							{
								"name": "transmitBuffers",
								"type": "size_t",
								"default": "10"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1620,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byLineAsync",
				"line": 1601,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Terminator",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Char",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byChunkAsync",
						"line": 1720,
						"type": "(const(char)[] url, const(PostUnit)[] postData, size_t chunkSize = 1024, size_t transmitBuffers = 10, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "postData",
								"type": "const(PostUnit)[]"
							},
							{
								"name": "chunkSize",
								"type": "size_t",
								"default": "1024"
							},
							{
								"name": "transmitBuffers",
								"type": "size_t",
								"default": "10"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1746,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byChunkAsync",
				"line": 1720,
				"comment": " HTTP/FTP fetch content as a range of chunks asynchronously.\n\n A range of chunks is returned immediately and the request that fetches the\n chunks is performed in another thread. If the method or other request\n properties is to be customized then set the $(D conn) parameter with a\n HTTP/FTP instance that has these properties set.\n\n If $(D postData) is non-_null the method will be set to $(D post) for HTTP\n requests.\n\n The background thread will buffer up to transmitBuffers number of chunks\n before is stops receiving data from network. When the main thread reads the\n chunks from the range it frees up buffers and allows for the background\n thread to receive more data from the network.\n\n If no data is available and the main thread access the range it will block\n until data becomes available. An exception to this is the $(D wait(Duration))\n method on the $(LREF AsyncChunkInputRange). This method will wait at maximum for the specified\n duration and return true if data is available.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n // Get some pages in the background\n auto range1 = byChunkAsync(\"www.google.com\", 100);\n auto range2 = byChunkAsync(\"www.wikipedia.org\");\n foreach (chunk; byChunkAsync(\"dlang.org\"))\n     writeln(chunk); // chunk is ubyte[100]\n\n // Chunks already fetched in the background and ready\n foreach (chunk; range1) writeln(chunk);\n foreach (chunk; range2) writeln(chunk);\n ----\n\n ----\n import std.net.curl, std.stdio;\n // Get a line in a background thread and wait in\n // main thread for 2 seconds for it to arrive.\n auto range3 = byChunkAsync(\"dlang.com\", 10);\n if (range.wait(dur!\"seconds\"(2)))\n     writeln(range.front);\n else\n     writeln(\"No chunk received after 2 seconds!\");\n ----\n\n Params:\n url = The url to receive content from\n postData = Data to HTTP Post\n chunkSize = The size of the chunks\n transmitBuffers = The number of chunks buffered asynchronously\n conn = The connection to use e.g. HTTP or FTP.\n\n Returns:\n A range of ubyte[chunkSize] with the content of the resource pointer to by\n the URL.\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"name": "PostUnit",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byChunkAsync",
						"line": 1749,
						"type": "(const(char)[] url, size_t chunkSize = 1024, size_t transmitBuffers = 10, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "chunkSize",
								"type": "size_t",
								"default": "1024"
							},
							{
								"name": "transmitBuffers",
								"type": "size_t",
								"default": "10"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1769,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byChunkAsync",
				"line": 1749,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"name": "HTTP",
				"line": 2302,
				"comment": " HTTP client functionality.\n\n Example:\n ---\n import std.net.curl, std.stdio;\n\n // Get with custom data receivers\n auto http = HTTP(\"dlang.org\");\n http.onReceiveHeader =\n     (in char[] key, in char[] value) { writeln(key ~ \": \" ~ value); };\n http.onReceive = (ubyte[] data) { /+ drop +/ return data.length; };\n http.perform();\n\n // Put with data senders\n auto msg = \"Hello world\";\n http.contentLength = msg.length;\n http.onSend = (void[] data)\n {\n     auto m = cast(void[])msg;\n     size_t len = m.length > data.length ? data.length : m.length;\n     if (len == 0) return len;\n     data[0..len] = m[0..len];\n     msg = msg[len..$];\n     return len;\n };\n http.perform();\n\n // Track progress\n http.method = HTTP.Method.get;\n http.url = \"http://upload.wikimedia.org/wikipedia/commons/\"\n            \"5/53/Wikipedia-logo-en-big.png\";\n http.onReceive = (ubyte[] data) { return data.length; };\n http.onProgress = (size_t dltotal, size_t dlnow,\n                    size_t ultotal, size_t ulnow)\n {\n     writeln(\"Progress \", dltotal, \", \", dlnow, \", \", ultotal, \", \", ulnow);\n     return 0;\n };\n http.perform();\n ---\n\n See_Also: $(WEB www.ietf.org/rfc/rfc2616.txt, RFC2616)\n\n",
				"members": [
					{
						"name": "AuthMethod",
						"line": 2307,
						"comment": "Authentication method equal to $(ECXREF curl, CurlAuth)\n",
						"deco": "E3etc1c4curl8CurlAuth",
						"char": 5,
						"kind": "alias"
					},
					{
						"name": "TimeCond",
						"line": 2402,
						"comment": " Time condition enumeration as an alias of $(ECXREF curl, CurlTimeCond)\n\n        $(WEB www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25, _RFC2616 Section 14.25)\n",
						"deco": "E3etc1c4curl12CurlTimeCond",
						"char": 5,
						"kind": "alias"
					},
					{
						"endchar": 5,
						"name": "opCall",
						"line": 2407,
						"comment": "       Constructor taking the url as parameter.\n",
						"deco": "FAxaZS3std3net4curl4HTTP",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 2413,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "perform",
						"line": 2465,
						"comment": "       Perform a http request.\n\n       After the HTTP client has been setup and possibly assigned callbacks the\n       $(D perform()) method will start performing the request towards the\n       specified server.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n",
						"deco": "FE3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4FlagZi",
						"parameters": [
							{
								"name": "throwOnError",
								"deco": "E3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4Flag",
								"default": "cast(Flag)true"
							}
						],
						"endline": 2513,
						"originalType": "CurlCode(ThrowOnError throwOnError = ThrowOnError.yes)",
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "url",
						"line": 2516,
						"comment": "The URL to specify the location of the resource.\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 2521,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "caInfo",
						"line": 2524,
						"comment": "Set the CA certificate bundle file to use for SSL peer verification\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "caFile",
								"deco": "Axa"
							}
						],
						"endline": 2527,
						"char": 20,
						"kind": "function"
					},
					{
						"name": "requestPause",
						"line": 2535,
						"comment": "Value to return from $(D onSend)/$(D onReceive) delegates in order to\n\npause a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "requestAbort",
						"line": 2538,
						"comment": "Value to return from onSend delegate in order to abort a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "isStopped",
						"line": 2543,
						"comment": "           True if the instance is stopped. A stopped instance is not usable.\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "shutdown",
						"line": 2546,
						"comment": "Stop and invalidate this instance.\n",
						"deco": "FZv",
						"char": 14,
						"kind": "function"
					},
					{
						"name": "verbose",
						"line": 2551,
						"comment": " Set verbose.\n            This will print request information to stderr.\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dataTimeout",
						"line": 2556,
						"comment": "Set timeout for activity on connection.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "operationTimeout",
						"line": 2561,
						"comment": " Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "connectTimeout",
						"line": 2564,
						"comment": "Set timeout for connecting.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxy",
						"line": 2571,
						"comment": " Proxy\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "host",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxyPort",
						"line": 2576,
						"comment": " Proxy port\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "CurlProxy",
						"line": 2579,
						"comment": "Type of proxy\n",
						"deco": "E3etc1c4curl9CurlProxy",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "proxyType",
						"line": 2584,
						"comment": " Proxy type\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n",
						"deco": "FNdE3etc1c4curl9CurlProxyZv",
						"parameters": [
							{
								"name": "type",
								"deco": "E3etc1c4curl9CurlProxy"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dnsTimeout",
						"line": 2587,
						"comment": "DNS lookup timeout.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 2600,
						"comment": " The network interface to use in form of the the IP of the interface.\n\n Example:\n ----\n theprotocol.netInterface = \"192.168.1.32\";\n theprotocol.netInterface = [ 192, 168, 1, 32 ];\n ----\n\n See: $(XREF socket, InternetAddress)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "i",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 2603,
						"comment": "ditto\n",
						"deco": "FNdxG4hZv",
						"parameters": [
							{
								"name": "i",
								"deco": "xG4h"
							}
						],
						"originalType": "@property void(const(ubyte)[4] i)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 2606,
						"comment": "ditto\n",
						"deco": "FNdC3std6socket15InternetAddressZv",
						"parameters": [
							{
								"name": "i",
								"deco": "C3std6socket15InternetAddress"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPort",
						"line": 2613,
						"comment": "           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPortRange",
						"line": 2622,
						"comment": "           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "range",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "tcpNoDelay",
						"line": 2627,
						"comment": " Set the tcp no-delay socket option on or off.\n            See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "setAuthentication",
						"line": 2644,
						"comment": "           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n",
						"deco": "FAxaAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							},
							{
								"name": "domain",
								"deco": "Axa",
								"default": "\"\""
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "setProxyAuthentication",
						"line": 2654,
						"comment": "           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n",
						"deco": "FAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "onSend",
						"line": 2686,
						"comment": " The event handler that gets called when data is needed for sending. The\n length of the $(D void[]) specifies the maximum number of bytes that can\n be sent.\n\n Returns:\n The callback returns the number of elements in the buffer that have been\n filled and are ready to send.\n The special value $(D .abortRequest) can be returned in order to abort the\n current request.\n The special value $(D .pauseRequest) can be returned in order to pause the\n current request.\n\n Example:\n ----\n import std.net.curl;\n string msg = \"Hello world\";\n auto client = HTTP(\"dlang.org\");\n client.onSend = delegate size_t(void[] data)\n {\n     auto m = cast(void[])msg;\n     size_t length = m.length > data.length ? data.length : m.length;\n     if (length == 0) return 0;\n     data[0..length] = m[0..length];\n     msg = msg[length..$];\n     return length;\n };\n client.perform();\n ----\n",
						"deco": "FNdDFAvZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAvZm"
							}
						],
						"originalType": "@property void(size_t delegate(void[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onReceive",
						"line": 2711,
						"comment": " The event handler that receives incoming data. Be sure to copy the\n incoming ubyte[] since it is not guaranteed to be valid after the\n callback returns.\n\n Returns:\n The callback returns the incoming bytes read. If not the entire array is\n the request will abort.\n The special value .pauseRequest can be returned in order to pause the\n current request.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n auto client = HTTP(\"dlang.org\");\n client.onReceive = (ubyte[] data)\n {\n     writeln(\"Got data\", to!(const(char)[])(data));\n     return data.length;\n };\n client.perform();\n ----\n",
						"deco": "FNdDFAhZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAhZm"
							}
						],
						"originalType": "@property void(size_t delegate(ubyte[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onProgress",
						"line": 2735,
						"comment": " Register an event handler that gets called to inform of\n upload/download progress.\n\n Callback_parameters:\n $(CALLBACK_PARAMS)\n\n Callback_returns: Return 0 to signal success, return non-zero to\n abort transfer.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n auto client = HTTP(\"dlang.org\");\n client.onProgress = delegate int(size_t dl, size_t dln, size_t ul, size_t ult)\n {\n     writeln(\"Progress: downloaded \", dln, \" of \", dl);\n     writeln(\"Progress: uploaded \", uln, \" of \", ul);\n };\n client.perform();\n ----\n",
						"deco": "FNdDFmmmmZiZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFmmmmZi"
							}
						],
						"originalType": "@property void(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearRequestHeaders",
						"line": 2741,
						"comment": " Clear all outgoing headers.\n",
						"deco": "FZv",
						"endline": 2747,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "addRequestHeader",
						"line": 2762,
						"comment": " Add a header e.g. \"X-CustomField: Something is fishy\".\n\n There is no remove header functionality. Do a $(LREF clearRequestHeaders)\n and set the needed headers instead.\n\n Example:\n ---\n import std.net.curl;\n auto client = HTTP();\n client.addRequestHeader(\"X-Custom-ABC\", \"This is the custom value\");\n auto content = get(\"dlang.org\", client);\n ---\n",
						"deco": "FAxaAxaZv",
						"parameters": [
							{
								"name": "name",
								"deco": "Axa"
							},
							{
								"name": "value",
								"deco": "Axa"
							}
						],
						"endline": 2770,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "defaultUserAgent",
						"line": 2776,
						"comment": " The default \"User-Agent\" value send with a request.\n It has the form \"Phobos-std.net.curl/$(I PHOBOS_VERSION) (libcurl/$(I CURL_VERSION))\"\n",
						"deco": "FNdZAya",
						"endline": 2795,
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "setUserAgent",
						"line": 2803,
						"comment": " Set the value of the user agent request header field.\n\n By default a request has it's \"User-Agent\" field set to $(LREF\n defaultUserAgent) even if $(D setUserAgent) was never called.  Pass\n an empty string to suppress the \"User-Agent\" field altogether.\n",
						"deco": "FAxaZv",
						"parameters": [
							{
								"name": "userAgent",
								"deco": "Axa"
							}
						],
						"endline": 2806,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "responseHeaders",
						"line": 2811,
						"comment": " The headers read from a successful response.\n\n",
						"deco": "FNdZHAyaAya",
						"endline": 2814,
						"char": 30,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "method",
						"line": 2817,
						"comment": "HTTP method used.\n",
						"deco": "FNdE3std3net4curl4HTTP6MethodZv",
						"parameters": [
							{
								"name": "m",
								"deco": "E3std3net4curl4HTTP6Method"
							}
						],
						"endline": 2820,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "method",
						"line": 2823,
						"comment": "ditto\n",
						"deco": "FNdZE3std3net4curl4HTTP6Method",
						"endline": 2826,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "statusLine",
						"line": 2832,
						"comment": "       HTTP status line of last response. One call to perform may\n       result in several requests because of redirection.\n",
						"deco": "FNdZS3std3net4curl4HTTP10StatusLine",
						"endline": 2835,
						"char": 26,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setCookie",
						"line": 2838,
						"comment": "Set the active cookie string e.g. \"name1=value1;name2=value2\"\n",
						"deco": "FAxaZv",
						"parameters": [
							{
								"name": "cookie",
								"deco": "Axa"
							}
						],
						"endline": 2841,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setCookieJar",
						"line": 2844,
						"comment": "Set a file path to where a cookie jar should be read/stored.\n",
						"deco": "FAxaZv",
						"parameters": [
							{
								"name": "path",
								"deco": "Axa"
							}
						],
						"endline": 2849,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "flushCookieJar",
						"line": 2852,
						"comment": "Flush cookie jar to disk.\n",
						"deco": "FZv",
						"endline": 2855,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearSessionCookies",
						"line": 2858,
						"comment": "Clear session cookies.\n",
						"deco": "FZv",
						"endline": 2861,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearAllCookies",
						"line": 2864,
						"comment": "Clear all cookies.\n",
						"deco": "FZv",
						"endline": 2867,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setTimeCondition",
						"line": 2878,
						"comment": "       Set time condition on the request.\n\n       Params:\n       cond =  $(D CurlTimeCond.{none,ifmodsince,ifunmodsince,lastmod})\n       timestamp = Timestamp for the condition\n\n       $(WEB www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25, _RFC2616 Section 14.25)\n",
						"deco": "FE3etc1c4curl12CurlTimeCondS3std8datetime7SysTimeZv",
						"parameters": [
							{
								"name": "cond",
								"deco": "E3etc1c4curl12CurlTimeCond"
							},
							{
								"name": "timestamp",
								"deco": "S3std8datetime7SysTime"
							}
						],
						"endline": 2882,
						"originalType": "void(HTTP.TimeCond cond, SysTime timestamp)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "postData",
						"line": 2899,
						"comment": " Specifying data to post when not using the onSend callback.\n\n The data is NOT copied by the library.  Content-Type will default to\n application/octet-stream.  Data is not converted or encoded by this\n method.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n auto http = HTTP(\"http://www.mydomain.com\");\n http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n http.postData = [1,2,3,4,5];\n http.perform();\n ----\n",
						"deco": "FNdAxvZv",
						"parameters": [
							{
								"name": "data",
								"deco": "Axv"
							}
						],
						"endline": 2902,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "postData",
						"line": 2918,
						"comment": " Specifying data to post when not using the onSend callback.\n\n The data is NOT copied by the library.  Content-Type will default to\n text/plain.  Data is not converted or encoded by this method.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n auto http = HTTP(\"http://www.mydomain.com\");\n http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n http.postData = \"The quick....\";\n http.perform();\n ----\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "data",
								"deco": "Axa"
							}
						],
						"endline": 2921,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setPostData",
						"line": 2941,
						"comment": " Specify data to post when not using the onSend callback, with\n user-specified Content-Type.\n Params:\n  data = Data to post.\n  contentType = MIME type of the data, for example, \"text/plain\" or\n      \"application/octet-stream\". See also:\n      $(LINK2 http://en.wikipedia.org/wiki/Internet_media_type,\n      Internet media type) on Wikipedia.\n -----\n import std.net.curl;\n auto http = HTTP(\"http://onlineform.example.com\");\n auto data = \"app=login&username=bob&password=s00perS3kret\";\n http.setPostData(data, \"application/x-www-form-urlencoded\");\n http.onReceive = (ubyte[] data) { return data.length; };\n http.perform();\n -----\n",
						"deco": "FAxvAyaZv",
						"parameters": [
							{
								"name": "data",
								"deco": "Axv"
							},
							{
								"name": "contentType",
								"deco": "Aya"
							}
						],
						"endline": 2950,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onReceiveHeader",
						"line": 2988,
						"comment": " Set the event handler that receives incoming headers.\n\n The callback will receive a header field key, value as parameter. The\n $(D const(char)[]) arrays are not valid after the delegate has returned.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n auto http = HTTP(\"dlang.org\");\n http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n http.onReceiveHeader = (in char[] key, in char[] value) { writeln(key, \" = \", value); };\n http.perform();\n ----\n",
						"deco": "FNdDFxAaxAaZvZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFxAaxAaZv"
							}
						],
						"endline": 2992,
						"originalType": "@property void(void delegate(in char[] key, in char[] value) callback)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onReceiveStatusLine",
						"line": 3002,
						"comment": "       Callback for each received StatusLine.\n\n       Notice that several callbacks can be done for each call to\n       $(D perform()) due to redirections.\n\n       See_Also: $(LREF StatusLine)\n",
						"deco": "FNdDFS3std3net4curl4HTTP10StatusLineZvZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFS3std3net4curl4HTTP10StatusLineZv"
							}
						],
						"endline": 3005,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "contentLength",
						"line": 3012,
						"comment": "       The content length in bytes when using request that has content\n       e.g. POST/PUT and not using chunked transfer. Is set as the\n       \"Content-Length\" header.  Set to ulong.max to reset to chunked transfer.\n",
						"deco": "FNdmZv",
						"parameters": [
							{
								"name": "len",
								"deco": "m"
							}
						],
						"endline": 3039,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "authenticationMethod",
						"line": 3044,
						"comment": "       Authentication method as specified in $(LREF AuthMethod).\n",
						"deco": "FNdE3etc1c4curl8CurlAuthZv",
						"parameters": [
							{
								"name": "authMethod",
								"deco": "E3etc1c4curl8CurlAuth"
							}
						],
						"endline": 3047,
						"originalType": "@property void(AuthMethod authMethod)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "maxRedirects",
						"line": 3053,
						"comment": "       Set max allowed redirections using the location header.\n       uint.max for infinite.\n",
						"deco": "FNdkZv",
						"parameters": [
							{
								"name": "maxRedirs",
								"deco": "k"
							}
						],
						"endline": 3065,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"name": "head",
								"line": 3073,
								"value": "1",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "get",
								"line": 3074,
								"value": "2",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "post",
								"line": 3075,
								"value": "3",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "put",
								"line": 3076,
								"value": "4",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "del",
								"line": 3077,
								"value": "5",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "options",
								"line": 3078,
								"value": "6",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "trace",
								"line": 3079,
								"value": "7",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "connect",
								"line": 3080,
								"value": "8",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "patch",
								"line": 3081,
								"value": "9",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "Method",
						"line": 3070,
						"comment": " <a name=\"HTTP.Method\"/>The standard HTTP methods :\n  $(WEB www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1, _RFC2616 Section 5.1.1)\n",
						"baseDeco": "i",
						"char": 5,
						"kind": "enum"
					},
					{
						"name": "StatusLine",
						"line": 3090,
						"comment": "       HTTP status line ie. the first line returned in an HTTP response.\n\n       If authentication or redirections are done then the status will be for\n       the last response received.\n",
						"members": [
							{
								"offset": 0,
								"name": "majorVersion",
								"line": 3092,
								"comment": "Major HTTP version ie. 1 in HTTP/1.0.\n",
								"deco": "t",
								"char": 16,
								"kind": "variable"
							},
							{
								"offset": 2,
								"name": "minorVersion",
								"line": 3093,
								"comment": "Minor HTTP version ie. 0 in HTTP/1.0.\n",
								"deco": "t",
								"char": 16,
								"kind": "variable"
							},
							{
								"offset": 4,
								"name": "code",
								"line": 3094,
								"comment": "HTTP status line code e.g. 200.\n",
								"deco": "t",
								"char": 16,
								"kind": "variable"
							},
							{
								"offset": 8,
								"name": "reason",
								"line": 3095,
								"comment": "HTTP status line reason string.\n",
								"deco": "Aya",
								"char": 16,
								"kind": "variable"
							},
							{
								"endchar": 9,
								"name": "reset",
								"line": 3098,
								"comment": "Reset this status line\n",
								"deco": "FNfZv",
								"endline": 3104,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "toString",
								"line": 3107,
								"comment": "\n",
								"deco": "FZAya",
								"endline": 3111,
								"char": 16,
								"kind": "function"
							}
						],
						"char": 5,
						"kind": "struct"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "FTP",
				"line": 3121,
				"comment": "   FTP client functionality.\n\n   See_Also: $(WEB tools.ietf.org/html/rfc959, RFC959)\n",
				"members": [
					{
						"endchar": 5,
						"name": "opCall",
						"line": 3145,
						"comment": "       FTP access to the specified url.\n",
						"deco": "FAxaZS3std3net4curl3FTP",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 3151,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "perform",
						"line": 3196,
						"comment": "       Performs the ftp request as it has been configured.\n\n       After a FTP client has been setup and possibly assigned callbacks the $(D\n       perform()) method will start performing the actual communication with the\n       server.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n",
						"deco": "FE3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4FlagZi",
						"parameters": [
							{
								"name": "throwOnError",
								"deco": "E3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4Flag",
								"default": "cast(Flag)true"
							}
						],
						"endline": 3199,
						"originalType": "CurlCode(ThrowOnError throwOnError = ThrowOnError.yes)",
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "url",
						"line": 3202,
						"comment": "The URL to specify the location of the resource.\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 3207,
						"char": 20,
						"kind": "function"
					},
					{
						"name": "requestPause",
						"line": 3215,
						"comment": "Value to return from $(D onSend)/$(D onReceive) delegates in order to\n\npause a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "requestAbort",
						"line": 3218,
						"comment": "Value to return from onSend delegate in order to abort a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "isStopped",
						"line": 3223,
						"comment": "           True if the instance is stopped. A stopped instance is not usable.\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "shutdown",
						"line": 3226,
						"comment": "Stop and invalidate this instance.\n",
						"deco": "FZv",
						"char": 14,
						"kind": "function"
					},
					{
						"name": "verbose",
						"line": 3231,
						"comment": " Set verbose.\n            This will print request information to stderr.\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dataTimeout",
						"line": 3236,
						"comment": "Set timeout for activity on connection.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "operationTimeout",
						"line": 3241,
						"comment": " Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "connectTimeout",
						"line": 3244,
						"comment": "Set timeout for connecting.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxy",
						"line": 3251,
						"comment": " Proxy\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "host",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxyPort",
						"line": 3256,
						"comment": " Proxy port\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "CurlProxy",
						"line": 3259,
						"comment": "Type of proxy\n",
						"deco": "E3etc1c4curl9CurlProxy",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "proxyType",
						"line": 3264,
						"comment": " Proxy type\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n",
						"deco": "FNdE3etc1c4curl9CurlProxyZv",
						"parameters": [
							{
								"name": "type",
								"deco": "E3etc1c4curl9CurlProxy"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dnsTimeout",
						"line": 3267,
						"comment": "DNS lookup timeout.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3280,
						"comment": " The network interface to use in form of the the IP of the interface.\n\n Example:\n ----\n theprotocol.netInterface = \"192.168.1.32\";\n theprotocol.netInterface = [ 192, 168, 1, 32 ];\n ----\n\n See: $(XREF socket, InternetAddress)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "i",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3283,
						"comment": "ditto\n",
						"deco": "FNdxG4hZv",
						"parameters": [
							{
								"name": "i",
								"deco": "xG4h"
							}
						],
						"originalType": "@property void(const(ubyte)[4] i)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3286,
						"comment": "ditto\n",
						"deco": "FNdC3std6socket15InternetAddressZv",
						"parameters": [
							{
								"name": "i",
								"deco": "C3std6socket15InternetAddress"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPort",
						"line": 3293,
						"comment": "           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPortRange",
						"line": 3302,
						"comment": "           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "range",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "tcpNoDelay",
						"line": 3307,
						"comment": " Set the tcp no-delay socket option on or off.\n            See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "setAuthentication",
						"line": 3324,
						"comment": "           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n",
						"deco": "FAxaAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							},
							{
								"name": "domain",
								"deco": "Axa",
								"default": "\"\""
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "setProxyAuthentication",
						"line": 3334,
						"comment": "           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n",
						"deco": "FAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "onSend",
						"line": 3350,
						"comment": " The event handler that gets called when data is needed for sending. The\n length of the $(D void[]) specifies the maximum number of bytes that can\n be sent.\n\n Returns:\n The callback returns the number of elements in the buffer that have been\n filled and are ready to send.\n The special value $(D .abortRequest) can be returned in order to abort the\n current request.\n The special value $(D .pauseRequest) can be returned in order to pause the\n current request.\n\n",
						"deco": "FNdDFAvZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAvZm"
							}
						],
						"originalType": "@property void(size_t delegate(void[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onReceive",
						"line": 3364,
						"comment": " The event handler that receives incoming data. Be sure to copy the\n incoming ubyte[] since it is not guaranteed to be valid after the\n callback returns.\n\n Returns:\n The callback returns the incoming bytes read. If not the entire array is\n the request will abort.\n The special value .pauseRequest can be returned in order to pause the\n current request.\n\n",
						"deco": "FNdDFAhZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAhZm"
							}
						],
						"originalType": "@property void(size_t delegate(ubyte[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onProgress",
						"line": 3376,
						"comment": " The event handler that gets called to inform of upload/download progress.\n\n Callback_parameters:\n $(CALLBACK_PARAMS)\n\n Callback_returns:\n Return 0 from the callback to signal success, return non-zero to\n abort transfer.\n",
						"deco": "FNdDFmmmmZiZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFmmmmZi"
							}
						],
						"originalType": "@property void(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearCommands",
						"line": 3382,
						"comment": " Clear all commands send to ftp server.\n",
						"deco": "FZv",
						"endline": 3388,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "addCommand",
						"line": 3404,
						"comment": " Add a command to send to ftp server.\n\n There is no remove command functionality. Do a $(LREF clearCommands) and\n set the needed commands instead.\n\n Example:\n ---\n import std.net.curl;\n auto client = FTP();\n client.addCommand(\"RNFR my_file.txt\");\n client.addCommand(\"RNTO my_renamed_file.txt\");\n upload(\"my_file.txt\", \"ftp.digitalmars.com\", client);\n ---\n",
						"deco": "FAxaZv",
						"parameters": [
							{
								"name": "command",
								"deco": "Axa"
							}
						],
						"endline": 3409,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "encoding",
						"line": 3412,
						"comment": "Connection encoding. Defaults to ISO-8859-1.\n",
						"deco": "FNdAyaZv",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							}
						],
						"endline": 3415,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "encoding",
						"line": 3418,
						"comment": "ditto\n",
						"deco": "FNdZAya",
						"endline": 3421,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "contentLength",
						"line": 3426,
						"comment": "       The content length in bytes of the ftp data.\n",
						"deco": "FNdmZv",
						"parameters": [
							{
								"name": "len",
								"deco": "m"
							}
						],
						"endline": 3429,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "SMTP",
				"line": 3450,
				"comment": " Basic SMTP protocol support.\n\n Example:\n ---\n import std.net.curl;\n\n // Send an email with SMTPS\n auto smtp = SMTP(\"smtps://smtp.gmail.com\");\n smtp.setAuthentication(\"from.addr@gmail.com\", \"password\");\n smtp.mailTo = [\"<to.addr@gmail.com>\"];\n smtp.mailFrom = \"<from.addr@gmail.com>\";\n smtp.message = \"Example Message\";\n smtp.perform();\n ---\n\n See_Also: $(WEB www.ietf.org/rfc/rfc2821.txt, RFC2821)\n",
				"members": [
					{
						"endchar": 5,
						"name": "opCall",
						"line": 3486,
						"comment": "        Sets to the URL of the SMTP server.\n",
						"deco": "FAxaZS3std3net4curl4SMTP",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 3492,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "perform",
						"line": 3527,
						"comment": "        Performs the request as configured.\n        Params:\n        throwOnError = whether to throw an exception or return a CurlCode on error\n",
						"deco": "FE3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4FlagZi",
						"parameters": [
							{
								"name": "throwOnError",
								"deco": "E3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4Flag",
								"default": "cast(Flag)true"
							}
						],
						"endline": 3530,
						"originalType": "CurlCode(ThrowOnError throwOnError = ThrowOnError.yes)",
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "url",
						"line": 3533,
						"comment": "The URL to specify the location of the resource.\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 3547,
						"char": 20,
						"kind": "function"
					},
					{
						"name": "requestPause",
						"line": 3564,
						"comment": "Value to return from $(D onSend)/$(D onReceive) delegates in order to\n\npause a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "requestAbort",
						"line": 3567,
						"comment": "Value to return from onSend delegate in order to abort a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "isStopped",
						"line": 3572,
						"comment": "           True if the instance is stopped. A stopped instance is not usable.\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "shutdown",
						"line": 3575,
						"comment": "Stop and invalidate this instance.\n",
						"deco": "FZv",
						"char": 14,
						"kind": "function"
					},
					{
						"name": "verbose",
						"line": 3580,
						"comment": " Set verbose.\n            This will print request information to stderr.\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dataTimeout",
						"line": 3585,
						"comment": "Set timeout for activity on connection.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "operationTimeout",
						"line": 3590,
						"comment": " Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "connectTimeout",
						"line": 3593,
						"comment": "Set timeout for connecting.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxy",
						"line": 3600,
						"comment": " Proxy\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "host",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxyPort",
						"line": 3605,
						"comment": " Proxy port\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "CurlProxy",
						"line": 3608,
						"comment": "Type of proxy\n",
						"deco": "E3etc1c4curl9CurlProxy",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "proxyType",
						"line": 3613,
						"comment": " Proxy type\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n",
						"deco": "FNdE3etc1c4curl9CurlProxyZv",
						"parameters": [
							{
								"name": "type",
								"deco": "E3etc1c4curl9CurlProxy"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dnsTimeout",
						"line": 3616,
						"comment": "DNS lookup timeout.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3629,
						"comment": " The network interface to use in form of the the IP of the interface.\n\n Example:\n ----\n theprotocol.netInterface = \"192.168.1.32\";\n theprotocol.netInterface = [ 192, 168, 1, 32 ];\n ----\n\n See: $(XREF socket, InternetAddress)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "i",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3632,
						"comment": "ditto\n",
						"deco": "FNdxG4hZv",
						"parameters": [
							{
								"name": "i",
								"deco": "xG4h"
							}
						],
						"originalType": "@property void(const(ubyte)[4] i)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3635,
						"comment": "ditto\n",
						"deco": "FNdC3std6socket15InternetAddressZv",
						"parameters": [
							{
								"name": "i",
								"deco": "C3std6socket15InternetAddress"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPort",
						"line": 3642,
						"comment": "           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPortRange",
						"line": 3651,
						"comment": "           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "range",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "tcpNoDelay",
						"line": 3656,
						"comment": " Set the tcp no-delay socket option on or off.\n            See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "setAuthentication",
						"line": 3673,
						"comment": "           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n",
						"deco": "FAxaAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							},
							{
								"name": "domain",
								"deco": "Axa",
								"default": "\"\""
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "setProxyAuthentication",
						"line": 3683,
						"comment": "           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n",
						"deco": "FAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "onSend",
						"line": 3698,
						"comment": " The event handler that gets called when data is needed for sending. The\n length of the $(D void[]) specifies the maximum number of bytes that can\n be sent.\n\n Returns:\n The callback returns the number of elements in the buffer that have been\n filled and are ready to send.\n The special value $(D .abortRequest) can be returned in order to abort the\n current request.\n The special value $(D .pauseRequest) can be returned in order to pause the\n current request.\n",
						"deco": "FNdDFAvZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAvZm"
							}
						],
						"originalType": "@property void(size_t delegate(void[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onReceive",
						"line": 3711,
						"comment": " The event handler that receives incoming data. Be sure to copy the\n incoming ubyte[] since it is not guaranteed to be valid after the\n callback returns.\n\n Returns:\n The callback returns the incoming bytes read. If not the entire array is\n the request will abort.\n The special value .pauseRequest can be returned in order to pause the\n current request.\n",
						"deco": "FNdDFAhZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAhZm"
							}
						],
						"originalType": "@property void(size_t delegate(ubyte[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onProgress",
						"line": 3723,
						"comment": " The event handler that gets called to inform of upload/download progress.\n\n Callback_parameters:\n $(CALLBACK_PARAMS)\n\n Callback_returns:\n Return 0 from the callback to signal success, return non-zero to\n abort transfer.\n",
						"deco": "FNdDFmmmmZiZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFmmmmZi"
							}
						],
						"originalType": "@property void(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "mailFrom",
								"line": 3730,
								"type": "@property void(const(char)[] sender)",
								"parameters": [
									{
										"name": "sender",
										"type": "const(char)[]"
									}
								],
								"endline": 3734,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "mailFrom",
						"line": 3730,
						"comment": "        Setter for the sender's email address.\n",
						"parameters": [],
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "mailTo",
								"line": 3739,
								"type": "void(const(char)[][] recipients...)",
								"parameters": [
									{
										"name": "recipients",
										"type": "const(char)[][]"
									}
								],
								"endline": 3750,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "mailTo",
						"line": 3739,
						"comment": "        Setter for the recipient email addresses.\n",
						"parameters": [],
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "message",
						"line": 3756,
						"comment": "        Sets the message body text.\n",
						"deco": "FNdAyaZv",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							}
						],
						"endline": 3759,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3775,
						"comment": "        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std3net4curl13CurlException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 3781,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "CurlException",
				"line": 3765,
				"comment": "    Exception thrown on errors in std.net.curl functions.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3797,
						"comment": "        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std3net4curl20CurlTimeoutException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 3803,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "CurlTimeoutException",
				"line": 3787,
				"comment": "    Exception thrown on timeout errors in std.net.curl functions.\n",
				"base": "std.net.curl.CurlException",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "CurlCode",
				"line": 3807,
				"comment": "Equal to $(ECXREF curl, CURLcode)\n",
				"deco": "i",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "ThrowOnError",
				"line": 3811,
				"comment": "Flag to specify whether or not an exception is thrown on error.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Curl",
				"line": 3936,
				"comment": "  Wrapper to provide a better interface to libcurl than using the plain C API.\n  It is recommended to use the $(D HTTP)/$(D FTP) etc. structs instead unless\n  raw access to libcurl is needed.\n\n  Warning: This struct uses interior pointers for callbacks. Only allocate it\n  on the stack if you never move or copy it. This also means passing by reference\n  when passing Curl to other functions. Otherwise always allocate on\n  the heap.\n",
				"members": [
					{
						"endchar": 5,
						"name": "initialize",
						"line": 3962,
						"comment": "       Initialize the instance by creating a working curl handle.\n",
						"deco": "FZv",
						"endline": 3969,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dup",
						"line": 3979,
						"comment": "       Duplicate this handle.\n\n       The new handle will have all options set as the one it was duplicated\n       from. An exception to this is that all options that cannot be shared\n       across threads are reset thereby making it safe to use the duplicate\n       in a new thread.\n",
						"deco": "FZS3std3net4curl4Curl",
						"endline": 4027,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "shutdown",
						"line": 4058,
						"comment": "        Stop and invalidate this curl instance.\n        Warning: Do not call this from inside a callback handler e.g. $(D onReceive).\n",
						"deco": "FZv",
						"endline": 4064,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "pause",
						"line": 4069,
						"comment": "       Pausing and continuing transfers.\n",
						"deco": "FbbZv",
						"parameters": [
							{
								"name": "sendingPaused",
								"deco": "b"
							},
							{
								"name": "receivingPaused",
								"deco": "b"
							}
						],
						"endline": 4075,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "set",
						"line": 4083,
						"comment": "       Set a string curl option.\n       Params:\n       option = A $(ECXREF curl, CurlOption) as found in the curl documentation\n       value = The string\n",
						"deco": "FE3etc1c4curl10CurlOptionAxaZv",
						"parameters": [
							{
								"name": "option",
								"deco": "E3etc1c4curl10CurlOption"
							},
							{
								"name": "value",
								"deco": "Axa"
							}
						],
						"endline": 4087,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "set",
						"line": 4095,
						"comment": "       Set a long curl option.\n       Params:\n       option = A $(ECXREF curl, CurlOption) as found in the curl documentation\n       value = The long\n",
						"deco": "FE3etc1c4curl10CurlOptionlZv",
						"parameters": [
							{
								"name": "option",
								"deco": "E3etc1c4curl10CurlOption"
							},
							{
								"name": "value",
								"deco": "l"
							}
						],
						"endline": 4099,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "set",
						"line": 4107,
						"comment": "       Set a void* curl option.\n       Params:\n       option = A $(ECXREF curl, CurlOption) as found in the curl documentation\n       value = The pointer\n",
						"deco": "FE3etc1c4curl10CurlOptionPvZv",
						"parameters": [
							{
								"name": "option",
								"deco": "E3etc1c4curl10CurlOption"
							},
							{
								"name": "value",
								"deco": "Pv"
							}
						],
						"endline": 4111,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clear",
						"line": 4118,
						"comment": "       Clear a pointer option.\n       Params:\n       option = A $(ECXREF curl, CurlOption) as found in the curl documentation\n",
						"deco": "FE3etc1c4curl10CurlOptionZv",
						"parameters": [
							{
								"name": "option",
								"deco": "E3etc1c4curl10CurlOption"
							}
						],
						"endline": 4122,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearIfSupported",
						"line": 4130,
						"comment": "       Clear a pointer option. Does not raise an exception if the underlying\n       libcurl does not support the option. Use sparingly.\n       Params:\n       option = A $(ECXREF curl, CurlOption) as found in the curl documentation\n",
						"deco": "FE3etc1c4curl10CurlOptionZv",
						"parameters": [
							{
								"name": "option",
								"deco": "E3etc1c4curl10CurlOption"
							}
						],
						"endline": 4136,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "perform",
						"line": 4145,
						"comment": "       perform the curl request by doing the HTTP,FTP etc. as it has\n       been setup beforehand.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n",
						"deco": "FE3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4FlagZi",
						"parameters": [
							{
								"name": "throwOnError",
								"deco": "E3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4Flag",
								"default": "cast(Flag)true"
							}
						],
						"endline": 4152,
						"originalType": "CurlCode(ThrowOnError throwOnError = ThrowOnError.yes)",
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onReceive",
						"line": 4178,
						"comment": " The event handler that receives incoming data.\n\n Params:\n callback = the callback that receives the $(D ubyte[]) data.\n Be sure to copy the incoming data and not store\n a slice.\n\n Returns:\n The callback returns the incoming bytes read. If not the entire array is\n the request will abort.\n The special value HTTP.pauseRequest can be returned in order to pause the\n current request.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n curl.onReceive = (ubyte[] data) { writeln(\"Got data\", to!(const(char)[])(data)); return data.length;};\n curl.perform();\n ----\n",
						"deco": "FNdDFAhZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAhZm"
							}
						],
						"endline": 4187,
						"originalType": "@property void(size_t delegate(InData) callback)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onReceiveHeader",
						"line": 4209,
						"comment": " The event handler that receives incoming headers for protocols\n that uses headers.\n\n Params:\n callback = the callback that receives the header string.\n Make sure the callback copies the incoming params if\n it needs to store it because they are references into\n the backend and may very likely change.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n curl.onReceiveHeader = (in char[] header) { writeln(header); };\n curl.perform();\n ----\n",
						"deco": "FNdDFxAaZvZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFxAaZv"
							}
						],
						"endline": 4220,
						"originalType": "@property void(void delegate(in char[]) callback)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onSend",
						"line": 4256,
						"comment": " The event handler that gets called when data is needed for sending.\n\n Params:\n callback = the callback that has a $(D void[]) buffer to be filled\n\n Returns:\n The callback returns the number of elements in the buffer that have been\n filled and are ready to send.\n The special value $(D Curl.abortRequest) can be returned in\n order to abort the current request.\n The special value $(D Curl.pauseRequest) can be returned in order to\n pause the current request.\n\n Example:\n ----\n import std.net.curl;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n\n string msg = \"Hello world\";\n curl.onSend = (void[] data)\n {\n     auto m = cast(void[])msg;\n     size_t length = m.length > data.length ? data.length : m.length;\n     if (length == 0) return 0;\n     data[0..length] = m[0..length];\n     msg = msg[length..$];\n     return length;\n };\n curl.perform();\n ----\n",
						"deco": "FNdDFAvZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAvZm"
							}
						],
						"endline": 4265,
						"originalType": "@property void(size_t delegate(OutData) callback)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onSeek",
						"line": 4292,
						"comment": " The event handler that gets called when the curl backend needs to seek\n the data to be sent.\n\n Params:\n callback = the callback that receives a seek offset and a seek position\n            $(ECXREF curl, CurlSeekPos)\n\n Returns:\n The callback returns the success state of the seeking\n $(ECXREF curl, CurlSeek)\n\n Example:\n ----\n import std.net.curl;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n curl.onSeek = (long p, CurlSeekPos sp)\n {\n     return CurlSeek.cantseek;\n };\n curl.perform();\n ----\n",
						"deco": "FNdDFlE3etc1c4curl11CurlSeekPosZE3etc1c4curl8CurlSeekZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFlE3etc1c4curl11CurlSeekPosZE3etc1c4curl8CurlSeek"
							}
						],
						"endline": 4301,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onSocketOption",
						"line": 4326,
						"comment": " The event handler that gets called when the net socket has been created\n but a $(D connect()) call has not yet been done. This makes it possible to set\n misc. socket options.\n\n Params:\n callback = the callback that receives the socket and socket type\n $(ECXREF curl, CurlSockType)\n\n Returns:\n Return 0 from the callback to signal success, return 1 to signal error\n and make curl close the socket\n\n Example:\n ----\n import std.net.curl;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n curl.onSocketOption = delegate int(curl_socket_t s, CurlSockType t) { /+ do stuff +/ };\n curl.perform();\n ----\n",
						"deco": "FNdDFE3std6socket8socket_tE3etc1c4curl12CurlSockTypeZiZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFE3std6socket8socket_tE3etc1c4curl12CurlSockTypeZi"
							}
						],
						"endline": 4338,
						"originalType": "@property void(int delegate(curl_socket_t, CurlSockType) callback)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onProgress",
						"line": 4366,
						"comment": " The event handler that gets called to inform of upload/download progress.\n\n Params:\n callback = the callback that receives the (total bytes to download,\n currently downloaded bytes, total bytes to upload, currently uploaded\n bytes).\n\n Returns:\n Return 0 from the callback to signal success, return non-zero to abort\n transfer\n\n Example:\n ----\n import std.net.curl;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n curl.onProgress = delegate int(size_t dltotal, size_t dlnow, size_t ultotal, size_t uln)\n {\n     writeln(\"Progress: downloaded bytes \", dlnow, \" of \", dltotal);\n     writeln(\"Progress: uploaded bytes \", ulnow, \" of \", ultotal);\n     curl.perform();\n };\n ----\n",
						"deco": "FNdDFmmmmZiZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFmmmmZi"
							}
						],
						"endline": 4380,
						"originalType": "@property void(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback)",
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			}
		],
		"comment": "Networking client functionality as provided by $(WEB _curl.haxx.se/libcurl,\nlibcurl). The libcurl library must be installed on the system in order to use\nthis module.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW High level) $(TD $(MYREF download) $(MYREF upload) $(MYREF get)\n$(MYREF post) $(MYREF put) $(MYREF del) $(MYREF options) $(MYREF trace)\n$(MYREF connect) $(MYREF byLine) $(MYREF byChunk)\n$(MYREF byLineAsync) $(MYREF byChunkAsync) )\n)\n$(TR $(TDNW Low level) $(TD $(MYREF HTTP) $(MYREF FTP) $(MYREF\nSMTP) )\n)\n)\n)\n\nNote:\nYou may need to link to the $(B curl) library, e.g. by adding $(D \"libs\": [\"curl\"])\nto your $(B dub.json) file if you are using $(LINK2 http://code.dlang.org, DUB).\n\nWindows x86 note:\nA DMD compatible libcurl static library can be downloaded from the dlang.org\n$(LINK2 http://dlang.org/download.html, download page).\n\nCompared to using libcurl directly this module allows simpler client code for\ncommon uses, requires no unsafe operations, and integrates better with the rest\nof the language. Futhermore it provides <a href=\"std_range.html\">$(D range)</a>\naccess to protocols supported by libcurl both synchronously and asynchronously.\n\nA high level and a low level API are available. The high level API is built\nentirely on top of the low level one.\n\nThe high level API is for commonly used functionality such as HTTP/FTP get. The\n$(LREF byLineAsync) and $(LREF byChunkAsync) provides asynchronous <a\nhref=\"std_range.html\">$(D ranges)</a> that performs the request in another\nthread while handling a line/chunk in the current thread.\n\nThe low level API allows for streaming and other advanced features.\n\n$(BOOKTABLE Cheat Sheet,\n$(TR $(TH Function Name) $(TH Description)\n)\n$(LEADINGROW High level)\n$(TR $(TDNW $(LREF download)) $(TD $(D\ndownload(\"ftp.digitalmars.com/sieve.ds\", \"/tmp/downloaded-ftp-file\"))\ndownloads file from URL to file system.)\n)\n$(TR $(TDNW $(LREF upload)) $(TD $(D\nupload(\"/tmp/downloaded-ftp-file\", \"ftp.digitalmars.com/sieve.ds\");)\nuploads file from file system to URL.)\n)\n$(TR $(TDNW $(LREF get)) $(TD $(D\nget(\"dlang.org\")) returns a char[] containing the dlang.org web page.)\n)\n$(TR $(TDNW $(LREF put)) $(TD $(D\nput(\"dlang.org\", \"Hi\")) returns a char[] containing\nthe dlang.org web page. after a HTTP PUT of \"hi\")\n)\n$(TR $(TDNW $(LREF post)) $(TD $(D\npost(\"dlang.org\", \"Hi\")) returns a char[] containing\nthe dlang.org web page. after a HTTP POST of \"hi\")\n)\n$(TR $(TDNW $(LREF byLine)) $(TD $(D\nbyLine(\"dlang.org\")) returns a range of char[] containing the\ndlang.org web page.)\n)\n$(TR $(TDNW $(LREF byChunk)) $(TD $(D\nbyChunk(\"dlang.org\", 10)) returns a range of ubyte[10] containing the\ndlang.org web page.)\n)\n$(TR $(TDNW $(LREF byLineAsync)) $(TD $(D\nbyLineAsync(\"dlang.org\")) returns a range of char[] containing the dlang.org web\n page asynchronously.)\n)\n$(TR $(TDNW $(LREF byChunkAsync)) $(TD $(D\nbyChunkAsync(\"dlang.org\", 10)) returns a range of ubyte[10] containing the\ndlang.org web page asynchronously.)\n)\n$(LEADINGROW Low level\n)\n$(TR $(TDNW $(LREF HTTP)) $(TD $(D HTTP) struct for advanced usage))\n$(TR $(TDNW $(LREF FTP)) $(TD $(D FTP) struct for advanced usage))\n$(TR $(TDNW $(LREF SMTP)) $(TD $(D SMTP) struct for advanced usage))\n)\n\n\nExample:\n---\nimport std.net.curl, std.stdio;\n\n// Return a char[] containing the content specified by an URL\nauto content = get(\"dlang.org\");\n\n// Post data and return a char[] containing the content specified by an URL\nauto content = post(\"mydomain.com/here.cgi\", \"post data\");\n\n// Get content of file from ftp server\nauto content = get(\"ftp.digitalmars.com/sieve.ds\");\n\n// Post and print out content line by line. The request is done in another thread.\nforeach (line; byLineAsync(\"dlang.org\", \"Post data\"))\n    writeln(line);\n\n// Get using a line range and proxy settings\nauto client = HTTP();\nclient.proxy = \"1.2.3.4\";\nforeach (line; byLine(\"dlang.org\", client))\n    writeln(line);\n---\n\nFor more control than the high level functions provide, use the low level API:\n\nExample:\n---\nimport std.net.curl, std.stdio;\n\n// GET with custom data receivers\nauto http = HTTP(\"dlang.org\");\nhttp.onReceiveHeader =\n    (in char[] key, in char[] value) { writeln(key, \": \", value); };\nhttp.onReceive = (ubyte[] data) { /+ drop +/ return data.length; };\nhttp.perform();\n---\n\nFirst, an instance of the reference-counted HTTP struct is created. Then the\ncustom delegates are set. These will be called whenever the HTTP instance\nreceives a header and a data buffer, respectively. In this simple example, the\nheaders are written to stdout and the data is ignored. If the request should be\nstopped before it has finished then return something less than data.length from\nthe onReceive callback. See $(LREF onReceiveHeader)/$(LREF onReceive) for more\ninformation. Finally the HTTP request is effected by calling perform(), which is\nsynchronous.\n\nSource: $(PHOBOSSRC std/net/_curl.d)\n\nCopyright: Copyright Jonas Drewsen 2011-2012\nLicense: $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors: Jonas Drewsen. Some of the SMTP code contributed by Jimmy Cao.\n\nCredits: The functionally is based on $(WEB _curl.haxx.se/libcurl, libcurl).\n         LibCurl is licensed under an MIT/X derivative license.\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/net/isemail.d",
		"name": "std.net.isemail",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "isEmail",
						"line": 59,
						"type": "EmailStatus(const(Char)[] email, CheckDns checkDNS = CheckDns.no, EmailStatusCode errorLevel = EmailStatusCode.none)",
						"parameters": [
							{
								"name": "email",
								"type": "const(Char)[]"
							},
							{
								"name": "checkDNS",
								"type": "CheckDns",
								"default": "CheckDns.no"
							},
							{
								"name": "errorLevel",
								"type": "EmailStatusCode",
								"default": "EmailStatusCode.none"
							}
						],
						"endline": 763,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "isEmail",
				"line": 59,
				"comment": " Check that an email address conforms to RFCs 5321, 5322 and others.\n\n As of Version 3.0, we are now distinguishing clearly between a Mailbox as defined\n by RFC 5321 and an addr-spec as defined by RFC 5322. Depending on the context,\n either can be regarded as a valid email address. The RFC 5321 Mailbox specification\n is more restrictive (comments, white space and obsolete forms are not allowed).\n\n Note: The DNS check is currently not implemented.\n\n Params:\n     email = The email address to check\n     checkDNS = If CheckDns.yes then a DNS check for MX records will be made\n     errorLevel = Determines the boundary between valid and invalid addresses.\n                  Status codes above this number will be returned as-is,\n                  status codes below will be returned as EmailStatusCode.valid.\n                  Thus the calling program can simply look for EmailStatusCode.valid\n                  if it is only interested in whether an address is valid or not. The\n                  $(D_PARAM errorLevel) will determine how \"picky\" isEmail() is about\n                  the address.\n\n                  If omitted or passed as EmailStatusCode.none then isEmail() will\n                  not perform any finer grained error checking and an address is\n                  either considered valid or not. Email status code will either be\n                  EmailStatusCode.valid or EmailStatusCode.error.\n\n Returns: an EmailStatus, indicating the status of the email address.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 1236,
						"value": "0",
						"comment": "Does not perform DNS checking\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 1239,
						"value": "1",
						"comment": "Performs DNS checking\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CheckDns",
				"line": 1233,
				"comment": "Enum for indicating if the isEmail function should perform a DNS check or not.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "EmailStatus",
				"line": 1243,
				"comment": "This struct represents the status of an email address\n",
				"members": [
					{
						"endchar": 5,
						"name": "valid",
						"line": 1272,
						"comment": "Indicates if the email address is valid or not.\n",
						"deco": "xFNdZb",
						"endline": 1275,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "localPart",
						"line": 1278,
						"comment": "The local part of the email address, that is, the part before the @ sign.\n",
						"deco": "xFNdZAya",
						"endline": 1281,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "domainPart",
						"line": 1284,
						"comment": "The domain part of the email address, that is, the part after the @ sign.\n",
						"deco": "xFNdZAya",
						"endline": 1287,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "statusCode",
						"line": 1290,
						"comment": "The email status code\n",
						"deco": "xFNdZE3std3net7isemail15EmailStatusCode",
						"endline": 1293,
						"char": 31,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "status",
						"line": 1296,
						"comment": "Returns a describing string of the status code\n",
						"deco": "xFNdZAya",
						"endline": 1299,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1302,
						"comment": "Returns a textual representation of the email status\n",
						"deco": "xFZAya",
						"endline": 1307,
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "statusCodeDescription",
				"line": 1311,
				"comment": "Returns a describing string of the given status code\n",
				"deco": "FE3std3net7isemail15EmailStatusCodeZAya",
				"parameters": [
					{
						"name": "statusCode",
						"deco": "E3std3net7isemail15EmailStatusCode"
					}
				],
				"endline": 1440,
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "validCategory",
						"line": 1451,
						"value": "1",
						"comment": "Address is valid\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "dnsWarning",
						"line": 1454,
						"value": "7",
						"comment": "Address is valid but a DNS check was not successful\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321",
						"line": 1457,
						"value": "15",
						"comment": "Address is valid for SMTP but has unusual elements\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "cFoldingWhitespace",
						"line": 1460,
						"value": "31",
						"comment": "Address is valid within the message but cannot be used unmodified for the envelope\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecated_",
						"line": 1463,
						"value": "63",
						"comment": "Address contains deprecated elements but may still be valid in restricted contexts\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322",
						"line": 1466,
						"value": "127",
						"comment": "The address is only valid according to the broad definition of RFC 5322. It is otherwise invalid\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "any",
						"line": 1473,
						"value": "252",
						"comment": " All finer grained error checking is turned on. Address containing errors or\n warnings is considered invalid. A specific email status code will be\n returned indicating the error/warning of the address.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "none",
						"line": 1479,
						"value": "253",
						"comment": " Address is either considered valid or not, no finer grained error checking\n is performed. Returned email status code will be either Error or Valid.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "warning",
						"line": 1485,
						"value": "254",
						"comment": " Address containing warnings is considered valid, that is,\n any status code below 16 is considered valid.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "error",
						"line": 1488,
						"value": "255",
						"comment": "Address is invalid for any purpose\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "valid",
						"line": 1495,
						"value": "0",
						"comment": "Address is valid\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "dnsWarningNoMXRecord",
						"line": 1500,
						"value": "5",
						"comment": "Could not find an MX record for this domain but an A-record does exist\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "dnsWarningNoRecord",
						"line": 1503,
						"value": "6",
						"comment": "Could not find an MX record or an A-record for this domain\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321TopLevelDomain",
						"line": 1510,
						"value": "9",
						"comment": "Address is valid but at a Top Level Domain\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321TopLevelDomainNumeric",
						"line": 1513,
						"value": "10",
						"comment": "Address is valid but the Top Level Domain begins with a number\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321QuotedString",
						"line": 1516,
						"value": "11",
						"comment": "Address is valid but contains a quoted string\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321AddressLiteral",
						"line": 1519,
						"value": "12",
						"comment": "Address is valid but at a literal address not a domain\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321IpV6Deprecated",
						"line": 1522,
						"value": "13",
						"comment": "Address is valid but contains a :: that only elides one zero group\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "comment",
						"line": 1529,
						"value": "17",
						"comment": "Address contains comments\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "foldingWhitespace",
						"line": 1532,
						"value": "18",
						"comment": "Address contains Folding White Space\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedLocalPart",
						"line": 1539,
						"value": "33",
						"comment": "The local part is in a deprecated form\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedFoldingWhitespace",
						"line": 1542,
						"value": "34",
						"comment": "Address contains an obsolete form of Folding White Space\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedQuotedText",
						"line": 1545,
						"value": "35",
						"comment": "A quoted string contains a deprecated character\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedQuotedPair",
						"line": 1548,
						"value": "36",
						"comment": "A quoted pair contains a deprecated character\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedComment",
						"line": 1551,
						"value": "37",
						"comment": "Address contains a comment in a position that is deprecated\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedCommentText",
						"line": 1554,
						"value": "38",
						"comment": "A comment contains a deprecated character\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedCommentFoldingWhitespaceNearAt",
						"line": 1557,
						"value": "49",
						"comment": "Address contains a comment or Folding White Space around the @ sign\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322Domain",
						"line": 1564,
						"value": "65",
						"comment": "Address is RFC 5322 compliant but contains domain characters that are not allowed by DNS\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322TooLong",
						"line": 1567,
						"value": "66",
						"comment": "Address is too long\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322LocalTooLong",
						"line": 1570,
						"value": "67",
						"comment": "The local part of the address is too long\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322DomainTooLong",
						"line": 1573,
						"value": "68",
						"comment": "The domain part is too long\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322LabelTooLong",
						"line": 1576,
						"value": "69",
						"comment": "The domain part contains an element that is too long\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322DomainLiteral",
						"line": 1579,
						"value": "70",
						"comment": "The domain literal is not a valid RFC 5321 address literal\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322DomainLiteralObsoleteText",
						"line": 1582,
						"value": "71",
						"comment": "The domain literal is not a valid RFC 5321 address literal and it contains obsolete characters\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6GroupCount",
						"line": 1585,
						"value": "72",
						"comment": "The IPv6 literal address contains the wrong number of groups\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6TooManyDoubleColons",
						"line": 1588,
						"value": "73",
						"comment": "The IPv6 literal address contains too many :: sequences\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6BadChar",
						"line": 1591,
						"value": "74",
						"comment": "The IPv6 address contains an illegal group of characters\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6MaxGroups",
						"line": 1594,
						"value": "75",
						"comment": "The IPv6 address has too many groups\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6ColonStart",
						"line": 1597,
						"value": "76",
						"comment": "IPv6 address starts with a single colon\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6ColonEnd",
						"line": 1600,
						"value": "77",
						"comment": "IPv6 address ends with a single colon\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorExpectingDomainText",
						"line": 1607,
						"value": "129",
						"comment": "A domain literal contains a character that is not allowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorNoLocalPart",
						"line": 1610,
						"value": "130",
						"comment": "Address has no local part\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorNoDomain",
						"line": 1613,
						"value": "131",
						"comment": "Address has no domain part\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorConsecutiveDots",
						"line": 1616,
						"value": "132",
						"comment": "The address may not contain consecutive dots\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorTextAfterCommentFoldingWhitespace",
						"line": 1619,
						"value": "133",
						"comment": "Address contains text after a comment or Folding White Space\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorTextAfterQuotedString",
						"line": 1622,
						"value": "134",
						"comment": "Address contains text after a quoted string\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorTextAfterDomainLiteral",
						"line": 1625,
						"value": "135",
						"comment": "Extra characters were found after the end of the domain literal\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorExpectingQuotedPair",
						"line": 1628,
						"value": "136",
						"comment": "The address contains a character that is not allowed in a quoted pair\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorExpectingText",
						"line": 1631,
						"value": "137",
						"comment": "Address contains a character that is not allowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorExpectingQuotedText",
						"line": 1634,
						"value": "138",
						"comment": "A quoted string contains a character that is not allowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorExpectingCommentText",
						"line": 1637,
						"value": "139",
						"comment": "A comment contains a character that is not allowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorBackslashEnd",
						"line": 1640,
						"value": "140",
						"comment": "The address cannot end with a backslash\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorDotStart",
						"line": 1643,
						"value": "141",
						"comment": "Neither part of the address may begin with a dot\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorDotEnd",
						"line": 1646,
						"value": "142",
						"comment": "Neither part of the address may end with a dot\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorDomainHyphenStart",
						"line": 1649,
						"value": "143",
						"comment": "A domain or subdomain cannot begin with a hyphen\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorDomainHyphenEnd",
						"line": 1652,
						"value": "144",
						"comment": "A domain or subdomain cannot end with a hyphen\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorUnclosedQuotedString",
						"line": 1655,
						"value": "145",
						"comment": "Unclosed quoted string\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorUnclosedComment",
						"line": 1658,
						"value": "146",
						"comment": "Unclosed comment\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorUnclosedDomainLiteral",
						"line": 1661,
						"value": "147",
						"comment": "Domain literal is missing its closing bracket\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorFoldingWhitespaceCrflX2",
						"line": 1664,
						"value": "148",
						"comment": "Folding White Space contains consecutive CRLF sequences\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorFoldingWhitespaceCrLfEnd",
						"line": 1667,
						"value": "149",
						"comment": "Folding White Space ends with a CRLF sequence\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorCrNoLf",
						"line": 1670,
						"value": "150",
						"comment": "Address contains a carriage return that is not followed by a line feed\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "EmailStatusCode",
				"line": 1446,
				"comment": " An email status code, indicating if an email address is valid or not.\n If it is invalid it also indicates why.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			}
		],
		"comment": " Validates an email address according to RFCs 5321, 5322 and others.\n\n Authors: Dominic Sayers $(LT)dominic@sayers.cc$(GT), Jacob Carlborg\n Copyright: Dominic Sayers, Jacob Carlborg 2008-.\n Test schema documentation: Copyright © 2011, Daniel Marschall\n License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0)\n Version: 3.0.13 - Version 3.0 of the original PHP implementation: $(LINK http://www.dominicsayers.com/isemail)\n\n Standards:\n         $(UL\n             $(LI RFC 5321)\n             $(LI RFC 5322)\n          )\n\n References:\n         $(UL\n             $(LI $(LINK http://www.dominicsayers.com/isemail))\n             $(LI $(LINK http://tools.ietf.org/html/rfc5321))\n             $(LI $(LINK http://tools.ietf.org/html/rfc5322))\n          )\n\n Source: $(PHOBOSSRC std/net/_isemail.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/array.d",
		"name": "std.array",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "array",
						"line": 97,
						"type": "ForeachType!Range[](Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 139,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "array",
				"line": 97,
				"comment": " Allocates an array and initializes it with copies of the elements\n of range $(D r).\n\n Narrow strings are handled as a special case in an overload.\n\n Params:\n      r = range (or aggregate with $(D opApply) function) whose elements are copied into the allocated array\n Returns:\n      allocated and initialized array\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL142_3869)\n---\nauto a = array([1, 2, 3, 4, 5][]);\nassert(a == [ 1, 2, 3, 4, 5 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL142_3869)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isIterable!Range && !isNarrowString!Range && !isInfinite!Range",
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "array",
						"line": 199,
						"type": "ElementType!String[](String str)",
						"parameters": [
							{
								"name": "str",
								"type": "String"
							}
						],
						"endline": 203,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "array",
				"line": 199,
				"comment": "Convert a narrow string to an array type that fully supports random access.\nThis is handled as a special case and always returns a $(D dchar[]),\n$(D const(dchar)[]), or $(D immutable(dchar)[]) depending on the constness of\nthe input.\n",
				"parameters": [
					{
						"name": "String",
						"kind": "type"
					}
				],
				"constraint": "isNarrowString!String",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assocArray",
						"line": 342,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 358,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "assocArray",
				"line": 342,
				"comment": "Returns a newly allocated associative _array from a range of key/value tuples.\nParams: r = An input range of tuples of keys and values.\nReturns: A newly allocated associative array out of elements of the input\nrange, which must be a range of tuples (Key, Value).\nSee_Also: $(XREF typecons, Tuple)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL361_3879)\n---\nimport std.range;\nimport std.typecons;\nauto a = assocArray(zip([0, 1, 2], [\"a\", \"b\", \"c\"]));\nassert(is(typeof(a) == string[int]));\nassert(a == [0:\"a\", 1:\"b\", 2:\"c\"]);\n\nauto b = assocArray([ tuple(\"foo\", \"bar\"), tuple(\"baz\", \"quux\") ]);\nassert(is(typeof(b) == string[string]));\nassert(b == [\"foo\":\"bar\", \"baz\":\"quux\"]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL361_3879)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byPair",
						"line": 401,
						"type": "(Value[Key] aa)",
						"parameters": [
							{
								"name": "aa",
								"type": "Value[Key]"
							}
						],
						"endline": 407,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byPair",
				"line": 401,
				"comment": "Construct a range iterating over an associative array by key/value tuples.\n\nParams: aa = The associative array to iterate over.\n\nReturns: A forward range of Tuple's of key and value pairs from the given\nassociative array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL410_3883)\n---\nimport std.typecons : tuple, Tuple;\nimport std.algorithm : sort;\n\nauto aa = [\"a\": 1, \"b\": 2, \"c\": 3];\nTuple!(string, int)[] pairs;\n\n// Iteration over key/value pairs.\nforeach (pair; aa.byPair)\n{\n    pairs ~= pair;\n}\n\n// Iteration order is implementation-dependent, so we should sort it to get\n// a fixed order.\nsort(pairs);\nassert(pairs == [\n    tuple(\"a\", 1),\n    tuple(\"b\", 2),\n    tuple(\"c\", 3)\n]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL410_3883)\n",
				"parameters": [
					{
						"name": "Key",
						"kind": "type"
					},
					{
						"name": "Value",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uninitializedArray",
						"line": 503,
						"type": "nothrow @system (I sizes)",
						"parameters": [
							{
								"name": "sizes",
								"type": "I"
							}
						],
						"endline": 517,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uninitializedArray",
				"line": 503,
				"comment": "Returns a new array of type $(D T) allocated on the garbage collected heap\nwithout initializing its elements.  This can be a useful optimization if every\nelement will be immediately initialized.  $(D T) may be a multidimensional\narray.  In this case sizes may be specified for any number of dimensions from 0\nto the number in $(D T).\n\nuninitializedArray is nothrow and weakly pure.\n\nuninitializedArray is @system if the uninitialized element type has pointers.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "tuple"
					}
				],
				"constraint": "isDynamicArray!T && allSatisfy!(isIntegral, I) && hasIndirections!(ElementEncodingType!T)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uninitializedArray",
						"line": 520,
						"type": "nothrow @trusted (I sizes)",
						"parameters": [
							{
								"name": "sizes",
								"type": "I"
							}
						],
						"endline": 534,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uninitializedArray",
				"line": 520,
				"comment": "\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL536_3885)\n---\ndouble[] arr = uninitializedArray!(double[])(100);\nassert(arr.length == 100);\n\ndouble[][] matrix = uninitializedArray!(double[][])(42, 31);\nassert(matrix.length == 42);\nassert(matrix[0].length == 31);\n\nchar*[] ptrs = uninitializedArray!(char*[])(100);\nassert(ptrs.length == 100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL536_3885)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "tuple"
					}
				],
				"constraint": "isDynamicArray!T && allSatisfy!(isIntegral, I) && !hasIndirections!(ElementEncodingType!T)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "minimallyInitializedArray",
						"line": 558,
						"type": "nothrow @trusted (I sizes)",
						"parameters": [
							{
								"name": "sizes",
								"type": "I"
							}
						],
						"endline": 571,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "minimallyInitializedArray",
				"line": 558,
				"comment": "Returns a new array of type $(D T) allocated on the garbage collected heap.\n\nPartial initialization is done for types with indirections, for preservation\nof memory safety. Note that elements will only be initialized to 0, but not\nnecessarily the element type's $(D .init).\n\nminimallyInitializedArray is nothrow and weakly pure.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL732_3891)\n---\nint[] a = [ 10, 11, 12, 13, 14 ];\nint[] b = a[1 .. 3];\nassert(overlap(a, b) == [ 11, 12 ]);\nb = b.dup;\n// overlap disappears even though the content is the same\nassert(overlap(a, b).empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL732_3891)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "tuple"
					}
				],
				"constraint": "isDynamicArray!T && allSatisfy!(isIntegral, I)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "insertInPlace",
						"line": 818,
						"type": "void(ref T[] array, size_t pos, U stuff)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "pos",
								"type": "size_t"
							},
							{
								"name": "stuff",
								"type": "U"
							}
						],
						"endline": 874,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "insertInPlace",
				"line": 818,
				"comment": "    Inserts $(D stuff) (which must be an input range or any number of\n    implicitly convertible items) in $(D array) at position $(D pos).\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL967_3894)\n---\nint[] a = [ 1, 2, 3, 4 ];\na.insertInPlace(2, [ 1, 2 ]);\nassert(a == [ 1, 2, 1, 2, 3, 4 ]);\na.insertInPlace(3, 10u, 11);\nassert(a == [ 1, 2, 1, 10, 11, 2, 3, 4]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL967_3894)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "tuple"
					}
				],
				"constraint": "!isSomeString!(T[]) && allSatisfy!(isInputRangeOrConvertible!T, U) && U.length > 0",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "insertInPlace",
						"line": 877,
						"type": "void(ref T[] array, size_t pos, U stuff)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "pos",
								"type": "size_t"
							},
							{
								"name": "stuff",
								"type": "U"
							}
						],
						"endline": 964,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "insertInPlace",
				"line": 877,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "tuple"
					}
				],
				"constraint": "isSomeString!(T[]) && allSatisfy!(isCharOrStringOrDcharRange, U)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sameHead",
						"line": 1181,
						"type": "pure nothrow @safe bool(in T[] lhs, in T[] rhs)",
						"parameters": [
							{
								"name": "lhs",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "rhs",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1184,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "sameHead",
				"line": 1181,
				"comment": "    Returns whether the $(D front)s of $(D lhs) and $(D rhs) both refer to the\n    same place in memory, making one of the arrays a slice of the other which\n    starts at index $(D 0).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1187_3899)\n---\nauto a = [1, 2, 3, 4, 5];\nauto b = a[0..2];\n\nassert(a.sameHead(b));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1187_3899)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sameTail",
						"line": 1202,
						"type": "pure nothrow @trusted bool(in T[] lhs, in T[] rhs)",
						"parameters": [
							{
								"name": "lhs",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "rhs",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1205,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "sameTail",
				"line": 1202,
				"comment": "    Returns whether the $(D back)s of $(D lhs) and $(D rhs) both refer to the\n    same place in memory, making one of the arrays a slice of the other which\n    end at index $(D $).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1208_3900)\n---\nauto a = [1, 2, 3, 4, 5];\nauto b = a[3..$];\n\nassert(a.sameTail(b));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1208_3900)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replicate",
						"line": 1249,
						"type": "ElementEncodingType!S[](S s, size_t n)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1270,
						"char": 25,
						"kind": "function"
					}
				],
				"name": "replicate",
				"line": 1249,
				"comment": "Returns an array that consists of $(D s) (which must be an input\nrange) repeated $(D n) times. This function allocates, fills, and\nreturns a new array. For a lazy version, refer to $(XREF range, repeat).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1282_3902)\n---\nauto a = \"abc\";\nauto s = replicate(a, 3);\n\nassert(s == \"abcabcabc\");\n\nauto b = [1, 2, 3];\nauto c = replicate(b, 3);\n\nassert(c == [1, 2, 3, 1, 2, 3, 1, 2, 3]);\n\nauto d = replicate(b, 0);\n\nassert(d == []);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1282_3902)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!S",
				"char": 25,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replicate",
						"line": 1273,
						"type": "ElementType!S[](S s, size_t n)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1278,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "replicate",
				"line": 1273,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!S && !isDynamicArray!S",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "split",
						"line": 1333,
						"type": "pure @safe S[](S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 1363,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "split",
				"line": 1333,
				"comment": "Eagerly split the string $(D s) into an array of words, using whitespace as\ndelimiter. Runs of whitespace are merged together (no empty words are produced).\n\n$(D @safe), $(D pure) and $(D CTFE)-able.\n\nSee_Also:\n$(XREF_PACK algorithm,iteration,splitter) for a version that splits using any\nseparator.\n\n$(XREF regex, splitter) for a version that splits using a regular\nexpression defined separator.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1410_3906)\n---\nassert(split(\"hello world\") == [\"hello\",\"world\"]);\nassert(split(\"192.168.0.1\", \".\") == [\"192\", \"168\", \"0\", \"1\"]);\n\nauto a = split([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], [2, 3]);\nassert(a == [[1], [4, 5, 1], [4, 5]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1410_3906)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 5,
				"kind": "template"
			},
			{
				"name": "splitter",
				"line": 1423,
				"comment": "Alias for $(XREF_PACK algorithm,iteration,_splitter).\n",
				"storageClass": [
					"deprecated"
				],
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "split",
						"line": 1451,
						"type": "(Range range, Separator sep)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "sep",
								"type": "Separator"
							}
						],
						"endline": 1456,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "split",
				"line": 1451,
				"comment": "    Eagerly splits $(D range) into an array, using $(D sep) as the delimiter.\n\n    The _range must be a\n    $(XREF_PACK_NAMED _range,primitives,isForwardRange,forward _range).\n    The separator can be a value of the same type as the elements in $(D range)\n    or it can be another forward _range.\n\n    Example:\n        If $(D range) is a $(D string), $(D sep) can be a $(D char) or another\n        $(D string). The return type will be an array of strings. If $(D range) is\n        an $(D int) array, $(D sep) can be an $(D int) or another $(D int) array.\n        The return type will be an array of $(D int) arrays.\n\n    Params:\n        range = a forward _range.\n        sep = a value of the same type as the elements of $(D range) or another\n        forward range.\n\n    Returns:\n        An array containing the divided parts of $(D range).\n\n    See_Also:\n        $(XREF_PACK algorithm,iteration,splitter) for the lazy version of this\n        function.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && is(typeof(ElementType!Range.init == Separator.init))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "split",
						"line": 1458,
						"type": "(Range range, Separator sep)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "sep",
								"type": "Separator"
							}
						],
						"endline": 1463,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "split",
				"line": 1458,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isForwardRange!Separator && is(typeof(ElementType!Range.init == ElementType!Separator.init))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "split",
						"line": 1465,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 1470,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "split",
				"line": 1465,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "isTerminator",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && is(typeof(unaryFun!isTerminator(range.front)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "join",
						"line": 1550,
						"type": "ElementEncodingType!(ElementType!RoR)[](RoR ror, R sep)",
						"parameters": [
							{
								"name": "ror",
								"type": "RoR"
							},
							{
								"name": "sep",
								"type": "R"
							}
						],
						"endline": 1618,
						"char": 41,
						"kind": "function"
					}
				],
				"name": "join",
				"line": 1550,
				"comment": "   Concatenates all of the ranges in $(D ror) together into one array using\n   $(D sep) as the separator if present.\n\n   Params:\n        ror = Range of Ranges of Elements\n        sep = Range of Elements\n\n   Returns:\n        an allocated array of Elements\n\n   See_Also:\n        $(XREF_PACK algorithm,iteration,joiner)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1749_3911)\n---\nassert(join([\"hello\", \"silly\", \"world\"], \" \") == \"hello silly world\");\nassert(join([\"hello\", \"silly\", \"world\"]) == \"hellosillyworld\");\n\nassert(join([[1, 2, 3], [4, 5]], [72, 73]) == [1, 2, 3, 72, 73, 4, 5]);\nassert(join([[1, 2, 3], [4, 5]]) == [1, 2, 3, 4, 5]);\n\nconst string[] arr = [\"apple\", \"banana\"];\nassert(arr.join(\",\") == \"apple,banana\");\nassert(arr.join() == \"applebanana\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1749_3911)\n",
				"parameters": [
					{
						"name": "RoR",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RoR && isInputRange!(Unqual!(ElementType!RoR)) && isInputRange!R && is(Unqual!(ElementType!(ElementType!RoR)) == Unqual!(ElementType!R))",
				"char": 41,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "join",
						"line": 1627,
						"type": "ElementEncodingType!(ElementType!RoR)[](RoR ror, E sep)",
						"parameters": [
							{
								"name": "ror",
								"type": "RoR"
							},
							{
								"name": "sep",
								"type": "E"
							}
						],
						"endline": 1690,
						"char": 41,
						"kind": "function"
					}
				],
				"name": "join",
				"line": 1627,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "RoR",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RoR && isInputRange!(Unqual!(ElementType!RoR)) && is(E : ElementType!(ElementType!RoR))",
				"char": 41,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "join",
						"line": 1713,
						"type": "ElementEncodingType!(ElementType!RoR)[](RoR ror)",
						"parameters": [
							{
								"name": "ror",
								"type": "RoR"
							}
						],
						"endline": 1746,
						"char": 41,
						"kind": "function"
					}
				],
				"name": "join",
				"line": 1713,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "RoR",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RoR && isInputRange!(Unqual!(ElementType!RoR))",
				"char": 41,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replace",
						"line": 1944,
						"type": "E[](E[] subject, R1 from, R2 to)",
						"parameters": [
							{
								"name": "subject",
								"type": "E[]"
							},
							{
								"name": "from",
								"type": "R1"
							},
							{
								"name": "to",
								"type": "R2"
							}
						],
						"endline": 1960,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "replace",
				"line": 1944,
				"comment": "    Replace occurrences of $(D from) with $(D to) in $(D subject). Returns a new\n    array without changing the contents of $(D subject), or the original array\n    if no match is found.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1963_3919)\n---\nassert(\"Hello Wörld\".replace(\"o Wö\", \"o Wo\") == \"Hello World\");\nassert(\"Hello Wörld\".replace(\"l\", \"h\") == \"Hehho Wörhd\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1963_3919)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!(E[]) && isForwardRange!R1 && isForwardRange!R2 && (hasLength!R2 || isSomeString!R2)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceInto",
						"line": 1973,
						"type": "void(Sink sink, E[] subject, R1 from, R2 to)",
						"parameters": [
							{
								"name": "sink",
								"type": "Sink"
							},
							{
								"name": "subject",
								"type": "E[]"
							},
							{
								"name": "from",
								"type": "R1"
							},
							{
								"name": "to",
								"type": "R2"
							}
						],
						"endline": 1995,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "replaceInto",
				"line": 1973,
				"comment": "    Same as above, but outputs the result via OutputRange $(D sink).\n    If no match is found the original array is transferred to $(D sink) as is.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1998_3920)\n---\nauto arr = [1, 2, 3, 4, 5];\nauto from = [2, 3];\nauto into = [4, 6];\nauto sink = appender!(int[])();\n\nreplaceInto(sink, arr, from, into);\n\nassert(sink.data == [1, 4, 6, 4, 5]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1998_3920)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "Sink",
						"kind": "type"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isOutputRange!(Sink, E) && isDynamicArray!(E[]) && isForwardRange!R1 && isForwardRange!R2 && (hasLength!R2 || isSomeString!R2)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replace",
						"line": 2070,
						"type": "T[](T[] subject, size_t from, size_t to, Range stuff)",
						"parameters": [
							{
								"name": "subject",
								"type": "T[]"
							},
							{
								"name": "from",
								"type": "size_t"
							},
							{
								"name": "to",
								"type": "size_t"
							},
							{
								"name": "stuff",
								"type": "Range"
							}
						],
						"endline": 2097,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "replace",
				"line": 2070,
				"comment": "    Replaces elements from $(D array) with indices ranging from $(D from)\n    (inclusive) to $(D to) (exclusive) with the range $(D stuff). Returns a new\n    array without changing the contents of $(D subject).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2100_3923)\n---\nauto a = [ 1, 2, 3, 4 ];\nauto b = a.replace(1, 3, [ 9, 9, 9 ]);\nassert(a == [ 1, 2, 3, 4 ]);\nassert(b == [ 1, 9, 9, 9, 4 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2100_3923)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && (is(ElementType!Range : T) || isSomeString!(T[]) && is(ElementType!Range : dchar))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceInPlace",
						"line": 2186,
						"type": "void(ref T[] array, size_t from, size_t to, Range stuff)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "from",
								"type": "size_t"
							},
							{
								"name": "to",
								"type": "size_t"
							},
							{
								"name": "stuff",
								"type": "Range"
							}
						],
						"endline": 2224,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "replaceInPlace",
				"line": 2186,
				"comment": "    Replaces elements from $(D array) with indices ranging from $(D from)\n    (inclusive) to $(D to) (exclusive) with the range $(D stuff). Expands or\n    shrinks the array as needed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2227_3925)\n---\nint[] a = [1, 4, 5];\nreplaceInPlace(a, 1u, 2u, [2, 3, 4]);\nassert(a == [1, 2, 3, 4, 5]);\nreplaceInPlace(a, 1u, 2u, cast(int[])[]);\nassert(a == [1, 3, 4, 5]);\nreplaceInPlace(a, 1u, 3u, a[2 .. 4]);\nassert(a == [1, 4, 5, 5]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2227_3925)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(replace(array, from, to, stuff)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceFirst",
						"line": 2384,
						"type": "E[](E[] subject, R1 from, R2 to)",
						"parameters": [
							{
								"name": "subject",
								"type": "E[]"
							},
							{
								"name": "from",
								"type": "R1"
							},
							{
								"name": "to",
								"type": "R2"
							}
						],
						"endline": 2419,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "replaceFirst",
				"line": 2384,
				"comment": "    Replaces the first occurrence of $(D from) with $(D to) in $(D a). Returns a\n    new array without changing the contents of $(D subject), or the original\n    array if no match is found.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2422_3930)\n---\nauto a = [1, 2, 2, 3, 4, 5];\nauto b = a.replaceFirst([2], [1337]);\nassert(b == [1, 1337, 2, 3, 4, 5]);\n\nauto s = \"This is a foo foo list\";\nauto r = s.replaceFirst(\"foo\", \"silly\");\nassert(r == \"This is a silly foo list\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2422_3930)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!(E[]) && isForwardRange!R1 && is(typeof(appender!(E[])().put(from[0..1]))) && isForwardRange!R2 && is(typeof(appender!(E[])().put(to[0..1])))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceLast",
						"line": 2484,
						"type": "E[](E[] subject, R1 from, R2 to)",
						"parameters": [
							{
								"name": "subject",
								"type": "E[]"
							},
							{
								"name": "from",
								"type": "R1"
							},
							{
								"name": "to",
								"type": "R2"
							}
						],
						"endline": 2527,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "replaceLast",
				"line": 2484,
				"comment": "    Replaces the last occurrence of $(D from) with $(D to) in $(D a). Returns a\n    new array without changing the contents of $(D subject), or the original\n    array if no match is found.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2530_3933)\n---\nauto a = [1, 2, 2, 3, 4, 5];\nauto b = a.replaceLast([2], [1337]);\nassert(b == [1, 2, 1337, 3, 4, 5]);\n\nauto s = \"This is a foo foo list\";\nauto r = s.replaceLast(\"foo\", \"silly\");\nassert(r == \"This is a foo silly list\", r);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2530_3933)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!(E[]) && isForwardRange!R1 && is(typeof(appender!(E[])().put(from[0..1]))) && isForwardRange!R2 && is(typeof(appender!(E[])().put(to[0..1])))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceSlice",
						"line": 2583,
						"type": "inout(T)[](inout(T)[] s, in T[] slice, in T[] replacement)",
						"parameters": [
							{
								"name": "s",
								"type": "inout(T)[]"
							},
							{
								"name": "slice",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "replacement",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 2599,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "replaceSlice",
				"line": 2583,
				"comment": "    Returns a new array that is $(D s) with $(D slice) replaced by\n    $(D replacement[]).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2602_3935)\n---\nauto a = [1, 2, 3, 4, 5];\nauto b = replaceSlice(a, a[1..4], [0, 0, 0]);\n\nassert(b == [1, 0, 0, 0, 5]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2602_3935)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Appender",
						"line": 2629,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 2650,
								"comment": " Construct an appender with a given array.  Note that this does not copy the\n data.  If the array has a larger capacity as determined by arr.capacity,\n it will be used by the appender.  After initializing an appender on an array,\n appending to the original array will reallocate.\n",
								"type": "pure nothrow @trusted (T[] arr)",
								"parameters": [
									{
										"name": "arr",
										"type": "T[]"
									}
								],
								"endline": 2671,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "reserve",
								"line": 2694,
								"comment": " Reserve at least newCapacity elements for appending.  Note that more elements\n may be reserved than requested.  If newCapacity <= capacity, then nothing is\n done.\n",
								"type": "pure nothrow @safe void(size_t newCapacity)",
								"parameters": [
									{
										"name": "newCapacity",
										"type": "size_t"
									}
								],
								"endline": 2705,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "capacity",
								"line": 2712,
								"comment": " Returns the capacity of the array (the maximum number of elements the\n managed array can accommodate before triggering a reallocation).  If any\n appending will reallocate, $(D capacity) returns $(D 0).\n",
								"type": "const pure nothrow @property @safe size_t()",
								"endline": 2715,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "data",
								"line": 2720,
								"comment": " Returns the managed array.\n",
								"type": "inout pure nothrow @property @trusted inout(T)[]()",
								"endline": 2726,
								"char": 26,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "put",
										"line": 2808,
										"type": "void(U item)",
										"parameters": [
											{
												"name": "item",
												"type": "U"
											}
										],
										"endline": 2833,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "put",
								"line": 2808,
								"comment": " Appends one item to the managed array.\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "canPutItem!U",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "put",
										"line": 2845,
										"type": "void(Range items)",
										"parameters": [
											{
												"name": "items",
												"type": "Range"
											}
										],
										"endline": 2905,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "put",
								"line": 2845,
								"comment": " Appends an entire range to the managed array.\n",
								"parameters": [
									{
										"name": "Range",
										"kind": "type"
									}
								],
								"constraint": "canPutRange!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 2910,
										"type": "void(U item)",
										"parameters": [
											{
												"name": "item",
												"type": "U"
											}
										],
										"endline": 2913,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 2910,
								"comment": " Appends one item to the managed array.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"~\"",
										"kind": "value"
									},
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "canPutItem!U",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 2924,
										"type": "void(Range items)",
										"parameters": [
											{
												"name": "items",
												"type": "Range"
											}
										],
										"endline": 2927,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 2924,
								"comment": " Appends an entire range to the managed array.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"~\"",
										"kind": "value"
									},
									{
										"name": "Range",
										"kind": "type"
									}
								],
								"constraint": "canPutRange!Range",
								"char": 10,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Appender",
				"line": 2629,
				"comment": "Implements an output range that appends data to an array. This is\nrecommended over $(D a ~= data) when appending many elements because it is more\nefficient.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2973_3937)\n---\nauto app = appender!string();\nstring b = \"abcdefg\";\nforeach (char c; b)\n    app.put(c);\nassert(app.data == \"abcdefg\");\n\nint[] a = [ 1, 2 ];\nauto app2 = appender(a);\napp2.put(3);\napp2.put([ 4, 5, 6 ]);\nassert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2973_3937)\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!A",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RefAppender",
						"line": 3021,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 3041,
								"comment": " Construct a ref appender with a given array reference.  This does not copy the\n data.  If the array has a larger capacity as determined by arr.capacity, it\n will be used by the appender.  $(D RefAppender) assumes that arr is a non-null\n value.\n\n Note, do not use builtin appending (i.e. ~=) on the original array passed in\n until you are done with the appender, because calls to the appender override\n those appends.\n",
								"type": "(T[]* arr)",
								"parameters": [
									{
										"name": "arr",
										"type": "T[]*"
									}
								],
								"endline": 3045,
								"char": 5,
								"kind": "constructor"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 3059,
										"type": "void(U item)",
										"parameters": [
											{
												"name": "item",
												"type": "U"
											}
										],
										"endline": 3063,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 3059,
								"comment": " Appends one item to the managed array.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"~\"",
										"kind": "value"
									},
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "AppenderType.canPutItem!U",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 3075,
										"type": "void(Range items)",
										"parameters": [
											{
												"name": "items",
												"type": "Range"
											}
										],
										"endline": 3079,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 3075,
								"comment": " Appends an entire range to the managed array.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"~\"",
										"kind": "value"
									},
									{
										"name": "Range",
										"kind": "type"
									}
								],
								"constraint": "AppenderType.canPutRange!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "capacity",
								"line": 3086,
								"comment": " Returns the capacity of the array (the maximum number of elements the\n managed array can accommodate before triggering a reallocation).  If any\n appending will reallocate, $(D capacity) returns $(D 0).\n",
								"type": "const @property size_t()",
								"endline": 3089,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "data",
								"line": 3094,
								"comment": " Returns the managed array.\n",
								"type": "inout @property inout(T)[]()",
								"endline": 3097,
								"char": 26,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "RefAppender",
				"line": 3021,
				"comment": " An appender that can update an array in-place.  It forwards all calls to an\n underlying appender implementation.  Any calls made to the appender also update\n the pointer to the original array passed in.\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!A",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "appender",
						"line": 3104,
						"type": "Appender!A()",
						"endline": 3108,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "appender",
				"line": 3104,
				"comment": "    Convenience function that returns an $(D Appender!A) object initialized\n    with $(D array).\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!A",
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "appender",
						"line": 3110,
						"type": "Appender!(E[])(auto ref A array)",
						"parameters": [
							{
								"name": "array",
								"type": "A",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 3116,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "appender",
				"line": 3110,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "A",
						"type": "E[]",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "appender",
						"line": 3480,
						"type": "RefAppender!(E[])(A array)",
						"parameters": [
							{
								"name": "array",
								"type": "A"
							}
						],
						"endline": 3483,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "appender",
				"line": 3480,
				"comment": "    Convenience function that returns a $(D RefAppender!A) object initialized\n    with $(D array).  Don't use null for the $(D array) pointer, use the other\n    version of $(D appender) instead.\n",
				"parameters": [
					{
						"name": "A",
						"type": "E[]*",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 19,
				"kind": "template"
			}
		],
		"comment": "Functions and types that manipulate built-in arrays and associative arrays.\n\nThis module provides all kinds of functions to create, manipulate or convert arrays:\n\n$(BOOKTABLE ,\n$(TR $(TH Function Name) $(TH Description)\n)\n    $(TR $(TD $(D $(LREF _array)))\n        $(TD Returns a copy of the input in a newly allocated dynamic _array.\n    ))\n    $(TR $(TD $(D $(LREF appender)))\n        $(TD Returns a new Appender initialized with a given _array.\n    ))\n    $(TR $(TD $(D $(LREF assocArray)))\n        $(TD Returns a newly allocated associative _array from a range of key/value tuples.\n    ))\n    $(TR $(TD $(D $(LREF byPair)))\n        $(TD Construct a range iterating over an associative _array by key/value tuples.\n    ))\n    $(TR $(TD $(D $(LREF insertInPlace)))\n        $(TD Inserts into an existing _array at a given position.\n    ))\n    $(TR $(TD $(D $(LREF join)))\n        $(TD Concatenates a range of ranges into one _array.\n    ))\n    $(TR $(TD $(D $(LREF minimallyInitializedArray)))\n        $(TD Returns a new _array of type $(D T).\n    ))\n    $(TR $(TD $(D $(LREF replace)))\n        $(TD Returns a new _array with all occurrences of a certain subrange replaced.\n    ))\n    $(TR $(TD $(D $(LREF replaceFirst)))\n        $(TD Returns a new _array with the first occurrence of a certain subrange replaced.\n    ))\n    $(TR $(TD $(D $(LREF replaceInPlace)))\n        $(TD Replaces all occurrences of a certain subrange and puts the result into a given _array.\n    ))\n    $(TR $(TD $(D $(LREF replaceInto)))\n        $(TD Replaces all occurrences of a certain subrange and puts the result into an output range.\n    ))\n    $(TR $(TD $(D $(LREF replaceLast)))\n        $(TD Returns a new _array with the last occurrence of a certain subrange replaced.\n    ))\n    $(TR $(TD $(D $(LREF replaceSlice)))\n        $(TD Returns a new _array with a given slice replaced.\n    ))\n    $(TR $(TD $(D $(LREF replicate)))\n        $(TD Creates a new _array out of several copies of an input _array or range.\n    ))\n    $(TR $(TD $(D $(LREF sameHead)))\n        $(TD Checks if the initial segments of two arrays refer to the same\n        place in memory.\n    ))\n    $(TR $(TD $(D $(LREF sameTail)))\n        $(TD Checks if the final segments of two arrays refer to the same place\n        in memory.\n    ))\n    $(TR $(TD $(D $(LREF split)))\n        $(TD Eagerly split a range or string into an _array.\n    ))\n    $(TR $(TD $(D $(LREF uninitializedArray)))\n        $(TD Returns a new _array of type $(D T) without initializing its elements.\n    ))\n)\n\nCopyright: Copyright Andrei Alexandrescu 2008- and Jonathan M Davis 2011-.\n\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu) and Jonathan M Davis\n\nSource: $(PHOBOSSRC std/_array.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/traits.d",
		"name": "std.traits",
		"members": [
			{
				"members": [
					{
						"name": "InoutOf",
						"line": 275,
						"type": "inout(T)",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "InoutOf",
				"line": 275,
				"comment": "Add specific qualifier to the given type T.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ConstOf",
						"line": 277,
						"type": "const(T)",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "ConstOf",
				"line": 277,
				"comment": "ditto.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SharedOf",
						"line": 279,
						"type": "shared(T)",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "SharedOf",
				"line": 279,
				"comment": "ditto.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SharedInoutOf",
						"line": 281,
						"type": "shared(inout(T))",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "SharedInoutOf",
				"line": 281,
				"comment": "ditto.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SharedConstOf",
						"line": 283,
						"type": "shared(const(T))",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "SharedConstOf",
				"line": 283,
				"comment": "ditto.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ImmutableOf",
						"line": 285,
						"type": "immutable(T)",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "ImmutableOf",
				"line": 285,
				"comment": "ditto.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "packageName",
				"line": 338,
				"comment": " Get the full package name for the given symbol.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL356_3960)\n---\nimport std.traits;\nstatic assert(packageName!packageName == \"std\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL356_3960)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "moduleName",
				"line": 392,
				"comment": " Get the module name (including package) for the given symbol.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL412_3962)\n---\nimport std.traits;\nstatic assert(moduleName!moduleName == \"std.traits\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL412_3962)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "fullyQualifiedName",
				"line": 455,
				"comment": " Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string  converter.\n\nExample:\n-----------------\nmodule myModule;\nstruct MyStruct {}\nstatic assert(fullyQualifiedName!(const MyStruct[]) == \"const(myModule.MyStruct[])\");\n-----------------\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL466_3964)\n---\nstatic assert(fullyQualifiedName!fullyQualifiedName == \"std.traits.fullyQualifiedName\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL466_3964)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "ReturnType",
				"line": 860,
				"comment": " Get the type of the return value from a function,\n a pointer to function, a delegate, a struct\n with an opCall, a pointer to a struct with an opCall,\n or a class with an $(D opCall). Please note that $(D_KEYWORD ref)\n is not part of a type, but the attribute of the function\n (see template $(LREF functionAttributes)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL870_3968)\n---\nint foo();\nReturnType!foo x;   // x is declared as int\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL870_3968)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Parameters",
				"line": 919,
				"comment": "Get, as a tuple, the types of the parameters to a function, a pointer\nto function, a delegate, a struct with an $(D opCall), a pointer to a\nstruct with an $(D opCall), or a class with an $(D opCall).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL929_3970)\n---\nint foo(int, long);\nvoid bar(Parameters!foo);      // declares void bar(int, long);\nvoid abc(Parameters!foo[1]);   // declares void abc(long);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL929_3970)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "ParameterTypeTuple",
				"line": 939,
				"comment": " Alternate name for $(LREF Parameters), kept for legacy compatibility.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "arity",
						"line": 972,
						"type": "size_t",
						"init": "Parameters!func.length",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "arity",
				"line": 969,
				"comment": "Returns the number of arguments of function $(D func).\narity is undefined for variadic functions.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL976_3972)\n---\nvoid foo(){}\nstatic assert(arity!foo==0);\nvoid bar(uint){}\nstatic assert(arity!bar==1);\nvoid variadicFoo(uint...){}\nstatic assert(!__traits(compiles, arity!variadicFoo));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL976_3972)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "alias"
					}
				],
				"constraint": "isCallable!func && variadicFunctionStyle!func == Variadic.no",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 995,
						"value": "0u",
						"comment": " These flags can be bitwise OR-ed together to represent complex storage\n class.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "scope_",
						"line": 996,
						"value": "1u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "out_",
						"line": 997,
						"value": "2u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ref_",
						"line": 998,
						"value": "4u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lazy_",
						"line": 999,
						"value": "8u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "return_",
						"line": 1000,
						"value": "16u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "ParameterStorageClass",
				"line": 989,
				"comment": "Returns a tuple consisting of the storage classes of the parameters of a\nfunction $(D func).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1043_3973)\n---\nalias STC = ParameterStorageClass; // shorten the enum name\n\nvoid func(ref int ctx, out real result, real param)\n{\n}\nalias pstc = ParameterStorageClassTuple!func;\nstatic assert(pstc.length == 3); // three parameters\nstatic assert(pstc[0] == STC.ref_);\nstatic assert(pstc[1] == STC.out_);\nstatic assert(pstc[2] == STC.none);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1043_3973)\n",
				"baseDeco": "k",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "ParameterStorageClassTuple",
						"line": 1039,
						"type": "demangleNextParameter!margs",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ParameterStorageClassTuple",
				"line": 1004,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ParameterIdentifierTuple",
						"line": 1148,
						"type": "Impl!()",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ParameterIdentifierTuple",
				"line": 1112,
				"comment": "Get, as a tuple, the identifiers of the parameters to a function symbol.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1152_3976)\n---\nint foo(int num, string name, int);\nstatic assert([ParameterIdentifierTuple!foo] == [\"num\", \"name\", \"\"]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1152_3976)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ParameterDefaults",
						"line": 1242,
						"type": "Impl!()",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ParameterDefaults",
				"line": 1199,
				"comment": "Get, as a tuple, the default value of the parameters to a function symbol.\nIf a parameter doesn't have the default value, $(D void) is returned instead.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1246_3978)\n---\nint foo(int num, string name = \"hello\", int[] = [1,2,3]);\nstatic assert(is(ParameterDefaults!foo[0] == void));\nstatic assert(   ParameterDefaults!foo[1] == \"hello\");\nstatic assert(   ParameterDefaults!foo[2] == [1,2,3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1246_3978)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "ParameterDefaultValueTuple",
				"line": 1257,
				"comment": " Alternate name for $(LREF ParameterDefaults), kept for legacy compatibility.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1302,
						"value": "0u",
						"comment": " These flags can be bitwise OR-ed together to represent a complex attribute.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "pure_",
						"line": 1303,
						"value": "1u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "nothrow_",
						"line": 1304,
						"value": "2u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ref_",
						"line": 1305,
						"value": "4u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "property",
						"line": 1306,
						"value": "8u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "trusted",
						"line": 1307,
						"value": "16u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "safe",
						"line": 1308,
						"value": "32u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "nogc",
						"line": 1309,
						"value": "64u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "system",
						"line": 1310,
						"value": "128u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "const_",
						"line": 1311,
						"value": "256u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "immutable_",
						"line": 1312,
						"value": "512u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "inout_",
						"line": 1313,
						"value": "1024u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "shared_",
						"line": 1314,
						"value": "2048u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "return_",
						"line": 1315,
						"value": "4096u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "FunctionAttribute",
				"line": 1297,
				"comment": "Returns the attributes attached to a function $(D func).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1331_3980)\n---\nimport std.traits : functionAttributes, FunctionAttribute;\n\nalias FA = FunctionAttribute; // shorten the enum name\n\nreal func(real x) pure nothrow @safe\n{\n    return x;\n}\nstatic assert(functionAttributes!func & FA.pure_);\nstatic assert(functionAttributes!func & FA.safe);\nstatic assert(!(functionAttributes!func & FA.trusted)); // not @trusted\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1331_3980)\n",
				"baseDeco": "k",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "functionAttributes",
						"line": 1326,
						"type": "FunctionAttribute",
						"init": "extractAttribFlags!(__traits(getFunctionAttributes, FuncSym))()",
						"char": 28,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "functionAttributes",
				"line": 1319,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSafe",
						"line": 1490,
						"init": "(functionAttributes!func & FunctionAttribute.safe) != 0 || (functionAttributes!func & FunctionAttribute.trusted) != 0",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSafe",
				"line": 1487,
				"comment": "$(D true) if $(D func) is $(D @safe) or $(D @trusted).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1495_3982)\n---\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert( isSafe!add);\nstatic assert( isSafe!sub);\nstatic assert(!isSafe!mul);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1495_3982)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "alias"
					}
				],
				"constraint": "isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isUnsafe",
						"line": 1568,
						"init": "!isSafe!func",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isUnsafe",
				"line": 1566,
				"comment": "$(D true) if $(D func) is $(D @system).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1572_3984)\n---\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert(!isUnsafe!add);\nstatic assert(!isUnsafe!sub);\nstatic assert( isUnsafe!mul);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1572_3984)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "functionLinkage",
						"line": 1692,
						"type": "string",
						"init": "['F':\"D\", 'U':\"C\", 'W':\"Windows\", 'V':\"Pascal\", 'R':\"C++\"][mangledName!Func[0]]",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "functionLinkage",
				"line": 1687,
				"comment": "Returns the calling convention of function as a string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1703_3988)\n---\nextern(D) void Dfunc() {}\nextern(C) void Cfunc() {}\nstatic assert(functionLinkage!Dfunc == \"D\");\nstatic assert(functionLinkage!Cfunc == \"C\");\n\nstring a = functionLinkage!Dfunc;\nassert(a == \"D\");\n\nauto fp = &Cfunc;\nstring b = functionLinkage!fp;\nassert(b == \"C\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1703_3988)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 1737,
						"value": "0",
						"comment": "Function is not variadic.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "c",
						"line": 1738,
						"value": "1",
						"comment": "Function is a _C-style variadic function.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "d",
						"line": 1740,
						"value": "2",
						"comment": "Function is a _D-style variadic function, which uses\n\n__argptr and __arguments.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "typesafe",
						"line": 1741,
						"value": "3",
						"comment": "Function is a typesafe variadic function.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Variadic",
				"line": 1735,
				"comment": "Determines what kind of variadic parameters function has.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1766_3990)\n---\nvoid func() {}\nstatic assert(variadicFunctionStyle!func == Variadic.no);\n\nextern(C) int printf(in char*, ...);\nstatic assert(variadicFunctionStyle!printf == Variadic.c);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1766_3990)\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "variadicFunctionStyle",
						"line": 1759,
						"type": "Variadic",
						"init": "argclose == 'X' ? Variadic.typesafe : argclose == 'Y' ? callconv == \"C\" ? Variadic.c : Variadic.d : Variadic.no",
						"char": 19,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "variadicFunctionStyle",
				"line": 1745,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "FunctionTypeOf",
				"line": 1804,
				"comment": "Get the function type from a callable object $(D func).\n\nUsing builtin $(D typeof) on a property function yields the types of the\nproperty value, not of the property function itself.  Still,\n$(D FunctionTypeOf) is able to obtain function types of properties.\n\nNote:\nDo not confuse function types with function pointer types; function types are\nusually used for compile-time reflection purposes.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1835_3992)\n---\nclass C\n{\n    int value() @property { return 0; }\n}\nstatic assert(is( typeof(C.value) == int ));\nstatic assert(is( FunctionTypeOf!(C.value) == function ));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1835_3992)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "SetFunctionAttributes",
				"line": 1909,
				"comment": " Constructs a new function or delegate type with the same basic signature\n as the given one, but different attributes (including linkage).\n\n This is especially useful for adding/removing attributes to/from types in\n generic code, where the actual type name cannot be spelt out.\n\n Params:\n    T = The base type.\n    linkage = The desired linkage of the result type.\n    attrs = The desired $(LREF FunctionAttribute)s of the result type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1994_3994)\n---\nalias ExternC(T) = SetFunctionAttributes!(T, \"C\", functionAttributes!T);\n\nauto assumePure(T)(T t)\n    if (isFunctionPointer!T || isDelegate!T)\n{\n    enum attrs = functionAttributes!T | FunctionAttribute.pure_;\n    return cast(SetFunctionAttributes!(T, functionLinkage!T, attrs)) t;\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1994_3994)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "linkage",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "attrs",
						"deco": "k",
						"kind": "value"
					}
				],
				"constraint": "isFunctionPointer!T || isDelegate!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SetFunctionAttributes",
						"line": 1990,
						"type": "FunctionTypeOf!(SetFunctionAttributes!(T*, linkage, attrs))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "SetFunctionAttributes",
				"line": 1984,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "linkage",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "attrs",
						"deco": "k",
						"kind": "value"
					}
				],
				"constraint": "is(T == function)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isNested",
						"line": 2073,
						"init": "__traits(isNested, T)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isNested",
				"line": 2070,
				"comment": "Determines whether $(D T) has its own context pointer.\n$(D T) must be either $(D class), $(D struct), or $(D union).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2077_3996)\n---\nstatic struct S { }\nstatic assert(!isNested!S);\n\nint i;\nstruct NestedStruct { void f() { ++i; } }\nstatic assert(isNested!NestedStruct);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2077_3996)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) || is(T == struct) || is(T == union)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasNested",
				"line": 2091,
				"comment": "Determines whether $(D T) or any of its representation types\nhave a context pointer.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2103_3997)\n---\nstatic struct S { }\n\nint i;\nstruct NS { void f() { ++i; } }\n\nstatic assert(!hasNested!(S[2]));\nstatic assert(hasNested!(NS[2]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2103_3997)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Fields",
				"line": 2174,
				"comment": " Get as a tuple the types of the fields of a struct, class, or union.\n This consists of the fields that take up memory space,\n excluding the hidden fields like the virtual function\n table pointer or a context pointer for nested types.\n If $(D T) isn't a struct, class, or union returns a tuple\n with one element $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2185_3999)\n---\nstruct S { int x; float y; }\nstatic assert(is(Fields!S == TypeTuple!(int, float)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2185_3999)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "FieldTypeTuple",
				"line": 2194,
				"comment": " Alternate name for $(LREF Fields), kept for legacy compatibility.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "FieldNameTuple",
				"line": 2229,
				"comment": " Get as an expression tuple the names of the fields of a struct, class, or\n union. This consists of the fields that take up memory space, excluding the\n hidden fields like the virtual function table pointer or a context pointer\n for nested types. If $(D T) isn't a struct, class, or union returns an\n expression tuple with an empty string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2240_4001)\n---\nstruct S { int x; float y; }\nstatic assert(FieldNameTuple!S == TypeTuple!(\"x\", \"y\"));\nstatic assert(FieldNameTuple!int == TypeTuple!\"\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2240_4001)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "RepresentationTypeTuple",
				"line": 2274,
				"comment": "Get the primitive types of the fields of a struct or class, in\ntopological order.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2315_4003)\n---\nstruct S1 { int a; float b; }\nstruct S2 { char[] a; union { S1 b; S1 * c; } }\nalias R = RepresentationTypeTuple!S2;\nassert(R.length == 4\n    && is(R[0] == char[]) && is(R[1] == int)\n    && is(R[2] == float) && is(R[3] == S1*));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2315_4003)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2389_4005)\n---\n// simple types\nstatic assert(!hasRawAliasing!int);\nstatic assert( hasRawAliasing!(char*));\n// references aren't raw pointers\nstatic assert(!hasRawAliasing!Object);\n// built-in arrays do contain raw pointers\nstatic assert( hasRawAliasing!(int[]));\n// aggregate of simple types\nstruct S1 { int a; double b; }\nstatic assert(!hasRawAliasing!S1);\n// indirect aggregation\nstruct S2 { S1 a; double b; }\nstatic assert(!hasRawAliasing!S2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2389_4005)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2485_4007)\n---\n// simple types\nstatic assert(!hasRawUnsharedAliasing!int);\nstatic assert( hasRawUnsharedAliasing!(char*));\nstatic assert(!hasRawUnsharedAliasing!(shared char*));\n// references aren't raw pointers\nstatic assert(!hasRawUnsharedAliasing!Object);\n// built-in arrays do contain raw pointers\nstatic assert( hasRawUnsharedAliasing!(int[]));\nstatic assert(!hasRawUnsharedAliasing!(shared int[]));\n// aggregate of simple types\nstruct S1 { int a; double b; }\nstatic assert(!hasRawUnsharedAliasing!S1);\n// indirect aggregation\nstruct S2 { S1 a; double b; }\nstatic assert(!hasRawUnsharedAliasing!S2);\n// struct with a pointer member\nstruct S3 { int a; double * b; }\nstatic assert( hasRawUnsharedAliasing!S3);\nstruct S4 { int a; shared double * b; }\nstatic assert(!hasRawUnsharedAliasing!S4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2485_4007)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasAliasing",
				"line": 2689,
				"comment": "Returns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*) and $(D U)\nis not immutable;) $(LI an array $(D U[]) and $(D U) is not\nimmutable;) $(LI a reference to a class or interface type $(D C) and $(D C) is\nnot immutable.) $(LI an associative array that is not immutable.)\n$(LI a delegate.))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2711_4009)\n---\nstruct S1 { int a; Object b; }\nstruct S2 { string a; }\nstruct S3 { int a; immutable Object b; }\nstruct S4 { float[3] vals; }\nstatic assert( hasAliasing!S1);\nstatic assert(!hasAliasing!S2);\nstatic assert(!hasAliasing!S3);\nstatic assert(!hasAliasing!S4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2711_4009)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasIndirections",
				"line": 2792,
				"comment": "Returns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*);) $(LI an\narray $(D U[]);) $(LI a reference to a class type $(D C).)\n$(LI an associative array.) $(LI a delegate.))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2806_4011)\n---\nstatic assert( hasIndirections!(int[string]));\nstatic assert( hasIndirections!(void delegate()));\nstatic assert( hasIndirections!(void delegate() immutable));\nstatic assert( hasIndirections!(immutable(void delegate())));\nstatic assert( hasIndirections!(immutable(void delegate() immutable)));\n\nstatic assert(!hasIndirections!(void function()));\nstatic assert( hasIndirections!(void*[1]));\nstatic assert(!hasIndirections!(byte[1]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2806_4011)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasUnsharedAliasing",
				"line": 2902,
				"comment": "Returns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*) and $(D U)\nis not immutable or shared;) $(LI an array $(D U[]) and $(D U) is not\nimmutable or shared;) $(LI a reference to a class type $(D C) and\n$(D C) is not immutable or shared.) $(LI an associative array that is not\nimmutable or shared.) $(LI a delegate that is not shared.))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2935_4014)\n---\nstruct S1 { int a; Object b; }\nstruct S2 { string a; }\nstruct S3 { int a; immutable Object b; }\nstatic assert( hasUnsharedAliasing!S1);\nstatic assert(!hasUnsharedAliasing!S2);\nstatic assert(!hasUnsharedAliasing!S3);\n\nstruct S4 { int a; shared Object b; }\nstruct S5 { char[] a; }\nstruct S6 { shared char[] b; }\nstruct S7 { float[3] vals; }\nstatic assert(!hasUnsharedAliasing!S4);\nstatic assert( hasUnsharedAliasing!S5);\nstatic assert(!hasUnsharedAliasing!S6);\nstatic assert(!hasUnsharedAliasing!S7);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2935_4014)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasElaborateCopyConstructor",
				"line": 3077,
				"comment": " True if $(D S) or any type embedded directly in the representation of $(D S)\n defines an elaborate copy constructor. Elaborate copy constructors are\n introduced by defining $(D this(this)) for a $(D struct).\n\n Classes and unions never have elaborate copy constructors.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3095_4017)\n---\nstatic assert(!hasElaborateCopyConstructor!int);\n\nstatic struct S1 { }\nstatic struct S2 { this(this) {} }\nstatic struct S3 { S2 field; }\nstatic struct S4 { S3[1] field; }\nstatic struct S5 { S3[] field; }\nstatic struct S6 { S3[0] field; }\nstatic struct S7 { @disable this(); S3 field; }\nstatic assert(!hasElaborateCopyConstructor!S1);\nstatic assert( hasElaborateCopyConstructor!S2);\nstatic assert( hasElaborateCopyConstructor!(immutable S2));\nstatic assert( hasElaborateCopyConstructor!S3);\nstatic assert( hasElaborateCopyConstructor!(S3[1]));\nstatic assert(!hasElaborateCopyConstructor!(S3[0]));\nstatic assert( hasElaborateCopyConstructor!S4);\nstatic assert(!hasElaborateCopyConstructor!S5);\nstatic assert(!hasElaborateCopyConstructor!S6);\nstatic assert( hasElaborateCopyConstructor!S7);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3095_4017)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasElaborateAssign",
				"line": 3133,
				"comment": "   True if $(D S) or any type directly embedded in the representation of $(D S)\n   defines an elaborate assignment. Elaborate assignments are introduced by\n   defining $(D opAssign(typeof(this))) or $(D opAssign(ref typeof(this)))\n   for a $(D struct) or when there is a compiler-generated $(D opAssign).\n\n   A type $(D S) gets compiler-generated $(D opAssign) in case it has\n   an elaborate copy constructor or elaborate destructor.\n\n   Classes and unions never have elaborate assignments.\n\n   Note: Structs with (possibly nested) postblit operator(s) will have a\n   hidden yet elaborate compiler generated assignment operator (unless\n   explicitly disabled).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3152_4018)\n---\nstatic assert(!hasElaborateAssign!int);\n\nstatic struct S  { void opAssign(S) {} }\nstatic assert( hasElaborateAssign!S);\nstatic assert(!hasElaborateAssign!(const(S)));\n\nstatic struct S1 { void opAssign(ref S1) {} }\nstatic struct S2 { void opAssign(int) {} }\nstatic struct S3 { S s; }\nstatic assert( hasElaborateAssign!S1);\nstatic assert(!hasElaborateAssign!S2);\nstatic assert( hasElaborateAssign!S3);\nstatic assert( hasElaborateAssign!(S3[1]));\nstatic assert(!hasElaborateAssign!(S3[0]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3152_4018)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasElaborateDestructor",
				"line": 3219,
				"comment": "   True if $(D S) or any type directly embedded in the representation\n   of $(D S) defines an elaborate destructor. Elaborate destructors\n   are introduced by defining $(D ~this()) for a $(D\n   struct).\n\n   Classes and unions never have elaborate destructors, even\n   though classes may define $(D ~this()).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3237_4020)\n---\nstatic assert(!hasElaborateDestructor!int);\n\nstatic struct S1 { }\nstatic struct S2 { ~this() {} }\nstatic struct S3 { S2 field; }\nstatic struct S4 { S3[1] field; }\nstatic struct S5 { S3[] field; }\nstatic struct S6 { S3[0] field; }\nstatic struct S7 { @disable this(); S3 field; }\nstatic assert(!hasElaborateDestructor!S1);\nstatic assert( hasElaborateDestructor!S2);\nstatic assert( hasElaborateDestructor!(immutable S2));\nstatic assert( hasElaborateDestructor!S3);\nstatic assert( hasElaborateDestructor!(S3[1]));\nstatic assert(!hasElaborateDestructor!(S3[0]));\nstatic assert( hasElaborateDestructor!S4);\nstatic assert(!hasElaborateDestructor!S5);\nstatic assert(!hasElaborateDestructor!S6);\nstatic assert( hasElaborateDestructor!S7);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3237_4020)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasMember",
						"line": 3266,
						"init": "__traits(hasMember, T, name)",
						"char": 6,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasMember",
				"line": 3266,
				"comment": "   Yields $(D true) if and only if $(D T) is an aggregate that defines\n   a symbol called $(D name).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3269_4021)\n---\nstatic assert(!hasMember!(int, \"blah\"));\nstruct S1 { int blah; }\nstruct S2 { int blah(){ return 0; } }\nclass C1 { int blah; }\nclass C2 { int blah(){ return 0; } }\nstatic assert(hasMember!(S1, \"blah\"));\nstatic assert(hasMember!(S2, \"blah\"));\nstatic assert(hasMember!(C1, \"blah\"));\nstatic assert(hasMember!(C2, \"blah\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3269_4021)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "name",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "EnumMembers",
						"line": 3427,
						"type": "EnumSpecificMembers!(__traits(allMembers, E))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "EnumMembers",
				"line": 3388,
				"comment": "Retrieves the members of an enumerated type $(D enum E).\n\nParams:\n E = An enumerated type. $(D E) may have duplicated values.\n\nReturns:\n Static tuple composed of the members of the enumerated type $(D E).\n The members are arranged in the same order as declared in $(D E).\n\nNote:\n An enum can have multiple members which have the same value. If you want\n to use EnumMembers to e.g. generate switch cases at compile-time,\n you should use the $(XREF typetuple, NoDuplicates) template to avoid\n generating duplicate switch cases.\n\nNote:\n Returned values are strictly typed with $(D E). Thus, the following code\n does not work without the explicit cast:\n--------------------\nenum E : int { a, b, c }\nint[] abc = cast(int[]) [ EnumMembers!E ];\n--------------------\n Cast is not necessary if the type of the variable is inferred. See the\n example below.\n\nExample:\n Creating an array of enumerated values:\n--------------------\nenum Sqrts : real\n{\n    one   = 1,\n    two   = 1.41421,\n    three = 1.73205,\n}\nauto sqrts = [ EnumMembers!Sqrts ];\nassert(sqrts == [ Sqrts.one, Sqrts.two, Sqrts.three ]);\n--------------------\n\n A generic function $(D rank(v)) in the following example uses this\n template for finding a member $(D e) in an enumerated type $(D E).\n--------------------\n// Returns i if e is the i-th enumerator of E.\nsize_t rank(E)(E e)\n    if (is(E == enum))\n{\n    foreach (i, member; EnumMembers!E)\n    {\n        if (e == member)\n            return i;\n    }\n    assert(0, \"Not an enum member\");\n}\n\nenum Mode\n{\n    read  = 1,\n    write = 2,\n    map   = 4,\n}\nassert(rank(Mode.read ) == 0);\nassert(rank(Mode.write) == 1);\nassert(rank(Mode.map  ) == 2);\n--------------------\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "is(E == enum)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "BaseTypeTuple",
				"line": 3480,
				"comment": " Get a $(D_PARAM TypeTuple) of the base class and base interfaces of\n this class or interface. $(D_PARAM BaseTypeTuple!Object) returns\n the empty type tuple.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3489_4028)\n---\ninterface I1 { }\ninterface I2 { }\ninterface I12 : I1, I2 { }\nstatic assert(is(BaseTypeTuple!I12 == TypeTuple!(I1, I2)));\n\ninterface I3 : I1 { }\ninterface I123 : I1, I2, I3 { }\nstatic assert(is(BaseTypeTuple!I123 == TypeTuple!(I1, I2, I3)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3489_4028)\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "BaseClassesTuple",
				"line": 3522,
				"comment": " Get a $(D_PARAM TypeTuple) of $(I all) base classes of this class,\n in decreasing order. Interfaces are not included. $(D_PARAM\n BaseClassesTuple!Object) yields the empty type tuple.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3542_4030)\n---\nclass C1 { }\nclass C2 : C1 { }\nclass C3 : C2 { }\nstatic assert(!BaseClassesTuple!Object.length);\nstatic assert(is(BaseClassesTuple!C1 == TypeTuple!(Object)));\nstatic assert(is(BaseClassesTuple!C2 == TypeTuple!(C1, Object)));\nstatic assert(is(BaseClassesTuple!C3 == TypeTuple!(C2, C1, Object)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3542_4030)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "InterfacesTuple",
				"line": 3570,
				"comment": " Get a $(D_PARAM TypeTuple) of $(I all) interfaces directly or\n indirectly inherited by this class or interface. Interfaces do not\n repeat if multiply implemented. $(D_PARAM InterfacesTuple!Object)\n yields the empty type tuple.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "TransitiveBaseTypeTuple",
				"line": 3630,
				"comment": " Get a $(D_PARAM TypeTuple) of $(I all) base classes of $(D_PARAM\n T), in decreasing order, followed by $(D_PARAM T)'s\n interfaces. $(D_PARAM TransitiveBaseTypeTuple!Object) yields the\n empty type tuple.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3640_4034)\n---\ninterface J1 {}\ninterface J2 {}\nclass B1 {}\nclass B2 : B1, J1, J2 {}\nclass B3 : B2, J1 {}\nalias TL = TransitiveBaseTypeTuple!B3;\nassert(TL.length == 5);\nassert(is (TL[0] == B2));\nassert(is (TL[1] == B1));\nassert(is (TL[2] == Object));\nassert(is (TL[3] == J1));\nassert(is (TL[4] == J2));\n\nassert(TransitiveBaseTypeTuple!Object.length == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3640_4034)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "MemberFunctionsTuple",
				"line": 3664,
				"comment": "Returns a tuple of non-static functions with the name $(D name) declared in the\nclass or interface $(D C).  Covariant duplicates are shrunk into the most\nderived one.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3755_4035)\n---\ninterface I { I foo(); }\nclass B\n{\n    real foo(real v) { return v; }\n}\nclass C : B, I\n{\n    override C foo() { return this; } // covariant overriding of I.foo()\n}\nalias foos = MemberFunctionsTuple!(C, \"foo\");\nstatic assert(foos.length == 2);\nstatic assert(__traits(isSame, foos[0], C.foo));\nstatic assert(__traits(isSame, foos[1], B.foo));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3755_4035)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "name",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "is(C == class) || is(C == interface)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "TemplateOf",
						"line": 3818,
						"type": "Base",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "TemplateOf",
				"line": 3816,
				"comment": "Returns an alias to the template that $(D T) is an instance of.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3828_4037)\n---\nstruct Foo(T, U) {}\nstatic assert(__traits(isSame, TemplateOf!(Foo!(int, real)), Foo));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3828_4037)\n",
				"parameters": [
					{
						"name": "T",
						"specAlias": "Base!Args",
						"kind": "alias"
					},
					{
						"name": "Base",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "TemplateOf",
						"line": 3824,
						"type": "Base",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "TemplateOf",
				"line": 3822,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"type": "Base!Args",
						"kind": "type"
					},
					{
						"name": "Base",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "TemplateArgsOf",
						"line": 3863,
						"type": "Args",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "TemplateArgsOf",
				"line": 3861,
				"comment": "Returns a $(D TypeTuple) of the template arguments used to instantiate $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3873_4039)\n---\nstruct Foo(T, U) {}\nstatic assert(is(TemplateArgsOf!(Foo!(int, real)) == TypeTuple!(int, real)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3873_4039)\n",
				"parameters": [
					{
						"name": "T",
						"specAlias": "Base!Args",
						"kind": "alias"
					},
					{
						"name": "Base",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "TemplateArgsOf",
						"line": 3869,
						"type": "Args",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "TemplateArgsOf",
				"line": 3867,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"type": "Base!Args",
						"kind": "type"
					},
					{
						"name": "Base",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "classInstanceAlignment",
						"line": 3924,
						"type": "maxAlignment!(void*, typeof(T.tupleof))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "classInstanceAlignment",
				"line": 3922,
				"comment": "Returns class instance alignment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3928_4041)\n---\nclass A { byte b; }\nclass B { long l; }\n\n// As class instance always has a hidden pointer\nstatic assert(classInstanceAlignment!A == (void*).alignof);\nstatic assert(classInstanceAlignment!B == long.alignof);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3928_4041)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "CommonType",
				"line": 3949,
				"comment": "Get the type that all types can be implicitly converted to. Useful\ne.g. in figuring out an array type from a bunch of initializing\nvalues. Returns $(D_PARAM void) if passed an empty list, or if the\ntypes have no common type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3975_4042)\n---\nalias X = CommonType!(int, long, short);\nassert(is(X == long));\nalias Y = CommonType!(int, char[], short);\nassert(is(Y == void));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3975_4042)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "ImplicitConversionTargets",
				"line": 4002,
				"comment": " Returns a tuple with all possible target types of an implicit\n conversion of a value of type $(D_PARAM T).\n\n Important note:\n\n The possible targets are computed more conservatively than the D\n 2.005 compiler does, eliminating all dangerous conversions. For\n example, $(D_PARAM ImplicitConversionTargets!double) does not\n include $(D_PARAM float).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isImplicitlyConvertible",
						"line": 4075,
						"deco": "b",
						"init": "is(typeof(()\n{\nvoid fun(ref From v)\n{\nvoid gun(To)\n{\n}\ngun(v);\n}\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isImplicitlyConvertible",
				"line": 4073,
				"comment": "Is $(D From) implicitly convertible to $(D To)?\n",
				"parameters": [
					{
						"name": "From",
						"kind": "type"
					},
					{
						"name": "To",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAssignable",
						"line": 4110,
						"init": "isRvalueAssignable!(Lhs, Rhs) && isLvalueAssignable!(Lhs, Rhs)",
						"char": 6,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAssignable",
				"line": 4110,
				"comment": "Returns $(D true) iff a value of type $(D Rhs) can be assigned to a variable of\ntype $(D Lhs).\n\n$(D isAssignable) returns whether both an lvalue and rvalue can be assigned.\n\nIf you omit $(D Rhs), $(D isAssignable) will check identity assignable of $(D Lhs).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4113_4046)\n---\nstatic assert( isAssignable!(long, int));\nstatic assert(!isAssignable!(int, long));\nstatic assert( isAssignable!(const(char)[], string));\nstatic assert(!isAssignable!(string, char[]));\n\n// int is assignable to int\nstatic assert( isAssignable!int);\n\n// immutable int is not assignable to immutable int\nstatic assert(!isAssignable!(immutable int));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4113_4046)\n",
				"parameters": [
					{
						"name": "Lhs",
						"kind": "type"
					},
					{
						"name": "Rhs",
						"default": "Lhs",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isCovariantWith",
				"line": 4321,
				"comment": "Determines whether the function type $(D F) is covariant with $(D G), i.e.,\nfunctions of the type $(D F) can override ones of the type $(D G).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4430_4050)\n---\ninterface I { I clone(); }\ninterface J { J clone(); }\nclass C : I\n{\n    override C clone()   // covariant overriding of I.clone()\n    {\n        return new C;\n    }\n}\n\n// C.clone() can override I.clone(), indeed.\nstatic assert(isCovariantWith!(typeof(C.clone), typeof(I.clone)));\n\n// C.clone() can't override J.clone(); the return type C is not implicitly\n// convertible to J.\nstatic assert(!isCovariantWith!(typeof(C.clone), typeof(J.clone)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4430_4050)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "G",
						"kind": "type"
					}
				],
				"constraint": "is(F == function) && is(G == function)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "rvalueOf",
						"line": 4534,
						"type": "@property T(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init)",
						"parameters": [
							{
								"type": "__InoutWorkaroundStruct",
								"storageClass": [
									"inout"
								],
								"default": "__InoutWorkaroundStruct.init"
							}
						],
						"char": 13,
						"kind": "function"
					}
				],
				"name": "rvalueOf",
				"line": 4534,
				"comment": "Creates an lvalue or rvalue of type $(D T) for $(D typeof(...)) and\n$(D __traits(compiles, ...)) purposes. No actual value is returned.\n\nNote: Trying to use returned value will result in a\n\"Symbol Undefined\" error at link time.\n\nExample:\n---\n// Note that `f` doesn't have to be implemented\n// as is isn't called.\nint f(int);\nbool f(ref int);\nstatic assert(is(typeof(f(rvalueOf!int)) == int));\nstatic assert(is(typeof(f(lvalueOf!int)) == bool));\n\nint i = rvalueOf!int; // error, no actual value is returned\n---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "lvalueOf",
						"line": 4537,
						"type": "@property ref T(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init)",
						"parameters": [
							{
								"type": "__InoutWorkaroundStruct",
								"storageClass": [
									"inout"
								],
								"default": "__InoutWorkaroundStruct.init"
							}
						],
						"char": 17,
						"kind": "function"
					}
				],
				"name": "lvalueOf",
				"line": 4537,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isBoolean",
						"line": 4987,
						"deco": "b",
						"init": "is(BooleanTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isBoolean",
				"line": 4987,
				"comment": " Detect whether $(D T) is a built-in boolean type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4990_4064)\n---\nstatic assert( isBoolean!bool);\nenum EB : bool { a = true }\nstatic assert( isBoolean!EB);\nstatic assert(!isBoolean!(SubTypeOf!bool));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4990_4064)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isIntegral",
						"line": 5002,
						"deco": "b",
						"init": "is(IntegralTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isIntegral",
				"line": 5002,
				"comment": " Detect whether $(D T) is a built-in integral type. Types $(D bool),\n $(D char), $(D wchar), and $(D dchar) are not considered integral.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isFloatingPoint",
						"line": 5026,
						"deco": "b",
						"init": "is(FloatingPointTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isFloatingPoint",
				"line": 5026,
				"comment": " Detect whether $(D T) is a built-in floating point type.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isNumeric",
						"line": 5053,
						"deco": "b",
						"init": "is(NumericTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isNumeric",
				"line": 5053,
				"comment": "Detect whether $(D T) is a built-in numeric type (integral or floating\npoint).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isScalarType",
						"line": 5070,
						"deco": "b",
						"init": "isNumeric!T || isSomeChar!T || isBoolean!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isScalarType",
				"line": 5070,
				"comment": "Detect whether $(D T) is a scalar type (a built-in numeric, character or boolean type).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5073_4068)\n---\nstatic assert(!isScalarType!void);\nstatic assert( isScalarType!(immutable(int)));\nstatic assert( isScalarType!(shared(float)));\nstatic assert( isScalarType!(shared(const bool)));\nstatic assert( isScalarType!(const(dchar)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5073_4068)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isBasicType",
						"line": 5085,
						"deco": "b",
						"init": "isScalarType!T || is(T == void)",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isBasicType",
				"line": 5085,
				"comment": "Detect whether $(D T) is a basic type (scalar type or void).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5088_4069)\n---\nstatic assert(isBasicType!void);\nstatic assert(isBasicType!(immutable(int)));\nstatic assert(isBasicType!(shared(float)));\nstatic assert(isBasicType!(shared(const bool)));\nstatic assert(isBasicType!(const(dchar)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5088_4069)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isUnsigned",
						"line": 5100,
						"deco": "b",
						"init": "is(UnsignedTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isUnsigned",
				"line": 5100,
				"comment": "Detect whether $(D T) is a built-in unsigned numeric type.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSigned",
						"line": 5117,
						"deco": "b",
						"init": "is(SignedTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSigned",
				"line": 5117,
				"comment": "Detect whether $(D T) is a built-in signed numeric type.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSomeChar",
						"line": 5134,
						"deco": "b",
						"init": "is(CharTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSomeChar",
				"line": 5134,
				"comment": "Detect whether $(D T) is one of the built-in character types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5137_4072)\n---\nstatic assert(!isSomeChar!int);\nstatic assert(!isSomeChar!byte);\nstatic assert(!isSomeChar!string);\nstatic assert(!isSomeChar!wstring);\nstatic assert(!isSomeChar!dstring);\nstatic assert(!isSomeChar!(char[4]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5137_4072)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSomeString",
						"line": 5170,
						"deco": "b",
						"init": "is(StringTypeOf!T) && !isAggregateType!T && !isStaticArray!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSomeString",
				"line": 5170,
				"comment": "Detect whether $(D T) is one of the built-in string types.\n\nThe built-in string types are $(D Char[]), where $(D Char) is any of $(D char),\n$(D wchar) or $(D dchar), with or without qualifiers.\n\nStatic arrays of characters (like $(D char[80])) are not considered\nbuilt-in string types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5173_4074)\n---\nstatic assert(!isSomeString!int);\nstatic assert(!isSomeString!(int[]));\nstatic assert(!isSomeString!(byte[]));\nstatic assert(!isSomeString!(typeof(null)));\nstatic assert(!isSomeString!(char[4]));\n\nenum ES : string { a = \"aaa\", b = \"bbb\" }\nstatic assert( isSomeString!ES);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5173_4074)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isNarrowString",
						"line": 5200,
						"deco": "b",
						"init": "(is(T : const(char[])) || is(T : const(wchar[]))) && !isAggregateType!T && !isStaticArray!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isNarrowString",
				"line": 5200,
				"comment": " Detect whether type $(D T) is a narrow string.\n\n All arrays that use char, wchar, and their qualified versions are narrow\n strings. (Those include string and wstring).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5203_4076)\n---\nstatic assert(isNarrowString!string);\nstatic assert(isNarrowString!wstring);\nstatic assert(isNarrowString!(char[]));\nstatic assert(isNarrowString!(wchar[]));\n\nstatic assert(!isNarrowString!dstring);\nstatic assert(!isNarrowString!(dchar[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5203_4076)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAutodecodableString",
						"line": 5281,
						"deco": "b",
						"init": "(is(T : const(char[])) || is(T : const(wchar[]))) && !isStaticArray!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAutodecodableString",
				"line": 5281,
				"comment": " Detect whether type $(D T) is a string that will be autodecoded.\n\n All arrays that use char, wchar, and their qualified versions are narrow\n strings. (Those include string and wstring).\n Aggregates that implicitly cast to narrow strings are included.\n\n Params:\n      T = type to be tested\n\n Returns:\n      true if T represents a string that is subject to autodecoding\n\n See Also:\n      $(LREF isNarrowString)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5284_4079)\n---\nstatic struct Stringish\n{\n    string s;\n    alias s this;\n}\nassert(isAutodecodableString!wstring);\nassert(isAutodecodableString!Stringish);\nassert(!isAutodecodableString!dstring);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5284_4079)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isStaticArray",
						"line": 5299,
						"deco": "b",
						"init": "is(StaticArrayTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isStaticArray",
				"line": 5299,
				"comment": " Detect whether type $(D T) is a static array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5302_4080)\n---\nstatic assert(!isStaticArray!(const(int)[]));\nstatic assert(!isStaticArray!(immutable(int)[]));\nstatic assert(!isStaticArray!(const(int)[4][]));\nstatic assert(!isStaticArray!(int[]));\nstatic assert(!isStaticArray!(int[char]));\nstatic assert(!isStaticArray!(int[1][]));\nstatic assert(!isStaticArray!(int[int]));\nstatic assert(!isStaticArray!int);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5302_4080)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isDynamicArray",
						"line": 5334,
						"deco": "b",
						"init": "is(DynamicArrayTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isDynamicArray",
				"line": 5334,
				"comment": " Detect whether type $(D T) is a dynamic array.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isArray",
						"line": 5358,
						"deco": "b",
						"init": "isStaticArray!T || isDynamicArray!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isArray",
				"line": 5358,
				"comment": " Detect whether type $(D T) is an array (static or dynamic; for associative\n  arrays see $(LREF isAssociativeArray)).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAssociativeArray",
						"line": 5379,
						"deco": "b",
						"init": "is(AssocArrayTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAssociativeArray",
				"line": 5379,
				"comment": " Detect whether $(D T) is an associative array type\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isBuiltinType",
						"line": 5410,
						"deco": "b",
						"init": "is(BuiltinTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isBuiltinType",
				"line": 5410,
				"comment": " Detect whether type $(D T) is a builtin type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5413_4085)\n---\nclass C;\nunion U;\nstruct S;\ninterface I;\n\nstatic assert( isBuiltinType!void);\nstatic assert( isBuiltinType!string);\nstatic assert( isBuiltinType!(int[]));\nstatic assert( isBuiltinType!(C[string]));\nstatic assert(!isBuiltinType!C);\nstatic assert(!isBuiltinType!U);\nstatic assert(!isBuiltinType!S);\nstatic assert(!isBuiltinType!I);\nstatic assert(!isBuiltinType!(void delegate(int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5413_4085)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSIMDVector",
						"line": 5434,
						"deco": "b",
						"init": "is(T : __vector(V[N]), V, size_t N)",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSIMDVector",
				"line": 5434,
				"comment": " Detect whether type $(D T) is a SIMD vector type.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isPointer",
						"line": 5451,
						"deco": "b",
						"init": "is(T == U*, U) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isPointer",
				"line": 5451,
				"comment": " Detect whether type $(D T) is a pointer.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "PointerTarget",
						"line": 5473,
						"type": "T",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "PointerTarget",
				"line": 5473,
				"comment": "Returns the target type of a pointer.\n",
				"parameters": [
					{
						"name": "T",
						"type": "T*",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAggregateType",
						"line": 5490,
						"deco": "b",
						"init": "is(T == struct) || is(T == union) || is(T == class) || is(T == interface)",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAggregateType",
				"line": 5490,
				"comment": " Detect whether type $(D T) is an aggregate type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5494_4089)\n---\nclass C;\nunion U;\nstruct S;\ninterface I;\n\nstatic assert( isAggregateType!C);\nstatic assert( isAggregateType!U);\nstatic assert( isAggregateType!S);\nstatic assert( isAggregateType!I);\nstatic assert(!isAggregateType!void);\nstatic assert(!isAggregateType!string);\nstatic assert(!isAggregateType!(int[]));\nstatic assert(!isAggregateType!(C[string]));\nstatic assert(!isAggregateType!(void delegate(int)));\n}\n\n/**\n* Returns $(D true) if T can be iterated over using a $(D foreach) loop with\n* a single loop variable of automatically inferred type, regardless of how\n* the $(D foreach) loop is implemented.  This includes ranges, structs/classes\n* that define $(D opApply) with a single loop variable, and builtin dynamic,\n* static and associative arrays.\n*/\nenum bool isIterable(T) = is(typeof({ foreach(elem; T.init) {} \n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5494_4089)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isIterable",
						"line": 5519,
						"deco": "b",
						"init": "is(typeof(()\n{\nforeach (elem; T.init)\n{\n}\n}\n))",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isIterable",
				"line": 5519,
				"comment": " Returns $(D true) if T can be iterated over using a $(D foreach) loop with\n a single loop variable of automatically inferred type, regardless of how\n the $(D foreach) loop is implemented.  This includes ranges, structs/classes\n that define $(D opApply) with a single loop variable, and builtin dynamic,\n static and associative arrays.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5522_4090)\n---\nstruct OpApply\n{\n    int opApply(int delegate(ref uint) dg) { assert(0); }\n}\n\nstruct Range\n{\n    @property uint front() { assert(0); }\n    void popFront() { assert(0); }\n    enum bool empty = false;\n}\n\nstatic assert( isIterable!(uint[]));\nstatic assert( isIterable!OpApply);\nstatic assert( isIterable!(uint[string]));\nstatic assert( isIterable!Range);\n\nstatic assert(!isIterable!uint);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5522_4090)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isMutable",
						"line": 5548,
						"deco": "b",
						"init": "!is(T == const) && !is(T == immutable) && !is(T == inout)",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isMutable",
				"line": 5548,
				"comment": " Returns true if T is not const or immutable.  Note that isMutable is true for\n string, or immutable(char)[], because the 'head' is mutable.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5551_4091)\n---\nstatic assert( isMutable!int);\nstatic assert( isMutable!string);\nstatic assert( isMutable!(shared int));\nstatic assert( isMutable!(shared const(int)[]));\n\nstatic assert(!isMutable!(const int));\nstatic assert(!isMutable!(inout int));\nstatic assert(!isMutable!(shared(const int)));\nstatic assert(!isMutable!(shared(inout int)));\nstatic assert(!isMutable!(immutable string));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5551_4091)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isInstanceOf",
						"line": 5568,
						"deco": "b",
						"init": "is(T == S!Args, Args...)",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isInstanceOf",
				"line": 5568,
				"comment": " Returns true if T is an instance of the template S.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5571_4092)\n---\nstatic struct Foo(T...) { }\nstatic struct Bar(T...) { }\nstatic struct Doo(T) { }\nstatic struct ABC(int x) { }\nstatic assert(isInstanceOf!(Foo, Foo!int));\nstatic assert(!isInstanceOf!(Foo, Bar!int));\nstatic assert(!isInstanceOf!(Foo, int));\nstatic assert(isInstanceOf!(Doo, Doo!int));\nstatic assert(isInstanceOf!(ABC, ABC!1));\nstatic assert(!__traits(compiles, isInstanceOf!(Foo, Foo)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5571_4092)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isExpressions",
				"line": 5591,
				"comment": " Check whether the tuple T is an expression tuple.\n An expression tuple only contains expressions.\n\n See_Also: $(LREF isTypeTuple).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5605_4093)\n---\nstatic assert(isExpressions!(1, 2.0, \"a\"));\nstatic assert(!isExpressions!(int, double, string));\nstatic assert(!isExpressions!(int, 2.0, \"a\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5605_4093)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "isExpressionTuple",
				"line": 5616,
				"comment": " Alternate name for $(LREF isExpressions), kept for legacy compatibility.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "isTypeTuple",
				"line": 5644,
				"comment": " Check whether the tuple $(D T) is a type tuple.\n A type tuple only contains types.\n\n See_Also: $(LREF isExpressions).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5655_4096)\n---\nstatic assert(isTypeTuple!(int, float, string));\nstatic assert(!isTypeTuple!(1, 2.0, \"a\"));\nstatic assert(!isTypeTuple!(1, double, string));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5655_4096)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isFunctionPointer",
				"line": 5684,
				"comment": "Detect whether symbol or type $(D T) is a function pointer.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5699_4098)\n---\nstatic void foo() {}\nvoid bar() {}\n\nauto fpfoo = &foo;\nstatic assert( isFunctionPointer!fpfoo);\nstatic assert( isFunctionPointer!(void function()));\n\nauto dgbar = &bar;\nstatic assert(!isFunctionPointer!dgbar);\nstatic assert(!isFunctionPointer!(void delegate()));\nstatic assert(!isFunctionPointer!foo);\nstatic assert(!isFunctionPointer!bar);\n\nstatic assert( isFunctionPointer!((int a) {}));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5699_4098)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isDelegate",
				"line": 5720,
				"comment": "Detect whether symbol or type $(D T) is a delegate.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5738_4099)\n---\nstatic void sfunc() { }\nint x;\nvoid func() { x++; }\n\nint delegate() dg;\nassert(isDelegate!dg);\nassert(isDelegate!(int delegate()));\nassert(isDelegate!(typeof(&func)));\n\nint function() fp;\nassert(!isDelegate!fp);\nassert(!isDelegate!(int function()));\nassert(!isDelegate!(typeof(&sfunc)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5738_4099)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isSomeFunction",
				"line": 5758,
				"comment": "Detect whether symbol or type $(D T) is a function, a function pointer or a delegate.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isCallable",
				"line": 5819,
				"comment": "Detect whether $(D T) is a callable object, which can be called with the\nfunction call operator $(D $(LPAREN)...$(RPAREN)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5833_4101)\n---\ninterface I { real value() @property; }\nstruct S { static int opCall(int) { return 0; } }\nclass C { int opCall(int) { return 0; } }\nauto c = new C;\n\nstatic assert( isCallable!c);\nstatic assert( isCallable!S);\nstatic assert( isCallable!(c.opCall));\nstatic assert( isCallable!(I.value));\nstatic assert( isCallable!((int a) { return a; }));\n\nstatic assert(!isCallable!I);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5833_4101)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAbstractFunction",
						"line": 5856,
						"deco": "b",
						"init": "__traits(isAbstractFunction, T[0])",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAbstractFunction",
				"line": 5853,
				"comment": " Detect whether $(D T) is a an abstract function.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isFinalFunction",
						"line": 5875,
						"deco": "b",
						"init": "__traits(isFinalFunction, T[0])",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isFinalFunction",
				"line": 5872,
				"comment": " Detect whether $(D T) is a a final function.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5879_4103)\n---\nstruct S { void bar() { } }\nfinal class FC { void foo(); }\nclass C\n{\n    void bar() { }\n    final void foo();\n}\nstatic assert(!isFinalFunction!(S.bar));\nstatic assert( isFinalFunction!(FC.foo));\nstatic assert(!isFinalFunction!(C.bar));\nstatic assert( isFinalFunction!(C.foo));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5879_4103)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isNestedFunction",
						"line": 5899,
						"init": "__traits(isNested, f)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isNestedFunction",
				"line": 5897,
				"comment": "Determines whether function $(D f) requires a context pointer.\n",
				"parameters": [
					{
						"name": "f",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAbstractClass",
						"line": 5916,
						"deco": "b",
						"init": "__traits(isAbstractClass, T[0])",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAbstractClass",
				"line": 5913,
				"comment": " Detect whether $(D T) is a an abstract class.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5920_4105)\n---\nstruct S { }\nclass C { }\nabstract class AC { }\nstatic assert(!isAbstractClass!S);\nstatic assert(!isAbstractClass!C);\nstatic assert( isAbstractClass!AC);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5920_4105)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isFinalClass",
						"line": 5936,
						"deco": "b",
						"init": "__traits(isFinalClass, T[0])",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isFinalClass",
				"line": 5933,
				"comment": " Detect whether $(D T) is a a final class.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5940_4106)\n---\nclass C { }\nabstract class AC { }\nfinal class FC1 : C { }\nfinal class FC2 { }\nstatic assert(!isFinalClass!C);\nstatic assert(!isFinalClass!AC);\nstatic assert( isFinalClass!FC1);\nstatic assert( isFinalClass!FC2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5940_4106)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Unqual",
				"line": 5959,
				"comment": "Removes all qualifiers, if any, from type $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5984_4107)\n---\nstatic assert(is(Unqual!int == int));\nstatic assert(is(Unqual!(const int) == int));\nstatic assert(is(Unqual!(immutable int) == int));\nstatic assert(is(Unqual!(shared int) == int));\nstatic assert(is(Unqual!(shared(const int)) == int));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5984_4107)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CopyTypeQualifiers",
						"line": 6055,
						"type": "ModifyTypePreservingTQ!(T, FromType)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CopyTypeQualifiers",
				"line": 6052,
				"comment": " Copies type qualifiers from $(D FromType) to $(D ToType).\n\n Supported type qualifiers:\n $(UL\n     $(LI $(D const))\n     $(LI $(D inout))\n     $(LI $(D immutable))\n     $(LI $(D shared))\n )\n Example:\n ---\n static assert(is(CopyTypeQualifiers!(inout const real, int) == inout const int));\n ---\n",
				"parameters": [
					{
						"name": "FromType",
						"kind": "type"
					},
					{
						"name": "ToType",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CopyConstness",
						"line": 6081,
						"type": "Unshared!(CopyTypeQualifiers!(FromType, ToType))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CopyConstness",
				"line": 6076,
				"comment": "Returns the type of `Target` with the \"constness\" of `Source`. A type's $(BOLD constness)\nrefers to whether it is `const`, `immutable`, or `inout`. If `source` has no constness, the\nreturned type will be the same as `Target`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6085_4111)\n---\nconst(int) i;\nCopyConstness!(typeof(i), float) f;\nassert( is(typeof(f) == const float));\n\nCopyConstness!(char, uint) u;\nassert( is(typeof(u) == uint));\n\n//The 'shared' qualifier will not be copied\nassert(!is(CopyConstness!(shared bool, int) == shared int));\n\n//But the constness will be\nassert( is(CopyConstness!(shared const real, double) == const double));\n\n//Careful, const(int)[] is a mutable array of const(int)\nalias MutT = CopyConstness!(const(int)[], int);\nassert(!is(MutT == const(int)));\n\n//Okay, const(int[]) applies to array and contained ints\nalias CstT = CopyConstness!(const(int[]), int);\nassert( is(CstT == const(int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6085_4111)\n",
				"parameters": [
					{
						"name": "FromType",
						"kind": "type"
					},
					{
						"name": "ToType",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ForeachType",
						"line": 6153,
						"type": "ReturnType!(typeof((inout int x = 0)\n{\nforeach (elem; T.init)\n{\nreturn elem;\n}\nassert(0);\n}\n))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ForeachType",
				"line": 6151,
				"comment": "Returns the inferred type of the loop variable when a variable of type T\nis iterated over using a $(D foreach) loop with a single loop variable and\nautomatically inferred return type.  Note that this may not be the same as\n$(D std.range.ElementType!Range) in the case of narrow strings, or if T\nhas both opApply and a range interface.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6165_4115)\n---\nstatic assert(is(ForeachType!(uint[]) == uint));\nstatic assert(is(ForeachType!string == immutable(char)));\nstatic assert(is(ForeachType!(string[string]) == string));\nstatic assert(is(ForeachType!(inout(int)[]) == inout(int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6165_4115)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "OriginalType",
						"line": 6185,
						"type": "ModifyTypePreservingTQ!(Impl, T)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "OriginalType",
				"line": 6177,
				"comment": " Strips off all $(D enum)s from type $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6189_4116)\n---\nenum E : real { a }\nenum F : E    { a = E.a }\nalias G = const(F);\nstatic assert(is(OriginalType!E == real));\nstatic assert(is(OriginalType!F == real));\nstatic assert(is(OriginalType!G == const real));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6189_4116)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "KeyType",
						"line": 6202,
						"type": "K",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "KeyType",
				"line": 6202,
				"comment": " Get the Key type of an Associative Array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6205_4117)\n---\nimport std.traits;\nalias Hash = int[string];\nstatic assert(is(KeyType!Hash == string));\nstatic assert(is(ValueType!Hash == int));\nKeyType!Hash str = \"a\"; // str is declared as string\nValueType!Hash num = 1; // num is declared as int\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6205_4117)\n",
				"parameters": [
					{
						"name": "V",
						"type": "V[K]",
						"kind": "type"
					},
					{
						"name": "K",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ValueType",
						"line": 6218,
						"type": "V",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "ValueType",
				"line": 6218,
				"comment": " Get the Value type of an Associative Array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6221_4118)\n---\nimport std.traits;\nalias Hash = int[string];\nstatic assert(is(KeyType!Hash == string));\nstatic assert(is(ValueType!Hash == int));\nKeyType!Hash str = \"a\"; // str is declared as string\nValueType!Hash num = 1; // num is declared as int\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6221_4118)\n",
				"parameters": [
					{
						"name": "V",
						"type": "V[K]",
						"kind": "type"
					},
					{
						"name": "K",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Unsigned",
						"line": 6256,
						"type": "ModifyTypePreservingTQ!(Impl, OriginalType!T)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Unsigned",
				"line": 6235,
				"comment": " Returns the corresponding unsigned type for T. T must be a numeric\n integral type, otherwise a compile-time error occurs.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Largest",
				"line": 6293,
				"comment": "Returns the largest type, i.e. T such that T.sizeof is the largest.  If more\nthan one type is of the same size, the leftmost argument of these in will be\nreturned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6317_4120)\n---\nstatic assert(is(Largest!(uint, ubyte, ushort, real) == real));\nstatic assert(is(Largest!(ulong, double) == ulong));\nstatic assert(is(Largest!(double, ulong) == double));\nstatic assert(is(Largest!(uint, byte, double, short) == double));\nstatic if (is(ucent))\n    static assert(is(Largest!(uint, ubyte, ucent, ushort) == ucent));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6317_4120)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length >= 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Signed",
						"line": 6352,
						"type": "ModifyTypePreservingTQ!(Impl, OriginalType!T)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Signed",
				"line": 6331,
				"comment": "Returns the corresponding signed type for T. T must be a numeric integral type,\notherwise a compile-time error occurs.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6356_4121)\n---\nalias S1 = Signed!uint;\nstatic assert(is(S1 == int));\nalias S2 = Signed!(const(uint));\nstatic assert(is(S2 == const(int)));\nalias S3 = Signed!(immutable(uint));\nstatic assert(is(S3 == immutable(int)));\nstatic if (is(ucent))\n{\n    alias S4 = Signed!ucent;\n    static assert(is(S4 == cent));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6356_4121)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "mostNegative",
				"line": 6387,
				"comment": "Returns the most negative value of the numeric type T.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6399_4123)\n---\nstatic assert(mostNegative!float == -float.max);\nstatic assert(mostNegative!double == -double.max);\nstatic assert(mostNegative!real == -real.max);\nstatic assert(mostNegative!bool == false);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6399_4123)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6408_4124)\n---\nforeach(T; TypeTuple!(bool, byte, short, int, long))\n    static assert(mostNegative!T == T.min);\n\nforeach(T; TypeTuple!(ubyte, ushort, uint, ulong, char, wchar, dchar))\n    static assert(mostNegative!T == 0);\n}\n\n\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://\n// Misc.\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://\n\n/**\nReturns the mangled name of symbol or type $(D sth).\n\n$(D mangledName) is the same as builtin $(D .mangleof) property, except that\nthe correct names of property functions are obtained.\n--------------------\nmodule test;\nimport std.traits : mangledName;\n\nclass C\n{\nint value() @property;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6408_4124)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isNumeric!T || isSomeChar!T || isBoolean!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "mangledName",
				"line": 6439,
				"comment": "Returns the mangled name of symbol or type $(D sth).\n\n$(D mangledName) is the same as builtin $(D .mangleof) property, except that\nthe correct names of property functions are obtained.\n--------------------\nmodule test;\nimport std.traits : mangledName;\n\nclass C\n{\n    int value() @property;\n}\npragma(msg, C.value.mangleof);      // prints \"i\"\npragma(msg, mangledName!(C.value)); // prints \"_D4test1C5valueMFNdZi\"\n--------------------\n",
				"parameters": [
					{
						"name": "sth",
						"kind": "tuple"
					}
				],
				"constraint": "sth.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Select",
						"line": 6542,
						"type": "T[!condition]",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Select",
				"line": 6540,
				"comment": "Aliases itself to $(D T[0]) if the boolean $(D condition) is $(D true)\nand to $(D T[1]) otherwise.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6546_4127)\n---\n// can select types\nstatic assert(is(Select!(true, int, long) == int));\nstatic assert(is(Select!(false, int, long) == long));\n\n// can select symbols\nint a = 1;\nint b = 2;\nalias selA = Select!(true, a, b);\nalias selB = Select!(false, a, b);\nassert(selA == 1);\nassert(selB == 2);\n}\n\n/**\nIf $(D cond) is $(D true), returns $(D a) without evaluating $(D\nb). Otherwise, returns $(D b) without evaluating $(D a).\n*/\nA select(bool cond : true, A, B)(A a, lazy B b) { return a; \n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6546_4127)\n",
				"parameters": [
					{
						"name": "condition",
						"deco": "b",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 61,
						"name": "select",
						"line": 6565,
						"type": "A(A a, lazy B b)",
						"parameters": [
							{
								"name": "a",
								"type": "A"
							},
							{
								"name": "b",
								"type": "B",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 6565,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "select",
				"line": 6565,
				"comment": "If $(D cond) is $(D true), returns $(D a) without evaluating $(D\nb). Otherwise, returns $(D b) without evaluating $(D a).\n",
				"parameters": [
					{
						"name": "cond",
						"deco": "b",
						"specValue": "true",
						"kind": "value"
					},
					{
						"name": "A",
						"kind": "type"
					},
					{
						"name": "B",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 62,
						"name": "select",
						"line": 6567,
						"type": "B(lazy A a, B b)",
						"parameters": [
							{
								"name": "a",
								"type": "A",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "b",
								"type": "B"
							}
						],
						"endline": 6567,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "select",
				"line": 6567,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "cond",
						"deco": "b",
						"specValue": "false",
						"kind": "value"
					},
					{
						"name": "A",
						"kind": "type"
					},
					{
						"name": "B",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasUDA",
				"line": 6583,
				"comment": " Determine if a symbol has a given\n $(DDSUBLINK spec/attribute,uda, user-defined attribute).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6604_4129)\n---\nenum E;\nstruct S;\nstruct Named { string name; }\n\n@(\"alpha\") int a;\nstatic assert(hasUDA!(a, \"alpha\"));\nstatic assert(!hasUDA!(a, S));\nstatic assert(!hasUDA!(a, E));\n\n@(E) int b;\nstatic assert(!hasUDA!(b, \"alpha\"));\nstatic assert(!hasUDA!(b, S));\nstatic assert(hasUDA!(b, E));\n\n@E int c;\nstatic assert(!hasUDA!(c, \"alpha\"));\nstatic assert(!hasUDA!(c, S));\nstatic assert(hasUDA!(c, E));\n\n@(S, E) int d;\nstatic assert(!hasUDA!(d, \"alpha\"));\nstatic assert(hasUDA!(d, S));\nstatic assert(hasUDA!(d, E));\n\n@S int e;\nstatic assert(!hasUDA!(e, \"alpha\"));\nstatic assert(hasUDA!(e, S));\nstatic assert(!hasUDA!(e, E));\n\n@(S, E, \"alpha\") int f;\nstatic assert(hasUDA!(f, \"alpha\"));\nstatic assert(hasUDA!(f, S));\nstatic assert(hasUDA!(f, E));\n\n@(100) int g;\nstatic assert(hasUDA!(g, 100));\n\n@Named(\"abc\") int h;\nstatic assert(hasUDA!(h, Named));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6604_4129)\n",
				"parameters": [
					{
						"name": "symbol",
						"kind": "alias"
					},
					{
						"name": "attribute",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "getUDAs",
						"line": 6662,
						"type": "Filter!(isDesiredUDA, __traits(getAttributes, symbol))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "getUDAs",
				"line": 6651,
				"comment": " Gets the $(DDSUBLINK spec/attribute,uda, user-defined attributes) of the\n given type from the given symbol.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6666_4130)\n---\nstruct Attr\n{\n    string name;\n    int value;\n}\n\n@Attr(\"Answer\", 42) int a;\nstatic assert(getUDAs!(a, Attr)[0].name == \"Answer\");\nstatic assert(getUDAs!(a, Attr)[0].value == 42);\n\n@(Attr(\"Answer\", 42), \"string\", 9999) int b;\nstatic assert(getUDAs!(b, Attr)[0].name == \"Answer\");\nstatic assert(getUDAs!(b, Attr)[0].value == 42);\n\n@Attr(\"Answer\", 42) @Attr(\"Pi\", 3) int c;\nstatic assert(getUDAs!(c, Attr)[0].name == \"Answer\");\nstatic assert(getUDAs!(c, Attr)[0].value == 42);\nstatic assert(getUDAs!(c, Attr)[1].name == \"Pi\");\nstatic assert(getUDAs!(c, Attr)[1].value == 3);\n\nstruct AttrT(T)\n{\n    string name;\n    T value;\n}\n\n@AttrT!uint(\"Answer\", 42) @AttrT!int(\"Pi\", 3) @AttrT int d;\nstatic assert(getUDAs!(d, AttrT)[0].name == \"Answer\");\nstatic assert(getUDAs!(d, AttrT)[0].value == 42);\nstatic assert(getUDAs!(d, AttrT)[1].name == \"Pi\");\nstatic assert(getUDAs!(d, AttrT)[1].value == 3);\nstatic assert(getUDAs!(d, AttrT!uint)[0].name == \"Answer\");\nstatic assert(getUDAs!(d, AttrT!uint)[0].value == 42);\nstatic assert(getUDAs!(d, AttrT!int)[0].name == \"Pi\");\nstatic assert(getUDAs!(d, AttrT!int)[0].value == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6666_4130)\n",
				"parameters": [
					{
						"name": "symbol",
						"kind": "alias"
					},
					{
						"name": "attribute",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "getSymbolsByUDA",
				"line": 6710,
				"comment": " Gets all symbols within `symbol` that have the given user-defined attribute.\n This is not recursive; it will not search for symbols within symbols such as\n nested structs or unions.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6736_4131)\n---\nenum Attr;\n\nstatic struct A\n{\n    @Attr int a;\n    int b;\n    @Attr void doStuff() {}\n    void doOtherStuff() {}\n    static struct Inner\n    {\n        // Not found by getSymbolsByUDA\n        @Attr int c;\n    }\n}\n\n// Finds both variables and functions with the attribute, but\n// doesn't include the variables and functions without it.\nstatic assert(getSymbolsByUDA!(A, Attr).length == 2);\n// Can access attributes on the symbols returned by getSymbolsByUDA.\nstatic assert(hasUDA!(getSymbolsByUDA!(A, Attr)[0], Attr));\nstatic assert(hasUDA!(getSymbolsByUDA!(A, Attr)[1], Attr));\n\nstatic struct UDA { string name; }\n\nstatic struct B\n{\n    @UDA(\"X\")\n    int x;\n    @UDA(\"Y\")\n    int y;\n    @(100)\n    int z;\n}\n\n// Finds both UDA attributes.\nstatic assert(getSymbolsByUDA!(B, UDA).length == 2);\n// Finds one `100` attribute.\nstatic assert(getSymbolsByUDA!(B, 100).length == 1);\n// Can get the value of the UDA from the return value\nstatic assert(getUDAs!(getSymbolsByUDA!(B, UDA)[0], UDA)[0].name == \"X\");\n\n@UDA(\"A\")\nstatic struct C\n{\n    @UDA(\"B\")\n    int d;\n}\n\n// Also checks the symbol itself\nstatic assert(getSymbolsByUDA!(C, UDA).length == 2);\nstatic assert(getSymbolsByUDA!(C, UDA)[0].stringof == \"C\");\nstatic assert(getSymbolsByUDA!(C, UDA)[1].stringof == \"d\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6736_4131)\n",
				"parameters": [
					{
						"name": "symbol",
						"kind": "alias"
					},
					{
						"name": "attribute",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "allSameType",
				"line": 6805,
				"comment": "   Returns: $(D true) iff all types $(D T) are the same.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6818_4133)\n---\nstatic assert(allSameType!(int, int));\nstatic assert(allSameType!(int, int, int));\nstatic assert(allSameType!(float, float, float));\nstatic assert(!allSameType!(int, double));\nstatic assert(!allSameType!(int, float, double));\nstatic assert(!allSameType!(int, float, double, real));\nstatic assert(!allSameType!(short, int, float, double, real));\n}\n\n/**\nReturns: $(D true) iff the type $(D T) can be tested in an $(D\nif)-expression, that is if $(D if (pred(T.init)) {}) is compilable.\n*/\nenum ifTestable(T, alias pred = a => a) = __traits(compiles, { if (pred(T.init)) {} \n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6818_4133)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ifTestable",
						"line": 6833,
						"init": "__traits(compiles, ()\n{\nif (pred(T.init))\n{\n}\n}\n)",
						"char": 6,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "ifTestable",
				"line": 6833,
				"comment": "   Returns: $(D true) iff the type $(D T) can be tested in an $(D\n   if)-expression, that is if $(D if (pred(T.init)) {}) is compilable.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "pred",
						"defaultAlias": "",
						"kind": "alias"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": " Templates which extract information about types and symbols at compile time.\n\n $(SCRIPT inhibitQuickIndex = 1;)\n\n $(DIVC quickindex,\n $(BOOKTABLE ,\n $(TR $(TH Category) $(TH Templates))\n $(TR $(TD Symbol Name _traits) $(TD\n           $(LREF fullyQualifiedName)\n           $(LREF moduleName)\n           $(LREF packageName)\n ))\n $(TR $(TD Function _traits) $(TD\n           $(LREF arity)\n           $(LREF functionAttributes)\n           $(LREF functionLinkage)\n           $(LREF FunctionTypeOf)\n           $(LREF isSafe)\n           $(LREF isUnsafe)\n           $(LREF ParameterDefaults)\n           $(LREF ParameterIdentifierTuple)\n           $(LREF ParameterStorageClassTuple)\n           $(LREF Parameters)\n           $(LREF ReturnType)\n           $(LREF SetFunctionAttributes)\n           $(LREF variadicFunctionStyle)\n ))\n $(TR $(TD Aggregate Type _traits) $(TD\n           $(LREF BaseClassesTuple)\n           $(LREF BaseTypeTuple)\n           $(LREF classInstanceAlignment)\n           $(LREF EnumMembers)\n           $(LREF FieldNameTuple)\n           $(LREF Fields)\n           $(LREF hasAliasing)\n           $(LREF hasElaborateAssign)\n           $(LREF hasElaborateCopyConstructor)\n           $(LREF hasElaborateDestructor)\n           $(LREF hasIndirections)\n           $(LREF hasMember)\n           $(LREF hasNested)\n           $(LREF hasUnsharedAliasing)\n           $(LREF InterfacesTuple)\n           $(LREF isNested)\n           $(LREF MemberFunctionsTuple)\n           $(LREF RepresentationTypeTuple)\n           $(LREF TemplateArgsOf)\n           $(LREF TemplateOf)\n           $(LREF TransitiveBaseTypeTuple)\n ))\n $(TR $(TD Type Conversion) $(TD\n           $(LREF CommonType)\n           $(LREF ImplicitConversionTargets)\n           $(LREF CopyTypeQualifiers)\n           $(LREF CopyConstness)\n           $(LREF isAssignable)\n           $(LREF isCovariantWith)\n           $(LREF isImplicitlyConvertible)\n ))\n <!--$(TR $(TD SomethingTypeOf) $(TD\n           $(LREF BooleanTypeOf)\n           $(LREF IntegralTypeOf)\n           $(LREF FloatingPointTypeOf)\n           $(LREF NumericTypeOf)\n           $(LREF UnsignedTypeOf)\n           $(LREF SignedTypeOf)\n           $(LREF CharTypeOf)\n           $(LREF StaticArrayTypeOf)\n           $(LREF DynamicArrayTypeOf)\n           $(LREF ArrayTypeOf)\n           $(LREF StringTypeOf)\n           $(LREF AssocArrayTypeOf)\n           $(LREF BuiltinTypeOf)\n ))-->\n $(TR $(TD Categories of types) $(TD\n           $(LREF isAggregateType)\n           $(LREF isArray)\n           $(LREF isAssociativeArray)\n           $(LREF isAutodecodableString)\n           $(LREF isBasicType)\n           $(LREF isBoolean)\n           $(LREF isBuiltinType)\n           $(LREF isDynamicArray)\n           $(LREF isFloatingPoint)\n           $(LREF isIntegral)\n           $(LREF isNarrowString)\n           $(LREF isNumeric)\n           $(LREF isPointer)\n           $(LREF isScalarType)\n           $(LREF isSigned)\n           $(LREF isSomeChar)\n           $(LREF isSomeString)\n           $(LREF isStaticArray)\n           $(LREF isUnsigned)\n ))\n $(TR $(TD Type behaviours) $(TD\n           $(LREF isAbstractClass)\n           $(LREF isAbstractFunction)\n           $(LREF isCallable)\n           $(LREF isDelegate)\n           $(LREF isExpressions)\n           $(LREF isFinalClass)\n           $(LREF isFinalFunction)\n           $(LREF isFunctionPointer)\n           $(LREF isInstanceOf)\n           $(LREF isIterable)\n           $(LREF isMutable)\n           $(LREF isSomeFunction)\n           $(LREF isTypeTuple)\n ))\n $(TR $(TD General Types) $(TD\n           $(LREF ForeachType)\n           $(LREF KeyType)\n           $(LREF Largest)\n           $(LREF mostNegative)\n           $(LREF OriginalType)\n           $(LREF PointerTarget)\n           $(LREF Signed)\n           $(LREF Unqual)\n           $(LREF Unsigned)\n           $(LREF ValueType)\n ))\n $(TR $(TD Misc) $(TD\n           $(LREF mangledName)\n           $(LREF Select)\n           $(LREF select)\n ))\n $(TR $(TD User-Defined Attributes) $(TD\n           $(LREF hasUDA)\n           $(LREF getUDAs)\n           $(LREF getSymbolsByUDA)\n ))\n )\n )\n\n Macros:\n  WIKI = Phobos/StdTraits\n\n Copyright: Copyright Digital Mars 2005 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright),\n            Tomasz Stachowiak ($(D isExpressions)),\n            $(WEB erdani.org, Andrei Alexandrescu),\n            Shin Fujishiro,\n            $(WEB octarineparrot.com, Robert Clipsham),\n            $(WEB klickverbot.at, David Nadlinger),\n            Kenji Hara,\n            Shoichi Kato\n Source:    $(PHOBOSSRC std/_traits.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/syserror.d",
		"name": "std.syserror",
		"members": [],
		"comment": " Convert Win32 error code to string\n\n $(RED This module has been deprecated. Please see\n    $(LINK2 std_windows_syserror.html, std.windows._syserror) instead).\n\n Source:    $(PHOBOSSRC std/_syserror.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/bitmanip.d",
		"name": "std.bitmanip",
		"members": [
			{
				"members": [
					{
						"name": "bitfields",
						"line": 250,
						"value": "createFields!(createStoreName!T, 0, T).result",
						"char": 12,
						"kind": "enum member"
					}
				],
				"name": "bitfields",
				"line": 248,
				"comment": "Allows creating bit fields inside $(D_PARAM struct)s and $(D_PARAM\nclass)es.\n\nExample:\n\n----\nstruct A\n{\n    int a;\n    mixin(bitfields!(\n        uint, \"x\",    2,\n        int,  \"y\",    3,\n        uint, \"z\",    2,\n        bool, \"flag\", 1));\n}\nA obj;\nobj.x = 2;\nobj.z = obj.x;\n----\n\nThe example above creates a bitfield pack of eight bits, which fit in\none $(D_PARAM ubyte). The bitfields are allocated starting from the\nleast significant bit, i.e. x occupies the two least significant bits\nof the bitfields storage.\n\nThe sum of all bit lengths in one $(D_PARAM bitfield) instantiation\nmust be exactly 8, 16, 32, or 64. If padding is needed, just allocate\none bitfield with an empty name.\n\nExample:\n\n----\nstruct A\n{\n    mixin(bitfields!(\n        bool, \"flag1\",    1,\n        bool, \"flag2\",    1,\n        uint, \"\",         6));\n}\n----\n\nThe type of a bit field can be any integral type or enumerated\ntype. The most efficient type to store in bitfields is $(D_PARAM\nbool), followed by unsigned types, followed by signed types.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "taggedPointer",
						"line": 273,
						"init": "createTaggedReference!(createStoreName!(T, name, 0, Ts), T*, T.alignof, name, Ts).result",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "taggedPointer",
				"line": 272,
				"comment": "This string mixin generator allows one to create tagged pointers inside $(D_PARAM struct)s and $(D_PARAM class)es.\n\nA tagged pointer uses the bits known to be zero in a normal pointer or class reference to store extra information.\nFor example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero.\nOne can store a 2-bit integer there.\n\nThe example above creates a tagged pointer in the struct A. The pointer is of type\n$(D uint*) as specified by the first argument, and is named x, as specified by the second\nargument.\n\nFollowing arguments works the same way as $(D bitfield)'s. The bitfield must fit into the\nbits known to be zero because of the pointer alignment.\n\n$(RED Warning: Don't use $(D taggedPointer) with pointers to garbage collected objects, as it will result in\nundefined behaviour. See\n$(DDLINK spec/garbage, Garbage Collection, Garbage Collection) for details.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL277_4137)\n---\nstruct A\n{\n    int a;\n    mixin(taggedPointer!(\n        uint*, \"x\",\n        bool, \"b1\", 1,\n        bool, \"b2\", 1));\n}\nA obj;\nobj.x = new uint;\nobj.b1 = true;\nobj.b2 = false;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL277_4137)\n",
				"parameters": [
					{
						"name": "T",
						"type": "T*",
						"kind": "type"
					},
					{
						"name": "name",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "Ts",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "taggedClassRef",
						"line": 309,
						"init": "createTaggedReference!(createStoreName!(T, name, 0, Ts), T, 8, name, Ts).result",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "taggedClassRef",
				"line": 308,
				"comment": "This string mixin generator allows one to create tagged class reference inside $(D_PARAM struct)s and $(D_PARAM class)es.\n\nA tagged class reference uses the bits known to be zero in a normal class reference to store extra information.\nFor example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero.\nOne can store a 2-bit integer there.\n\nThe example above creates a tagged reference to an Object in the struct A. This expects the same parameters\nas $(D taggedPointer), except the first argument which must be a class type instead of a pointer type.\n\n$(RED Warning: Don't use $(D taggedClassRef) with references to garbage collected objects, as it will result in\nundefined behaviour. See\n$(DDLINK spec/garbage, Garbage Collection, Garbage Collection) for details.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL313_4138)\n---\nstruct A\n{\n    int a;\n    mixin(taggedClassRef!(\n        Object, \"o\",\n        uint, \"i\", 2));\n}\nA obj;\nobj.o = new Object();\nobj.i = 3;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL313_4138)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "name",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "Ts",
						"kind": "tuple"
					}
				],
				"constraint": "is(T == class)",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "FloatRep",
				"line": 627,
				"comment": "   Allows manipulating the fraction, exponent, and sign parts of a\n   $(D_PARAM float) separately. The definition is:\n\n----\nstruct FloatRep\n{\n    union\n    {\n        float value;\n        mixin(bitfields!(\n                  uint,  \"fraction\", 23,\n                  ubyte, \"exponent\",  8,\n                  bool,  \"sign\",      1));\n    }\n    enum uint bias = 127, fractionBits = 23, exponentBits = 8, signBits = 1;\n}\n----\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "DoubleRep",
				"line": 660,
				"comment": "   Allows manipulating the fraction, exponent, and sign parts of a\n   $(D_PARAM double) separately. The definition is:\n\n----\nstruct DoubleRep\n{\n    union\n    {\n        double value;\n        mixin(bitfields!(\n                  ulong,   \"fraction\", 52,\n                  ushort,  \"exponent\", 11,\n                  bool,    \"sign\",      1));\n    }\n    enum uint bias = 1023, signBits = 1, fractionBits = 52, exponentBits = 11;\n}\n----\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "BitArray",
				"line": 721,
				"comment": " An array of bits.\n",
				"members": [
					{
						"endchar": 5,
						"name": "dim",
						"line": 765,
						"comment": " Gets the amount of native words backing this $(D BitArray).\n",
						"deco": "xFNaNbNdNiZm",
						"endline": 768,
						"originalType": "const pure nothrow @nogc @property size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "length",
						"line": 773,
						"comment": " Gets the amount of bits in the $(D BitArray).\n",
						"deco": "xFNaNbNdNiZm",
						"endline": 776,
						"originalType": "const pure nothrow @nogc @property size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "length",
						"line": 784,
						"comment": " Sets the amount of bits in the $(D BitArray).\n $(RED Warning: increasing length may overwrite bits in\n final word up to the next word boundary. i.e. D dynamic\n array extension semantics are not followed.)\n",
						"deco": "FNaNbNdmZm",
						"parameters": [
							{
								"name": "newlen",
								"deco": "m"
							}
						],
						"endline": 802,
						"originalType": "pure nothrow @property size_t(size_t newlen)",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 807,
						"comment": " Gets the $(D i)'th bit in the $(D BitArray).\n",
						"deco": "xFNaNbNimZb",
						"parameters": [
							{
								"name": "i",
								"deco": "m"
							}
						],
						"endline": 815,
						"originalType": "const pure nothrow @nogc bool(size_t i)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndexAssign",
						"line": 835,
						"comment": " Sets the $(D i)'th bit in the $(D BitArray).\n",
						"deco": "FNaNbNibmZb",
						"parameters": [
							{
								"name": "b",
								"deco": "b"
							},
							{
								"name": "i",
								"deco": "m"
							}
						],
						"endline": 847,
						"originalType": "pure nothrow @nogc bool(bool b, size_t i)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dup",
						"line": 852,
						"comment": " Duplicates the $(D BitArray) and its contents.\n",
						"deco": "xFNaNbNdZS3std8bitmanip8BitArray",
						"endline": 860,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 883,
						"comment": " Support for $(D foreach) loops for $(D BitArray).\n",
						"deco": "FMDFKbZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFKbZi"
							}
						],
						"endline": 896,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 899,
						"comment": " ditto\n",
						"deco": "xFMDFbZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFbZi"
							}
						],
						"endline": 911,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 914,
						"comment": " ditto\n",
						"deco": "FMDFmKbZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFmKbZi"
							}
						],
						"endline": 927,
						"originalType": "int(scope int delegate(size_t, ref bool) dg)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 930,
						"comment": " ditto\n",
						"deco": "xFMDFmbZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFmbZi"
							}
						],
						"endline": 942,
						"originalType": "const int(scope int delegate(size_t, bool) dg)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "reverse",
						"line": 981,
						"comment": " Reverses the bits of the $(D BitArray).\n",
						"deco": "FNaNbNdNiZS3std8bitmanip8BitArray",
						"endline": 1003,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sort",
						"line": 1025,
						"comment": " Sorts the $(D BitArray)'s elements.\n",
						"deco": "FNaNbNdNiZS3std8bitmanip8BitArray",
						"endline": 1067,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1086,
						"comment": " Support for operators == and != for $(D BitArray).\n",
						"deco": "xFNaNbNiKxS3std8bitmanip8BitArrayZb",
						"parameters": [
							{
								"name": "a2",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std8bitmanip8BitArray"
							}
						],
						"endline": 1101,
						"originalType": "const pure nothrow @nogc bool(ref const BitArray a2)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1133,
						"comment": " Supports comparison operators for $(D BitArray).\n",
						"deco": "xFNaNbNiS3std8bitmanip8BitArrayZi",
						"parameters": [
							{
								"name": "a2",
								"deco": "S3std8bitmanip8BitArray"
							}
						],
						"endline": 1167,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toHash",
						"line": 1234,
						"comment": " Support for hashing for $(D BitArray).\n",
						"deco": "xFNaNbNiZm",
						"endline": 1249,
						"originalType": "const pure nothrow @nogc size_t()",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1268,
						"comment": " Set this $(D BitArray) to the contents of $(D ba).\n",
						"deco": "FNaNbNcAbZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "ba",
								"deco": "Ab"
							}
						],
						"endline": 1275,
						"originalType": "pure nothrow ref (bool[] ba)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1292,
						"comment": " Map the $(D BitArray) onto $(D v), with $(D numbits) being the number of bits\n in the array. Does not copy the data. $(D v.length) must be a multiple of\n $(D size_t.sizeof). If there are unmapped bits in the final mapped word then\n these will be set to 0.\n\n This is the inverse of $(D opCast).\n",
						"deco": "FNaNbNcAvmZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "v",
								"deco": "Av"
							},
							{
								"name": "numbits",
								"deco": "m"
							}
						],
						"endline": 1307,
						"originalType": "pure nothrow ref (void[] v, size_t numbits)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 1336,
								"type": "pure nothrow @nogc void[]()",
								"endline": 1339,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 1336,
						"comment": " Convert to $(D void[]).\n",
						"parameters": [
							{
								"name": "T",
								"deco": "Av",
								"kind": "type"
							}
						],
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 1344,
								"type": "pure nothrow @nogc size_t[]()",
								"endline": 1347,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 1344,
						"comment": " Convert to $(D size_t[]).\n",
						"parameters": [
							{
								"name": "T",
								"deco": "Am",
								"kind": "type"
							}
						],
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opCom",
						"line": 1364,
						"comment": " Support for unary operator ~ for $(D BitArray).\n",
						"deco": "xFNaNbZS3std8bitmanip8BitArray",
						"endline": 1379,
						"char": 14,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 1401,
								"type": "const pure nothrow BitArray(const BitArray e2)",
								"parameters": [
									{
										"name": "e2",
										"type": "BitArray",
										"storageClass": [
											"const"
										]
									}
								],
								"endline": 1425,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 1401,
						"comment": " Support for binary bitwise operators for $(D BitArray).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\" || op == \"&\" || op == \"|\" || op == \"^\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 1507,
								"type": "pure nothrow @nogc BitArray(const BitArray e2)",
								"parameters": [
									{
										"name": "e2",
										"type": "BitArray",
										"storageClass": [
											"const"
										]
									}
								],
								"endline": 1534,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 1507,
						"comment": " Support for operator op= for $(D BitArray).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\" || op == \"&\" || op == \"|\" || op == \"^\"",
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 1632,
						"comment": " Support for operator ~= for $(D BitArray).\n $(RED Warning: This will overwrite a bit in the final word\n of the current underlying data regardless of whether it is\n shared between BitArray objects. i.e. D dynamic array\n concatenation semantics are not followed)\n",
						"deco": "FNaNbbZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "b",
								"deco": "b"
							}
						],
						"endline": 1637,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 1663,
						"comment": " ditto\n",
						"deco": "FNaNbS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "b",
								"deco": "S3std8bitmanip8BitArray"
							}
						],
						"endline": 1670,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCat",
						"line": 1697,
						"comment": " Support for binary operator ~ for $(D BitArray).\n",
						"deco": "xFNaNbbZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "b",
								"deco": "b"
							}
						],
						"endline": 1705,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCat_r",
						"line": 1708,
						"comment": " ditto\n",
						"deco": "xFNaNbbZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "b",
								"deco": "b"
							}
						],
						"endline": 1717,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCat",
						"line": 1720,
						"comment": " ditto\n",
						"deco": "xFNaNbS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "b",
								"deco": "S3std8bitmanip8BitArray"
							}
						],
						"endline": 1727,
						"char": 14,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 1840,
								"type": "pure nothrow @nogc void(size_t nbits)",
								"parameters": [
									{
										"name": "nbits",
										"type": "size_t"
									}
								],
								"endline": 1861,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 1840,
						"comment": " Operator $(D <<=) support.\n\n Shifts all the bits in the array to the left by the given number of\n bits.  The leftmost bits are dropped, and 0's are appended to the end\n to fill up the vacant bits.\n\n $(RED Warning: unused bits in the final word up to the next word\n boundary may be overwritten by this operation. It does not attempt to\n preserve bits past the end of the array.)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"<<\"",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 1874,
								"type": "pure nothrow @nogc void(size_t nbits)",
								"parameters": [
									{
										"name": "nbits",
										"type": "size_t"
									}
								],
								"endline": 1902,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 1874,
						"comment": " Operator $(D >>=) support.\n\n Shifts all the bits in the array to the right by the given number of\n bits.  The rightmost bits are dropped, and 0's are inserted at the back\n to fill up the vacant bits.\n\n $(RED Warning: unused bits in the final word up to the next word\n boundary may be overwritten by this operation. It does not attempt to\n preserve bits past the end of the array.)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \">>\"",
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1995,
						"comment": " Return a string representation of this BitArray.\n\n Two format specifiers are supported:\n $(LI $(B %s) which prints the bits as an array, and)\n $(LI $(B %b) which prints the bits as 8-bit byte packets)\n separated with an underscore.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2010_4175)\n---\nimport std.format : format;\n\ndebug(bitarray) printf(\"BitArray.toString unittest\\n\");\nauto b = BitArray([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);\n\nauto s1 = format(\"%s\", b);\nassert(s1 == \"[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]\");\n\nauto s2 = format(\"%b\", b);\nassert(s2 == \"00001111_00001111\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2010_4175)\n",
						"deco": "xFMDFAxaZvS3std6format18__T10FormatSpecTaZ10FormatSpecZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFAxaZv"
							},
							{
								"name": "fmt",
								"deco": "S3std6format18__T10FormatSpecTaZ10FormatSpec"
							}
						],
						"endline": 2007,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "bitsSet",
						"line": 2027,
						"comment": " Return a lazy range of the indices of set bits.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2039_4178)\n---\nimport std.algorithm : equal;\n\nauto b1 = BitArray([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);\nassert(b1.bitsSet.equal([4, 5, 6, 7, 12, 13, 14, 15]));\n\nBitArray b2;\nb2.length = 1000;\nb2[333] = true;\nb2[666] = true;\nb2[999] = true;\nassert(b2.bitsSet.equal([333, 666, 999]));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2039_4178)\n",
						"deco": "xFNaNbNdZS3std9algorithm9iteration270__T6joinerTS3std9algorithm9iteration220__T9MapResultS483std8bitmanip8BitArray7bitsSetMxFNbNdZ9__lambda2TS3std9algorithm9iteration112__T12FilterResultS483std8bitmanip8BitArray7bitsSetMxFNbNdZ9__lambda1TS3std5range13__T4iotaTmTmZ4iotaFmmZ6ResultZ12FilterResultZ9MapResultZ6joinerFS3std9algorithm9iteration220__T9MapResultS483std8bitmanip8BitArray7bitsSetMxFNbNdZ9__lambda2TS3std9algorithm9iteration112__T12FilterResultS483std8bitmanip8BitArray7bitsSetMxFNbNdZ9__lambda1TS3std5range13__T4iotaTmTmZ4iotaFmmZ6ResultZ12FilterResultZ9MapResultZ6Result",
						"endline": 2036,
						"originalType": "const nothrow @property ()",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "swapEndian",
						"line": 2153,
						"type": "pure nothrow @nogc @safe T(T val)",
						"parameters": [
							{
								"name": "val",
								"type": "T"
							}
						],
						"endline": 2168,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "swapEndian",
				"line": 2153,
				"comment": "    Swaps the endianness of the given integral value or character.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!T || isSomeChar!T || isBoolean!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nativeToBigEndian",
						"line": 2265,
						"type": "pure nothrow @nogc @safe (T val)",
						"parameters": [
							{
								"name": "val",
								"type": "T"
							}
						],
						"endline": 2269,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "nativeToBigEndian",
				"line": 2265,
				"comment": "    Converts the given value from the native endianness to big endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2272_4182)\n---\nint i = 12345;\nubyte[4] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToBigEndian(d);\nassert(d == bigEndianToNative!double(swappedD));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2272_4182)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "bigEndianToNative",
						"line": 2387,
						"type": "pure nothrow @nogc @safe T(ubyte[n] val)",
						"parameters": [
							{
								"name": "val",
								"type": "ubyte[n]"
							}
						],
						"endline": 2391,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "bigEndianToNative",
				"line": 2387,
				"comment": "    Converts the given value from big endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2394_4184)\n---\nushort i = 12345;\nubyte[2] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToBigEndian(c);\nassert(c == bigEndianToNative!dchar(swappedC));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2394_4184)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "n",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "canSwapEndianness!T && n == T.sizeof",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nativeToLittleEndian",
						"line": 2439,
						"type": "pure nothrow @nogc @safe (T val)",
						"parameters": [
							{
								"name": "val",
								"type": "T"
							}
						],
						"endline": 2443,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "nativeToLittleEndian",
				"line": 2439,
				"comment": "    Converts the given value from the native endianness to little endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2446_4185)\n---\nint i = 12345;\nubyte[4] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToLittleEndian(d);\nassert(d == littleEndianToNative!double(swappedD));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2446_4185)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "littleEndianToNative",
						"line": 2534,
						"type": "pure nothrow @nogc @safe T(ubyte[n] val)",
						"parameters": [
							{
								"name": "val",
								"type": "ubyte[n]"
							}
						],
						"endline": 2538,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "littleEndianToNative",
				"line": 2534,
				"comment": "    Converts the given value from little endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2541_4187)\n---\nushort i = 12345;\nubyte[2] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToLittleEndian(c);\nassert(c == littleEndianToNative!dchar(swappedC));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2541_4187)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "n",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "canSwapEndianness!T && n == T.sizeof",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "peek",
						"line": 2679,
						"type": "T(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2703,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "peek",
				"line": 2679,
				"comment": "    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The range is not consumed.\n\n    Params:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\n        index = The index to start reading from (instead of starting at the\n                front). If index is a pointer, then it is updated to the index\n                after the bytes read. The overloads with index are only\n                available if $(D hasSlicing!R) is $(D true).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2736_4190)\n---\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.peek!uint() == 17110537);\nassert(buffer.peek!ushort() == 261);\nassert(buffer.peek!ubyte() == 1);\n\nassert(buffer.peek!uint(2) == 369700095);\nassert(buffer.peek!ushort(2) == 5641);\nassert(buffer.peek!ubyte(2) == 22);\n\nsize_t index = 0;\nassert(buffer.peek!ushort(&index) == 261);\nassert(index == 2);\n\nassert(buffer.peek!uint(&index) == 369700095);\nassert(index == 6);\n\nassert(buffer.peek!ubyte(&index) == 8);\nassert(index == 7);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2736_4190)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isForwardRange!R && is(ElementType!R : const(ubyte))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "peek",
						"line": 2706,
						"type": "T(R range, size_t index)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 2713,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "peek",
				"line": 2706,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isForwardRange!R && hasSlicing!R && is(ElementType!R : const(ubyte))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "peek",
						"line": 2716,
						"type": "T(R range, size_t* index)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "index",
								"type": "size_t*"
							}
						],
						"endline": 2733,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "peek",
				"line": 2716,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isForwardRange!R && hasSlicing!R && is(ElementType!R : const(ubyte))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "read",
						"line": 2981,
						"type": "T(ref R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 3004,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "read",
				"line": 2981,
				"comment": "    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The $(D T.sizeof) bytes which are read are consumed from\n    the range.\n\n    Params:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3007_4193)\n---\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.length == 7);\n\nassert(buffer.read!ushort() == 261);\nassert(buffer.length == 5);\n\nassert(buffer.read!uint() == 369700095);\nassert(buffer.length == 1);\n\nassert(buffer.read!ubyte() == 8);\nassert(buffer.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3007_4193)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isInputRange!R && is(ElementType!R : const(ubyte))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "write",
						"line": 3226,
						"type": "void(R range, T value, size_t index)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 3233,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "write",
				"line": 3226,
				"comment": "    Takes an integral value, converts it to the given endianness, and writes it\n    to the given range of $(D ubyte)s as a sequence of $(D T.sizeof) $(D ubyte)s\n    starting at index. $(D hasSlicing!R) must be $(D true).\n\n    Params:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to _write the bytes in.\n        range = The range to _write to.\n        value = The value to _write.\n        index = The index to start writing to. If index is a pointer, then it\n                is updated to the index after the bytes read.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3256_4196)\n---\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(29110231u, 0);\n    assert(buffer == [1, 188, 47, 215, 0, 0, 0, 0]);\n\n    buffer.write!ushort(927, 0);\n    assert(buffer == [3, 159, 47, 215, 0, 0, 0, 0]);\n\n    buffer.write!ubyte(42, 0);\n    assert(buffer == [42, 159, 47, 215, 0, 0, 0, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(142700095u, 2);\n    assert(buffer == [0, 0, 8, 129, 110, 63, 0, 0, 0]);\n\n    buffer.write!ushort(19839, 2);\n    assert(buffer == [0, 0, 77, 127, 110, 63, 0, 0, 0]);\n\n    buffer.write!ubyte(132, 2);\n    assert(buffer == [0, 0, 132, 127, 110, 63, 0, 0, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];\n    size_t index = 0;\n    buffer.write!ushort(261, &index);\n    assert(buffer == [1, 5, 0, 0, 0, 0, 0, 0]);\n    assert(index == 2);\n\n    buffer.write!uint(369700095u, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 0, 0]);\n    assert(index == 6);\n\n    buffer.write!ubyte(8, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 8, 0]);\n    assert(index == 7);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3256_4196)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isForwardRange!R && hasSlicing!R && is(ElementType!R : ubyte)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "write",
						"line": 3236,
						"type": "void(R range, T value, size_t* index)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "index",
								"type": "size_t*"
							}
						],
						"endline": 3253,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "write",
				"line": 3236,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isForwardRange!R && hasSlicing!R && is(ElementType!R : ubyte)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "append",
						"line": 3570,
						"type": "void(R range, T value)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "value",
								"type": "T"
							}
						],
						"endline": 3579,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "append",
				"line": 3570,
				"comment": "    Takes an integral value, converts it to the given endianness, and appends\n    it to the given range of $(D ubyte)s (using $(D put)) as a sequence of\n    $(D T.sizeof) $(D ubyte)s starting at index. $(D hasSlicing!R) must be\n    $(D true).\n\n    Params:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to write the bytes in.\n        range = The range to _append to.\n        value = The value to _append.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3582_4198)\n---\nimport std.array;\nauto buffer = appender!(const ubyte[])();\nbuffer.append!ushort(261);\nassert(buffer.data == [1, 5]);\n\nbuffer.append!uint(369700095u);\nassert(buffer.data == [1, 5, 22, 9, 44, 255]);\n\nbuffer.append!ubyte(8);\nassert(buffer.data == [1, 5, 22, 9, 44, 255, 8]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3582_4198)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3796_4201)\n---\nassert(countTrailingZeros(1) == 0);\nassert(countTrailingZeros(0) == 32);\nassert(countTrailingZeros(int.min) == 31);\nassert(countTrailingZeros(256) == 8);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3796_4201)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3877_4203)\n---\nassert(countBitsSet(1) == 1);\nassert(countBitsSet(0) == 0);\nassert(countBitsSet(int.min) == 1);\nassert(countBitsSet(uint.max) == 32);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3877_4203)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isOutputRange!(R, ubyte)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "bitsSet",
						"line": 3965,
						"type": "pure nothrow @nogc (T value)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							}
						],
						"endline": 3969,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "bitsSet",
				"line": 3965,
				"comment": "Range that iterates the indices of the set bits in $(D value).\nIndex 0 corresponds to the least significant bit.\nFor signed integers, the highest index corresponds to the sign bit.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3972_4205)\n---\nimport std.algorithm : equal;\nimport std.range : iota;\n\nassert(bitsSet(1).equal([0]));\nassert(bitsSet(5).equal([0, 2]));\nassert(bitsSet(-1).equal(iota(32)));\nassert(bitsSet(int.min).equal([31]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3972_4205)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!T",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "Bit-level manipulation facilities.\n\nMacros:\n\nWIKI = StdBitarray\n\nCopyright: Copyright Digital Mars 2007 - 2011.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Jonathan M Davis,\n           Alex Rønne Petersen,\n           Damian Ziemba\n           Amaury SECHET\nSource: $(PHOBOSSRC std/_bitmanip.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/concurrencybase.d",
		"name": "std.concurrencybase",
		"members": [],
		"comment": " The only purpose of this module is to do the static construction for\n std.concurrency, to eliminate cyclic construction errors.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Source:    $(PHOBOSSRC std/_concurrencybase.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/zip.d",
		"name": "std.zip",
		"members": [
			{
				"members": [],
				"name": "ZipException",
				"line": 81,
				"comment": " Thrown on error.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 94,
						"value": "cast(ushort)0u",
						"comment": "No compression, just archiving\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deflate",
						"line": 95,
						"value": "cast(ushort)8u",
						"comment": "Deflate algorithm. Use zlib library to compress\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CompressionMethod",
				"line": 92,
				"comment": " Compression method used by ArchiveMember\n",
				"baseDeco": "t",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "ArchiveMember",
				"line": 101,
				"comment": " A member of the ZipArchive.\n",
				"members": [
					{
						"offset": 16,
						"name": "name",
						"line": 111,
						"comment": " Read/Write: Usually the file name of the archive member; it is used to\n index the archive directory for the member. Each member must have a unique\n name[]. Do not change without removing member from the directory first.\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "extra",
						"line": 113,
						"comment": "Read/Write: extra data for this member.\n",
						"deco": "Ah",
						"char": 13,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "comment",
						"line": 114,
						"comment": "Read/Write: comment associated with this member.\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 128,
						"name": "flags",
						"line": 129,
						"comment": "Read/Write: normally set to 0\n",
						"deco": "t",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 130,
						"name": "internalAttributes",
						"line": 130,
						"comment": "Read/Write\n",
						"deco": "t",
						"char": 12,
						"kind": "variable"
					},
					{
						"endchar": 69,
						"name": "extractVersion",
						"line": 132,
						"comment": "Read Only\n",
						"deco": "FNdZt",
						"endline": 132,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 53,
						"name": "crc32",
						"line": 133,
						"comment": "Read Only: cyclic redundancy check (CRC) value\n",
						"deco": "FNdZk",
						"endline": 133,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 67,
						"name": "compressedSize",
						"line": 136,
						"comment": "Read Only: size of data of member in compressed form.\n",
						"deco": "FNdZk",
						"endline": 136,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 63,
						"name": "expandedSize",
						"line": 139,
						"comment": "Read Only: size of data of member in expanded form.\n",
						"deco": "FNdZk",
						"endline": 139,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 61,
						"name": "diskNumber",
						"line": 140,
						"comment": "Read Only: should be 0.\n",
						"deco": "FNdZt",
						"endline": 140,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 70,
						"name": "compressedData",
						"line": 143,
						"comment": "Read Only: data of member in compressed form.\n",
						"deco": "FNdZAh",
						"endline": 143,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 66,
						"name": "expandedData",
						"line": 146,
						"comment": "Read data of member in uncompressed form.\n",
						"deco": "FNdZAh",
						"endline": 146,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "expandedData",
						"line": 149,
						"comment": "Write data of member in uncompressed form.\n",
						"deco": "FNdAhZv",
						"parameters": [
							{
								"name": "ed",
								"deco": "Ah"
							}
						],
						"endline": 157,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fileAttributes",
						"line": 163,
						"comment": " Set the OS specific file attributes, as obtained by\n $(XREF file,getAttributes) or $(XREF file,DirEntry.attributes), for this archive member.\n",
						"deco": "FNdkZv",
						"parameters": [
							{
								"name": "attr",
								"deco": "k"
							}
						],
						"endline": 180,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fileAttributes",
						"line": 197,
						"comment": " Get the OS specific file attributes for the archive member.\n\n Returns: The file attributes or 0 if the file attributes were\n encoded for an incompatible OS (Windows vs. Posix).\n\n",
						"deco": "xFNdZk",
						"endline": 215,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "time",
						"line": 218,
						"comment": "Set the last modification time for this member.\n",
						"deco": "FNdS3std8datetime7SysTimeZv",
						"parameters": [
							{
								"name": "time",
								"deco": "S3std8datetime7SysTime"
							}
						],
						"endline": 221,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "time",
						"line": 224,
						"comment": "ditto\n",
						"deco": "FNdkZv",
						"parameters": [
							{
								"name": "time",
								"deco": "k"
							}
						],
						"endline": 227,
						"originalType": "@property void(DosFileTime time)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "time",
						"line": 230,
						"comment": "Get the last modification time for this member.\n",
						"deco": "xFNdZk",
						"endline": 233,
						"originalType": "const @property DosFileTime()",
						"char": 27,
						"kind": "function"
					},
					{
						"endchar": 82,
						"name": "compressionMethod",
						"line": 240,
						"comment": " Read compression method used for this member\n See_Also:\n     CompressionMethod\n",
						"deco": "FNdZE3std3zip17CompressionMethod",
						"endline": 240,
						"char": 33,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "compressionMethod",
						"line": 247,
						"comment": " Write compression method used for this member\n See_Also:\n     CompressionMethod\n",
						"deco": "FNdE3std3zip17CompressionMethodZv",
						"parameters": [
							{
								"name": "cm",
								"deco": "E3std3zip17CompressionMethod"
							}
						],
						"endline": 255,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "class"
			},
			{
				"name": "ZipArchive",
				"line": 281,
				"comment": " Object representing the entire archive.\n ZipArchives are collections of ArchiveMembers.\n",
				"members": [
					{
						"offset": 16,
						"name": "comment",
						"line": 289,
						"comment": "Read/Write: the archive comment. Must be less than 65536 bytes in length.\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"endchar": 52,
						"name": "data",
						"line": 305,
						"comment": "Read Only: array representing the entire contents of the archive.\n",
						"deco": "FNdZAh",
						"endline": 305,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 58,
						"name": "diskNumber",
						"line": 308,
						"comment": "Read Only: 0 since multi-disk zip archives are not supported.\n",
						"deco": "FNdZk",
						"endline": 308,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 60,
						"name": "diskStartDir",
						"line": 311,
						"comment": "Read Only: 0 since multi-disk zip archives are not supported\n",
						"deco": "FNdZk",
						"endline": 311,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 58,
						"name": "numEntries",
						"line": 314,
						"comment": "Read Only: number of ArchiveMembers in the directory.\n",
						"deco": "FNdZk",
						"endline": 314,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 60,
						"name": "totalEntries",
						"line": 315,
						"comment": "ditto\n",
						"deco": "FNdZk",
						"endline": 315,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 50,
						"name": "isZip64",
						"line": 318,
						"comment": "True when the archive is in Zip64 format.\n",
						"deco": "FNdZb",
						"endline": 318,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 60,
						"name": "isZip64",
						"line": 321,
						"comment": "Set this to true to force building a Zip64 archive.\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "value",
								"deco": "b"
							}
						],
						"endline": 321,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 70,
						"name": "directory",
						"line": 334,
						"comment": " Read Only: array indexed by the name of each member of the archive.\n  All the members of the archive can be accessed with a foreach loop:\n Example:\n --------------------\n ZipArchive archive = new ZipArchive(data);\n foreach (ArchiveMember am; archive.directory)\n {\n     writefln(\"member name is '%s'\", am.name);\n }\n --------------------\n",
						"deco": "FNdZHAyaC3std3zip13ArchiveMember",
						"endline": 334,
						"char": 37,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 354,
						"comment": " Constructor to use when creating a new archive.\n",
						"deco": "FZC3std3zip10ZipArchive",
						"endline": 356,
						"originalType": "()",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "addMember",
						"line": 360,
						"comment": " Add de to the archive.\n",
						"deco": "FC3std3zip13ArchiveMemberZv",
						"parameters": [
							{
								"name": "de",
								"deco": "C3std3zip13ArchiveMember"
							}
						],
						"endline": 363,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "deleteMember",
						"line": 367,
						"comment": " Delete de from the archive.\n",
						"deco": "FC3std3zip13ArchiveMemberZv",
						"parameters": [
							{
								"name": "de",
								"deco": "C3std3zip13ArchiveMember"
							}
						],
						"endline": 370,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "build",
						"line": 382,
						"comment": " Construct an archive out of the current members of the archive.\n\n Fills in the properties data[], diskNumber, diskStartDir, numEntries,\n totalEntries, and directory[].\n For each ArchiveMember, fills in properties crc32, compressedSize,\n compressedData[].\n\n Returns: array representing the entire archive.\n",
						"deco": "FZAv",
						"endline": 538,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 557,
						"comment": " Constructor to use when reading an existing archive.\n\n Fills in the properties data[], diskNumber, diskStartDir, numEntries,\n totalEntries, comment[], and directory[].\n For each ArchiveMember, fills in\n properties madeVersion, extractVersion, flags, compressionMethod, time,\n crc32, compressedSize, expandedSize, compressedData[], diskNumber,\n internalAttributes, externalAttributes, name[], extra[], comment[].\n Use expand() to get the expanded data for each ArchiveMember.\n\n Params:\n  buffer = the entire contents of the archive.\n",
						"deco": "FAvZC3std3zip10ZipArchive",
						"parameters": [
							{
								"name": "buffer",
								"deco": "Av"
							}
						],
						"endline": 710,
						"originalType": "(void[] buffer)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "expand",
						"line": 719,
						"comment": " Decompress the contents of archive member de and return the expanded\n data.\n\n Fills in properties extractVersion, flags, compressionMethod, time,\n crc32, compressedSize, expandedSize, expandedData[], name[], extra[].\n",
						"deco": "FC3std3zip13ArchiveMemberZAh",
						"parameters": [
							{
								"name": "de",
								"deco": "C3std3zip13ArchiveMember"
							}
						],
						"endline": 772,
						"char": 13,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "class"
			}
		],
		"comment": " Read/write data in the $(LINK2 http://www.info-_zip.org, zip archive) format.\n Makes use of the etc.c.zlib compression library.\n\n Bugs:\n      $(UL\n      $(LI Multi-disk zips not supported.)\n      $(LI Only Zip version 20 formats are supported.)\n      $(LI Only supports compression modes 0 (no compression) and 8 (deflate).)\n      $(LI Does not support encryption.)\n      $(LI $(BUGZILLA 592))\n      $(LI $(BUGZILLA 2137))\n      )\n\n Macros:\n      WIKI = Phobos/StdZip\n\n Example:\n ---\n// Read existing zip file.\nimport std.digest.crc, std.file, std.stdio, std.zip;\n\nvoid main(string[] args)\n{\n    // read a zip file into memory\n    auto zip = new ZipArchive(read(args[1]));\n    writeln(\"Archive: \", args[1]);\n    writefln(\"%-10s  %-8s  Name\", \"Length\", \"CRC-32\");\n    // iterate over all zip members\n    foreach (name, am; zip.directory)\n    {\n        // print some data about each member\n        writefln(\"%10s  %08x  %s\", am.expandedSize, am.crc32, name);\n        assert(am.expandedData.length == 0);\n        // decompress the archive member\n        zip.expand(am);\n        assert(am.expandedData.length == am.expandedSize);\n    }\n}\n\n// Create and write new zip file.\nimport std.file: write;\nimport std.string: representation;\n\nvoid main()\n{\n    char[] data = \"Test data.\\n\".dup;\n    // Create an ArchiveMember for the test file.\n    ArchiveMember am = new ArchiveMember();\n    am.name = \"test.txt\";\n    am.expandedData(data.representation);\n    // Create an archive and add the member.\n    ZipArchive zip = new ZipArchive();\n    zip.addMember(am);\n    // Build the archive\n    void[] compressed_data = zip.build();\n    // Write to a file\n    write(\"test.zip\", compressed_data);\n}\n ---\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_zip.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/etc/c/curl.d",
		"name": "etc.c.curl",
		"members": [
			{
				"name": "LIBCURL_COPYRIGHT",
				"line": 50,
				"comment": " This is the global package copyright\n",
				"deco": "Aya",
				"init": "\"1996 - 2010 Daniel Stenberg, <daniel@haxx.se>.\"",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_VERSION",
				"line": 54,
				"comment": " This is the version number of the libcurl package from which this header\n   file origins:\n",
				"deco": "Aya",
				"init": "\"7.21.4\"",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_VERSION_MAJOR",
				"line": 58,
				"comment": " The numeric version number is also available \"in parts\" by using these\n   constants\n",
				"deco": "i",
				"init": "7",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_VERSION_MINOR",
				"line": 60,
				"comment": "ditto\n",
				"deco": "i",
				"init": "21",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_VERSION_PATCH",
				"line": 62,
				"comment": "ditto\n",
				"deco": "i",
				"init": "4",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_VERSION_NUM",
				"line": 80,
				"comment": " This is the numeric version of the libcurl version number, meant for easier\n   parsing and comparions by programs. The LIBCURL_VERSION_NUM define will\n   always follow this syntax:\n\n         0xXXYYZZ\n\n   Where XX, YY and ZZ are the main version, release and patch numbers in\n   hexadecimal (using 8 bits each). All three numbers are always represented\n   using two digits.  1.2 would appear as \"0x010200\" while version 9.11.7\n   appears as \"0x090b07\".\n\n   This 6-digit (24 bits) hexadecimal number does not show pre-release number,\n   and it is always a greater number in a more recent release. It makes\n   comparisons with greater than and less than work.\n",
				"deco": "i",
				"init": "464132",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_TIMESTAMP",
				"line": 91,
				"comment": " This is the date and time when the full source package was created. The\n timestamp is not stored in git, as the timestamp is properly set in the\n tarballs by the maketgz script.\n\n The format of the date should follow this template:\n\n \"Mon Feb 12 11:35:33 UTC 2007\"\n",
				"deco": "Aya",
				"init": "\"Thu Feb 17 12:19:40 UTC 2011\"",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "curl_off_t",
				"line": 109,
				"comment": " Data type definition of curl_off_t.\n\n jdrewsen - Always 64bit signed and that is what long is in D.\n\n Comment below is from curlbuild.h:\n\n NOTE 2:\n\n For any given platform/compiler curl_off_t must be typedef'ed to a\n 64-bit wide signed integral data type. The width of this data type\n must remain constant and independent of any possible large file\n support settings.\n\n As an exception to the above, curl_off_t shall be typedef'ed to a\n 32-bit wide signed integral data type if there is no 64-bit type.\n",
				"deco": "l",
				"char": 12,
				"kind": "alias"
			},
			{
				"name": "CURL",
				"line": 112,
				"comment": "\n",
				"deco": "v",
				"char": 12,
				"kind": "alias"
			},
			{
				"name": "curl_socket_t",
				"line": 115,
				"comment": "jdrewsen - Get socket alias from std.socket\n",
				"deco": "E3std6socket8socket_t",
				"char": 16,
				"kind": "alias"
			},
			{
				"name": "curl_httppost",
				"line": 125,
				"comment": "\n",
				"members": [
					{
						"offset": 0,
						"name": "next",
						"line": 127,
						"comment": " next entry in the list\n",
						"deco": "PS3etc1c4curl13curl_httppost",
						"char": 20,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "name",
						"line": 128,
						"comment": " pointer to allocated name\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "namelength",
						"line": 129,
						"comment": " length of name length\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "contents",
						"line": 130,
						"comment": " pointer to allocated data contents\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "contentslength",
						"line": 131,
						"comment": " length of contents field\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 40,
						"name": "buffer",
						"line": 132,
						"comment": " pointer to allocated buffer contents\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "bufferlength",
						"line": 133,
						"comment": " length of buffer field\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 56,
						"name": "contenttype",
						"line": 134,
						"comment": " Content-Type\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 64,
						"name": "contentheader",
						"line": 135,
						"comment": " list of extra headers for this form\n",
						"deco": "PS3etc1c4curl10curl_slist",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 72,
						"name": "more",
						"line": 136,
						"comment": " if one field name has more than one\n                                    file, this link should link to following\n                                    files\n",
						"deco": "PS3etc1c4curl13curl_httppost",
						"char": 20,
						"kind": "variable"
					},
					{
						"offset": 80,
						"name": "flags",
						"line": 139,
						"comment": " as defined below\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 88,
						"name": "showfilename",
						"line": 140,
						"comment": " The file name to show. If not set, the\n                                    actual file name will be used (if this\n                                    is a file part)\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 96,
						"name": "userp",
						"line": 143,
						"comment": " custom pointer used for\n                                    HTTPPOST_CALLBACK posts\n",
						"deco": "Pv",
						"char": 11,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"name": "HTTPPOST_FILENAME",
				"line": 147,
				"comment": " specified content is a file name\n",
				"deco": "i",
				"init": "1",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_READFILE",
				"line": 148,
				"comment": " specified content is a file name\n",
				"deco": "i",
				"init": "2",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_PTRNAME",
				"line": 149,
				"comment": " name is only stored pointer\n                                    do not free in formfree\n",
				"deco": "i",
				"init": "4",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_PTRCONTENTS",
				"line": 151,
				"comment": " contents is only stored pointer\n                                    do not free in formfree\n",
				"deco": "i",
				"init": "8",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_BUFFER",
				"line": 153,
				"comment": " upload file from buffer\n",
				"deco": "i",
				"init": "16",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_PTRBUFFER",
				"line": 154,
				"comment": " upload file from pointer contents\n",
				"deco": "i",
				"init": "32",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_CALLBACK",
				"line": 155,
				"comment": " upload file contents by using the\n                                    regular read callback to get the data\n                                    and pass the given pointer as custom\n                                    pointer\n",
				"deco": "i",
				"init": "64",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "curl_progress_callback",
				"line": 161,
				"comment": "\n",
				"deco": "PFPvddddZi",
				"char": 95,
				"kind": "alias"
			},
			{
				"name": "CURL_MAX_WRITE_SIZE",
				"line": 169,
				"comment": " Tests have proven that 20K is a very bad buffer size for uploads on\n   Windows, while 16K for some odd reason performed a lot better.\n   We do the ifndef check to allow this value to easier be changed at build\n   time for those who feel adventurous. The practical minimum is about\n   400 bytes since libcurl uses a buffer of this size as a scratch area\n   (unrelated to network send operations).\n",
				"deco": "i",
				"init": "16384",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURL_MAX_HTTP_HEADER",
				"line": 174,
				"comment": " The only reason to have a max limit for this is to avoid the risk of a bad\n   server feeding libcurl with a never-ending header that will cause reallocs\n   infinitely\n",
				"deco": "i",
				"init": "102400",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURL_WRITEFUNC_PAUSE",
				"line": 179,
				"comment": " This is a magic return code for the write callback that, when returned,\n   will signal libcurl to pause receiving on the current transfer.\n",
				"deco": "i",
				"init": "268435457",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "curl_write_callback",
				"line": 182,
				"comment": "\n",
				"deco": "PFPammPvZm",
				"char": 82,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "file",
						"line": 186,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "directory",
						"line": 187,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "symlink",
						"line": 188,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "device_block",
						"line": 189,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "device_char",
						"line": 190,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "namedpipe",
						"line": 191,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socket",
						"line": 192,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "door",
						"line": 193,
						"value": "7",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unknown",
						"line": 194,
						"value": "8",
						"comment": " is possible only on Sun Solaris now\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFileType",
				"line": 185,
				"comment": " enumeration of file types\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curlfiletype",
				"line": 198,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "filename",
						"line": 202,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "filetype",
						"line": 203,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "time",
						"line": 204,
						"value": "4",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "perm",
						"line": 205,
						"value": "8",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "uid",
						"line": 206,
						"value": "16",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "gid",
						"line": 207,
						"value": "32",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "size",
						"line": 208,
						"value": "64",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "hlinkcount",
						"line": 209,
						"value": "128",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlFInfoFlagKnown",
				"line": 201,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "_N2",
				"line": 219,
				"comment": " Content of this structure depends on information which is known and is\n   achievable (e.g. by FTP LIST parsing). Please see the url_easy_setopt(3) man\n   page for callbacks returning this structure -- some fields are mandatory,\n   some others are optional. The FLAG field has special meaning.\n\n If some of these fields is not NULL, it is a pointer to b_data.\n",
				"members": [
					{
						"offset": 0,
						"name": "time",
						"line": 221,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "perm",
						"line": 222,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "user",
						"line": 223,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "group",
						"line": 224,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "target",
						"line": 225,
						"comment": " pointer to the target filename of a symlink\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"name": "curl_fileinfo",
				"line": 232,
				"comment": " Content of this structure depends on information which is known and is\n   achievable (e.g. by FTP LIST parsing). Please see the url_easy_setopt(3) man\n   page for callbacks returning this structure -- some fields are mandatory,\n   some others are optional. The FLAG field has special meaning.\n",
				"members": [
					{
						"offset": 0,
						"name": "filename",
						"line": 234,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "filetype",
						"line": 235,
						"comment": "\n",
						"deco": "i",
						"originalType": "curlfiletype",
						"char": 18,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "time",
						"line": 236,
						"comment": "\n",
						"deco": "l",
						"originalType": "time_t",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "perm",
						"line": 237,
						"comment": "\n",
						"deco": "k",
						"char": 10,
						"kind": "variable"
					},
					{
						"offset": 28,
						"name": "uid",
						"line": 238,
						"comment": "\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "gid",
						"line": 239,
						"comment": "\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 40,
						"name": "size",
						"line": 240,
						"comment": "\n",
						"deco": "l",
						"originalType": "curl_off_t",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "hardlinks",
						"line": 241,
						"comment": "\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 56,
						"name": "strings",
						"line": 242,
						"comment": "\n",
						"deco": "S3etc1c4curl3_N2",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 96,
						"name": "flags",
						"line": 243,
						"comment": "\n",
						"deco": "k",
						"char": 10,
						"kind": "variable"
					},
					{
						"offset": 104,
						"name": "b_data",
						"line": 244,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 112,
						"name": "b_size",
						"line": 245,
						"comment": "\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 120,
						"name": "b_used",
						"line": 246,
						"comment": "\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 251,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fail",
						"line": 252,
						"value": "1",
						"comment": " tell the lib to end the task\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "skip",
						"line": 253,
						"value": "2",
						"comment": " skip this chunk over\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlChunkBgnFunc",
				"line": 250,
				"comment": " return codes for CURLOPT_CHUNK_BGN_FUNCTION\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_chunk_bgn_callback",
				"line": 259,
				"comment": " if splitting of data transfer is enabled, this callback is called before\n   download of an individual chunk started. Note that parameter \"remains\" works\n   only for FTP wildcard downloading (for now), otherwise is not used\n",
				"deco": "PFPvPviZl",
				"char": 67,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 263,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fail",
						"line": 264,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlChunkEndFunc",
				"line": 262,
				"comment": " return codes for CURLOPT_CHUNK_END_FUNCTION\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_chunk_end_callback",
				"line": 272,
				"comment": " If splitting of data transfer is enabled this callback is called after\n   download of an individual chunk finished.\n   Note! After this callback was set then it have to be called FOR ALL chunks.\n   Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC.\n   This is the reason why we don't need \"transfer_info\" parameter in this\n   callback and we are not interested in \"remains\" parameter too.\n",
				"deco": "PFPvZl",
				"char": 33,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "match",
						"line": 276,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "nomatch",
						"line": 277,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fail",
						"line": 278,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlFnMAtchFunc",
				"line": 275,
				"comment": " return codes for FNMATCHFUNCTION\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_fnmatch_callback",
				"line": 283,
				"comment": " callback type for wildcard downloading pattern matching. If the\n   string matches the pattern, return CURL_FNMATCHFUNC_MATCH value, etc.\n",
				"deco": "PFPvxPaxPaZi",
				"char": 66,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "set",
						"line": 287,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "current",
						"line": 288,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "end",
						"line": 289,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlSeekPos",
				"line": 286,
				"comment": "seek whence...\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 294,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fail",
						"line": 295,
						"value": "1",
						"comment": " fail the entire transfer\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cantseek",
						"line": 296,
						"value": "2",
						"comment": " tell libcurl seeking can't be done, so\n               libcurl might try other means instead\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlSeek",
				"line": 293,
				"comment": " These are the return codes for the seek callbacks\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_seek_callback",
				"line": 301,
				"comment": "\n",
				"deco": "PFPvliZi",
				"char": 67,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "abort",
						"line": 307,
						"value": "268435456",
						"comment": " This is a return code for the read callback that, when returned, will\n     signal libcurl to immediately abort the current transfer.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "pause",
						"line": 312,
						"value": "268435457",
						"comment": " This is a return code for the read callback that, when returned,\n     will const signal libcurl to pause sending data on the current\n     transfer.\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlReadFunc",
				"line": 304,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_read_callback",
				"line": 316,
				"comment": "\n",
				"deco": "PFPammPvZm",
				"char": 81,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ipcxn",
						"line": 320,
						"value": "0",
						"comment": " socket created for a specific IP connection\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 321,
						"value": "1",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlSockType",
				"line": 319,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curlsocktype",
				"line": 324,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_sockopt_callback",
				"line": 327,
				"comment": "\n",
				"deco": "PFPvE3std6socket8socket_tiZi",
				"char": 79,
				"kind": "alias"
			},
			{
				"name": "curl_sockaddr",
				"line": 331,
				"comment": " addrlen was a socklen_t type before 7.18.0 but it turned really\n   ugly and painful on the systems that lack this type\n",
				"members": [
					{
						"offset": 0,
						"name": "family",
						"line": 333,
						"comment": "\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 4,
						"name": "socktype",
						"line": 334,
						"comment": "\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "protocol",
						"line": 335,
						"comment": "\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 12,
						"name": "addrlen",
						"line": 336,
						"comment": " addrlen was a socklen_t type before 7.18.0 but it\n                     turned really ugly and painful on the systems that\n                     lack this type\n",
						"deco": "k",
						"char": 10,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "addr",
						"line": 339,
						"comment": "\n",
						"deco": "S4core3sys5posix3sys6socket8sockaddr",
						"char": 14,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"name": "curl_opensocket_callback",
				"line": 343,
				"comment": "\n",
				"deco": "PFPviPS3etc1c4curl13curl_sockaddrZE3std6socket8socket_t",
				"char": 91,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 348,
						"value": "0",
						"comment": " I/O operation successful\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unknowncmd",
						"line": 349,
						"value": "1",
						"comment": " command was unknown to callback\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "failrestart",
						"line": 350,
						"value": "2",
						"comment": " failed to restart the read\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 351,
						"value": "3",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlIoError",
				"line": 346,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curlioerr",
				"line": 354,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "nop",
						"line": 358,
						"value": "0",
						"comment": " command was unknown to callback\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "restartread",
						"line": 359,
						"value": "1",
						"comment": " failed to restart the read\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 360,
						"value": "2",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlIoCmd",
				"line": 357,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curliocmd",
				"line": 363,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_ioctl_callback",
				"line": 366,
				"comment": "\n",
				"deco": "PFPviPvZi",
				"char": 64,
				"kind": "alias"
			},
			{
				"name": "curl_malloc_callback",
				"line": 374,
				"comment": " The following typedef's are signatures of malloc, free, realloc, strdup and\n calloc respectively.  Function pointers of these types can be passed to the\n curl_global_init_mem() function to set user defined memory management\n callback routines.\n",
				"deco": "PFmZPv",
				"char": 35,
				"kind": "alias"
			},
			{
				"name": "curl_free_callback",
				"line": 376,
				"comment": "ditto\n",
				"deco": "PFPvZv",
				"char": 32,
				"kind": "alias"
			},
			{
				"name": "curl_realloc_callback",
				"line": 378,
				"comment": "ditto\n",
				"deco": "PFPvmZPv",
				"char": 46,
				"kind": "alias"
			},
			{
				"name": "curl_strdup_callback",
				"line": 380,
				"comment": "ditto\n",
				"deco": "PFxPaZPa",
				"char": 36,
				"kind": "alias"
			},
			{
				"name": "curl_calloc_callback",
				"line": 382,
				"comment": "ditto\n",
				"deco": "PFmmZPv",
				"char": 49,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "text",
						"line": 386,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "header_in",
						"line": 387,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "header_out",
						"line": 388,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "data_in",
						"line": 389,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "data_out",
						"line": 390,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_data_in",
						"line": 391,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_data_out",
						"line": 392,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "end",
						"line": 393,
						"value": "7",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlCallbackInfo",
				"line": 385,
				"comment": " the kind of data that is passed to information_callback\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_infotype",
				"line": 396,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_debug_callback",
				"line": 404,
				"comment": "\n",
				"deco": "PFPviPamPvZi",
				"char": 22,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 414,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unsupported_protocol",
						"line": 415,
						"value": "1",
						"comment": " 1\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "failed_init",
						"line": 416,
						"value": "2",
						"comment": " 2\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "url_malformat",
						"line": 417,
						"value": "3",
						"comment": " 3\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "not_built_in",
						"line": 418,
						"value": "4",
						"comment": " 4 - [was obsoleted in August 2007 for\n                                    7.17.0, reused in April 2011 for 7.21.5]\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "couldnt_resolve_proxy",
						"line": 420,
						"value": "5",
						"comment": " 5\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "couldnt_resolve_host",
						"line": 421,
						"value": "6",
						"comment": " 6\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "couldnt_connect",
						"line": 422,
						"value": "7",
						"comment": " 7\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_weird_server_reply",
						"line": 423,
						"value": "8",
						"comment": " 8\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "remote_access_denied",
						"line": 424,
						"value": "9",
						"comment": " 9 a service was denied by the server\n                                    due to lack of access - when login fails\n                                    this is not returned.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete10",
						"line": 427,
						"value": "10",
						"comment": " 10 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_weird_pass_reply",
						"line": 428,
						"value": "11",
						"comment": " 11\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete12",
						"line": 429,
						"value": "12",
						"comment": " 12 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_weird_pasv_reply",
						"line": 430,
						"value": "13",
						"comment": " 13\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_weird_227_format",
						"line": 431,
						"value": "14",
						"comment": " 14\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_cant_get_host",
						"line": 432,
						"value": "15",
						"comment": " 15\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete16",
						"line": 433,
						"value": "16",
						"comment": " 16 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_couldnt_set_type",
						"line": 434,
						"value": "17",
						"comment": " 17\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "partial_file",
						"line": 435,
						"value": "18",
						"comment": " 18\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_couldnt_retr_file",
						"line": 436,
						"value": "19",
						"comment": " 19\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete20",
						"line": 437,
						"value": "20",
						"comment": " 20 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "quote_error",
						"line": 438,
						"value": "21",
						"comment": " 21 - quote command failure\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "http_returned_error",
						"line": 439,
						"value": "22",
						"comment": " 22\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "write_error",
						"line": 440,
						"value": "23",
						"comment": " 23\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete24",
						"line": 441,
						"value": "24",
						"comment": " 24 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "upload_failed",
						"line": 442,
						"value": "25",
						"comment": " 25 - failed upload \"command\"\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "read_error",
						"line": 443,
						"value": "26",
						"comment": " 26 - couldn't open/read from file\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "out_of_memory",
						"line": 444,
						"value": "27",
						"comment": " 27\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "operation_timedout",
						"line": 449,
						"value": "28",
						"comment": " Note: CURLE_OUT_OF_MEMORY may sometimes indicate a conversion error\n             instead of a memory allocation error if CURL_DOES_CONVERSIONS\n             is defined\n\n 28 - the timeout time was reached\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete29",
						"line": 450,
						"value": "29",
						"comment": " 29 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_port_failed",
						"line": 451,
						"value": "30",
						"comment": " 30 - FTP PORT operation failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_couldnt_use_rest",
						"line": 452,
						"value": "31",
						"comment": " 31 - the REST command failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete32",
						"line": 453,
						"value": "32",
						"comment": " 32 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "range_error",
						"line": 454,
						"value": "33",
						"comment": " 33 - RANGE \"command\" didn't work\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "http_post_error",
						"line": 455,
						"value": "34",
						"comment": " 34\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_connect_error",
						"line": 456,
						"value": "35",
						"comment": " 35 - wrong when connecting with SSL\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_download_resume",
						"line": 457,
						"value": "36",
						"comment": " 36 - couldn't resume download\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "file_couldnt_read_file",
						"line": 458,
						"value": "37",
						"comment": " 37\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ldap_cannot_bind",
						"line": 459,
						"value": "38",
						"comment": " 38\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ldap_search_failed",
						"line": 460,
						"value": "39",
						"comment": " 39\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete40",
						"line": 461,
						"value": "40",
						"comment": " 40 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "function_not_found",
						"line": 462,
						"value": "41",
						"comment": " 41\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "aborted_by_callback",
						"line": 463,
						"value": "42",
						"comment": " 42\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_function_argument",
						"line": 464,
						"value": "43",
						"comment": " 43\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete44",
						"line": 465,
						"value": "44",
						"comment": " 44 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "interface_failed",
						"line": 466,
						"value": "45",
						"comment": " 45 - CURLOPT_INTERFACE failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete46",
						"line": 467,
						"value": "46",
						"comment": " 46 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "too_many_redirects",
						"line": 468,
						"value": "47",
						"comment": " 47 - catch endless re-direct loops\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unknown_option",
						"line": 469,
						"value": "48",
						"comment": " 48 - User specified an unknown option\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "telnet_option_syntax",
						"line": 470,
						"value": "49",
						"comment": " 49 - Malformed telnet option\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete50",
						"line": 471,
						"value": "50",
						"comment": " 50 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "peer_failed_verification",
						"line": 472,
						"value": "51",
						"comment": " 51 - peer's certificate or fingerprint\n                                         wasn't verified fine\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "got_nothing",
						"line": 474,
						"value": "52",
						"comment": " 52 - when this is a specific error\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_engine_notfound",
						"line": 475,
						"value": "53",
						"comment": " 53 - SSL crypto engine not found\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_engine_setfailed",
						"line": 476,
						"value": "54",
						"comment": " 54 - can not set SSL crypto engine as default\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "send_error",
						"line": 477,
						"value": "55",
						"comment": " 55 - failed sending network data\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "recv_error",
						"line": 478,
						"value": "56",
						"comment": " 56 - failure in receiving network data\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete57",
						"line": 479,
						"value": "57",
						"comment": " 57 - NOT IN USE\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_certproblem",
						"line": 480,
						"value": "58",
						"comment": " 58 - problem with the local certificate\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_cipher",
						"line": 481,
						"value": "59",
						"comment": " 59 - couldn't use specified cipher\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_cacert",
						"line": 482,
						"value": "60",
						"comment": " 60 - problem with the CA cert (path?)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_content_encoding",
						"line": 483,
						"value": "61",
						"comment": " 61 - Unrecognized transfer encoding\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ldap_invalid_url",
						"line": 484,
						"value": "62",
						"comment": " 62 - Invalid LDAP URL\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "filesize_exceeded",
						"line": 485,
						"value": "63",
						"comment": " 63 - Maximum file size exceeded\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "use_ssl_failed",
						"line": 486,
						"value": "64",
						"comment": " 64 - Requested FTP SSL level failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "send_fail_rewind",
						"line": 487,
						"value": "65",
						"comment": " 65 - Sending the data requires a rewind that failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_engine_initfailed",
						"line": 488,
						"value": "66",
						"comment": " 66 - failed to initialise ENGINE\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "login_denied",
						"line": 489,
						"value": "67",
						"comment": " 67 - user, password or similar was not accepted and we failed to login\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tftp_notfound",
						"line": 490,
						"value": "68",
						"comment": " 68 - file not found on server\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tftp_perm",
						"line": 491,
						"value": "69",
						"comment": " 69 - permission problem on server\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "remote_disk_full",
						"line": 492,
						"value": "70",
						"comment": " 70 - out of disk space on server\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tftp_illegal",
						"line": 493,
						"value": "71",
						"comment": " 71 - Illegal TFTP operation\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tftp_unknownid",
						"line": 494,
						"value": "72",
						"comment": " 72 - Unknown transfer ID\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "remote_file_exists",
						"line": 495,
						"value": "73",
						"comment": " 73 - File already exists\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tftp_nosuchuser",
						"line": 496,
						"value": "74",
						"comment": " 74 - No such user\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "conv_failed",
						"line": 497,
						"value": "75",
						"comment": " 75 - conversion failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "conv_reqd",
						"line": 498,
						"value": "76",
						"comment": " 76 - caller must register conversion\n                                    callbacks using curl_easy_setopt options\n                                    CURLOPT_CONV_FROM_NETWORK_FUNCTION,\n                                    CURLOPT_CONV_TO_NETWORK_FUNCTION, and\n                                    CURLOPT_CONV_FROM_UTF8_FUNCTION\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_cacert_badfile",
						"line": 503,
						"value": "77",
						"comment": " 77 - could not load CACERT file, missing  or wrong format\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "remote_file_not_found",
						"line": 504,
						"value": "78",
						"comment": " 78 - remote file not found\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssh",
						"line": 505,
						"value": "79",
						"comment": " 79 - error from the SSH layer, somewhat\n                                    generic so the error message will be of\n                                    interest when this has happened\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_shutdown_failed",
						"line": 508,
						"value": "80",
						"comment": " 80 - Failed to shut down the SSL connection\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "again",
						"line": 509,
						"value": "81",
						"comment": " 81 - socket is not ready for send/recv,\n                                    wait till it's ready and try again (Added\n                                    in 7.18.2)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_crl_badfile",
						"line": 512,
						"value": "82",
						"comment": " 82 - could not load CRL file, missing or wrong format (Added in 7.19.0)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_issuer_error",
						"line": 513,
						"value": "83",
						"comment": " 83 - Issuer check failed.  (Added in 7.19.0)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_pret_failed",
						"line": 514,
						"value": "84",
						"comment": " 84 - a PRET command failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_cseq_error",
						"line": 515,
						"value": "85",
						"comment": " 85 - mismatch of RTSP CSeq numbers\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_session_error",
						"line": 516,
						"value": "86",
						"comment": " 86 - mismatch of RTSP Session Identifiers\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_bad_file_list",
						"line": 517,
						"value": "87",
						"comment": " 87 - unable to parse FTP file list\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "chunk_failed",
						"line": 518,
						"value": "88",
						"comment": " 88 - chunk callback reported error\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "curl_last",
						"line": 519,
						"value": "89",
						"comment": " never use!\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlError",
				"line": 412,
				"comment": " All possible error codes from all sorts of curl functions. Future versions\n   may return other values, stay prepared.\n\n   Always add new return codes last. Never *EVER* remove any. The return\n   codes must remain the same!\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLcode",
				"line": 522,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_conv_callback",
				"line": 525,
				"comment": " This prototype applies to all conversion callbacks\n",
				"deco": "PFPamZi",
				"char": 54,
				"kind": "alias"
			},
			{
				"name": "curl_ssl_ctx_callback",
				"line": 532,
				"comment": " actually an OpenSSL SSL_CTX\n",
				"deco": "PFPvPvPvZi",
				"char": 27,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "http",
						"line": 536,
						"value": "0",
						"comment": " added in 7.10, new in 7.19.4 default is to use CONNECT HTTP/1.1\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "http_1_0",
						"line": 537,
						"value": "1",
						"comment": " added in 7.19.4, force to use CONNECT HTTP/1.0\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socks4",
						"line": 538,
						"value": "4",
						"comment": " support added in 7.15.2, enum existed already in 7.10\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socks5",
						"line": 539,
						"value": "5",
						"comment": " added in 7.10\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socks4a",
						"line": 540,
						"value": "6",
						"comment": " added in 7.18.0\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socks5_hostname",
						"line": 541,
						"value": "7",
						"comment": " Use the SOCKS5 protocol but pass along the\n                         host name rather than the IP address. added\n                         in 7.18.0\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlProxy",
				"line": 535,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_proxytype",
				"line": 546,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "basic",
						"line": 551,
						"value": "1L",
						"comment": " Basic (default)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "digest",
						"line": 552,
						"value": "2L",
						"comment": " Digest\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "gssnegotiate",
						"line": 553,
						"value": "4L",
						"comment": " GSS-Negotiate\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ntlm",
						"line": 554,
						"value": "8L",
						"comment": " NTLM\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "digest_ie",
						"line": 555,
						"value": "16L",
						"comment": " Digest with IE flavour\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "only",
						"line": 556,
						"value": "2147483648L",
						"comment": " used together with a single other\n                                type to force no auth or just that\n                                single type\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "any",
						"line": 559,
						"value": "-17L",
						"comment": " all fine types set\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "anysafe",
						"line": 560,
						"value": "-18L",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlAuth",
				"line": 549,
				"comment": "\n",
				"baseDeco": "l",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "any",
						"line": 565,
						"value": "-1",
						"comment": " all types supported by the server\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "none",
						"line": 566,
						"value": "0",
						"comment": " none allowed, silly but complete\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "publickey",
						"line": 567,
						"value": "1",
						"comment": " public/private key files\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "password",
						"line": 568,
						"value": "2",
						"comment": " password\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "host",
						"line": 569,
						"value": "4",
						"comment": " host key files\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "keyboard",
						"line": 570,
						"value": "8",
						"comment": " keyboard interactive\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlSshAuth",
				"line": 564,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURL_ERROR_SIZE",
				"line": 574,
				"comment": "\n",
				"deco": "i",
				"init": "256",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "unknown",
						"line": 579,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rsa1",
						"line": 580,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rsa",
						"line": 581,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "dss",
						"line": 582,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlKHType",
				"line": 577,
				"comment": " points to a zero-terminated string encoded with base64\n   if len is zero, otherwise to the \"raw\" data\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_khkey",
				"line": 585,
				"comment": "\n",
				"members": [
					{
						"offset": 0,
						"name": "key",
						"line": 587,
						"comment": " points to a zero-terminated string encoded with base64\n                         if len is zero, otherwise to the \"raw\" data\n",
						"deco": "Pxa",
						"char": 18,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "len",
						"line": 589,
						"comment": "\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "keytype",
						"line": 590,
						"comment": "\n",
						"deco": "E3etc1c4curl10CurlKHType",
						"char": 16,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "fine_add_to_file",
						"line": 596,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "fine",
						"line": 597,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "reject",
						"line": 598,
						"value": "2",
						"comment": " reject the connection, return an error\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "defer",
						"line": 599,
						"value": "3",
						"comment": " do not accept it, but we can't answer right now so\n                this causes a CURLE_DEFER error but otherwise the\n                connection will be left intact etc\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 602,
						"value": "4",
						"comment": " not for use, only a marker for last-in-list\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlKHStat",
				"line": 595,
				"comment": " this is the set of return values expected from the curl_sshkeycallback\n   callback\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 607,
						"value": "0",
						"comment": " match\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "mismatch",
						"line": 608,
						"value": "1",
						"comment": " host found, key mismatch!\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "missing",
						"line": 609,
						"value": "2",
						"comment": " no matching host/key found\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 610,
						"value": "3",
						"comment": " not for use, only a marker for last-in-list\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlKHMatch",
				"line": 606,
				"comment": " this is the set of status codes pass in to the callback\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_sshkeycallback",
				"line": 619,
				"comment": "\n",
				"deco": "PFPvPS3etc1c4curl10curl_khkeyPS3etc1c4curl10curl_khkeyE3etc1c4curl11CurlKHMatchPvZi",
				"char": 22,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 623,
						"value": "0",
						"comment": " do not attempt to use SSL\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tryssl",
						"line": 624,
						"value": "1",
						"comment": " try using SSL, proceed anyway otherwise\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "control",
						"line": 625,
						"value": "2",
						"comment": " SSL for the control connection or fail\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 626,
						"value": "3",
						"comment": " SSL for all communication or fail\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 627,
						"value": "4",
						"comment": " not an option, never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlUseSSL",
				"line": 622,
				"comment": " parameter for the CURLOPT_USE_SSL option\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_usessl",
				"line": 630,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ccc_none",
						"line": 634,
						"value": "0",
						"comment": " do not send CCC\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ccc_passive",
						"line": 635,
						"value": "1",
						"comment": " Let the server initiate the shutdown\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ccc_active",
						"line": 636,
						"value": "2",
						"comment": " Initiate the shutdown\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ccc_last",
						"line": 637,
						"value": "3",
						"comment": " not an option, never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFtpSSL",
				"line": 633,
				"comment": " parameter for the CURLOPT_FTP_SSL_CCC option\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_ftpccc",
				"line": 640,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "defaultauth",
						"line": 644,
						"value": "0",
						"comment": " let libcurl decide\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl",
						"line": 645,
						"value": "1",
						"comment": " use \"AUTH SSL\"\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tls",
						"line": 646,
						"value": "2",
						"comment": " use \"AUTH TLS\"\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 647,
						"value": "3",
						"comment": " not an option, never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFtpAuth",
				"line": 643,
				"comment": " parameter for the CURLOPT_FTPSSLAUTH option\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_ftpauth",
				"line": 650,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "create_dir_none",
						"line": 654,
						"value": "0",
						"comment": " do NOT create missing dirs!\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "create_dir",
						"line": 655,
						"value": "1",
						"comment": " (FTP/SFTP) if CWD fails, try MKD and then CWD again if MKD\n                          succeeded, for SFTP this does similar magic\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "create_dir_retry",
						"line": 657,
						"value": "2",
						"comment": " (FTP only) if CWD fails, try MKD and then CWD again even if MKD\n                          failed!\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "create_dir_last",
						"line": 659,
						"value": "3",
						"comment": " not an option, never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFtp",
				"line": 653,
				"comment": " parameter for the CURLOPT_FTP_CREATE_MISSING_DIRS option\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_ftpcreatedir",
				"line": 662,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "defaultmethod",
						"line": 666,
						"value": "0",
						"comment": " let libcurl pick\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "multicwd",
						"line": 667,
						"value": "1",
						"comment": " single CWD operation for each path part\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "nocwd",
						"line": 668,
						"value": "2",
						"comment": " no CWD at all\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "singlecwd",
						"line": 669,
						"value": "3",
						"comment": " one CWD to full dir, then work on file\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 670,
						"value": "4",
						"comment": " not an option, never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFtpMethod",
				"line": 665,
				"comment": " parameter for the CURLOPT_FTP_FILEMETHOD option\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_ftpmethod",
				"line": 673,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "http",
						"line": 677,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "https",
						"line": 678,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp",
						"line": 679,
						"value": "4",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftps",
						"line": 680,
						"value": "8",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "scp",
						"line": 681,
						"value": "16",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sftp",
						"line": 682,
						"value": "32",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "telnet",
						"line": 683,
						"value": "64",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ldap",
						"line": 684,
						"value": "128",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ldaps",
						"line": 685,
						"value": "256",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "dict",
						"line": 686,
						"value": "512",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "file",
						"line": 687,
						"value": "1024",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tftp",
						"line": 688,
						"value": "2048",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "imap",
						"line": 689,
						"value": "4096",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "imaps",
						"line": 690,
						"value": "8192",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "pop3",
						"line": 691,
						"value": "16384",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "pop3s",
						"line": 692,
						"value": "32768",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "smtp",
						"line": 693,
						"value": "65536",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "smtps",
						"line": 694,
						"value": "131072",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp",
						"line": 695,
						"value": "262144",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmp",
						"line": 696,
						"value": "524288",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmpt",
						"line": 697,
						"value": "1048576",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmpe",
						"line": 698,
						"value": "2097152",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmpte",
						"line": 699,
						"value": "4194304",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmps",
						"line": 700,
						"value": "8388608",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmpts",
						"line": 701,
						"value": "16777216",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "gopher",
						"line": 702,
						"value": "33554432",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 703,
						"value": "-1",
						"comment": " enable everything\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlProto",
				"line": 676,
				"comment": " CURLPROTO_ defines are for the CURLOPT_*PROTOCOLS options\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLOPTTYPE_LONG",
				"line": 708,
				"comment": " long may be 32 or 64 bits, but we should never depend on anything else\n   but 32\n",
				"deco": "i",
				"init": "0",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPTTYPE_OBJECTPOINT",
				"line": 710,
				"comment": "ditto\n",
				"deco": "i",
				"init": "10000",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPTTYPE_FUNCTIONPOINT",
				"line": 712,
				"comment": "ditto\n",
				"deco": "i",
				"init": "20000",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPTTYPE_OFF_T",
				"line": 715,
				"comment": "ditto\n",
				"deco": "i",
				"init": "30000",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LONG",
				"line": 721,
				"comment": " name is uppercase CURLOPT_$(LT)name$(GT),\n   type is one of the defined CURLOPTTYPE_$(LT)type$(GT)\n   number is unique identifier\n\n The macro \"##\" is ISO C, we assume pre-ISO C doesn't support it.\n",
				"char": 24,
				"kind": "alias"
			},
			{
				"name": "OBJECTPOINT",
				"line": 723,
				"comment": "ditto\n",
				"char": 31,
				"kind": "alias"
			},
			{
				"name": "FUNCTIONPOINT",
				"line": 725,
				"comment": "ditto\n",
				"char": 33,
				"kind": "alias"
			},
			{
				"name": "OFF_T",
				"line": 728,
				"comment": "ditto\n",
				"char": 25,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "file",
						"line": 733,
						"value": "10001",
						"comment": " This is the FILE * or void * the regular output should be written to.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "url",
						"line": 735,
						"value": "10002",
						"comment": " The full URL to get/put\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "port",
						"line": 737,
						"value": "3",
						"comment": " Port number to connect to, if other than default.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxy",
						"line": 739,
						"value": "10004",
						"comment": " Name of proxy to use.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "userpwd",
						"line": 741,
						"value": "10005",
						"comment": " \"name:password\" to use when fetching.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxyuserpwd",
						"line": 743,
						"value": "10006",
						"comment": " \"name:password\" to use with proxy.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "range",
						"line": 745,
						"value": "10007",
						"comment": " Range to get, specified as an ASCII string.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "infile",
						"line": 749,
						"value": "10009",
						"comment": " not used\n\n Specified file stream to upload from (use as input):\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "errorbuffer",
						"line": 752,
						"value": "10010",
						"comment": " Buffer to receive error messages in, must be at least CURL_ERROR_SIZE\n bytes big. If this is not used, error messages go to stderr instead:\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "writefunction",
						"line": 755,
						"value": "20011",
						"comment": " Function that will be called to store the output (instead of fwrite). The\n parameters will use fwrite() syntax, make sure to follow them.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "readfunction",
						"line": 758,
						"value": "20012",
						"comment": " Function that will be called to read the input (instead of fread). The\n parameters will use fread() syntax, make sure to follow them.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "timeout",
						"line": 760,
						"value": "13",
						"comment": " Time-out the read operation after this amount of seconds\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "infilesize",
						"line": 770,
						"value": "14",
						"comment": " If the CURLOPT_INFILE is used, this can be used to inform libcurl about\n how large the file being sent really is. That allows better error\n checking and better verifies that the upload was successful. -1 means\n unknown size.\n\n For large file support, there is also a _LARGE version of the key\n which takes an off_t type, allowing platforms with larger off_t\n sizes to handle larger files.  See below for INFILESIZE_LARGE.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "postfields",
						"line": 772,
						"value": "10015",
						"comment": " POST static input fields.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "referer",
						"line": 774,
						"value": "10016",
						"comment": " Set the referrer page (needed by some CGIs)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftpport",
						"line": 777,
						"value": "10017",
						"comment": " Set the FTP PORT string (interface name, named or numerical IP address)\n     Use i.e '-' to use default address.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "useragent",
						"line": 779,
						"value": "10018",
						"comment": " Set the User-Agent string (examined by some CGIs)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "low_speed_limit",
						"line": 787,
						"value": "19",
						"comment": " If the download receives less than \"low speed limit\" bytes/second\n during \"low speed time\" seconds, the operations is aborted.\n You could i.e if you have a pretty high speed connection, abort if\n it is less than 2000 bytes/sec during 20 seconds.\n\n Set the \"low speed limit\"\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "low_speed_time",
						"line": 789,
						"value": "20",
						"comment": " Set the \"low speed time\"\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "resume_from",
						"line": 796,
						"value": "21",
						"comment": " Set the continuation offset.\n\n Note there is also a _LARGE version of this key which uses\n off_t types, allowing for large file offsets on platforms which\n use larger-than-32-bit off_t's.  Look below for RESUME_FROM_LARGE.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cookie",
						"line": 798,
						"value": "10022",
						"comment": " Set cookie in request:\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "httpheader",
						"line": 800,
						"value": "10023",
						"comment": " This points to a linked list of headers, struct curl_slist kind\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "httppost",
						"line": 802,
						"value": "10024",
						"comment": " This points to a linked list of post entries, struct curl_httppost\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslcert",
						"line": 804,
						"value": "10025",
						"comment": " name of the file keeping your private SSL-certificate\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "keypasswd",
						"line": 806,
						"value": "10026",
						"comment": " password for the SSL or SSH private key\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "crlf",
						"line": 808,
						"value": "27",
						"comment": " send TYPE parameter?\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "quote",
						"line": 810,
						"value": "10028",
						"comment": " send linked-list of QUOTE commands\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "writeheader",
						"line": 813,
						"value": "10029",
						"comment": " send FILE * or void * to store headers to, if you use a callback it\n     is simply passed to the callback unmodified\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cookiefile",
						"line": 816,
						"value": "10031",
						"comment": " point to a file to read the initial cookies from, also enables\n     \"cookie awareness\"\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslversion",
						"line": 819,
						"value": "32",
						"comment": " What version to specifically try to use.\n     See CURL_SSLVERSION defines below.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "timecondition",
						"line": 821,
						"value": "33",
						"comment": " What kind of HTTP time condition to use, see defines\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "timevalue",
						"line": 824,
						"value": "34",
						"comment": " Time to use with the above condition. Specified in number of seconds\n     since 1 Jan 1970\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "customrequest",
						"line": 831,
						"value": "10036",
						"comment": " Custom request, for customizing the get command like\n     HTTP: DELETE, TRACE and others\n     FTP: to use a different list command\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "stderr",
						"line": 833,
						"value": "10037",
						"comment": " HTTP request, for odd commands like DELETE, TRACE and others\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "postquote",
						"line": 837,
						"value": "10039",
						"comment": " send linked-list of post-transfer QUOTE commands\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "writeinfo",
						"line": 840,
						"value": "10040",
						"comment": " Pass a pointer to string of the output using full variable-replacement\n     as described elsewhere.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "verbose",
						"line": 841,
						"value": "41",
						"comment": " talk a lot\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "header",
						"line": 842,
						"value": "42",
						"comment": " throw the header out too\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "noprogress",
						"line": 843,
						"value": "43",
						"comment": " shut off the progress meter\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "nobody",
						"line": 844,
						"value": "44",
						"comment": " use HEAD to get http document\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "failonerror",
						"line": 845,
						"value": "45",
						"comment": " no output on http error codes >= 300\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "upload",
						"line": 846,
						"value": "46",
						"comment": " this is an upload\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "post",
						"line": 847,
						"value": "47",
						"comment": " HTTP POST method\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "dirlistonly",
						"line": 848,
						"value": "48",
						"comment": " return bare names when listing directories\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "append",
						"line": 849,
						"value": "50",
						"comment": " Append instead of overwrite on upload!\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "netrc",
						"line": 852,
						"value": "51",
						"comment": " Specify whether to read the user+password from the .netrc or the URL.\n This must be one of the CURL_NETRC_* enums below.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "followlocation",
						"line": 853,
						"value": "52",
						"comment": " use Location: Luke!\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "transfertext",
						"line": 854,
						"value": "53",
						"comment": " transfer data in text/ASCII format\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "put",
						"line": 855,
						"value": "54",
						"comment": " HTTP PUT\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "progressfunction",
						"line": 861,
						"value": "20056",
						"comment": " Function that will be called instead of the internal progress display\n function. This function should be defined as the curl_progress_callback\n prototype defines.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "progressdata",
						"line": 863,
						"value": "10057",
						"comment": " Data passed to the progress callback\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "autoreferer",
						"line": 865,
						"value": "58",
						"comment": " We want the referrer field set automatically when following locations\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxyport",
						"line": 868,
						"value": "59",
						"comment": " Port of the proxy, can be set in the proxy string as well with:\n     \"[host]:[port]\"\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "postfieldsize",
						"line": 870,
						"value": "60",
						"comment": " size of the POST input data, if strlen() is not good to use\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "httpproxytunnel",
						"line": 872,
						"value": "61",
						"comment": " tunnel non-http operations through a HTTP proxy\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "intrface",
						"line": 874,
						"value": "10062",
						"comment": " Set the interface string to use as outgoing network interface\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "krblevel",
						"line": 878,
						"value": "10063",
						"comment": " Set the krb4/5 security level, this also enables krb4/5 awareness.  This\n is a string, 'clear', 'safe', 'confidential' or 'private'.  If the string\n is set but doesn't match one of these, 'private' will be used.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_verifypeer",
						"line": 880,
						"value": "64",
						"comment": " Set if we should verify the peer in ssl handshake, set 1 to verify.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cainfo",
						"line": 883,
						"value": "10065",
						"comment": " The CApath or CAfile used to validate the peer certificate\n     this option is used only if SSL_VERIFYPEER is true\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "maxredirs",
						"line": 888,
						"value": "68",
						"comment": " Maximum number of http redirects to follow\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "filetime",
						"line": 891,
						"value": "69",
						"comment": " Pass a long set to 1 to get the date of the requested document (if\n     possible)! Pass a zero to shut it off.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "telnetoptions",
						"line": 893,
						"value": "10070",
						"comment": " This points to a linked list of telnet options\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "maxconnects",
						"line": 895,
						"value": "71",
						"comment": " Max amount of cached alive connections\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "closepolicy",
						"line": 898,
						"value": "72",
						"comment": " What policy to use when closing connections when the cache is filled\n     up\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fresh_connect",
						"line": 904,
						"value": "74",
						"comment": " Set to explicitly use a new connection for the upcoming transfer.\n     Do not use this unless you're absolutely sure of this, as it makes the\n     operation slower and is less friendly for the network.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "forbid_reuse",
						"line": 908,
						"value": "75",
						"comment": " Set to explicitly forbid the upcoming transfer's connection to be re-used\n     when done. Do not use this unless you're absolutely sure of this, as it\n     makes the operation slower and is less friendly for the network.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "random_file",
						"line": 911,
						"value": "10076",
						"comment": " Set to a file name that contains random data for libcurl to use to\n     seed the random engine when doing SSL connects.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "egdsocket",
						"line": 913,
						"value": "10077",
						"comment": " Set to the Entropy Gathering Daemon socket pathname\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "connecttimeout",
						"line": 917,
						"value": "78",
						"comment": " Time-out connect operations after this amount of seconds, if connects\n     are OK within this time, then fine... This only aborts the connect\n     phase. [Only works on unix-style/SIGALRM operating systems]\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "headerfunction",
						"line": 920,
						"value": "20079",
						"comment": " Function that will be called to store headers (instead of fwrite). The\n parameters will use fwrite() syntax, make sure to follow them.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "httpget",
						"line": 924,
						"value": "80",
						"comment": " Set this to force the HTTP request to get back to GET. Only really usable\n     if POST, PUT or a custom request have been used first.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_verifyhost",
						"line": 928,
						"value": "81",
						"comment": " Set if we should verify the Common name from the peer certificate in ssl\n handshake, set 1 to check existence, 2 to ensure that it matches the\n provided hostname.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cookiejar",
						"line": 931,
						"value": "10082",
						"comment": " Specify which file name to write all known cookies in after completed\n     operation. Set file name to \"-\" (dash) to make it go to stdout.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_cipher_list",
						"line": 933,
						"value": "10083",
						"comment": " Specify which SSL ciphers to use\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "http_version",
						"line": 936,
						"value": "84",
						"comment": " Specify which HTTP version to use! This must be set to one of the\n     CURL_HTTP_VERSION* enums set below.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_use_epsv",
						"line": 940,
						"value": "85",
						"comment": " Specifically switch on or off the FTP engine's use of the EPSV command. By\n     default, that one will always be attempted before the more traditional\n     PASV command.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslcerttype",
						"line": 942,
						"value": "10086",
						"comment": " type of the file keeping your SSL-certificate (\"DER\", \"PEM\", \"ENG\")\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslkey",
						"line": 944,
						"value": "10087",
						"comment": " name of the file keeping your private SSL-key\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslkeytype",
						"line": 946,
						"value": "10088",
						"comment": " type of the file keeping your private SSL-key (\"DER\", \"PEM\", \"ENG\")\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslengine",
						"line": 948,
						"value": "10089",
						"comment": " crypto engine for the SSL-sub system\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslengine_default",
						"line": 952,
						"value": "90",
						"comment": " set the crypto engine for the SSL-sub system as default\n     the param has no meaning...\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "dns_use_global_cache",
						"line": 954,
						"value": "91",
						"comment": " Non-zero value means to use the global dns cache\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "dns_cache_timeout",
						"line": 956,
						"value": "92",
						"comment": " DNS cache timeout\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "prequote",
						"line": 958,
						"value": "10093",
						"comment": " send linked-list of pre-transfer QUOTE commands\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "debugfunction",
						"line": 960,
						"value": "20094",
						"comment": " set the debug function\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "debugdata",
						"line": 962,
						"value": "10095",
						"comment": " set the data for the debug function\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cookiesession",
						"line": 964,
						"value": "96",
						"comment": " mark this as start of a cookie session\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "capath",
						"line": 967,
						"value": "10097",
						"comment": " The CApath directory used to validate the peer certificate\n     this option is used only if SSL_VERIFYPEER is true\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "buffersize",
						"line": 969,
						"value": "98",
						"comment": " Instruct libcurl to use a smaller receive buffer\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "nosignal",
						"line": 973,
						"value": "99",
						"comment": " Instruct libcurl to not use any signal/alarm handlers, even when using\n     timeouts. This option is useful for multi-threaded applications.\n     See libcurl-the-guide for more background information.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "share",
						"line": 975,
						"value": "10100",
						"comment": " Provide a CURLShare for mutexing non-ts data\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxytype",
						"line": 978,
						"value": "101",
						"comment": " indicates type of proxy. accepted values are CURLPROXY_HTTP (default),\n     CURLPROXY_SOCKS4, CURLPROXY_SOCKS4A and CURLPROXY_SOCKS5.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "encoding",
						"line": 981,
						"value": "10102",
						"comment": " Set the Accept-Encoding string. Use this to tell a server you would like\n     the response to be compressed.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "private_opt",
						"line": 983,
						"value": "10103",
						"comment": " Set pointer to private data\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "http200aliases",
						"line": 985,
						"value": "10104",
						"comment": " Set aliases for HTTP 200 in the HTTP Response header\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "unrestricted_auth",
						"line": 989,
						"value": "105",
						"comment": " Continue to send authentication (user+password) when following locations,\n     even when hostname changed. This can potentially send off the name\n     and password to whatever host the server decides.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_use_eprt",
						"line": 993,
						"value": "106",
						"comment": " Specifically switch on or off the FTP engine's use of the EPRT command ( it\n     also disables the LPRT attempt). By default, those ones will always be\n     attempted before the good old traditional PORT command.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "httpauth",
						"line": 997,
						"value": "107",
						"comment": " Set this to a bitmask value to enable the particular authentications\n     methods you like. Use this in combination with CURLOPT_USERPWD.\n     Note that setting multiple bits may cause extra network round-trips.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_ctx_function",
						"line": 1001,
						"value": "20108",
						"comment": " Set the ssl context callback function, currently only for OpenSSL ssl_ctx\n     in second argument. The function must be matching the\n     curl_ssl_ctx_callback proto.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_ctx_data",
						"line": 1004,
						"value": "10109",
						"comment": " Set the userdata for the ssl context callback function's third\n     argument\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_create_missing_dirs",
						"line": 1009,
						"value": "110",
						"comment": " FTP Option that causes missing dirs to be created on the remote server.\n     In 7.19.4 we introduced the convenience enums for this option using the\n     CURLFTP_CREATE_DIR prefix.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxyauth",
						"line": 1013,
						"value": "111",
						"comment": " Set this to a bitmask value to enable the particular authentications\n     methods you like. Use this in combination with CURLOPT_PROXYUSERPWD.\n     Note that setting multiple bits may cause extra network round-trips.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_response_timeout",
						"line": 1018,
						"value": "112",
						"comment": " FTP option that changes the timeout, in seconds, associated with\n     getting a response.  This is different from transfer timeout time and\n     essentially places a demand on the FTP server to acknowledge commands\n     in a timely manner.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ipresolve",
						"line": 1022,
						"value": "113",
						"comment": " Set this option to one of the CURL_IPRESOLVE_* defines (see below) to\n     tell libcurl to resolve names to those IP versions only. This only has\n     affect on systems with support for more than one, i.e IPv4 _and_ IPv6.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "maxfilesize",
						"line": 1028,
						"value": "114",
						"comment": " Set this option to limit the size of a file that will be downloaded from\n     an HTTP or FTP server.\n\n     Note there is also _LARGE version which adds large file support for\n     platforms which have larger off_t sizes.  See MAXFILESIZE_LARGE below.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "infilesize_large",
						"line": 1032,
						"value": "30115",
						"comment": " See the comment for INFILESIZE above, but in short, specifies\n the size of the file being uploaded.  -1 means unknown.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "resume_from_large",
						"line": 1036,
						"value": "30116",
						"comment": " Sets the continuation offset.  There is also a LONG version of this;\n look above for RESUME_FROM.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "maxfilesize_large",
						"line": 1040,
						"value": "30117",
						"comment": " Sets the maximum size of data that will be downloaded from\n an HTTP or FTP server.  See MAXFILESIZE above for the LONG version.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "netrc_file",
						"line": 1045,
						"value": "10118",
						"comment": " Set this option to the file name of your .netrc file you want libcurl\n     to parse (using the CURLOPT_NETRC option). If not set, libcurl will do\n     a poor attempt to find the user's home directory and check for a .netrc\n     file in there.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "use_ssl",
						"line": 1051,
						"value": "119",
						"comment": " Enable SSL/TLS for FTP, pick one of:\n     CURLFTPSSL_TRY     - try using SSL, proceed anyway otherwise\n     CURLFTPSSL_CONTROL - SSL for the control connection or fail\n     CURLFTPSSL_ALL     - SSL for all communication or fail\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "postfieldsize_large",
						"line": 1053,
						"value": "30120",
						"comment": " The _LARGE version of the standard POSTFIELDSIZE option\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tcp_nodelay",
						"line": 1055,
						"value": "121",
						"comment": " Enable/disable the TCP Nagle algorithm\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftpsslauth",
						"line": 1074,
						"value": "129",
						"comment": " When FTP over SSL/TLS is selected (with CURLOPT_USE_SSL), this option\n     can be used to change libcurl's default action which is to first try\n     \"AUTH SSL\" and then \"AUTH TLS\" in this order, and proceed when a OK\n     response has been received.\n\n     Available parameters are:\n     CURLFTPAUTH_DEFAULT - let libcurl decide\n     CURLFTPAUTH_SSL     - try \"AUTH SSL\" first, then TLS\n     CURLFTPAUTH_TLS     - try \"AUTH TLS\" first, then SSL\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ioctlfunction",
						"line": 1075,
						"value": "20130",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ioctldata",
						"line": 1076,
						"value": "10131",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_account",
						"line": 1082,
						"value": "10134",
						"comment": " zero terminated string for pass on to the FTP server when asked for\n     \"account\" info\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cookielist",
						"line": 1084,
						"value": "10135",
						"comment": " feed cookies into cookie engine\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ignore_content_length",
						"line": 1086,
						"value": "136",
						"comment": " ignore Content-Length\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_skip_pasv_ip",
						"line": 1091,
						"value": "137",
						"comment": " Set to non-zero to skip the IP address received in a 227 PASV FTP server\n     response. Typically used for FTP-SSL purposes but is not restricted to\n     that. libcurl will then instead use the same IP address it used for the\n     control connection.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_filemethod",
						"line": 1094,
						"value": "138",
						"comment": " Select \"file method\" to use when doing FTP, see the curl_ftpmethod\n     above.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "localport",
						"line": 1096,
						"value": "139",
						"comment": " Local port number to bind the socket to\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "localportrange",
						"line": 1100,
						"value": "140",
						"comment": " Number of ports to try, including the first one set with LOCALPORT.\n     Thus, setting it to 1 will make no additional attempts but the first.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "connect_only",
						"line": 1103,
						"value": "141",
						"comment": " no transfer, set up connection and let application use the socket by\n     extracting it with CURLINFO_LASTSOCKET\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "conv_from_network_function",
						"line": 1106,
						"value": "20142",
						"comment": " Function that will be called to convert from the\n     network encoding (instead of using the iconv calls in libcurl)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "conv_to_network_function",
						"line": 1109,
						"value": "20143",
						"comment": " Function that will be called to convert to the\n     network encoding (instead of using the iconv calls in libcurl)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "conv_from_utf8_function",
						"line": 1113,
						"value": "20144",
						"comment": " Function that will be called to convert from UTF8\n     (instead of using the iconv calls in libcurl)\n     Note that this is used only for SSL certificate processing\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "max_send_speed_large",
						"line": 1117,
						"value": "30145",
						"comment": " If the connection proceeds too quickly then need to slow it down\n\n\n\n limit-rate: maximum number of bytes per second to send or receive\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "max_recv_speed_large",
						"line": 1118,
						"value": "30146",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_alternative_to_user",
						"line": 1120,
						"value": "10147",
						"comment": " Pointer to command string to send if USER/PASS fails.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sockoptfunction",
						"line": 1122,
						"value": "20148",
						"comment": " callback function for setting socket options\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_sessionid_cache",
						"line": 1126,
						"value": "150",
						"comment": " set to 0 to disable session ID re-use for this transfer, default is\n     enabled (== 1)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_auth_types",
						"line": 1128,
						"value": "151",
						"comment": " allowed SSH authentication methods\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_public_keyfile",
						"line": 1130,
						"value": "10152",
						"comment": " Used by scp/sftp to do public/private key authentication\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_ssl_ccc",
						"line": 1133,
						"value": "154",
						"comment": " Send CCC (Clear Command Channel) after authentication\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "timeout_ms",
						"line": 1135,
						"value": "155",
						"comment": " Same as TIMEOUT and CONNECTTIMEOUT, but with ms resolution\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "http_transfer_decoding",
						"line": 1139,
						"value": "157",
						"comment": " set to zero to disable the libcurl's decoding and thus pass the raw body\n     data to the application even when it is encoded/compressed\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "http_content_decoding",
						"line": 1140,
						"value": "158",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "new_file_perms",
						"line": 1143,
						"value": "159",
						"comment": " Permission used when creating new files and directories on the remote\n     server for protocols that support it, SFTP/SCP/FILE\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "new_directory_perms",
						"line": 1144,
						"value": "160",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "postredir",
						"line": 1147,
						"value": "161",
						"comment": " Set the behaviour of POST when redirecting. Values must be set to one\n     of CURL_REDIR* defines below. This used to be called CURLOPT_POST301\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_host_public_key_md5",
						"line": 1149,
						"value": "10162",
						"comment": " used by scp/sftp to verify the host's public key\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "opensocketfunction",
						"line": 1154,
						"value": "20163",
						"comment": " Callback function for opening socket (instead of socket(2)). Optionally,\n     callback is able change the address or refuse to connect returning\n     CURL_SOCKET_BAD.  The callback should have type\n     curl_opensocket_callback\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "opensocketdata",
						"line": 1155,
						"value": "10164",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "copypostfields",
						"line": 1157,
						"value": "10165",
						"comment": " POST volatile input fields.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxy_transfer_mode",
						"line": 1159,
						"value": "166",
						"comment": " set transfer mode (;type=$(LT)a|i$(GT)) when doing FTP via an HTTP proxy\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "seekfunction",
						"line": 1161,
						"value": "20167",
						"comment": " Callback function for seeking in the input stream\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "seekdata",
						"line": 1162,
						"value": "10168",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "crlfile",
						"line": 1164,
						"value": "10169",
						"comment": " CRL file\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "issuercert",
						"line": 1166,
						"value": "10170",
						"comment": " Issuer certificate\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "address_scope",
						"line": 1168,
						"value": "171",
						"comment": " (IPv6) Address scope\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "certinfo",
						"line": 1172,
						"value": "172",
						"comment": " Collect certificate chain info and allow it to get retrievable with\n     CURLINFO_CERTINFO after the transfer is complete. (Unfortunately) only\n     working with OpenSSL-powered builds.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "username",
						"line": 1174,
						"value": "10173",
						"comment": " \"name\" and \"pwd\" to use when fetching.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "password",
						"line": 1175,
						"value": "10174",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxyusername",
						"line": 1177,
						"value": "10175",
						"comment": " \"name\" and \"pwd\" to use with Proxy when fetching.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxypassword",
						"line": 1178,
						"value": "10176",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "noproxy",
						"line": 1186,
						"value": "10177",
						"comment": " Comma separated list of hostnames defining no-proxy zones. These should\n     match both hostnames directly, and hostnames within a domain. For\n     example, local.com will match local.com and www.local.com, but NOT\n     notlocal.com or www.notlocal.com. For compatibility with other\n     implementations of this, .local.com will be considered to be the same as\n     local.com. A single * is the only valid wildcard, and effectively\n     disables the use of proxy.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tftp_blksize",
						"line": 1188,
						"value": "178",
						"comment": " block size for TFTP transfers\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "socks5_gssapi_service",
						"line": 1190,
						"value": "10179",
						"comment": " Socks Service\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "socks5_gssapi_nec",
						"line": 1192,
						"value": "180",
						"comment": " Socks Service\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "protocols",
						"line": 1197,
						"value": "181",
						"comment": " set the bitmask for the protocols that are allowed to be used for the\n     transfer, which thus helps the app which takes URLs from users or other\n     external inputs and want to restrict what protocol(s) to deal\n     with. Defaults to CURLPROTO_ALL.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "redir_protocols",
						"line": 1202,
						"value": "182",
						"comment": " set the bitmask for the protocols that libcurl is allowed to follow to,\n     as a subset of the CURLOPT_PROTOCOLS ones. That means the protocol needs\n     to be set in both bitmasks to be allowed to get redirected to. Defaults\n     to all protocols except FILE and SCP.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_knownhosts",
						"line": 1204,
						"value": "10183",
						"comment": " set the SSH knownhost file name to use\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_keyfunction",
						"line": 1207,
						"value": "20184",
						"comment": " set the SSH host key callback, must point to a curl_sshkeycallback\n     function\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_keydata",
						"line": 1209,
						"value": "10185",
						"comment": " set the SSH host key callback custom pointer\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "mail_from",
						"line": 1211,
						"value": "10186",
						"comment": " set the SMTP mail originator\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "mail_rcpt",
						"line": 1213,
						"value": "10187",
						"comment": " set the SMTP mail receiver(s)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_use_pret",
						"line": 1215,
						"value": "188",
						"comment": " FTP: send PRET before PASV\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_request",
						"line": 1217,
						"value": "189",
						"comment": " RTSP request method (OPTIONS, SETUP, PLAY, etc...)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_session_id",
						"line": 1219,
						"value": "10190",
						"comment": " The RTSP session identifier\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_stream_uri",
						"line": 1221,
						"value": "10191",
						"comment": " The RTSP stream URI\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_transport",
						"line": 1223,
						"value": "10192",
						"comment": " The Transport: header to use in RTSP requests\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_client_cseq",
						"line": 1225,
						"value": "193",
						"comment": " Manually initialize the client RTSP CSeq for this handle\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_server_cseq",
						"line": 1227,
						"value": "194",
						"comment": " Manually initialize the server RTSP CSeq for this handle\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "interleavedata",
						"line": 1229,
						"value": "10195",
						"comment": " The stream to pass to INTERLEAVEFUNCTION.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "interleavefunction",
						"line": 1231,
						"value": "20196",
						"comment": " Let the application define a custom write method for RTP data\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "wildcardmatch",
						"line": 1233,
						"value": "197",
						"comment": " Turn on wildcard matching\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "chunk_bgn_function",
						"line": 1236,
						"value": "20198",
						"comment": " Directory matching callback called before downloading of an\n     individual file (chunk) started\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "chunk_end_function",
						"line": 1239,
						"value": "20199",
						"comment": " Directory matching callback called after the file (chunk)\n     was downloaded, or skipped\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fnmatch_function",
						"line": 1241,
						"value": "20200",
						"comment": " Change match (fnmatch-like) callback for wildcard matching\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "chunk_data",
						"line": 1243,
						"value": "10201",
						"comment": " Let the application define custom chunk data pointer\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fnmatch_data",
						"line": 1245,
						"value": "10202",
						"comment": " FNMATCH_FUNCTION user pointer\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "resolve",
						"line": 1247,
						"value": "10203",
						"comment": " send linked-list of name:port:address sets\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tlsauth_username",
						"line": 1249,
						"value": "10204",
						"comment": " Set a username for authenticated TLS\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tlsauth_password",
						"line": 1251,
						"value": "10205",
						"comment": " Set a password for authenticated TLS\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tlsauth_type",
						"line": 1253,
						"value": "10206",
						"comment": " Set authentication type for authenticated TLS\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "lastentry",
						"line": 1255,
						"value": "10207",
						"comment": " the last unused\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "writedata",
						"line": 1257,
						"value": "10001",
						"comment": "convenient alias\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "readdata",
						"line": 1258,
						"value": "10009",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "headerdata",
						"line": 1259,
						"value": "10029",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtspheader",
						"line": 1260,
						"value": "10023",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlOption",
				"line": 731,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLoption",
				"line": 1263,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "CURLOPT_SERVER_RESPONSE_TIMEOUT",
				"line": 1265,
				"comment": "\n",
				"deco": "E3etc1c4curl10CurlOption",
				"init": "cast(CurlOption)112",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "whatever",
						"line": 1271,
						"value": "0",
						"comment": " default, resolves addresses to all IP versions that your system allows\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "v4",
						"line": 1272,
						"value": "1",
						"comment": " resolve to ipv4 addresses\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "v6",
						"line": 1273,
						"value": "2",
						"comment": " resolve to ipv6 addresses\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlIpResolve",
				"line": 1270,
				"comment": " Below here follows defines for the CURLOPT_IPRESOLVE option. If a host\n   name resolves addresses using more than one IP protocol version, this\n   option might be handy to force libcurl to use a specific IP version.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLOPT_WRITEDATA",
				"line": 1277,
				"comment": " three convenient \"aliases\" that follow the name scheme better\n",
				"deco": "E3etc1c4curl10CurlOption",
				"init": "cast(CurlOption)10001",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPT_READDATA",
				"line": 1279,
				"comment": "ditto\n",
				"deco": "E3etc1c4curl10CurlOption",
				"init": "cast(CurlOption)10009",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPT_HEADERDATA",
				"line": 1281,
				"comment": "ditto\n",
				"deco": "E3etc1c4curl10CurlOption",
				"init": "cast(CurlOption)10029",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPT_RTSPHEADER",
				"line": 1283,
				"comment": "ditto\n",
				"deco": "E3etc1c4curl10CurlOption",
				"init": "cast(CurlOption)10023",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1287,
						"value": "0",
						"comment": " setting this means we don't care, and that we'd\n             like the library to choose the best possible\n             for us!\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "v1_0",
						"line": 1290,
						"value": "1",
						"comment": " please use HTTP 1.0 in the request\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "v1_1",
						"line": 1291,
						"value": "2",
						"comment": " please use HTTP 1.1 in the request\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1292,
						"value": "3",
						"comment": " *ILLEGAL* http version\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlHttpVersion",
				"line": 1286,
				"comment": " These enums are for use with the CURLOPT_HTTP_VERSION option.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1299,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "options",
						"line": 1300,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "describe",
						"line": 1301,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "announce",
						"line": 1302,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "setup",
						"line": 1303,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "play",
						"line": 1304,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "pause",
						"line": 1305,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "teardown",
						"line": 1306,
						"value": "7",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "get_parameter",
						"line": 1307,
						"value": "8",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "set_parameter",
						"line": 1308,
						"value": "9",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "record",
						"line": 1309,
						"value": "10",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "receive",
						"line": 1310,
						"value": "11",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1311,
						"value": "12",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlRtspReq",
				"line": 1298,
				"comment": " Public API enums for RTSP requests\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "ignored",
						"line": 1316,
						"value": "0",
						"comment": " The .netrc will never be read. This is the default.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "optional",
						"line": 1317,
						"value": "1",
						"comment": " A user:password in the URL will be preferred to one in the .netrc.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "required",
						"line": 1318,
						"value": "2",
						"comment": " A user:password in the URL will be ignored.\n Unless one is set programmatically, the .netrc\n will be queried.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1321,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlNetRcOption",
				"line": 1315,
				"comment": " These enums are for use with the CURLOPT_NETRC option.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "default_version",
						"line": 1326,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tlsv1",
						"line": 1327,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "sslv2",
						"line": 1328,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "sslv3",
						"line": 1329,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1330,
						"value": "4",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlSslVersion",
				"line": 1325,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1335,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "srp",
						"line": 1336,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1337,
						"value": "2",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlTlsAuth",
				"line": 1334,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "get_all",
						"line": 1344,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "post_301",
						"line": 1345,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "post_302",
						"line": 1346,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "post_all",
						"line": 1348,
						"value": "3",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlRedir",
				"line": 1343,
				"comment": " symbols to use with CURLOPT_POSTREDIR.\n   CURL_REDIR_POST_301 and CURL_REDIR_POST_302 can be bitwise ORed so that\n   CURL_REDIR_POST_301 | CURL_REDIR_POST_302 == CURL_REDIR_POST_ALL\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1352,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ifmodsince",
						"line": 1353,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ifunmodsince",
						"line": 1354,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lastmod",
						"line": 1355,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1356,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlTimeCond",
				"line": 1351,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_TimeCond",
				"line": 1359,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_strequal",
				"line": 1365,
				"comment": " curl_strequal() and curl_strnequal() are subject for removal in a future\n   libcurl, see lib/README.curlx for details\n",
				"deco": "UxPaxPaZi",
				"parameters": [
					{
						"name": "s1",
						"deco": "xPa"
					},
					{
						"name": "s2",
						"deco": "xPa"
					}
				],
				"originalType": "extern (C) int(in char* s1, in char* s2)",
				"char": 6,
				"kind": "function"
			},
			{
				"name": "curl_strnequal",
				"line": 1367,
				"comment": "ditto\n\n curl_strequal() and curl_strnequal() are subject for removal in a future\n   libcurl, see lib/README.curlx for details\n",
				"deco": "UxPaxPamZi",
				"parameters": [
					{
						"name": "s1",
						"deco": "xPa"
					},
					{
						"name": "s2",
						"deco": "xPa"
					},
					{
						"name": "n",
						"deco": "m"
					}
				],
				"originalType": "extern (C) int(in char* s1, in char* s2, size_t n)",
				"char": 6,
				"kind": "function"
			},
			{
				"name": "curl_forms",
				"line": 1396,
				"comment": " structure to be used as parameter for CURLFORM_ARRAY\n",
				"members": [
					{
						"offset": 0,
						"name": "option",
						"line": 1398,
						"comment": "\n",
						"deco": "i",
						"originalType": "CURLformoption",
						"char": 20,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "value",
						"line": 1399,
						"comment": "\n",
						"deco": "Pxa",
						"char": 18,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 1423,
						"value": "0",
						"comment": " first, no error\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "memory",
						"line": 1424,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "option_twice",
						"line": 1425,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "null_ptr",
						"line": 1426,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unknown_option",
						"line": 1427,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "incomplete",
						"line": 1428,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "illegal_array",
						"line": 1429,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "disabled",
						"line": 1430,
						"value": "7",
						"comment": " libcurl was built with this disabled\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1431,
						"value": "8",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFormAdd",
				"line": 1422,
				"comment": " Use this for multipart formpost building\n\n Returns code for curl_formadd()\n\n Returns:\n\n $(UL\n $(LI CURL_FORMADD_OK             on success )\n $(LI CURL_FORMADD_MEMORY         if the FormInfo allocation fails )\n $(LI CURL_FORMADD_OPTION_TWICE   if one option is given twice for one Form )\n $(LI CURL_FORMADD_NULL           if a null pointer was given for a char )\n $(LI CURL_FORMADD_MEMORY         if the allocation of a FormInfo struct failed )\n $(LI CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used )\n $(LI CURL_FORMADD_INCOMPLETE     if the some FormInfo is not complete (or error) )\n $(LI CURL_FORMADD_MEMORY         if a curl_httppost struct cannot be allocated )\n $(LI CURL_FORMADD_MEMORY         if some allocation for string copying failed. )\n $(LI CURL_FORMADD_ILLEGAL_ARRAY  if an illegal option is used in an array )\n )\n\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLFORMcode",
				"line": 1434,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_formadd",
				"line": 1447,
				"comment": " Name: curl_formadd()\n\n Description:\n\n Pretty advanced function for building multi-part formposts. Each invoke\n adds one part that together construct a full post. Then use\n CURLOPT_HTTPPOST to send it off to libcurl.\n",
				"deco": "UPPS3etc1c4curl13curl_httppostPPS3etc1c4curl13curl_httppostYi",
				"parameters": [
					{
						"name": "httppost",
						"deco": "PPS3etc1c4curl13curl_httppost"
					},
					{
						"name": "last_post",
						"deco": "PPS3etc1c4curl13curl_httppost"
					}
				],
				"originalType": "extern (C) CURLFORMcode(curl_httppost** httppost, curl_httppost** last_post, ...)",
				"char": 15,
				"kind": "function"
			},
			{
				"name": "curl_formget_callback",
				"line": 1457,
				"comment": " callback function for curl_formget()\n The void *arg pointer will be the one passed as second argument to\n   curl_formget().\n The character buffer passed to it must not be freed.\n Should return the buffer length passed to it as the argument \"len\" on\n   success.\n",
				"deco": "PUPvxPamZm",
				"char": 60,
				"kind": "alias"
			},
			{
				"name": "curl_formget",
				"line": 1469,
				"comment": " Name: curl_formget()\n\n Description:\n\n Serialize a curl_httppost struct built with curl_formadd().\n Accepts a void pointer as second argument which will be passed to\n the curl_formget_callback function.\n Returns 0 on success.\n",
				"deco": "UPS3etc1c4curl13curl_httppostPvPUPvxPamZmZi",
				"parameters": [
					{
						"name": "form",
						"deco": "PS3etc1c4curl13curl_httppost"
					},
					{
						"name": "arg",
						"deco": "Pv"
					},
					{
						"name": "append",
						"deco": "PUPvxPamZm"
					}
				],
				"originalType": "extern (C) int(curl_httppost* form, void* arg, curl_formget_callback append)",
				"char": 6,
				"kind": "function"
			},
			{
				"name": "curl_formfree",
				"line": 1477,
				"comment": " Name: curl_formfree()\n\n Description:\n\n Free a multipart formpost previously built with curl_formadd().\n",
				"deco": "UPS3etc1c4curl13curl_httppostZv",
				"parameters": [
					{
						"name": "form",
						"deco": "PS3etc1c4curl13curl_httppost"
					}
				],
				"char": 7,
				"kind": "function"
			},
			{
				"name": "curl_getenv",
				"line": 1487,
				"comment": " Name: curl_getenv()\n\n Description:\n\n Returns a malloc()'ed string that MUST be curl_free()ed after usage is\n complete. DEPRECATED - see lib/README.curlx\n",
				"deco": "UxPaZPa",
				"parameters": [
					{
						"name": "variable",
						"deco": "xPa"
					}
				],
				"originalType": "extern (C) char*(in char* variable)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_version",
				"line": 1496,
				"comment": " Name: curl_version()\n\n Description:\n\n Returns a static ascii string of the libcurl version.\n",
				"deco": "UZPa",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_easy_escape",
				"line": 1507,
				"comment": " Name: curl_easy_escape()\n\n Description:\n\n Escapes URL strings (converts all letters consider illegal in URLs to their\n %XX versions). This function returns a new allocated string or NULL if an\n error occurred.\n",
				"deco": "UNePvxPaiZPa",
				"parameters": [
					{
						"name": "handle",
						"deco": "Pv"
					},
					{
						"name": "string",
						"deco": "xPa"
					},
					{
						"name": "length",
						"deco": "i"
					}
				],
				"originalType": "@trusted extern (C) char*(CURL* handle, in char* string, int length)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_escape",
				"line": 1510,
				"comment": " the previous version:\n",
				"deco": "UNexPaiZPa",
				"parameters": [
					{
						"name": "string",
						"deco": "xPa"
					},
					{
						"name": "length",
						"deco": "i"
					}
				],
				"originalType": "@trusted extern (C) char*(in char* string, int length)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_easy_unescape",
				"line": 1524,
				"comment": " Name: curl_easy_unescape()\n\n Description:\n\n Unescapes URL encoding in strings (converts all %XX codes to their 8bit\n versions). This function returns a new allocated string or NULL if an error\n occurred.\n Conversion Note: On non-ASCII platforms the ASCII %XX codes are\n converted into the host encoding.\n",
				"deco": "UNePvxPaiPiZPa",
				"parameters": [
					{
						"name": "handle",
						"deco": "Pv"
					},
					{
						"name": "string",
						"deco": "xPa"
					},
					{
						"name": "length",
						"deco": "i"
					},
					{
						"name": "outlength",
						"deco": "Pi"
					}
				],
				"originalType": "@trusted extern (C) char*(CURL* handle, in char* string, int length, int* outlength)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_unescape",
				"line": 1527,
				"comment": " the previous version\n",
				"deco": "UNexPaiZPa",
				"parameters": [
					{
						"name": "string",
						"deco": "xPa"
					},
					{
						"name": "length",
						"deco": "i"
					}
				],
				"originalType": "@trusted extern (C) char*(in char* string, int length)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_free",
				"line": 1537,
				"comment": " Name: curl_free()\n\n Description:\n\n Provided for de-allocation in the same translation unit that did the\n allocation. Added in libcurl 7.10\n",
				"deco": "UPvZv",
				"parameters": [
					{
						"name": "p",
						"deco": "Pv"
					}
				],
				"char": 7,
				"kind": "function"
			},
			{
				"name": "curl_global_init",
				"line": 1549,
				"comment": " Name: curl_global_init()\n\n Description:\n\n curl_global_init() should be invoked exactly once for each application that\n uses libcurl and before any call of other libcurl functions.\n\n This function is not thread-safe!\n",
				"deco": "UlZi",
				"parameters": [
					{
						"name": "flags",
						"deco": "l"
					}
				],
				"originalType": "extern (C) CURLcode(c_long flags)",
				"char": 11,
				"kind": "function"
			},
			{
				"name": "curl_global_init_mem",
				"line": 1564,
				"comment": " Name: curl_global_init_mem()\n\n Description:\n\n curl_global_init() or curl_global_init_mem() should be invoked exactly once\n for each application that uses libcurl.  This function can be used to\n initialize libcurl and set user defined memory management callback\n functions.  Users can implement memory management routines to check for\n memory leaks, check for mis-use of the curl library etc.  User registered\n callback routines with be invoked by this library instead of the system\n memory management routines like malloc, free etc.\n",
				"deco": "UlPFmZPvPFPvZvPFPvmZPvPFxPaZPaPFmmZPvZi",
				"parameters": [
					{
						"name": "flags",
						"deco": "l"
					},
					{
						"name": "m",
						"deco": "PFmZPv"
					},
					{
						"name": "f",
						"deco": "PFPvZv"
					},
					{
						"name": "r",
						"deco": "PFPvmZPv"
					},
					{
						"name": "s",
						"deco": "PFxPaZPa"
					},
					{
						"name": "c",
						"deco": "PFmmZPv"
					}
				],
				"originalType": "extern (C) CURLcode(c_long flags, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c)",
				"char": 11,
				"kind": "function"
			},
			{
				"name": "curl_global_cleanup",
				"line": 1574,
				"comment": " Name: curl_global_cleanup()\n\n Description:\n\n curl_global_cleanup() should be invoked exactly once for each application\n that uses libcurl\n",
				"deco": "UZv",
				"char": 7,
				"kind": "function"
			},
			{
				"name": "curl_slist",
				"line": 1580,
				"comment": " linked-list structure for the CURLOPT_QUOTE option (and other)\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "curl_slist_append",
				"line": 1594,
				"comment": " Name: curl_slist_append()\n\n Description:\n\n Appends a string to a linked list. If no list exists, it will be created\n first. Returns the new list, after appending.\n\n linked-list structure for the CURLOPT_QUOTE option (and other)\n",
				"deco": "UPS3etc1c4curl10curl_slistxPaZPS3etc1c4curl10curl_slist",
				"parameters": [
					{
						"deco": "PS3etc1c4curl10curl_slist"
					},
					{
						"deco": "xPa"
					}
				],
				"originalType": "extern (C) curl_slist*(curl_slist*, in char*)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_slist_free_all",
				"line": 1603,
				"comment": " Name: curl_slist_free_all()\n\n Description:\n\n free a previously built curl_slist.\n\n linked-list structure for the CURLOPT_QUOTE option (and other)\n",
				"deco": "UPS3etc1c4curl10curl_slistZv",
				"parameters": [
					{
						"deco": "PS3etc1c4curl10curl_slist"
					}
				],
				"char": 7,
				"kind": "function"
			},
			{
				"name": "curl_getdate",
				"line": 1614,
				"comment": " Name: curl_getdate()\n\n Description:\n\n Returns the time, in seconds since 1 Jan 1970 of the time string given in\n the first argument. The time argument in the second parameter is unused\n and should be set to NULL.\n\n linked-list structure for the CURLOPT_QUOTE option (and other)\n",
				"deco": "UPaPlZl",
				"parameters": [
					{
						"name": "p",
						"deco": "Pa"
					},
					{
						"name": "unused",
						"deco": "Pl"
					}
				],
				"originalType": "extern (C) time_t(char* p, time_t* unused)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "curl_certinfo",
				"line": 1618,
				"comment": " info about the certificate chain, only for OpenSSL builds. Asked\n   for with CURLOPT_CERTINFO / CURLINFO_CERTINFO\n\n linked-list structure for the CURLOPT_QUOTE option (and other)\n",
				"members": [
					{
						"offset": 0,
						"name": "num_of_certs",
						"line": 1620,
						"comment": " number of certificates with information\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "certinfo",
						"line": 1621,
						"comment": " for each index in this array, there's a\n                              linked list with textual information in the\n                              format \"name: value\"\n",
						"deco": "PPS3etc1c4curl10curl_slist",
						"char": 18,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "CURLINFO_STRING",
				"line": 1629,
				"comment": "\n",
				"deco": "i",
				"init": "1048576",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLINFO_LONG",
				"line": 1631,
				"comment": "\n",
				"deco": "i",
				"init": "2097152",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLINFO_DOUBLE",
				"line": 1633,
				"comment": "\n",
				"deco": "i",
				"init": "3145728",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLINFO_SLIST",
				"line": 1635,
				"comment": "\n",
				"deco": "i",
				"init": "4194304",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLINFO_MASK",
				"line": 1637,
				"comment": "\n",
				"deco": "i",
				"init": "1048575",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLINFO_TYPEMASK",
				"line": 1640,
				"comment": "\n",
				"deco": "i",
				"init": "15728640",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1644,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "effective_url",
						"line": 1645,
						"value": "1048577",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "response_code",
						"line": 1646,
						"value": "2097154",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "total_time",
						"line": 1647,
						"value": "3145731",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "namelookup_time",
						"line": 1648,
						"value": "3145732",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "connect_time",
						"line": 1649,
						"value": "3145733",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "pretransfer_time",
						"line": 1650,
						"value": "3145734",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "size_upload",
						"line": 1651,
						"value": "3145735",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "size_download",
						"line": 1652,
						"value": "3145736",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "speed_download",
						"line": 1653,
						"value": "3145737",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "speed_upload",
						"line": 1654,
						"value": "3145738",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "header_size",
						"line": 1655,
						"value": "2097163",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "request_size",
						"line": 1656,
						"value": "2097164",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_verifyresult",
						"line": 1657,
						"value": "2097165",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "filetime",
						"line": 1658,
						"value": "2097166",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "content_length_download",
						"line": 1659,
						"value": "3145743",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "content_length_upload",
						"line": 1660,
						"value": "3145744",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "starttransfer_time",
						"line": 1661,
						"value": "3145745",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "content_type",
						"line": 1662,
						"value": "1048594",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "redirect_time",
						"line": 1663,
						"value": "3145747",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "redirect_count",
						"line": 1664,
						"value": "2097172",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "private_info",
						"line": 1665,
						"value": "1048597",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "http_connectcode",
						"line": 1666,
						"value": "2097174",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "httpauth_avail",
						"line": 1667,
						"value": "2097175",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "proxyauth_avail",
						"line": 1668,
						"value": "2097176",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "os_errno",
						"line": 1669,
						"value": "2097177",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "num_connects",
						"line": 1670,
						"value": "2097178",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_engines",
						"line": 1671,
						"value": "4194331",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "cookielist",
						"line": 1672,
						"value": "4194332",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lastsocket",
						"line": 1673,
						"value": "2097181",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_entry_path",
						"line": 1674,
						"value": "1048606",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "redirect_url",
						"line": 1675,
						"value": "1048607",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "primary_ip",
						"line": 1676,
						"value": "1048608",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "appconnect_time",
						"line": 1677,
						"value": "3145761",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "certinfo",
						"line": 1678,
						"value": "4194338",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "condition_unmet",
						"line": 1679,
						"value": "2097187",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_session_id",
						"line": 1680,
						"value": "1048612",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_client_cseq",
						"line": 1681,
						"value": "2097189",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_server_cseq",
						"line": 1682,
						"value": "2097190",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_cseq_recv",
						"line": 1683,
						"value": "2097191",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "primary_port",
						"line": 1684,
						"value": "2097192",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "local_ip",
						"line": 1685,
						"value": "1048617",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "local_port",
						"line": 1686,
						"value": "2097194",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lastone",
						"line": 1688,
						"value": "42",
						"comment": " Fill in new entries below here!\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlInfo",
				"line": 1643,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLINFO",
				"line": 1691,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "CURLINFO_HTTP_CODE",
				"line": 1695,
				"comment": " CURLINFO_RESPONSE_CODE is the new name for the option previously known as\n   CURLINFO_HTTP_CODE\n",
				"deco": "E3etc1c4curl8CurlInfo",
				"init": "cast(CurlInfo)2097154",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1699,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "oldest",
						"line": 1700,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "least_recently_used",
						"line": 1701,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "least_traffic",
						"line": 1702,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "slowest",
						"line": 1703,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "callback",
						"line": 1704,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1705,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlClosePolicy",
				"line": 1698,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_closepolicy",
				"line": 1708,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ssl",
						"line": 1712,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "win32",
						"line": 1713,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 1715,
						"value": "3",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "nothing",
						"line": 1716,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "default_",
						"line": 1717,
						"value": "3",
						"comment": "all\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlGlobal",
				"line": 1711,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1726,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "share",
						"line": 1731,
						"value": "1",
						"comment": "  CURL_LOCK_DATA_SHARE is used internally to say that\n  the locking is just made to change the internal state of the share\n  itself.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "cookie",
						"line": 1732,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "dns",
						"line": 1733,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_session",
						"line": 1734,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "connect",
						"line": 1735,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1736,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlLockData",
				"line": 1725,
				"comment": " Setup defines, protos etc for the sharing stuff.\n\n Different data locks for a single share\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_lock_data",
				"line": 1739,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1743,
						"value": "0",
						"comment": " unspecified action\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "shared_access",
						"line": 1744,
						"value": "1",
						"comment": " for read perhaps\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "single",
						"line": 1745,
						"value": "2",
						"comment": " for write perhaps\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1746,
						"value": "3",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlLockAccess",
				"line": 1742,
				"comment": " Different lock access types\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_lock_access",
				"line": 1749,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_lock_function",
				"line": 1752,
				"comment": "\n",
				"deco": "PFPviiPvZv",
				"char": 98,
				"kind": "alias"
			},
			{
				"name": "curl_unlock_function",
				"line": 1754,
				"comment": "\n",
				"deco": "PFPviPvZv",
				"char": 71,
				"kind": "alias"
			},
			{
				"name": "CURLSH",
				"line": 1757,
				"comment": "\n",
				"deco": "v",
				"char": 12,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 1761,
						"value": "0",
						"comment": " all is fine\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_option",
						"line": 1762,
						"value": "1",
						"comment": " 1\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "in_use",
						"line": 1763,
						"value": "2",
						"comment": " 2\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "invalid",
						"line": 1764,
						"value": "3",
						"comment": " 3\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "nomem",
						"line": 1765,
						"value": "4",
						"comment": " out of memory\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1766,
						"value": "5",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlShError",
				"line": 1760,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLSHcode",
				"line": 1769,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1774,
						"value": "0",
						"comment": " don't use\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "share",
						"line": 1775,
						"value": "1",
						"comment": " specify a data type to share\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unshare",
						"line": 1776,
						"value": "2",
						"comment": " specify which data type to stop sharing\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lockfunc",
						"line": 1777,
						"value": "3",
						"comment": " pass in a 'curl_lock_function' pointer\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unlockfunc",
						"line": 1778,
						"value": "4",
						"comment": " pass in a 'curl_unlock_function' pointer\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "userdata",
						"line": 1779,
						"value": "5",
						"comment": " pass in a user data pointer used in the lock/unlock\n                     callback functions\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1781,
						"value": "6",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlShOption",
				"line": 1773,
				"comment": " pass in a user data pointer used in the lock/unlock callback\n   functions\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLSHoption",
				"line": 1784,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_share_init",
				"line": 1788,
				"comment": "\n",
				"deco": "UZPv",
				"originalType": "extern (C) CURLSH*()",
				"char": 10,
				"kind": "function"
			},
			{
				"name": "curl_share_setopt",
				"line": 1790,
				"comment": "\n",
				"deco": "UPviYi",
				"parameters": [
					{
						"deco": "Pv"
					},
					{
						"name": "option",
						"deco": "i"
					}
				],
				"originalType": "extern (C) CURLSHcode(CURLSH*, CURLSHoption option, ...)",
				"char": 13,
				"kind": "function"
			},
			{
				"name": "curl_share_cleanup",
				"line": 1792,
				"comment": "\n",
				"deco": "UPvZi",
				"parameters": [
					{
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLSHcode(CURLSH*)",
				"char": 13,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "first",
						"line": 1801,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "second",
						"line": 1802,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "third",
						"line": 1803,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "fourth",
						"line": 1804,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1805,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlVer",
				"line": 1800,
				"comment": " Structures for querying information about the curl library at runtime.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLversion",
				"line": 1808,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "CURLVERSION_NOW",
				"line": 1815,
				"comment": " The 'CURLVERSION_NOW' is the symbolic name meant to be used by\n   basically all programs ever that want to get version information. It is\n   meant to be a built-in version number for what kind of struct the caller\n   expects. If the struct ever changes, we redefine the NOW to another enum\n   from above.\n",
				"deco": "E3etc1c4curl7CurlVer",
				"init": "cast(CurlVer)3",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "_N28",
				"line": 1818,
				"comment": "\n",
				"members": [
					{
						"offset": 0,
						"name": "age",
						"line": 1820,
						"comment": " age of the returned struct\n",
						"deco": "i",
						"originalType": "CURLversion",
						"char": 15,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "version_",
						"line": 1821,
						"comment": " LIBCURL_VERSION\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "version_num",
						"line": 1822,
						"comment": " LIBCURL_VERSION_NUM\n",
						"deco": "k",
						"char": 8,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "host",
						"line": 1823,
						"comment": " OS/host/cpu/machine when configured\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "features",
						"line": 1824,
						"comment": " bitmask, see defines below\n",
						"deco": "i",
						"char": 7,
						"kind": "variable"
					},
					{
						"offset": 40,
						"name": "ssl_version",
						"line": 1825,
						"comment": " human readable string\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "ssl_version_num",
						"line": 1826,
						"comment": " not used anymore, always 0\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 10,
						"kind": "variable"
					},
					{
						"offset": 56,
						"name": "libz_version",
						"line": 1827,
						"comment": " human readable string\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 64,
						"name": "protocols",
						"line": 1829,
						"comment": " protocols is terminated by an entry with a NULL protoname\n",
						"deco": "PPxa",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 72,
						"name": "ares",
						"line": 1831,
						"comment": " The fields below this were added in CURLVERSION_SECOND\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 88,
						"name": "libidn",
						"line": 1834,
						"comment": " This field was added in CURLVERSION_THIRD\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 96,
						"name": "iconv_ver_num",
						"line": 1837,
						"comment": " These field were added in CURLVERSION_FOURTH.\n\n Same as '_libiconv_version' if built with HAVE_ICONV\n",
						"deco": "i",
						"char": 7,
						"kind": "variable"
					},
					{
						"offset": 104,
						"name": "libssh_version",
						"line": 1838,
						"comment": " human readable string\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"name": "curl_version_info_data",
				"line": 1841,
				"comment": "\n",
				"deco": "S3etc1c4curl4_N28",
				"char": 12,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ipv6",
						"line": 1846,
						"value": "1",
						"comment": " IPv6-enabled\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "kerberos4",
						"line": 1847,
						"value": "2",
						"comment": " kerberos auth is supported\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl",
						"line": 1848,
						"value": "4",
						"comment": " SSL options are present\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "libz",
						"line": 1849,
						"value": "8",
						"comment": " libz features are present\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ntlm",
						"line": 1850,
						"value": "16",
						"comment": " NTLM auth is supported\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "gssnegotiate",
						"line": 1851,
						"value": "32",
						"comment": " Negotiate auth support\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "dbg",
						"line": 1852,
						"value": "64",
						"comment": " built with debug capabilities\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "asynchdns",
						"line": 1853,
						"value": "128",
						"comment": " asynchronous dns resolves\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "spnego",
						"line": 1854,
						"value": "256",
						"comment": " SPNEGO auth\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "largefile",
						"line": 1855,
						"value": "512",
						"comment": " supports files bigger than 2GB\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "idn",
						"line": 1856,
						"value": "1024",
						"comment": " International Domain Names support\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sspi",
						"line": 1857,
						"value": "2048",
						"comment": " SSPI is supported\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "conv",
						"line": 1858,
						"value": "4096",
						"comment": " character conversions supported\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "curldebug",
						"line": 1859,
						"value": "8192",
						"comment": " debug memory tracking supported\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tlsauth_srp",
						"line": 1860,
						"value": "16384",
						"comment": " TLS-SRP auth is supported\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlVersion",
				"line": 1845,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_version_info",
				"line": 1872,
				"comment": " Name: curl_version_info()\n\n Description:\n\n This function returns a pointer to a static copy of the version info\n struct. See above.\n",
				"deco": "UiZPS3etc1c4curl4_N28",
				"parameters": [
					{
						"deco": "i"
					}
				],
				"originalType": "extern (C) curl_version_info_data*(CURLversion)",
				"char": 26,
				"kind": "function"
			},
			{
				"name": "curl_easy_strerror",
				"line": 1883,
				"comment": " Name: curl_easy_strerror()\n\n Description:\n\n The curl_easy_strerror function may be used to turn a CURLcode value\n into the equivalent human readable error string.  This is useful\n for printing meaningful error messages.\n",
				"deco": "UiZPxa",
				"parameters": [
					{
						"deco": "i"
					}
				],
				"originalType": "extern (C) const(char)*(CURLcode)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_share_strerror",
				"line": 1894,
				"comment": " Name: curl_share_strerror()\n\n Description:\n\n The curl_share_strerror function may be used to turn a CURLSHcode value\n into the equivalent human readable error string.  This is useful\n for printing meaningful error messages.\n",
				"deco": "UiZPxa",
				"parameters": [
					{
						"deco": "i"
					}
				],
				"originalType": "extern (C) const(char)*(CURLSHcode)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_easy_pause",
				"line": 1905,
				"comment": " Name: curl_easy_pause()\n\n Description:\n\n The curl_easy_pause function pauses or unpauses transfers. Select the new\n state by setting the bitmask, use the convenience defines below.\n\n",
				"deco": "UPviZi",
				"parameters": [
					{
						"name": "handle",
						"deco": "Pv"
					},
					{
						"name": "bitmask",
						"deco": "i"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* handle, int bitmask)",
				"char": 11,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "recv",
						"line": 1911,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "recv_cont",
						"line": 1912,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "send",
						"line": 1913,
						"value": "4",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "send_cont",
						"line": 1914,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 1916,
						"value": "5",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cont",
						"line": 1918,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlPause",
				"line": 1910,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_easy_init",
				"line": 1947,
				"comment": "\n",
				"deco": "UZPv",
				"originalType": "extern (C) CURL*()",
				"char": 10,
				"kind": "function"
			},
			{
				"name": "curl_easy_setopt",
				"line": 1949,
				"comment": "\n",
				"deco": "UPviYi",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					},
					{
						"name": "option",
						"deco": "i"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* curl, CURLoption option, ...)",
				"char": 13,
				"kind": "function"
			},
			{
				"name": "curl_easy_perform",
				"line": 1951,
				"comment": "\n",
				"deco": "UPvZi",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* curl)",
				"char": 13,
				"kind": "function"
			},
			{
				"name": "curl_easy_cleanup",
				"line": 1953,
				"comment": "\n",
				"deco": "UPvZv",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) void(CURL* curl)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "curl_easy_getinfo",
				"line": 1969,
				"comment": " Name: curl_easy_getinfo()\n\n Description:\n\n Request internal information from the curl session with this function.  The\n third argument MUST be a pointer to a long, a pointer to a char * or a\n pointer to a double (as the documentation describes elsewhere).  The data\n pointed to will be filled in accordingly and can be relied upon only if the\n function returns CURLE_OK.  This function is intended to get used *AFTER* a\n performed transfer, all results from this function are undefined until the\n transfer is completed.\n",
				"deco": "UPviYi",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					},
					{
						"name": "info",
						"deco": "i"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* curl, CURLINFO info, ...)",
				"char": 22,
				"kind": "function"
			},
			{
				"name": "curl_easy_duphandle",
				"line": 1984,
				"comment": " Name: curl_easy_duphandle()\n\n Description:\n\n Creates a new curl session handle with the same options set for the handle\n passed in. Duplicating a handle could only be a matter of cloning data and\n options, internal state info and things like persistant connections cannot\n be transfered. It is useful in multithreaded applications when you can run\n curl_easy_duphandle() for each new thread to avoid a series of identical\n curl_easy_setopt() invokes in every thread.\n",
				"deco": "UPvZPv",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURL*(CURL* curl)",
				"char": 19,
				"kind": "function"
			},
			{
				"name": "curl_easy_reset",
				"line": 1997,
				"comment": " Name: curl_easy_reset()\n\n Description:\n\n Re-initializes a CURL handle to the default values. This puts back the\n handle to the same state as it was in when it was just created.\n\n It does keep: live connections, the Session ID cache, the DNS cache and the\n cookies.\n",
				"deco": "UPvZv",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) void(CURL* curl)",
				"char": 18,
				"kind": "function"
			},
			{
				"name": "curl_easy_recv",
				"line": 2007,
				"comment": " Name: curl_easy_recv()\n\n Description:\n\n Receives data from the connected socket. Use after successful\n curl_easy_perform() with CURLOPT_CONNECT_ONLY option.\n",
				"deco": "UPvPvmPmZi",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					},
					{
						"name": "buffer",
						"deco": "Pv"
					},
					{
						"name": "buflen",
						"deco": "m"
					},
					{
						"name": "n",
						"deco": "Pm"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* curl, void* buffer, size_t buflen, size_t* n)",
				"char": 22,
				"kind": "function"
			},
			{
				"name": "curl_easy_send",
				"line": 2017,
				"comment": " Name: curl_easy_send()\n\n Description:\n\n Sends data over the connected socket. Use after successful\n curl_easy_perform() with CURLOPT_CONNECT_ONLY option.\n",
				"deco": "UPvPvmPmZi",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					},
					{
						"name": "buffer",
						"deco": "Pv"
					},
					{
						"name": "buflen",
						"deco": "m"
					},
					{
						"name": "n",
						"deco": "Pm"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* curl, void* buffer, size_t buflen, size_t* n)",
				"char": 22,
				"kind": "function"
			},
			{
				"name": "CURLM",
				"line": 2052,
				"comment": "\n",
				"deco": "v",
				"char": 12,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "call_multi_perform",
						"line": 2056,
						"value": "-1",
						"comment": " please call curl_multi_perform() or curl_multi_socket*() soon\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ok",
						"line": 2057,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_handle",
						"line": 2058,
						"value": "1",
						"comment": " the passed-in handle is not a valid CURLM handle\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_easy_handle",
						"line": 2059,
						"value": "2",
						"comment": " an easy handle was not good/valid\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "out_of_memory",
						"line": 2060,
						"value": "3",
						"comment": " if you ever get this, you're in deep sh*t\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "internal_error",
						"line": 2061,
						"value": "4",
						"comment": " this is a libcurl bug\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_socket",
						"line": 2062,
						"value": "5",
						"comment": " the passed in socket argument did not match\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unknown_option",
						"line": 2063,
						"value": "6",
						"comment": " curl_multi_setopt() with unsupported option\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 2064,
						"value": "7",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlM",
				"line": 2055,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLMcode",
				"line": 2067,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "CURLM_CALL_MULTI_SOCKET",
				"line": 2072,
				"comment": " just to make code nicer when using curl_multi_socket() you can now check\n   for CURLM_CALL_MULTI_SOCKET too in the same style it works for\n   curl_multi_perform() and CURLM_CALL_MULTI_PERFORM\n",
				"deco": "E3etc1c4curl5CurlM",
				"init": "cast(CurlM)-1",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "none",
						"line": 2077,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "done",
						"line": 2078,
						"value": "1",
						"comment": " This easy handle has completed. 'result' contains\n             the CURLcode of the transfer\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 2080,
						"value": "2",
						"comment": " no used\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlMsg",
				"line": 2075,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLMSG",
				"line": 2083,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "_N31",
				"line": 2086,
				"comment": "\n",
				"members": [
					{
						"offset": 0,
						"name": "whatever",
						"line": 2088,
						"comment": " message-specific data\n",
						"deco": "Pv",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 0,
						"name": "result",
						"line": 2089,
						"comment": " return code for transfer\n",
						"deco": "i",
						"originalType": "CURLcode",
						"char": 14,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "union"
			},
			{
				"name": "CURLMsg",
				"line": 2093,
				"comment": "\n",
				"members": [
					{
						"offset": 0,
						"name": "msg",
						"line": 2095,
						"comment": " what this message means\n",
						"deco": "i",
						"originalType": "CURLMSG",
						"char": 13,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "easy_handle",
						"line": 2096,
						"comment": " the handle it concerns\n",
						"deco": "Pv",
						"originalType": "CURL*",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "data",
						"line": 2097,
						"comment": "\n",
						"deco": "S3etc1c4curl4_N31",
						"char": 10,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"name": "curl_multi_init",
				"line": 2107,
				"comment": " Name:    curl_multi_init()\n\n Desc:    inititalize multi-style curl usage\n\n Returns: a new CURLM handle to use in all 'curl_multi' functions.\n",
				"deco": "UZPv",
				"originalType": "extern (C) CURLM*()",
				"char": 20,
				"kind": "function"
			},
			{
				"name": "curl_multi_add_handle",
				"line": 2116,
				"comment": " Name:    curl_multi_add_handle()\n\n Desc:    add a standard curl handle to the multi stack\n\n Returns: CURLMcode type, general multi error code.\n",
				"deco": "UPvPvZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "curl_handle",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, CURL* curl_handle)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "curl_multi_remove_handle",
				"line": 2125,
				"comment": " Name:    curl_multi_remove_handle()\n\n Desc:    removes a curl handle from the multi stack again\n\n Returns: CURLMcode type, general multi error code.\n",
				"deco": "UPvPvZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "curl_handle",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, CURL* curl_handle)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "fd_set",
				"line": 2138,
				"comment": " Name:    curl_multi_fdset()\n\n Desc:    Ask curl for its fd_set sets. The app can use these to select() or\n          poll() on. We want curl_multi_perform() called as soon as one of\n          them are ready.\n\n Returns: CURLMcode type, general multi error code.\n\n tmp decl\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_multi_fdset",
				"line": 2140,
				"comment": "\n",
				"deco": "UPvPiPiPiPiZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "read_fd_set",
						"deco": "Pi"
					},
					{
						"name": "write_fd_set",
						"deco": "Pi"
					},
					{
						"name": "exc_fd_set",
						"deco": "Pi"
					},
					{
						"name": "max_fd",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, fd_set* read_fd_set, fd_set* write_fd_set, fd_set* exc_fd_set, int* max_fd)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "curl_multi_perform",
				"line": 2158,
				"comment": " Name:    curl_multi_perform()\n\n Desc:    When the app thinks there's data available for curl it calls this\n          function to read/write whatever there is right now. This returns\n          as soon as the reads and writes are done. This function does not\n          require that there actually is data available for reading or that\n          data can be written, it can be called just in case. It returns\n          the number of handles that still transfer data in the second\n          argument's integer-pointer.\n\n Returns: CURLMcode type, general multi error code. *NOTE* that this only\n          returns errors etc regarding the whole multi stack. There might\n          still have occurred problems on invidual transfers even when this\n          returns OK.\n",
				"deco": "UPvPiZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "running_handles",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, int* running_handles)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "curl_multi_cleanup",
				"line": 2170,
				"comment": " Name:    curl_multi_cleanup()\n\n Desc:    Cleans up and removes a whole multi stack. It does not free or\n          touch any individual easy handles in any way. We need to define\n          in what state those handles will be if this function is called\n          in the middle of a transfer.\n\n Returns: CURLMcode type, general multi error code.\n",
				"deco": "UPvZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "curl_multi_info_read",
				"line": 2200,
				"comment": " Name:    curl_multi_info_read()\n\n Desc:    Ask the multi handle if there's any messages/informationals from\n          the individual transfers. Messages include informationals such as\n          error code from the transfer or just the fact that a transfer is\n          completed. More details on these should be written down as well.\n\n          Repeated calls to this function will return a new struct each\n          time, until a special \"end of msgs\" struct is returned as a signal\n          that there is no more to get at this point.\n\n          The data the returned pointer points to will not survive calling\n          curl_multi_cleanup().\n\n          The 'CURLMsg' struct is meant to be very simple and only contain\n          very basic informations. If more involved information is wanted,\n          we will provide the particular \"transfer handle\" in that struct\n          and that should/could/would be used in subsequent\n          curl_easy_getinfo() calls (or similar). The point being that we\n          must never expose complex structs to applications, as then we'll\n          undoubtably get backwards compatibility problems in the future.\n\n Returns: A pointer to a filled-in struct, or NULL if it failed or ran out\n          of structs. It also writes the number of messages left in the\n          queue (after this read) in the integer the second argument points\n          to.\n",
				"deco": "UPvPiZPS3etc1c4curl7CURLMsg",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "msgs_in_queue",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMsg*(CURLM* multi_handle, int* msgs_in_queue)",
				"char": 22,
				"kind": "function"
			},
			{
				"name": "curl_multi_strerror",
				"line": 2211,
				"comment": " Name:    curl_multi_strerror()\n\n Desc:    The curl_multi_strerror function may be used to turn a CURLMcode\n          value into the equivalent human readable error string.  This is\n          useful for printing meaningful error messages.\n\n Returns: A pointer to a zero-terminated error message.\n",
				"deco": "UiZPxa",
				"parameters": [
					{
						"deco": "i"
					}
				],
				"originalType": "extern (C) const(char)*(CURLMcode)",
				"char": 25,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "none_",
						"line": 2223,
						"value": "0",
						"comment": " jdrewsen - underscored in order not to clash with reserved D symbols\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "in_",
						"line": 2224,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "out_",
						"line": 2225,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "inout_",
						"line": 2226,
						"value": "3",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "remove_",
						"line": 2227,
						"value": "4",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlPoll",
				"line": 2222,
				"comment": " Name:    curl_multi_socket() and\n          curl_multi_socket_all()\n\n Desc:    An alternative version of curl_multi_perform() that allows the\n          application to pass in one of the file descriptors that have been\n          detected to have \"action\" on them and let libcurl perform.\n          See man page for details.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURL_SOCKET_TIMEOUT",
				"line": 2231,
				"comment": "\n",
				"char": 23,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "in_",
						"line": 2235,
						"value": "1",
						"comment": " jdrewsen - underscored in order not to clash with reserved D symbols\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "out_",
						"line": 2236,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "err_",
						"line": 2237,
						"value": "4",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlCSelect",
				"line": 2234,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_socket_callback",
				"line": 2246,
				"comment": "\n\n private socket pointer\n",
				"deco": "PUPvE3std6socket8socket_tiPvPvZi",
				"char": 36,
				"kind": "alias"
			},
			{
				"name": "curl_multi_timer_callback",
				"line": 2263,
				"comment": " private callback pointer\n\n Name:    curl_multi_timer_callback\n\n Desc:    Called by libcurl whenever the library detects a change in the\n          maximum number of milliseconds the app is allowed to wait before\n          curl_multi_socket() or curl_multi_perform() must be called\n          (to allow libcurl's timed events to take place).\n\n Returns: The callback should return zero.\n",
				"deco": "PUPvlPvZi",
				"char": 35,
				"kind": "alias"
			},
			{
				"name": "curl_multi_socket",
				"line": 2265,
				"comment": "ditto\n\n Name:    curl_multi_timer_callback\n\n Desc:    Called by libcurl whenever the library detects a change in the\n          maximum number of milliseconds the app is allowed to wait before\n          curl_multi_socket() or curl_multi_perform() must be called\n          (to allow libcurl's timed events to take place).\n\n Returns: The callback should return zero.\n",
				"deco": "UPvE3std6socket8socket_tPiZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "s",
						"deco": "E3std6socket8socket_t"
					},
					{
						"name": "running_handles",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, curl_socket_t s, int* running_handles)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_multi_socket_action",
				"line": 2267,
				"comment": "ditto\n\n Name:    curl_multi_timer_callback\n\n Desc:    Called by libcurl whenever the library detects a change in the\n          maximum number of milliseconds the app is allowed to wait before\n          curl_multi_socket() or curl_multi_perform() must be called\n          (to allow libcurl's timed events to take place).\n\n Returns: The callback should return zero.\n",
				"deco": "UPvE3std6socket8socket_tiPiZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "s",
						"deco": "E3std6socket8socket_t"
					},
					{
						"name": "ev_bitmask",
						"deco": "i"
					},
					{
						"name": "running_handles",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, curl_socket_t s, int ev_bitmask, int* running_handles)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_multi_socket_all",
				"line": 2269,
				"comment": "ditto\n\n Name:    curl_multi_timer_callback\n\n Desc:    Called by libcurl whenever the library detects a change in the\n          maximum number of milliseconds the app is allowed to wait before\n          curl_multi_socket() or curl_multi_perform() must be called\n          (to allow libcurl's timed events to take place).\n\n Returns: The callback should return zero.\n",
				"deco": "UPvPiZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "running_handles",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, int* running_handles)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_multi_timeout",
				"line": 2285,
				"comment": " This macro below was added in 7.16.3 to push users who recompile to use\n   the new curl_multi_socket_action() instead of the old curl_multi_socket()\n\n Name:    curl_multi_timeout()\n\n Desc:    Returns the maximum number of milliseconds the app is allowed to\n          wait before curl_multi_socket() or curl_multi_perform() must be\n          called (to allow libcurl's timed events to take place).\n\n Returns: CURLM error code.\n",
				"deco": "UPvPlZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "milliseconds",
						"deco": "Pl"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, c_long* milliseconds)",
				"char": 23,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "socketfunction",
						"line": 2289,
						"value": "20001",
						"comment": " This is the socket callback function pointer\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socketdata",
						"line": 2290,
						"value": "10002",
						"comment": " This is the argument passed to the socket callback\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "pipelining",
						"line": 2291,
						"value": "3",
						"comment": " set to 1 to enable pipelining for this multi handle\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "timerfunction",
						"line": 2292,
						"value": "20004",
						"comment": " This is the timer callback function pointer\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "timerdata",
						"line": 2293,
						"value": "10005",
						"comment": " This is the argument passed to the timer callback\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "maxconnects",
						"line": 2294,
						"value": "6",
						"comment": " maximum number of entries in the connection cache\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lastentry",
						"line": 2295,
						"value": "7",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlMOption",
				"line": 2288,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLMoption",
				"line": 2298,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_multi_setopt",
				"line": 2308,
				"comment": " Name:    curl_multi_setopt()\n\n Desc:    Sets options for the multi handle.\n\n Returns: CURLM error code.\n",
				"deco": "UPviYi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "option",
						"deco": "i"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, CURLMoption option, ...)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "curl_multi_assign",
				"line": 2320,
				"comment": " Name:    curl_multi_assign()\n\n Desc:    This function sets an association in the multi handle between the\n          given socket and a private pointer of the application. This is\n          (only) useful for curl_multi_socket uses.\n\n Returns: CURLM error code.\n",
				"deco": "UPvE3std6socket8socket_tPvZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "sockfd",
						"deco": "E3std6socket8socket_t"
					},
					{
						"name": "sockp",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, curl_socket_t sockfd, void* sockp)",
				"char": 23,
				"kind": "function"
			}
		],
		"comment": "   This is an interface to the libcurl library.\n\n   Converted to D from curl headers by $(LINK2 http://www.digitalmars.com/d/2.0/htod.html, htod) and\n   cleaned up by Jonas Drewsen (jdrewsen)\n\n   Windows x86 note:\n   A DMD compatible libcurl static library can be downloaded from the dlang.org\n   $(LINK2 http://dlang.org/download.html, download page).\n\n Copyright (C) 1998 - 2010, Daniel Stenberg, &lt;daniel@haxx.se&gt;, et al.\n\n This software is licensed as described in the file COPYING, which\n you should have received as part of this distribution. The terms\n are also available at $(LINK http://curl.haxx.se/docs/copyright.html).\n\n You may opt to use, copy, modify, merge, publish, distribute and/or sell\n copies of the Software, and permit persons to whom the Software is\n furnished to do so, under the terms of the COPYING file.\n\n This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n KIND, either express or implied.\n\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/etc/c/odbc/sql.d",
		"name": "etc.c.odbc.sql",
		"members": [],
		"comment": "Declarations for interfacing with the ODBC library.\n\nAdapted with minimal changes from the work of David L. Davis\n(refer to the $(WEB\nforum.dlang.org/post/cfk7ql$(DOLLAR)1p4n$(DOLLAR)1@digitaldaemon.com,\noriginal announcement)).\n\n`etc.c.odbc.sql` is the the main include for ODBC v3.0+ Core functions,\ncorresponding to the `sql.h` C header file. It `import`s `public`ly\n`etc.c.odbc.sqltypes` for conformity with the C header.\n\nNote: The ODBC library itself not a part of the `dmd` distribution (and\ntypically not a part of the distribution packages of other compilers\nsuch as `gdc` and `ldc`). To use ODBC, install it per the vendor- and\nplatform-specific instructions and then use the appropriate command-line\nflags (e.g. for dmd, `-L-lodbc` on Posix and `-Lodbc32.lib` on Windows) to link\nwith the ODBC library. On Windows, using $(D pragma(lib, \"odbc32\")) in D\ncode at top level is also appropriate.\n\nSee_Also: $(LUCKY ODBC API Reference on MSN Online)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/etc/c/odbc/sqltypes.d",
		"name": "etc.c.odbc.sqltypes",
		"members": [],
		"comment": "Declarations for interfacing with the ODBC library.\n\nAdapted with minimal changes from the work of David L. Davis\n(refer to the $(WEB\nforum.dlang.org/post/cfk7ql$(DOLLAR)1p4n$(DOLLAR)1@digitaldaemon.com,\noriginal announcement)).\n\n`etc.c.odbc.sqlext.d` corresponds to the `sqlext.h` C header file.\n\nSee_Also: $(LUCKY ODBC API Reference on MSN Online)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/etc/c/odbc/sqlext.d",
		"name": "etc.c.odbc.sqlext",
		"members": [],
		"comment": "Declarations for interfacing with the ODBC library.\n\nAdapted with minimal changes from the work of David L. Davis\n(refer to the $(WEB\nforum.dlang.org/post/cfk7ql$(DOLLAR)1p4n$(DOLLAR)1@digitaldaemon.com,\noriginal announcement)).\n\n`etc.c.odbc.sqlext` corresponds to the `sqlext.h` C header file.\n\nSee_Also: $(LUCKY ODBC API Reference on MSN Online)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/etc/c/odbc/sqlucode.d",
		"name": "etc.c.odbc.sqlucode",
		"members": [],
		"comment": "Declarations for interfacing with the ODBC library.\n\nAdapted with minimal changes from the work of David L. Davis\n(refer to the $(WEB\nforum.dlang.org/post/cfk7ql$(DOLLAR)1p4n$(DOLLAR)1@digitaldaemon.com,\noriginal announcement)).\n\n`etc.c.odbc.sqlucode` corresponds to the `sqlucode.h` C include file.\n\nSee_Also: $(LUCKY ODBC API Reference on MSN Online)\n",
		"kind": "module"
	}
]